"use strict";
(function () {
	var _status = {
		paused: false,
		paused2: false,
		paused3: false,
		over: false,
		clicked: false,
		auto: false,
		event: {
			finished: true,
			next: [],
			after: []
		},
		ai: {},
		lastdragchange: [],
		skillaudio: [],
		dieClose: [],
		dragline: [],
		dying: [],
		globalHistory: [{
			cardMove: [],
			custom: [],
		}],
	};
	var lib = {
		configprefix: 'noname_0.9_',
		versionOL: 27,
		updateURLS: {
			coding: 'https://nakamurayuri.coding.net/p/noname/d/noname/git/raw',
			github: 'https://raw.githubusercontent.com/libccy/noname',
		},
		updateURL: 'https://raw.githubusercontent.com/libccy/noname',
		mirrorURL: 'https://nakamurayuri.coding.net/p/noname/d/noname/git/raw',
		hallURL: '47.97.248.244',
		assetURL: '',
		changeLog: [],
		updates: [],
		canvasUpdates: [],
		video: [],
		skilllist: [],
		connectBanned: [],
		characterIntro: {},
		characterTitle: {},
		characterPack: {},
		characterFilter: {},
		characterSort: {},
		dynamicTranslate: {},
		cardPack: {},
		onresize: [],
		onphase: [],
		onwash: [],
		onover: [],
		ondb: [],
		ondb2: [],
		chatHistory: [],
		emotionList: {
			shibing_emotion: 15,
			guojia_emotion: 20,
			zhenji_emotion: 20,
			xiaosha_emotion: 20,
			xiaotao_emotion: 20,
		},
		animate: {
			skill: {},
			card: {},
		},
		arenaReady: [],
		onfree: [],
		inpile: [],
		extensions: [],
		extensionPack: {},
		cardType: {},
		hook: { globaltrigger: {}, globalskill: {} },
		hookmap: {},
		imported: {},
		layoutfixed: ['chess', 'tafang', 'stone'],
		characterDialogGroup: {
			'收藏': function (name, capt) {
				return lib.config.favouriteCharacter.contains(name) ? capt : null;
			},
			'最近': function (name, capt) {
				var list = get.config('recentCharacter') || [];
				return list.contains(name) ? capt : null;
			}
		},
		listenEnd: function (node) {
			if (!node._listeningEnd) {
				node._listeningEnd = true;
				node.listenTransition(function () {
					delete node._listeningEnd;
					if (node._onEndMoveDelete) {
						node.moveDelete(node._onEndMoveDelete);
					}
					else if (node._onEndDelete) {
						node.delete();
					}
					node._transitionEnded = true;
				});
			}
		},
		configMenu: {
			general: {
				name: '通用',
				config: {
					low_performance: {
						name: '流畅模式',
						init: false,
						intro: '减少部分游戏特效，提高游戏速度',
						onclick: function (bool) {
							game.saveConfig('low_performance', bool);
							if (bool) {
								ui.window.classList.add('low_performance');
							}
							else {
								ui.window.classList.remove('low_performance');
							}
						}
					},
					compatiblemode: {
						name: '兼容模式',
						init: false,
						intro: '开启兼容模式可防止扩展使游戏卡死并提高对旧扩展的兼容性，但对游戏速度有一定影响，若无不稳定或不兼容的扩展建议关闭',
						onclick: function (bool) {
							game.saveConfig('compatiblemode', bool);
							if (bool) {
								ui.window.classList.add('compatiblemode');
							}
							else {
								ui.window.classList.remove('compatiblemode');
							}
						}
					},
					confirm_exit: {
						name: '确认退出',
						init: false,
						unfrequent: true,
						intro: '离开游戏前弹出确认对话框',
					},
					keep_awake: {
						name: '屏幕常亮',
						init: false,
						unfrequent: true,
						intro: '防止屏幕自动关闭<br>注：旧版本通过NoSleep.js实现的屏幕常亮可能会影响外置音频的音量',
						onclick: function (bool) {
							game.saveConfig('keep_awake', bool);
							if (bool) {
								if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.keepAwake();
								else if (window.noSleep) {
									document.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function enableNoSleepX() {
										document.removeEventListener(lib.config.touchscreen ? 'touchend' : 'click', enableNoSleepX, false);
										window.noSleep.enable();
									}, false);
								}
							}
							else {
								if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.allowSleepAgain();
								else if (window.noSleep) window.noSleep.disable();
							}
						}
					},
					auto_confirm: {
						name: '自动确认',
						init: true,
						unfrequent: true,
						intro: '当候选目标只有1个时，点击目标后无需再点击确认',
					},
					skip_shan: {
						name: '无闪自动取消',
						init: false,
						unfrequent: true,
						intro: '当自己需要使用或打出【闪】时，若自己没有【闪】，则跳过该步骤',
					},
					unauto_choose: {
						name: '拆顺手牌选择',
						init: false,
						unfrequent: true,
						intro: '拆牌或者顺牌时，就算只能选择对方的手牌依然手动选择',
					},
					wuxie_self: {
						name: '不无懈自己',
						init: true,
						unfrequent: true,
						intro: '自己使用的单目标普通锦囊即将生效时，不询问无懈',
					},
					tao_enemy: {
						name: '不对敌方出桃',
						init: false,
						intro: '双方阵营明确的模式中（如对决），敌方角色濒死时不询问出桃',
						unfrequent: true,
					},
					enable_drag: {
						name: '启用拖拽',
						init: true,
						intro: '按住卡牌后可将卡牌拖至目标',
						unfrequent: true,
					},
					enable_dragline: {
						name: '拖拽指示线',
						init: true,
						unfrequent: true,
						intro: '拖拽时显示虚线，可能降低游戏速度',
					},
					enable_touchdragline: {
						name: '拖拽指示线',
						init: false,
						unfrequent: true,
						intro: '拖拽时显示虚线，可能降低游戏速度',
					},
					// enable_pressure:{
					// 	name:'启用压感',
					// 	init:false,
					// 	intro:'开启后可通过按压执行操作',
					// 	unfrequent:true,
					// },
					// pressure_taptic:{
					// 	name:'触觉反馈',
					// 	init:false,
					// 	intro:'开启后按压操作执行时将产生震动',
					// 	unfrequent:true,
					// },
					// pressure_click:{
					// 	name:'按压操作',
					// 	init:'pause',
					// 	intro:'在空白区域按压时的操作',
					// 	unfrequent:true,
					// 	item:{
					// 		pause:'暂停',
					// 		config:'选项',
					// 		auto:'托管',
					// 	}
					// },
					touchscreen: {
						name: '触屏模式',
						init: false,
						restart: true,
						unfrequent: true,
						intro: '开启后可使触屏设备反应更快，但无法使用鼠标操作',
						onclick: function (bool) {
							if (get.is.nomenu('touchscreen', bool)) return false;
							game.saveConfig('touchscreen', bool);
						}
					},
					swipe: {
						name: '滑动手势',
						init: true,
						unfrequent: true,
						intro: '在非滚动区域向四个方向滑动可执行对应操作',
					},
					swipe_down: {
						name: '下划操作',
						init: 'menu',
						unfrequent: true,
						intro: '向下滑动时执行的操作',
						item: {
							system: '显示按钮',
							menu: '打开菜单',
							pause: '切换暂停',
							auto: '切换托管',
							chat: '显示聊天',
							off: '关闭',
						},
						onclick: function (item) {
							if (get.is.nomenu('swipe_down', item)) return false;
							game.saveConfig('swipe_down', item);
						}
					},
					swipe_up: {
						name: '上划操作',
						intro: '向上滑动时执行的操作',
						init: 'auto',
						unfrequent: true,
						item: {
							system: '显示按钮',
							menu: '打开菜单',
							pause: '切换暂停',
							auto: '切换托管',
							chat: '显示聊天',
							off: '关闭',
						},
						onclick: function (item) {
							if (get.is.nomenu('swipe_up', item)) return false;
							game.saveConfig('swipe_up', item);
						}
					},
					swipe_left: {
						name: '左划操作',
						intro: '向左滑动时执行的操作',
						init: 'system',
						unfrequent: true,
						item: {
							system: '显示按钮',
							menu: '打开菜单',
							pause: '切换暂停',
							auto: '切换托管',
							chat: '显示聊天',
							off: '关闭',
						},
						onclick: function (item) {
							if (get.is.nomenu('swipe_left', item)) return false;
							game.saveConfig('swipe_left', item);
						}
					},
					swipe_right: {
						name: '右划操作',
						intro: '向右滑动时执行的操作',
						init: 'system',
						unfrequent: true,
						item: {
							system: '显示按钮',
							menu: '打开菜单',
							pause: '切换暂停',
							auto: '切换托管',
							chat: '显示聊天',
							off: '关闭',
						},
						onclick: function (item) {
							if (get.is.nomenu('swipe_right', item)) return false;
							game.saveConfig('swipe_right', item);
						}
					},
					round_menu_func: {
						name: '触屏按钮操作',
						intro: '点击屏幕中圆形按钮时执行的操作',
						init: 'system',
						unfrequent: true,
						item: {
							system: '显示按钮',
							menu: '打开菜单',
							pause: '切换暂停',
							auto: '切换托管'
						},
						onclick: function (item) {
							if (get.is.nomenu('round_menu_func', item)) return false;
							game.saveConfig('round_menu_func', item);
						},
					},
					show_splash: {
						name: '显示开始界面',
						intro: '游戏开始前进入模式选择画面',
						init: 'init',
						item: {
							off: '关闭',
							init: '首次启动',
							always: '保持开启',
						}
					},
					game_speed: {
						name: '游戏速度',
						init: 'mid',
						item: {
							vslow: '慢',
							slow: '较慢',
							mid: '中',
							fast: '较快',
							vfast: '快',
							vvfast: '很快',
						},
						intro: '设置不同游戏操作间的时间间隔'
					},
					sync_speed: {
						name: '限制结算速度',
						intro: '在动画结算完成前不执行下一步操作，开启后游戏操作的间隔更长但画面更浏畅，在游戏较卡时建议开启',
						init: true
					},
					enable_vibrate: {
						name: '开启震动',
						intro: '回合开始时使手机震动',
						init: false
					},
					right_click: {
						name: '右键操作',
						init: 'pause',
						intro: '在空白区域点击右键时的操作',
						unfrequent: true,
						item: {
							pause: '暂停',
							shortcut: '工具',
							config: '选项',
							auto: '托管',
						},
						onclick: function (item) {
							if (get.is.nomenu('right_click', item)) return false;
							game.saveConfig('right_click', item);
						}
					},
					longpress_info: {
						name: '长按显示信息',
						init: true,
						unfrequent: true,
						restart: true,
						intro: '长按后弹出菜单',
					},
					right_info: {
						name: '右键显示信息',
						init: true,
						unfrequent: true,
						restart: true,
						intro: '右键点击后弹出菜单',
					},
					hover_all: {
						name: '悬停显示信息',
						init: true,
						unfrequent: true,
						restart: true,
						intro: '悬停后弹出菜单',
					},
					hover_handcard: {
						name: '悬停手牌显示信息',
						init: true,
						unfrequent: true,
						intro: '悬停手牌后弹出菜单',
					},
					hoveration: {
						name: '悬停菜单弹出时间',
						unfrequent: true,
						intro: '鼠标移至目标到弹出菜单的时间间隔',
						init: '1000',
						item: {
							'500': '0.5秒',
							'700': '0.7秒',
							'1000': '1秒',
							'1500': '1.5秒',
							'2500': '2.5秒',
						}
					},
					doubleclick_intro: {
						name: '双击显示武将资料',
						init: true,
						unfrequent: true,
						intro: '双击武将头像后显示其资料卡',
					},
					video: {
						name: '保存录像',
						init: '20',
						intro: '游戏结束后保存录像在最大条数，超过后将从最早的录像开始删除（已收藏的录像不计入条数）',
						item: {
							'0': '关闭',
							'5': '五局',
							'10': '十局',
							'20': '二十局',
							'50': '五十局',
							'10000': '无限',
						},
						unfrequent: true,
					},
					max_loadtime: {
						name: '最长载入时间',
						intro: '设置游戏从启动到完成载入所需的最长时间，超过此时间未完成载入会报错，若设备较慢或安装了较多扩展可适当延长此时间',
						init: '5000',
						unfrequent: true,
						item: {
							5000: '5秒',
							10000: '10秒',
							20000: '20秒',
							60000: '60秒'
						},
						onclick: function (item) {
							game.saveConfig('max_loadtime', item);
							if (item == '5000') {
								localStorage.removeItem(lib.configprefix + 'loadtime');
							}
							else {
								localStorage.setItem(lib.configprefix + 'loadtime', item);
							}
						}
					},
					mousewheel: {
						name: '滚轮控制手牌',
						init: true,
						unfrequent: true,
						intro: '开启后滚轮可使手牌横向滚动，在mac等可横向滚动的设备上建议关闭',
						onclick: function (bool) {
							game.saveConfig('mousewheel', bool);
							if (lib.config.touchscreen) return;
							if (lib.config.mousewheel) {
								ui.handcards1Container.onmousewheel = ui.click.mousewheel;
								ui.handcards2Container.onmousewheel = ui.click.mousewheel;
							}
							else {
								ui.handcards1Container.onmousewheel = null;
								ui.handcards2Container.onmousewheel = null;
							}
						}
					},
					auto_check_update: {
						name: '自动检查游戏更新',
						intro: '进入游戏时检查更新',
						init: false,
						unfrequent: true
					},
					lucky_star: {
						name: '幸运星模式',
						intro: '在涉及随机数等的技能中，必定得到效果最好的结果。（联机模式无效）',
						init: false,
						unfrequent: true
					},
					dev: {
						name: '开发者模式',
						intro: '开启后可使用浏览器控制台控制游戏，同时可更新到开发版',
						init: false,
						onclick: function (bool) {
							game.saveConfig('dev', bool);
							if (_status.connectMode) return;
							if (bool) {
								lib.cheat.i();
							}
							else {
								delete window.cheat;
								delete window.game;
								delete window.ui;
								delete window.get;
								delete window.ai;
								delete window.lib;
								delete window._status;
							}
						},
						unfrequent: true,
					},
					errstop: {
						name: '出错时停止游戏',
						init: false,
						unfrequent: true
					},
					update_link: {
						name: '更新地址',
						init: 'coding',
						unfrequent: true,
						item: {
							coding: 'Coding',
							github: 'GitHub',
						},
						onclick: function (item) {
							game.saveConfig('update_link', item);
							lib.updateURL = lib.updateURLS[item] || lib.updateURLS.coding;
						},
					},
					update: function (config, map) {
						if ('ontouchstart' in document) {
							map.touchscreen.show();
						}
						else {
							map.touchscreen.hide();
						}
						if (lib.device || lib.node) {
							map.auto_check_update.show();
						}
						else {
							map.auto_check_update.hide();
						}
						if (lib.device) {
							map.enable_vibrate.show();
							map.keep_awake.show();
						}
						else {
							map.enable_vibrate.hide();
							map.keep_awake.hide();
						}
						// if(config.enable_pressure){
						// 	map.pressure_click.show();
						// 	if(lib.device){
						// 		map.pressure_taptic.show();
						// 	}
						// 	else{
						// 		map.pressure_taptic.hide();
						// 	}
						// }
						// else{
						// 	map.pressure_click.hide();
						// 	map.pressure_taptic.hide();
						// }
						if (lib.config.touchscreen) {
							map.mousewheel.hide();
							map.hover_all.hide();
							map.hover_handcard.hide();
							map.hoveration.hide();
							map.right_info.hide();
							map.right_click.hide();
							map.longpress_info.show();
							map.swipe.show();
							if (lib.config.swipe) {
								map.swipe_up.show();
								map.swipe_down.show();
								map.swipe_left.show();
								map.swipe_right.show();
							}
							else {
								map.swipe_up.hide();
								map.swipe_down.hide();
								map.swipe_left.hide();
								map.swipe_right.hide();
							}
						}
						else {
							map.mousewheel.show();
							map.hover_all.show();
							map.right_info.show();
							map.right_click.show();
							map.longpress_info.hide();
							if (!config.hover_all) {
								map.hover_handcard.hide();
								map.hoveration.hide();
							}
							else {
								map.hover_handcard.show();
								map.hoveration.show();
							}
							map.swipe.hide();
							map.swipe_up.hide();
							map.swipe_down.hide();
							map.swipe_left.hide();
							map.swipe_right.hide();
						}
						if (lib.config.enable_drag) {
							if (lib.config.touchscreen) {
								map.enable_dragline.hide();
								map.enable_touchdragline.show();
							}
							else {
								map.enable_dragline.show();
								map.enable_touchdragline.hide();
							}
						}
						else {
							map.enable_dragline.hide();
							map.enable_touchdragline.hide();
						}
						if (!get.is.phoneLayout()) {
							map.round_menu_func.hide();
						}
						else {
							map.round_menu_func.show();
						}
						if (!lib.node && lib.device != 'ios') {
							map.confirm_exit.show();
						}
						else {
							map.confirm_exit.hide();
						}
						if (config.dev) {
							map.errstop.show();
						}
						else {
							map.errstop.hide();
						}
					}
				}
			},
			appearence: {
				name: '外观',
				config: {
					theme: {
						name: '主题',
						init: 'woodden',
						item: {},
						visualMenu: function (node, link) {
							if (!node.menu) {
								node.className = 'button character themebutton ' + link;
								node.menu = ui.create.div(node, '', '<div></div><div></div><div></div><div></div>');
							}
						},
						onclick: function (theme) {
							game.saveConfig('theme', theme);
							ui.arena.hide();
							lib.init.background();
							if (lib.config.autostyle) {
								if (theme == 'simple') {
									lib.configMenu.appearence.config.player_border.onclick('slim');
								}
								else {
									lib.configMenu.appearence.config.player_border.onclick('normal');
								}
							}
							setTimeout(function () {
								var theme = ui.css.theme;
								ui.css.theme = lib.init.css(lib.assetURL + 'theme/' + lib.config.theme, 'style');
								theme.remove();
								setTimeout(function () { ui.arena.show(); }, 100);
							}, 500);
						}
					},
					layout: {
						name: '布局',
						init: 'mobile',
						item: {
							default: '旧版',
							newlayout: '对称',
							mobile: '默认',
							long: '宽屏',
							long2: '手杀',
							nova: '新版'
						},
						visualMenu: function (node, link) {
							node.className = 'button character themebutton ' + lib.config.theme;
							if (!node.created) {
								node.created = true;
								node.style.overflow = 'hidden';
								node.firstChild.style.display = 'none';
								// node.firstChild.classList.add('shadowed');
								// node.firstChild.style.width='16px';
								// node.firstChild.style.height='auto';
								// node.firstChild.style.padding='2px';
								// node.firstChild.style.textAlign='center';
								var me = ui.create.div(node);
								me.style.top = 'auto';
								if (link == 'default' || link == 'newlayout') {
									me.style.width = 'calc(100% - 6px)';
									me.style.left = '3px';
									me.style.bottom = '3px';
									me.style.height = '25px';
									if (link == 'newlayout') {
										me.style.height = '23px';
										me.style.bottom = '4px';
									}
								}
								else if (link == 'long2' || link == 'nova') {
									me.style.display = 'none';
								}
								else {
									me.style.width = '120%';
									me.style.left = '-10%';
									me.style.bottom = '0';
									me.style.height = '22px';
								}
								me.style.borderRadius = '2px';
								var list = ['re_caocao', 're_liubei', 'sp_zhangjiao', 'sunquan'];
								for (var i = 0; i < 4; i++) {
									var player = ui.create.div('.fakeplayer', node);
									ui.create.div('.avatar', player).setBackground(list.randomRemove(), 'character');
									player.style.borderRadius = '2px';
									if (i != 3) {
										player.style.top = 'auto';
									}
									if (link == 'default') {
										player.style.height = '19px';
										player.style.width = '38px';
										player.classList.add('oldlayout')
									}
									else if (link == 'mobile' || link == 'newlayout') {
										player.style.width = '24px';
										player.style.height = '29px';
									}
									else if (link == 'nova') {
										player.style.width = '20px';
										player.style.height = '24px';
									}
									else {
										player.style.width = '20px';
										player.style.height = '34px';
									}
									if (i == 1) {
										player.style.left = '3px';
									}
									if (i == 2) {
										player.style.left = 'auto';
										player.style.right = '3px';
									}
									if (i == 3) {
										player.style.top = '3px';
									}
									if (link == 'default') {
										if (i == 0) {
											player.style.bottom = '6px';
										}
										if (i == 0 || i == 3) {
											player.style.left = 'calc(50% - 18px)';
										}
										if (i == 1 || i == 2) {
											player.style.bottom = '36px';
										}
									}
									else if (link == 'newlayout') {
										if (i == 0) {
											player.style.bottom = '1px';
										}
										if (i == 0 || i == 3) {
											player.style.left = 'calc(50% - 12px)';
										}
										if (i == 1 || i == 2) {
											player.style.bottom = '32px';
										}
									}
									else if (link == 'mobile') {
										if (i == 0 || i == 3) {
											player.style.left = 'calc(50% - 12px)';
										}
										if (i == 1 || i == 2) {
											player.style.bottom = '30px';
										}
									}
									else if (link == 'long') {
										if (i == 0 || i == 3) {
											player.style.left = 'calc(50% - 10px)';
										}
										if (i == 1 || i == 2) {
											player.style.bottom = '45px';
										}
									}
									else if (link == 'long2') {
										if (i == 0) {
											player.style.bottom = '2px';
											player.style.left = '3px';
										}
										if (i == 3) {
											player.style.left = 'calc(50% - 10px)';
										}
										if (i == 1 || i == 2) {
											player.style.bottom = '45px';
										}
									}
									else if (link == 'nova') {
										if (i == 0) {
											player.style.bottom = '2px';
											player.style.left = '3px';
										}
										if (i == 3) {
											player.style.left = 'calc(50% - 10px)';
										}
										if (i == 1 || i == 2) {
											player.style.left = '3px';
											player.style.bottom = (i * 30) + 'px';
										}
									}

									if (i == 0 && (link == 'mobile' || link == 'long')) {
										player.classList.add('me');
										player.style.borderRadius = '0px';
										player.style.width = '25px';
										player.style.height = '25px';
										player.style.bottom = '-3px';
										player.style.left = '-3px';
									}
								}
							}
						},
						onclick: function (layout) {
							if (lib.layoutfixed.contains(lib.config.mode)) {
								game.saveConfig('layout', layout);
							}
							else {
								lib.init.layout(layout);
							}
						}
					},
					// fewplayer:{
					//     name:'启用人数',
					// 	intro:'设置启用新版布局的最小人数（不足时切换至默认布局）',
					//     init:'3',
					//     // unfrequent:true,
					//     item:{
					//      			'2':'两人',
					//      			'3':'三人',
					//      			'4':'四人',
					//      			'5':'五人',
					//      			'6':'六人',
					//      			'7':'七人',
					//      			'8':'八人',
					//     },
					//     onclick:function(item){
					//      			game.saveConfig('fewplayer',item);
					//      			if(ui.arena) ui.arena.setNumber(ui.arena.dataset.number);
					//     }
					// },
					player_height: {
						name: '角色高度',
						init: 'long',
						// unfrequent:true,
						item: {
							short: '矮',
							default: '中',
							long: '高',
						},
						onclick: function (item) {
							game.saveConfig('player_height', item);
							ui.arena.dataset.player_height = item;
						}
					},
					player_height_nova: {
						name: '角色高度',
						init: 'short',
						item: {
							// auto:'自动',
							short: '矮',
							default: '中',
							long: '高',
						},
						onclick: function (item) {
							game.saveConfig('player_height_nova', item);
							// if(item=='auto'){
							// 	if(parseInt(ui.arena.dataset.number)>=7){
							// 		ui.arena.dataset.player_height_nova='short';
							// 	}
							// 	else{
							// 		ui.arena.dataset.player_height_nova='default';
							// 	}
							// }
							// else{
							ui.arena.dataset.player_height_nova = item;
							// }
						}
					},
					// background_color_music:{
					// 	name:'背景色',
					// 	init:'black',
					// 	item:{
					// 		blue:'蓝色',
					// 		black:'黑色',
					// 	},
					// 	onclick:function(color){
					// 		game.saveConfig('background_color_music',color);
					// 		document.body.dataset.background_color_music=color;
					// 	}
					// },
					// background_color_wood:{
					// 	name:'背景色',
					// 	init:'blue',
					// 	item:{
					// 		blue:'蓝色',
					// 		black:'黑色',
					// 	},
					// 	onclick:function(color){
					// 		game.saveConfig('background_color_wood',color);
					// 		document.body.dataset.background_color_wood=color;
					// 	}
					// },
					// theme_color_music:{
					// 	name:'主题色',
					// 	init:'black',
					// 	item:{
					// 		blue:'蓝色',
					// 		black:'黑色',
					// 	},
					// 	onclick:function(color){
					// 		game.saveConfig('theme_color_music',color);
					// 		document.body.dataset.theme_color_music=color;
					// 	}
					// },
					ui_zoom: {
						name: '界面缩放',
						unfrequent: true,
						init: 'normal',
						item: {
							esmall: '80%',
							vsmall: '90%',
							small: '95%',
							normal: '100%',
							big: '105%',
							vbig: '110%',
							ebig: '120%',
						},
						onclick: function (zoom) {
							game.saveConfig('ui_zoom', zoom);
							switch (zoom) {
								case 'esmall': zoom = 0.8; break;
								case 'vsmall': zoom = 0.9; break;
								case 'small': zoom = 0.93; break;
								case 'big': zoom = 1.05; break;
								case 'vbig': zoom = 1.1; break;
								case 'ebig': zoom = 1.2; break;
								default: zoom = 1;
							}
							game.documentZoom = game.deviceZoom * zoom;
							ui.updatez();
						}
					},
					image_background: {
						name: '游戏背景',
						init: 'default',
						item: {},
						visualBar: function (node, item, create) {
							if (node.created) {
								node.lastChild.classList.remove('active');
								return;
							}
							node.created = true;
							ui.create.filediv('.menubutton', '添加背景', node, function (file) {
								if (file) {
									var name = file.name;
									if (name.indexOf('.') != -1) {
										name = name.slice(0, name.indexOf('.'));
									}
									var link = (game.writeFile ? 'cdv_' : 'custom_') + name;
									if (item[link]) {
										for (var i = 1; i < 1000; i++) {
											if (!item[link + '_' + i]) {
												link = link + '_' + i; break;
											}
										}
									}
									item[link] = name;
									var callback = function () {
										create(link, node.parentNode.defaultNode);
										node.parentNode.updateBr();
										lib.config.customBackgroundPack.add(link);
										game.saveConfig('customBackgroundPack', lib.config.customBackgroundPack);
									};
									if (game.writeFile) {
										game.writeFile(file, 'image/background', link + '.jpg', callback);
									}
									else {
										game.putDB('image', link, file, callback);
									}
									if (node.lastChild.classList.contains('active')) {
										editbg.call(node.lastChild);
									}
								}
							}).inputNode.accept = 'image/*';
							var editbg = function () {
								this.classList.toggle('active');
								var page = this.parentNode.parentNode;
								for (var i = 0; i < page.childElementCount; i++) {
									if (page.childNodes[i].classList.contains('button')) {
										var link = page.childNodes[i]._link;
										if (link && link != 'default') {
											var str;
											if (this.classList.contains('active')) {
												if (link.indexOf('custom_') == 0 || link.indexOf('cdv_') == 0) {
													str = '删除';
												}
												else {
													str = '隐藏';
												}
											}
											else {
												str = item[link];
											}
											page.childNodes[i].firstChild.innerHTML = get.verticalStr(str);
										}
									}
								}
							};
							ui.create.div('.menubutton', '编辑背景', node, editbg);
						},
						visualMenu: function (node, link, name, config) {
							node.className = 'button character';
							node.style.backgroundImage = '';
							node.style.backgroundSize = '';
							if (node.firstChild) {
								node.firstChild.innerHTML = get.verticalStr(name);
							}
							if (link == 'default' || link.indexOf('custom_') == 0) {
								node.style.backgroundImage = 'none';
								node.classList.add('dashedmenubutton');
								if (link.indexOf('custom_') == 0) {
									game.getDB('image', link, function (fileToLoad) {
										if (!fileToLoad) return;
										var fileReader = new FileReader();
										fileReader.onload = function (fileLoadedEvent) {
											var data = fileLoadedEvent.target.result;
											node.style.backgroundImage = 'url(' + data + ')';
											node.style.backgroundSize = 'cover';
											node.classList.remove('dashedmenubutton');
										};
										fileReader.readAsDataURL(fileToLoad, "UTF-8");
									});
								}
								else {
									node.parentNode.defaultNode = node;
								}
							}
							else {
								node.setBackgroundImage('image/background/' + link + '.jpg');
								node.style.backgroundSize = 'cover';
							}
						},
						onclick: function (background, node) {
							if (node && node.firstChild) {
								var menu = node.parentNode;
								if (node.firstChild.innerHTML == get.verticalStr('隐藏')) {
									menu.parentNode.noclose = true;
									node.remove();
									menu.updateBr();
									if (!lib.config.prompt_hidebg) {
										alert('隐藏的背景可通过选项-其它-重置隐藏内容恢复');
										game.saveConfig('prompt_hidebg', true);
									}
									lib.config.hiddenBackgroundPack.add(background);
									game.saveConfig('hiddenBackgroundPack', lib.config.hiddenBackgroundPack);
									delete lib.configMenu.appearence.config.image_background.item[background];
									if (lib.config.image_background == background) {
										background = 'default';
										this.lastChild.innerHTML = '默认';
									}
									else {
										this.lastChild.innerHTML = lib.configMenu.appearence.config.image_background.item[lib.config.image_background];
										return;
									}
								}
								else if (node.firstChild.innerHTML == get.verticalStr('删除')) {
									menu.parentNode.noclose = true;
									if (confirm('是否删除此背景？（此操作不可撤销）')) {
										node.remove();
										menu.updateBr();
										lib.config.customBackgroundPack.remove(background);
										game.saveConfig('customBackgroundPack', lib.config.customBackgroundPack);
										if (background.indexOf('cdv_') == 0) {
											game.removeFile('image/background/' + background + '.jpg');
										}
										else {
											game.deleteDB('image', background);
										}
										delete lib.configMenu.appearence.config.image_background.item[background];
										if (lib.config.image_background == background) {
											background = 'default';
											this.lastChild.innerHTML = '默认';
										}
										else {
											this.lastChild.innerHTML = lib.configMenu.appearence.config.image_background.item[lib.config.image_background];
											return;
										}
									}
								}
							}
							var animate = lib.config.image_background == 'default';
							game.saveConfig('image_background', background);
							lib.init.background();
							ui.background.delete();
							ui.background = ui.create.div('.background');

							if (lib.config.image_background_blur) {
								ui.background.style.filter = 'blur(8px)';
								ui.background.style.webkitFilter = 'blur(8px)';
								ui.background.style.transform = 'scale(1.05)';
							}
							else {
								ui.background.style.filter = '';
								ui.background.style.webkitFilter = '';
								ui.background.style.transform = '';
							}

							document.body.insertBefore(ui.background, document.body.firstChild);
							if (animate) ui.background.animate('start');
							if (lib.config.image_background == 'default') {
								ui.background.style.backgroundImage = "none";
							}
							else if (lib.config.image_background.indexOf('custom_') == 0) {
								ui.background.style.backgroundImage = "none";
								game.getDB('image', lib.config.image_background, function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										ui.background.style.backgroundImage = 'url(' + data + ')';
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
							else {
								ui.background.setBackgroundImage('image/background/' + lib.config.image_background + '.jpg');
							}
							ui.background.style.backgroundSize = 'cover';
							ui.background.style.backgroundPosition = '50% 50%';
						},
					},
					image_background_random: {
						name: '随机背景',
						init: false,
						onclick: function (bool) {
							game.saveConfig('image_background_random', bool);
							lib.init.background();
						}
					},
					image_background_blur: {
						name: '背景模糊',
						init: false,
						onclick: function (bool) {
							game.saveConfig('image_background_blur', bool);
							if (lib.config.image_background_blur) {
								ui.background.style.filter = 'blur(8px)';
								ui.background.style.webkitFilter = 'blur(8px)';
								ui.background.style.transform = 'scale(1.05)';
							}
							else {
								ui.background.style.filter = '';
								ui.background.style.webkitFilter = '';
								ui.background.style.transform = '';
							}
						},
					},
					phonelayout: {
						name: '触屏布局',
						init: false,
						onclick: function (bool) {
							if (get.is.nomenu('phonelayout', bool)) return false;
							game.saveConfig('phonelayout', bool);
							if (get.is.phoneLayout()) {
								ui.css.phone.href = lib.assetURL + 'layout/default/phone.css';
								ui.arena.classList.add('phone');
							}
							else {
								ui.css.phone.href = '';
								ui.arena.classList.remove('phone');
							}
						}
					},
					change_skin: {
						name: '开启换肤',
						init: true,
						intro: '在武将的右键菜单中换肤，皮肤可在选项-文件-图片文件-皮肤图片中添加'
					},
					change_skin_auto: {
						name: '自动换肤',
						init: 'off',
						item: {
							'off': '关闭',
							'30000': '半分钟',
							'60000': '一分钟',
							'120000': '两分钟',
							'300000': '五分钟',
						},
						intro: '游戏每进行一段时间自动为一个随机角色更换皮肤',
						onclick: function (item) {
							game.saveConfig('change_skin_auto', item);
							clearTimeout(_status.skintimeout);
							if (item != 'off') {
								_status.skintimeout = setTimeout(ui.click.autoskin, parseInt(item));
							}
						}
					},
					card_style: {
						name: '卡牌样式',
						init: 'default',
						intro: '设置正面朝上的卡牌的样式',
						item: {
							wood: '木纹',
							music: '音乐',
							simple: '原版',
							ol: '手杀',
							// new:'新版',
							custom: '自定',
							default: '默认',
						},
						visualBar: function (node, item, create, switcher) {
							if (node.created) {
								return;
							}
							var button;
							for (var i = 0; i < node.parentNode.childElementCount; i++) {
								if (node.parentNode.childNodes[i]._link == 'custom') {
									button = node.parentNode.childNodes[i];
								}
							}
							if (!button) {
								return;
							}
							node.created = true;
							var deletepic;
							ui.create.filediv('.menubutton', '添加图片', node, function (file) {
								if (file) {
									game.putDB('image', 'card_style', file, function () {
										game.getDB('image', 'card_style', function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												button.style.backgroundImage = 'url(' + data + ')';
												button.className = 'button card fullskin';
												node.classList.add('showdelete');
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									});
								}
							}).inputNode.accept = 'image*';
							deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
								if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
									game.deleteDB('image', 'card_style');
									button.style.backgroundImage = 'none';
									button.className = 'button character dashedmenubutton';
									node.classList.remove('showdelete');
									if (lib.config.card_style == 'custom') {
										lib.configMenu.appearence.config.card_style.onclick('default');
										switcher.lastChild.innerHTML = '默认';
									}
									button.classList.add('transparent');
								}
							});
						},
						visualMenu: function (node, link, name, config) {
							node.className = 'button card fullskin';
							node.style.backgroundSize = '100% 100%';
							switch (link) {
								case 'default': case 'custom': {
									if (lib.config.theme == 'simple') {
										node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))';
										node.className = 'button character';
									}
									else {
										node.style.backgroundImage = 'none';
										node.className = 'button character dashedmenubutton';
									}
									break;
								}
								case 'new': node.setBackgroundImage('theme/style/card/image/new.png'); break;
								case 'ol': node.setBackgroundImage('theme/style/card/image/ol.png'); break;
								case 'wood': node.setBackgroundImage('theme/woodden/wood.jpg'); node.style.backgroundSize = 'initial'; break;
								case 'music': node.setBackgroundImage('theme/music/wood3.png'); break;
								case 'simple': node.setBackgroundImage('theme/simple/card.png'); break;
							}
							if (link == 'custom') {
								node.classList.add('transparent');
								game.getDB('image', 'card_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										node.style.backgroundImage = 'url(' + data + ')';
										node.className = 'button card fullskin';
										node.parentNode.lastChild.classList.add('showdelete');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						onclick: function (layout) {
							game.saveConfig('card_style', layout);
							var style = ui.css.card_style;
							ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', lib.config.card_style);
							style.remove();
							if (ui.css.card_stylesheet) {
								ui.css.card_stylesheet.remove();
								delete ui.css.card_stylesheet;
							}
							if (layout == 'custom') {
								game.getDB('image', 'card_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.card_stylesheet) {
											ui.css.card_stylesheet.remove();
										}
										ui.css.card_stylesheet = lib.init.sheet('.card:not(*:empty){background-image:url(' + fileLoadedEvent.target.result + ')}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						unfrequent: true,
					},
					cardback_style: {
						name: '卡背样式',
						intro: '设置背面朝上的卡牌的样式',
						init: 'default',
						item: {
							// wood:'木纹',
							// music:'音乐',
							official: '原版',
							// new:'新版',
							feicheng: '废城',
							liusha: '流沙',
							ol: '手杀',
							custom: '自定',
							default: '默认',
						},
						visualBar: function (node, item, create, switcher) {
							if (node.created) {
								return;
							}
							var button;
							for (var i = 0; i < node.parentNode.childElementCount; i++) {
								if (node.parentNode.childNodes[i]._link == 'custom') {
									button = node.parentNode.childNodes[i];
								}
							}
							if (!button) {
								return;
							}
							node.created = true;
							var deletepic;
							ui.create.filediv('.menubutton', '添加图片', node, function (file) {
								if (file) {
									game.putDB('image', 'cardback_style', file, function () {
										game.getDB('image', 'cardback_style', function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												button.style.backgroundImage = 'url(' + data + ')';
												button.className = 'button character';
												node.classList.add('showdelete');
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									});
								}
							}).inputNode.accept = 'image/*';
							ui.create.filediv('.menubutton.deletebutton.addbutton', '添加翻转图片', node, function (file) {
								if (file) {
									game.putDB('image', 'cardback_style2', file, function () {
										node.classList.add('hideadd');
									});
								}
							}).inputNode.accept = 'image/*';
							deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
								if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
									game.deleteDB('image', 'cardback_style');
									game.deleteDB('image', 'cardback_style2');
									button.style.backgroundImage = 'none';
									button.className = 'button character dashedmenubutton';
									node.classList.remove('showdelete');
									node.classList.remove('hideadd');
									if (lib.config.cardback_style == 'custom') {
										lib.configMenu.appearence.config.cardback_style.onclick('default');
										switcher.lastChild.innerHTML = '默认';
									}
									button.classList.add('transparent');
								}
							});
						},
						visualMenu: function (node, link, name, config) {
							node.style.backgroundSize = '100% 100%';
							switch (link) {
								case 'default': case 'custom': {
									node.style.backgroundImage = 'none';
									node.className = 'button character dashedmenubutton';
									break;
								}
								case 'new': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/new.png'); break;
								case 'feicheng': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/feicheng.png'); break;
								case 'official': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/official.png'); break;
								case 'liusha': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/liusha.png'); break;
								case 'ol': node.className = 'button character'; node.setBackgroundImage('theme/style/cardback/image/ol.png'); break;
								case 'wood': node.className = 'button card fullskin'; node.setBackgroundImage('theme/woodden/wood.jpg'); node.style.backgroundSize = 'initial'; break;
								case 'music': node.className = 'button card fullskin'; node.setBackgroundImage('theme/music/wood3.png'); break;
							}
							if (link == 'custom') {
								node.classList.add('transparent');
								game.getDB('image', 'cardback_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										node.style.backgroundImage = 'url(' + data + ')';
										node.className = 'button character';
										node.parentNode.lastChild.classList.add('showdelete');
										game.getDB('image', 'cardback_style2', function (file) {
											if (file) {
												node.parentNode.lastChild.classList.add('hideadd');
											}
										});
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						onclick: function (layout) {
							game.saveConfig('cardback_style', layout);
							var style = ui.css.cardback_style;
							ui.css.cardback_style = lib.init.css(lib.assetURL + 'theme/style/cardback', lib.config.cardback_style);
							style.remove();
							if (ui.css.cardback_stylesheet) {
								ui.css.cardback_stylesheet.remove();
								delete ui.css.cardback_stylesheet;
							}
							if (ui.css.cardback_stylesheet2) {
								ui.css.cardback_stylesheet2.remove();
								delete ui.css.cardback_stylesheet2;
							}
							if (layout == 'custom') {
								game.getDB('image', 'cardback_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.cardback_stylesheet) {
											ui.css.cardback_stylesheet.remove();
										}
										ui.css.cardback_stylesheet = lib.init.sheet('.card:empty,.card.infohidden{background-image:url(' + fileLoadedEvent.target.result + ')}');
										game.getDB('image', 'cardback_style2', function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												if (ui.css.cardback_stylesheet2) {
													ui.css.cardback_stylesheet2.remove();
												}
												ui.css.cardback_stylesheet2 = lib.init.sheet('.card.infohidden:not(.infoflip){background-image:url(' + fileLoadedEvent.target.result + ')}');
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						unfrequent: true,
					},
					hp_style: {
						name: '体力条样式',
						init: 'ol',
						item: {
							default: '默认',
							// official:'勾玉',
							emotion: '表情',
							glass: '勾玉',
							round: '国战',
							ol: '手杀',
							xinglass: '双鱼',
							xinround: 'OL',
							custom: '自定',
						},
						visualBar: function (node, item, create, switcher) {
							if (node.created) {
								return;
							}
							var button;
							for (var i = 0; i < node.parentNode.childElementCount; i++) {
								if (node.parentNode.childNodes[i]._link == 'custom') {
									button = node.parentNode.childNodes[i];
								}
							}
							if (!button) {
								return;
							}
							node.created = true;
							var deletepic;
							ui.create.filediv('.menubutton.addbutton', '添加图片', node, function (file) {
								if (file && node.currentDB) {
									game.putDB('image', 'hp_style' + node.currentDB, file, function () {
										game.getDB('image', 'hp_style' + node.currentDB, function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												button.childNodes[node.currentDB - 1].style.backgroundImage = 'url(' + data + ')';
												button.classList.add('shown');
												node.classList.add('showdelete');
												node.currentDB++;
												if (node.currentDB > 4) {
													node.classList.add('hideadd');
													button.classList.remove('transparent');
													delete node.currentDB;
												}
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									});
								}
							}).inputNode.accept = 'image/*';
							deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
								if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
									game.deleteDB('image', 'hp_style1');
									game.deleteDB('image', 'hp_style2');
									game.deleteDB('image', 'hp_style3');
									game.deleteDB('image', 'hp_style4');
									for (var i = 0; i < button.childElementCount; i++) {
										button.childNodes[i].style.backgroundImage = 'none';
									}
									node.classList.remove('showdelete');
									node.classList.remove('hideadd');
									if (lib.config.hp_style == 'custom') {
										lib.configMenu.appearence.config.hp_style.onclick('default');
										switcher.lastChild.innerHTML = '默认';
									}
									button.classList.add('transparent');
									button.classList.remove('shown');
									node.currentDB = 1;
								}
							});
						},
						visualMenu: function (node, link, name, config) {
							node.className = 'button hpbutton dashedmenubutton';
							node.innerHTML = '';
							for (var i = 1; i <= 4; i++) {
								var div = ui.create.div(node);
								if (link == 'default') {
									ui.create.div(div);
								}
								else if (link != 'custom') {
									div.setBackgroundImage('theme/style/hp/image/' + link + i + '.png');
								}
								if (i == 4) {
									div.style.webkitFilter = 'grayscale(1)';
								}
							}
							if (link == 'custom') {
								node.classList.add('transparent');
								var getDB = function (num) {
									node.parentNode.lastChild.currentDB = num;
									game.getDB('image', 'hp_style' + num, function (fileToLoad) {
										if (!fileToLoad) return;
										var fileReader = new FileReader();
										fileReader.onload = function (fileLoadedEvent) {
											var data = fileLoadedEvent.target.result;
											node.childNodes[num - 1].style.backgroundImage = 'url(' + data + ')';
											node.classList.add('shown');
											node.parentNode.lastChild.classList.add('showdelete');
											if (num < 4) {
												getDB(num + 1);
											}
											else {
												node.parentNode.lastChild.classList.add('hideadd');
												node.classList.remove('transparent');
												delete node.parentNode.firstChild.currentDB;
											}
										};
										fileReader.readAsDataURL(fileToLoad, "UTF-8");
									});
								}
								getDB(1);
							}
						},
						onclick: function (layout) {
							game.saveConfig('hp_style', layout);
							var style = ui.css.hp_style;
							ui.css.hp_style = lib.init.css(lib.assetURL + 'theme/style/hp', lib.config.hp_style);
							style.remove();
							if (ui.css.hp_stylesheet1) {
								ui.css.hp_stylesheet1.remove();
								delete ui.css.hp_stylesheet1;
							}
							if (ui.css.hp_stylesheet2) {
								ui.css.hp_stylesheet2.remove();
								delete ui.css.hp_stylesheet2;
							}
							if (ui.css.hp_stylesheet3) {
								ui.css.hp_stylesheet3.remove();
								delete ui.css.hp_stylesheet3;
							}
							if (ui.css.hp_stylesheet4) {
								ui.css.hp_stylesheet4.remove();
								delete ui.css.hp_stylesheet4;
							}
							if (layout == 'custom') {
								game.getDB('image', 'hp_style1', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.hp_stylesheet1) {
											ui.css.hp_stylesheet1.remove();
										}
										ui.css.hp_stylesheet1 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="high"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
								game.getDB('image', 'hp_style2', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.hp_stylesheet2) {
											ui.css.hp_stylesheet2.remove();
										}
										ui.css.hp_stylesheet2 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="mid"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
								game.getDB('image', 'hp_style3', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.hp_stylesheet3) {
											ui.css.hp_stylesheet3.remove();
										}
										ui.css.hp_stylesheet3 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="low"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
								game.getDB('image', 'hp_style4', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.hp_stylesheet4) {
											ui.css.hp_stylesheet4.remove();
										}
										ui.css.hp_stylesheet4 = lib.init.sheet('.hp:not(.text):not(.actcount)>.lost{background-image:url(' + fileLoadedEvent.target.result + ')}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						unfrequent: true,
					},
					player_style: {
						name: '角色背景',
						init: 'default',
						intro: '设置角色的背景图片',
						item: {
							wood: '木纹',
							music: '音乐',
							simple: '简约',
							custom: '自定',
							default: '默认',
						},
						visualBar: function (node, item, create, switcher) {
							if (node.created) {
								return;
							}
							var button;
							for (var i = 0; i < node.parentNode.childElementCount; i++) {
								if (node.parentNode.childNodes[i]._link == 'custom') {
									button = node.parentNode.childNodes[i];
								}
							}
							if (!button) {
								return;
							}
							node.created = true;
							var deletepic;
							ui.create.filediv('.menubutton', '添加图片', node, function (file) {
								if (file) {
									game.putDB('image', 'player_style', file, function () {
										game.getDB('image', 'player_style', function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												button.style.backgroundImage = 'url(' + data + ')';
												button.className = 'button character';
												button.style.backgroundSize = '100% 100%';
												node.classList.add('showdelete');
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									});
								}
							}).inputNode.accept = 'image/*';
							deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
								if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
									game.deleteDB('image', 'player_style');
									button.style.backgroundImage = 'none';
									button.className = 'button character dashedmenubutton';
									node.classList.remove('showdelete');
									if (lib.config.player_style == 'custom') {
										lib.configMenu.appearence.config.player_style.onclick('default');
										switcher.lastChild.innerHTML = '默认';
									}
									button.classList.add('transparent');
								}
							});
						},
						visualMenu: function (node, link, name, config) {
							node.className = 'button character';
							node.style.backgroundSize = '';
							node.style.height = '108px';
							switch (link) {
								case 'default': case 'custom': {
									node.style.backgroundImage = 'none';
									node.className = 'button character dashedmenubutton';
									break;
								}
								case 'wood': node.setBackgroundImage('theme/woodden/wood.jpg'); break;
								case 'music': node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)'; break;
								case 'simple': node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
							}
							if (link == 'custom') {
								node.classList.add('transparent');
								game.getDB('image', 'player_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										node.style.backgroundImage = 'url(' + data + ')';
										node.className = 'button character';
										node.parentNode.lastChild.classList.add('showdelete');
										node.style.backgroundSize = '100% 100%';
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						onclick: function (layout) {
							game.saveConfig('player_style', layout);
							if (ui.css.player_stylesheet) {
								ui.css.player_stylesheet.remove();
								delete ui.css.player_stylesheet;
							}
							if (layout == 'custom') {
								game.getDB('image', 'player_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.player_stylesheet) {
											ui.css.player_stylesheet.remove();
										}
										ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:url("' + fileLoadedEvent.target.result + '");background-size:100% 100%;}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
							else if (layout != 'default') {
								var str = '';
								switch (layout) {
									case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
									case 'music': str = 'linear-gradient(#4b4b4b, #464646)'; break;
									case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
								}
								ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:' + str + '}');
							}
						},
						unfrequent: true,
					},
					border_style: {
						name: '角色边框',
						init: 'default',
						intro: '设置角色边框的样式，当设为自动时，样式将随着一局游戏中伤害或击杀的数量自动改变',
						item: {
							gold: '金框',
							silver: '银框',
							bronze: '铜框',
							dragon_gold: '金龙',
							dragon_silver: '银龙',
							dragon_bronze: '玉龙',
							custom: '自定',
							auto: '自动',
							default: '默认',
						},
						visualBar: function (node, item, create, switcher) {
							if (node.created) {
								return;
							}
							var button;
							for (var i = 0; i < node.parentNode.childElementCount; i++) {
								if (node.parentNode.childNodes[i]._link == 'custom') {
									button = node.parentNode.childNodes[i];
								}
							}
							if (!button) {
								return;
							}
							node.created = true;
							var deletepic;
							ui.create.filediv('.menubutton', '添加图片', node, function (file) {
								if (file) {
									game.putDB('image', 'border_style', file, function () {
										game.getDB('image', 'border_style', function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												button.style.backgroundImage = 'url(' + data + ')';
												button.className = 'button character';
												button.style.backgroundSize = '100% 100%';
												node.classList.add('showdelete');
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									});
								}
							}).inputNode.accept = 'image/*';
							deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
								if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
									game.deleteDB('image', 'border_style');
									button.style.backgroundImage = 'none';
									button.className = 'button character dashedmenubutton';
									node.classList.remove('showdelete');
									if (lib.config.border_style == 'custom') {
										lib.configMenu.appearence.config.border_style.onclick('default');
										switcher.lastChild.innerHTML = '默认';
									}
									button.classList.add('transparent');
								}
							});
						},
						visualMenu: function (node, link, name, config) {
							node.className = 'button character';
							node.style.backgroundSize = '';
							node.style.height = '108px';
							node.dataset.decoration = '';
							if (link == 'default' || link == 'custom' || link == 'auto') {
								node.style.backgroundImage = 'none';
								node.className = 'button character dashedmenubutton';
							}
							else {
								if (link.indexOf('dragon_') == 0) {
									link = link.slice(7);
									node.dataset.decoration = link;
								}
								node.setBackgroundImage('theme/style/player/' + link + '1.png');
								node.style.backgroundSize = '100% 100%';
							}
							if (link == 'custom') {
								node.classList.add('transparent');
								game.getDB('image', 'border_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										node.style.backgroundImage = 'url(' + data + ')';
										node.className = 'button character';
										node.parentNode.lastChild.classList.add('showdelete');
										node.style.backgroundSize = '100% 100%';
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						onclick: function (layout) {
							game.saveConfig('border_style', layout);
							if (ui.css.border_stylesheet) {
								ui.css.border_stylesheet.remove();
								delete ui.css.border_stylesheet;
							}
							if (layout == 'custom') {
								game.getDB('image', 'border_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.border_stylesheet) {
											ui.css.border_stylesheet.remove();
										}
										ui.css.border_stylesheet = lib.init.sheet();
										ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg{display:block;background-image:url("' + fileLoadedEvent.target.result + '")}', 0);
										ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
							else if (layout != 'default' && layout != 'auto') {
								ui.css.border_stylesheet = lib.init.sheet();
								if (layout.indexOf('dragon_') == 0) {
									layout = layout.slice(7);
									ui.arena.dataset.framedecoration = layout;
								}
								else {
									ui.arena.dataset.framedecoration = '';
								}
								ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg,#window #arena.long.mobile:not(.fewplayer) .player[data-position="0"]>.framebg{display:block;background-image:url("' + lib.assetURL + 'theme/style/player/' + layout + '1.png")}', 0);
								ui.css.border_stylesheet.sheet.insertRule('#window #arena.long:not(.fewplayer) .player>.framebg, #arena.oldlayout .player>.framebg{background-image:url("' + lib.assetURL + 'theme/style/player/' + layout + '3.png")}', 0);
								ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
							}
						},
						unfrequent: true,
					},
					autoborder_count: {
						name: '边框升级方式',
						intro: '<strong>击杀</strong> 每击杀一人，边框提升两级<br><strong>伤害</strong> 每造成两点伤害，边框提升一级<br><strong>混合</strong> 击杀量决定边框颜色，伤害量决定边框装饰',
						init: 'kill',
						item: {
							kill: '击杀',
							damage: '伤害',
							mix: '混合',
						},
						unfrequent: true,
					},
					autoborder_start: {
						name: '基础边框颜色',
						init: 'bronze',
						item: {
							bronze: '铜',
							silver: '银',
							gold: '金'
						},
						unfrequent: true
					},
					player_border: {
						name: '边框宽度',
						init: 'normal',
						intro: '设置角色的边框宽度',
						unfrequent: true,
						item: {
							slim: '细',
							narrow: '窄',
							normal: '中',
							wide: '宽'
						},
						onclick: function (item) {
							game.saveConfig('player_border', item);
							if (item != 'wide' || game.layout == 'long' || game.layout == 'long2') {
								ui.arena.classList.add('slim_player');
							}
							else {
								ui.arena.classList.remove('slim_player');
							}
							if (item == 'slim') {
								ui.arena.classList.add('uslim_player');
							}
							else {
								ui.arena.classList.remove('uslim_player');
							}
							if (item == 'narrow') {
								ui.arena.classList.add('mslim_player');
							}
							else {
								ui.arena.classList.remove('mslim_player');
							}
							if (item == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
								ui.arena.classList.add('lslim_player');
							}
							else {
								ui.arena.classList.remove('lslim_player');
							}
							ui.window.dataset.player_border = item;
						}
					},
					menu_style: {
						name: '菜单背景',
						init: 'default',
						item: {
							wood: '木纹',
							music: '音乐',
							simple: '简约',
							custom: '自定',
							default: '默认',
						},
						visualBar: function (node, item, create, switcher) {
							if (node.created) {
								return;
							}
							var button;
							for (var i = 0; i < node.parentNode.childElementCount; i++) {
								if (node.parentNode.childNodes[i]._link == 'custom') {
									button = node.parentNode.childNodes[i];
								}
							}
							if (!button) {
								return;
							}
							node.created = true;
							var deletepic;
							ui.create.filediv('.menubutton', '添加图片', node, function (file) {
								if (file) {
									game.putDB('image', 'menu_style', file, function () {
										game.getDB('image', 'menu_style', function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												button.style.backgroundImage = 'url(' + data + ')';
												button.style.backgroundSize = 'cover';
												button.className = 'button character';
												node.classList.add('showdelete');
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									});
								}
							}).inputNode.accept = 'image/*';
							deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
								if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
									game.deleteDB('image', 'menu_style');
									button.style.backgroundImage = 'none';
									button.style.backgroundSize = 'auto';
									button.className = 'button character dashedmenubutton';
									node.classList.remove('showdelete');
									if (lib.config.menu_style == 'custom') {
										lib.configMenu.appearence.config.menu_style.onclick('default');
										switcher.lastChild.innerHTML = '默认';
									}
									button.classList.add('transparent');
								}
							});
						},
						visualMenu: function (node, link, name, config) {
							node.className = 'button character';
							node.style.backgroundSize = 'auto';
							switch (link) {
								case 'default': case 'custom': {
									node.style.backgroundImage = 'none';
									node.classList.add('dashedmenubutton');
									break;
								}
								case 'wood': node.setBackgroundImage('theme/woodden/wood2.png'); break;
								case 'music': node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)'; break;
								case 'simple': node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
							}
							if (link == 'custom') {
								node.classList.add('transparent');
								game.getDB('image', 'menu_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										node.style.backgroundImage = 'url(' + data + ')';
										node.style.backgroundSize = 'cover';
										node.className = 'button character';
										node.parentNode.lastChild.classList.add('showdelete');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						onclick: function (layout) {
							game.saveConfig('menu_style', layout);
							if (ui.css.menu_stylesheet) {
								ui.css.menu_stylesheet.remove();
								delete ui.css.menu_stylesheet;
							}
							if (layout == 'custom') {
								game.getDB('image', 'menu_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.menu_stylesheet) {
											ui.css.menu_stylesheet.remove();
										}
										ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:url("' + fileLoadedEvent.target.result + '");background-size:cover}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
							else if (layout != 'default') {
								var str = '';
								switch (layout) {
									case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood2.png")'; break;
									case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
									case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
								}
								ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:' + str + '}');
							}
						},
						unfrequent: true,
					},
					control_style: {
						name: '按钮背景',
						init: 'default',
						item: {
							wood: '木纹',
							music: '音乐',
							simple: '简约',
							custom: '自定',
							default: '默认',
						},
						visualBar: function (node, item, create, switcher) {
							if (node.created) {
								return;
							}
							var button;
							for (var i = 0; i < node.parentNode.childElementCount; i++) {
								if (node.parentNode.childNodes[i]._link == 'custom') {
									button = node.parentNode.childNodes[i];
								}
							}
							if (!button) {
								return;
							}
							node.created = true;
							var deletepic;
							ui.create.filediv('.menubutton', '添加图片', node, function (file) {
								if (file) {
									game.putDB('image', 'control_style', file, function () {
										game.getDB('image', 'control_style', function (fileToLoad) {
											if (!fileToLoad) return;
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												button.style.backgroundImage = 'url(' + data + ')';
												button.className = 'button character controlbutton';
												node.classList.add('showdelete');
											};
											fileReader.readAsDataURL(fileToLoad, "UTF-8");
										});
									});
								}
							}).inputNode.accept = 'image/*';
							deletepic = ui.create.div('.menubutton.deletebutton', '删除图片', node, function () {
								if (confirm('确定删除自定义图片？（此操作不可撤销）')) {
									game.deleteDB('image', 'control_style');
									button.style.backgroundImage = 'none';
									button.className = 'button character controlbutton dashedmenubutton';
									node.classList.remove('showdelete');
									if (lib.config.control_style == 'custom') {
										lib.configMenu.appearence.config.control_style.onclick('default');
										switcher.lastChild.innerHTML = '默认';
									}
									button.classList.add('transparent');
								}
							});
						},
						visualMenu: function (node, link, name, config) {
							node.className = 'button character controlbutton';
							node.style.backgroundSize = '';
							switch (link) {
								case 'default': case 'custom': {
									node.style.backgroundImage = 'none';
									node.classList.add('dashedmenubutton');
									break;
								}
								case 'wood': node.setBackgroundImage('theme/woodden/wood.jpg'); break;
								case 'music': node.style.backgroundImage = 'linear-gradient(#4b4b4b, #464646)'; break;
								case 'simple': node.style.backgroundImage = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
							}
							if (link == 'custom') {
								node.classList.add('transparent');
								game.getDB('image', 'control_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										node.style.backgroundImage = 'url(' + data + ')';
										node.className = 'button character controlbutton';
										node.parentNode.lastChild.classList.add('showdelete');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
						},
						onclick: function (layout) {
							game.saveConfig('control_style', layout);
							if (ui.css.control_stylesheet) {
								ui.css.control_stylesheet.remove();
								delete ui.css.control_stylesheet;
							}
							if (layout == 'custom') {
								game.getDB('image', 'control_style', function (fileToLoad) {
									if (!fileToLoad) return;
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										if (ui.css.control_stylesheet) {
											ui.css.control_stylesheet.remove();
										}
										ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:url("' + fileLoadedEvent.target.result + '")}');
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								});
							}
							else if (layout != 'default') {
								var str = '';
								switch (layout) {
									case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
									case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
									case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
								}
								if (layout == 'wood') {
									ui.css.control_stylesheet = lib.init.sheet('#window .control,#window .menubutton,#window #system>div>div,#window #system>div>.pressdown2{background-image:' + str + '}');
								}
								else {
									ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:' + str + '}');
								}
							}
						},
						unfrequent: true,
					},
					custom_button: {
						name: '自定义按钮高度',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							if (bool !== 'skip') {
								game.saveConfig('custom_button', bool);
							}
							if (ui.css.buttonsheet) {
								ui.css.buttonsheet.remove();
							}
							if (lib.config.custom_button) {
								var cbnum1 = 6 + (parseInt(lib.config.custom_button_system_top) || 0);
								var cbnum2 = 6 + (parseInt(lib.config.custom_button_system_bottom) || 0);
								var cbnum3 = 3 + (parseInt(lib.config.custom_button_control_top) || 0);
								var cbnum4 = 3 + (parseInt(lib.config.custom_button_control_bottom) || 0);
								var cbnum5 = 2;
								var cbnum6 = 2;
								if (cbnum3 < 0) {
									cbnum5 += cbnum3;
									cbnum3 = 0;
								}
								if (cbnum4 < 0) {
									cbnum6 += cbnum4;
									cbnum4 = 0;
								}
								ui.css.buttonsheet = lib.init.sheet(
									'#system>div>div, .caption>div>.tdnode{padding-top:' + cbnum1 + 'px !important;padding-bottom:' + cbnum2 + 'px !important}',
									'#control>.control>div{padding-top:' + cbnum3 + 'px;padding-bottom:' + cbnum4 + 'px}',
									'#control>.control{padding-top:' + cbnum5 + 'px;padding-bottom:' + cbnum6 + 'px}'
								);
							}
						}
					},
					custom_button_system_top: {
						name: '菜单上部高度',
						init: '0x',
						item: {
							'-5x': '-5px',
							'-4x': '-4px',
							'-3x': '-3px',
							'-2x': '-2px',
							'-1x': '-1px',
							'0x': '默认',
							'1x': '1px',
							'2x': '2px',
							'3x': '3px',
							'4x': '4px',
							'5x': '5px',
						},
						unfrequent: true,
						onclick: function (item) {
							game.saveConfig('custom_button_system_top', item);
							lib.configMenu.appearence.config.custom_button.onclick('skip');
						}
					},
					custom_button_system_bottom: {
						name: '菜单下部高度',
						init: '0x',
						item: {
							'-5x': '-5px',
							'-4x': '-4px',
							'-3x': '-3px',
							'-2x': '-2px',
							'-1x': '-1px',
							'0x': '默认',
							'1x': '1px',
							'2x': '2px',
							'3x': '3px',
							'4x': '4px',
							'5x': '5px',
						},
						unfrequent: true,
						onclick: function (item) {
							game.saveConfig('custom_button_system_bottom', item);
							lib.configMenu.appearence.config.custom_button.onclick('skip');
						}
					},
					custom_button_control_top: {
						name: '技能上部高度',
						init: '0x',
						item: {
							'-5x': '-5px',
							'-4x': '-4px',
							'-3x': '-3px',
							'-2x': '-2px',
							'-1x': '-1px',
							'0x': '默认',
							'1x': '1px',
							'2x': '2px',
							'3x': '3px',
							'4x': '4px',
							'5x': '5px',
						},
						unfrequent: true,
						onclick: function (item) {
							game.saveConfig('custom_button_control_top', item);
							lib.configMenu.appearence.config.custom_button.onclick('skip');
						}
					},
					custom_button_control_bottom: {
						name: '技能下部高度',
						init: '0x',
						item: {
							'-5x': '-5px',
							'-4x': '-4px',
							'-3x': '-3px',
							'-2x': '-2px',
							'-1x': '-1px',
							'0x': '默认',
							'1x': '1px',
							'2x': '2px',
							'3x': '3px',
							'4x': '4px',
							'5x': '5px',
						},
						unfrequent: true,
						onclick: function (item) {
							game.saveConfig('custom_button_control_bottom', item);
							lib.configMenu.appearence.config.custom_button.onclick('skip');
						}
					},
					radius_size: {
						name: '圆角大小',
						init: 'default',
						item: {
							off: '关闭',
							reduce: '减小',
							default: '默认',
							increase: '增大',
						},
						unfrequent: true,
						onclick: function (item) {
							game.saveConfig('radius_size', item);
							ui.window.dataset.radius_size = item;
						}
					},
					glow_phase: {
						name: '当前回合角色高亮',
						unfrequent: true,
						init: 'yellow',
						intro: '设置当前回合角色的边框颜色',
						item: {
							none: '无',
							yellow: '黄色',
							green: '绿色',
							purple: '紫色',
						},
						onclick: function (bool) {
							game.saveConfig('glow_phase', bool);
							lib.init.cssstyles();
						}
					},
					fold_card: {
						name: '折叠手牌',
						init: true,
						unfrequent: true,
					},
					fold_mode: {
						name: '折叠模式菜单',
						intro: '关闭后模式菜单中“更多”内的项目将直接展开',
						init: true,
						unfrequent: true,
					},
					seperate_control: {
						name: '分离选项条',
						init: true,
						unfrequent: true,
						intro: '开启后玩家在进行选择时不同的选项将分开，而不是连在一起',
					},
					blur_ui: {
						name: '模糊效果',
						intro: '在暂停或打开菜单时开启模糊效果',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('blur_ui', bool);
							if (bool) {
								ui.window.classList.add('blur_ui');
							}
							else {
								ui.window.classList.remove('blur_ui');
							}
						}
					},
					glass_ui: {
						name: '玻璃主题',
						intro: '为游戏主题打开玻璃效果（手机暂不支持）',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('glass_ui', bool);
							if (bool) {
								ui.window.classList.add('glass_ui');
							}
							else {
								ui.window.classList.remove('glass_ui');
							}
						}
					},
					damage_shake: {
						name: '伤害抖动',
						intro: '角色受到伤害时的抖动效果',
						init: true,
						unfrequent: true,
					},
					button_press: {
						name: '按钮效果',
						intro: '选项条被按下时将有按下效果',
						init: true,
						unfrequent: true,
					},
					jiu_effect: {
						name: '喝酒效果',
						init: true,
						unfrequent: true,
					},
					animation: {
						name: '游戏特效',
						intro: '开启后出现属性伤害、回复体力等情况时会显示动画',
						init: false,
						unfrequent: true,
					},
					skill_animation_type: {
						name: '技能特效',
						intro: '开启后觉醒技、限定技将显示全屏文字',
						init: 'default',
						unfrequent: true,
						item: {
							default: '默认',
							old: '旧版',
							off: '关闭'
						}
					},
					die_move: {
						name: '阵亡效果',
						intro: '阵亡后武将的显示效果',
						init: 'flip',
						unfrequent: true,
						item: {
							off: '关闭',
							move: '移动',
							flip: '翻面',
						}
					},
					target_shake: {
						name: '目标效果',
						intro: '一名玩家成为卡牌或技能的目标时的显示效果',
						init: 'off',
						item: {
							off: '关闭',
							zoom: '缩放',
							shake: '抖动',
						},
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('target_shake', bool);
							ui.arena.dataset.target_shake = bool;
						}
					},
					turned_style: {
						name: '翻面文字',
						intro: '角色被翻面时显示“翻面”',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('turned_style', bool);
							if (bool) {
								ui.arena.classList.remove('hide_turned');
							}
							else {
								ui.arena.classList.add('hide_turned');
							}
						}
					},
					link_style2: {
						name: '横置样式',
						intro: '设置角色被横置时的样式',
						init: 'chain',
						unfrequent: true,
						item: {
							chain: '铁索',
							rotate: '横置',
							mark: '标记'
						},
						onclick: function (style) {
							var list = [];
							for (var i = 0; i < game.players.length; i++) {
								if (game.players[i].isLinked()) {
									list.push(game.players[i]);
								}
							}
							game.saveConfig('link_style2', style);
							for (var i = 0; i < list.length; i++) {
								if (get.is.linked2(list[i])) {
									list[i].classList.add('linked2');
									list[i].classList.remove('linked');
								}
								else {
									list[i].classList.add('linked');
									list[i].classList.remove('linked2');
								}
							}
							if (style == 'chain') {
								ui.arena.classList.remove('nolink');
							}
							else {
								ui.arena.classList.add('nolink');
							}
							ui.updatem();
						}
					},
					cardshape: {
						name: '手牌显示',
						intro: '将手牌设置为正方形或长方形',
						init: 'default',
						unfrequent: true,
						item: {
							default: '默认',
							oblong: '长方',
						},
						onclick: function (item) {
							var linked = false;
							if (game.me && game.me.isLinked()) {
								linked = true;
							}
							game.saveConfig('cardshape', item);
							if (item == 'oblong' && (game.layout == 'long' || game.layout == 'mobile' || game.layout == 'long2' || game.layout == 'nova')) {
								ui.arena.classList.add('oblongcard');
								ui.window.classList.add('oblongcard');
							}
							else {
								ui.arena.classList.remove('oblongcard');
								ui.window.classList.remove('oblongcard');
							}
							if (linked) {
								if (get.is.linked2(game.me)) {
									game.me.classList.remove('linked');
									game.me.classList.add('linked2');
								}
								else {
									game.me.classList.add('linked');
									game.me.classList.remove('linked2');
								}
							}
						}
					},
					cardtempname: {
						name: '视为卡牌名称显示',
						intro: '显示强制视为类卡牌（如武魂）等名称的显示方式',
						init: 'default',
						unfrequent: true,
						item: {
							default: '纵向',
							horizon: '横向',
							off: '禁用',
						},
						onclick: function (item) {
							game.saveConfig('cardtempname', item);
							if (!game.me || !game.me.getCards) return;
							var hs = game.me.getCards('h');
							for (var i = 0; i < hs.length; i++) {
								if (hs[i]._tempName) {
									switch (item) {
										case 'default':
											var node = hs[i]._tempName;
											node.innerHTML = get.verticalStr(node.tempname);
											break;
										case 'horizon':
											var node = hs[i]._tempName;
											node.innerHTML = node.tempname;
											break;
										default:
											hs[i]._tempName.delete();
											delete hs[i]._tempName;
									}
								}
							}
						}
					},
					textequip: {
						name: '装备显示',
						init: 'image',
						unfrequent: true,
						item: {
							image: '图片',
							text: '文字',
						},
						onclick: function (item) {
							game.saveConfig('textequip', item);
							if (item == 'text' && (game.layout == 'long' || game.layout == 'mobile')) {
								ui.arena.classList.add('textequip');
							}
							else {
								ui.arena.classList.remove('textequip');
							}
						}
					},
					buttoncharacter_style: {
						name: '选将样式',
						init: 'default',
						item: {
							default: '默认',
							simple: '精简',
							old: '旧版'
						},
						unfrequent: true,
					},
					cursor_style: {
						name: '鼠标指针',
						init: 'auto',
						intro: '设置为固定后鼠标指针将不随移动到的区域而变化',
						unfrequent: true,
						item: {
							auto: '自动',
							pointer: '固定'
						},
						onclick: function (item) {
							game.saveConfig('cursor_style', item);
							if (item == 'pointer') {
								ui.window.classList.add('nopointer');
							}
							else {
								ui.window.classList.remove('nopointer');
							}
						}
					},
					name_font: {
						name: '人名字体',
						init: 'xingkai',
						unfrequent: true,
						item: {},
						textMenu: function (node, link) {
							if (link != 'default') {
								node.style.fontFamily = link;
							}
							node.style.fontSize = '20px';
						},
						onclick: function (font) {
							game.saveConfig('name_font', font);
							lib.init.cssstyles();
						}
					},
					identity_font: {
						name: '身份字体',
						init: 'huangcao',
						unfrequent: true,
						item: {},
						textMenu: function (node, link) {
							if (link != 'default') {
								node.style.fontFamily = link;
							}
							node.style.fontSize = '20px';
						},
						onclick: function (font) {
							game.saveConfig('identity_font', font);
							lib.init.cssstyles();
						}
					},
					cardtext_font: {
						name: '卡牌字体',
						init: 'default',
						unfrequent: true,
						item: {},
						textMenu: function (node, link) {
							if (link != 'default') {
								node.style.fontFamily = link;
							}
							node.style.fontSize = '20px';
						},
						onclick: function (font) {
							game.saveConfig('cardtext_font', font);
							lib.init.cssstyles();
						}
					},
					global_font: {
						name: '界面字体',
						init: 'default',
						unfrequent: true,
						item: {},
						textMenu: function (node, link) {
							if (link != 'default') {
								node.style.fontFamily = link;
							}
							else {
								node.style.fontFamily = "'STHeiti','SimHei','Microsoft JhengHei','Microsoft YaHei','WenQuanYi Micro Hei',Helvetica,Arial,sans-serif";
							}
							node.style.fontSize = '20px';
						},
						onclick: function (font) {
							game.saveConfig('global_font', font);
							lib.init.cssstyles();
						}
					},
					update: function (config, map) {
						if (lib.config.custom_button) {
							map.custom_button_system_top.show();
							map.custom_button_system_bottom.show();
							map.custom_button_control_top.show();
							map.custom_button_control_bottom.show();
						}
						else {
							map.custom_button_system_top.hide();
							map.custom_button_system_bottom.hide();
							map.custom_button_control_top.hide();
							map.custom_button_control_bottom.hide();
						}
						if (lib.config.change_skin) {
							map.change_skin_auto.show();
						}
						else {
							map.change_skin_auto.hide();
						}
						if (lib.config.image_background_random) {
							map.image_background_blur.show();
							map.image_background.hide();
							// map.import_background.hide();
						}
						else {
							map.image_background.show();
							if (lib.config.image_background == 'default') {
								map.image_background_blur.hide();
							}
							else {
								map.image_background_blur.show();
							}
							// if(lib.config.image_background=='custom'&&lib.db){
							// 	map.import_background.show();
							// }
							// else{
							// 	map.import_background.hide();
							// }
						}
						if (lib.config.layout == 'long' || lib.config.layout == 'mobile') {
							map.textequip.show();
							map.cardshape.show();
							map.phonelayout.show();
						}
						else {
							map.textequip.hide();
							if (lib.config.layout == 'long2' || lib.config.layout == 'nova') {
								map.phonelayout.show();
								map.cardshape.show();
							}
							else {
								map.phonelayout.hide();
								map.cardshape.hide();
							}
						}
						if (lib.config.layout == 'long') {
							// map.fewplayer.show();
							map.player_height.show();
						}
						else {
							// map.fewplayer.hide();
							if (lib.config.layout == 'long2') {
								map.player_height.show();
							}
							else {
								map.player_height.hide();
							}
						}
						if (lib.config.layout == 'nova') {
							map.player_height_nova.show();
						}
						else {
							map.player_height_nova.hide();
						}
						if (lib.config.touchscreen) {
							map.cursor_style.hide();
						}
						else {
							map.cursor_style.show();
						}
						if (lib.config.border_style == 'auto') {
							map.autoborder_count.show();
							map.autoborder_start.show();
						}
						else {
							map.autoborder_count.hide();
							map.autoborder_start.hide();
						}
					},
				}
			},
			view: {
				name: '显示',
				config: {
					update: function (config, map) {
						if (lib.config.mode == 'versus' || lib.config.mode == 'chess' || lib.config.mode == 'tafang' || lib.config.mode == 'boss') {
							map.show_handcardbutton.show();
						}
						else {
							map.show_handcardbutton.hide();
						}
						if (lib.config.touchscreen) {
							map.pop_logv.hide();
						}
						else {
							map.pop_logv.show();
						}
						if (lib.device) {
							if (lib.device == 'android') {
								map.show_statusbar_android.show();
								map.show_statusbar_ios.hide();
							}
							else if (lib.device == 'ios') {
								map.show_statusbar_ios.show();
								map.show_statusbar_android.hide();
							}
							if (!game.download) {
								setTimeout(function () {
									if (!window.StatusBar) {
										map.show_statusbar.hide();
									}
								}, 5000);
							}
						}
						else {
							map.show_statusbar_ios.hide();
							map.show_statusbar_android.hide();
						}
						if (get.is.phoneLayout()) {
							map.remember_round_button.show();
							map.popequip.show();
							map.filternode_button.show();
							map.show_pause.hide();
							map.show_auto.hide();
							map.show_replay.hide();
							map.show_round_menu.show();
						}
						else {
							map.show_pause.show();
							map.show_auto.show();
							map.show_replay.show();
							map.show_round_menu.hide();
							map.remember_round_button.hide();
							map.popequip.hide();
							map.filternode_button.hide();
						}
						if (lib.config.show_card_prompt) {
							map.hide_card_prompt_basic.show();
							map.hide_card_prompt_equip.show();
						}
						else {
							map.hide_card_prompt_basic.hide();
							map.hide_card_prompt_equip.hide();
						}
						if (lib.config.show_log != 'off') {
							map.clear_log.show();
						}
						else {
							map.clear_log.hide();
						}
						if (get.is.phoneLayout()) {
							map.show_time2.show();
							map.show_time.hide();
							if (lib.config.show_time2) {
								map.watchface.show();
							}
							else {
								map.watchface.hide();
							}
						}
						else {
							map.show_time2.hide();
							map.show_time.show();
							map.watchface.hide();
						}
						if (lib.config.show_extensionmaker) {
							map.show_extensionshare.show();
						}
						else {
							map.show_extensionshare.hide();
						}
					},
					show_history: {
						name: '出牌记录栏',
						init: 'off',
						intro: '在屏幕左侧或右侧显示出牌记录',
						unfrequent: true,
						item: {
							off: '关闭',
							left: '靠左',
							right: '靠右',
						},
						onclick: function (bool) {
							if (lib.config.show_history == 'right') ui.window.animate('rightbar2');
							game.saveConfig('show_history', bool);
							if (_status.video || !_status.prepareArena) return;
							if (bool == 'left') {
								ui.window.classList.add('leftbar');
								ui.window.classList.remove('rightbar');
							}
							else if (bool == 'right') {
								ui.window.classList.remove('leftbar');
								ui.window.classList.add('rightbar');
							}
							else {
								ui.window.classList.remove('leftbar');
								ui.window.classList.remove('rightbar');
							}
						}
					},
					pop_logv: {
						name: '自动弹出记录',
						init: false,
						unfrequent: true
					},
					show_log: {
						name: '历史记录栏',
						init: 'off',
						intro: '在屏幕中部显示出牌文字记录',
						unfrequent: true,
						item: {
							off: '关闭',
							left: '靠左',
							center: '居中',
							right: '靠右',
						},
						onclick: function (bool) {
							game.saveConfig('show_log', bool);
							if (lib.config.show_log != 'off') {
								ui.arenalog.style.display = '';
								ui.arenalog.dataset.position = bool;
							}
							else {
								ui.arenalog.style.display = 'none';
								ui.arenalog.innerHTML = '';
							}
						}
					},
					clear_log: {
						name: '自动清除历史记录',
						init: false,
						unfrequent: true,
						intro: '开启后将定时清除历史记录栏的条目（而不是等记录栏满后再清除）'
					},
					log_highlight: {
						name: '历史记录高亮',
						init: true,
						unfrequent: true,
						intro: '开启后历史记录不同类别的信息将以不同颜色显示',
					},
					show_time: {
						name: '显示时间',
						intro: '在屏幕顶部显示当前时间',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_time', bool);
							if (bool) {
								ui.time.style.display = '';
							}
							else {
								ui.time.style.display = 'none';
							}
						}
					},
					show_time2: {
						name: '显示时间',
						intro: '在触屏按钮处显示当前时间',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_time2', bool);
							if (bool) {
								ui.roundmenu.classList.add('clock');
							}
							else {
								ui.roundmenu.classList.remove('clock');
							}
						}
					},
					watchface: {
						name: '表盘样式',
						init: 'none',
						unfrequent: true,
						item: {
							none: '默认',
							simple: '简约',
						},
						onclick: function (item) {
							game.saveConfig('watchface', item);
							ui.roundmenu.dataset.watchface = item;
						}
					},
					show_time3: {
						name: '显示游戏时间',
						init: false,
						unfrequent: true
					},
					show_statusbar_android: {
						name: '显示状态栏',
						init: false,
						unfrequent: true,
						content: function (bool) {
							game.saveConfig('show_statusbar', bool);
							if (window.StatusBar && lib.device == 'android') {
								if (bool) {
									window.StatusBar.overlaysWebView(false);
									window.StatusBar.backgroundColorByName('black');
									window.StatusBar.show();
								}
								else {
									window.StatusBar.hide();
								}
							}
						}
					},
					show_statusbar_ios: {
						name: '显示状态栏',
						init: 'off',
						unfrequent: true,
						item: {
							default: '默认',
							overlay: '嵌入',
							auto: '自动',
							off: '关闭'
						},
						onclick: function (bool) {
							game.saveConfig('show_statusbar_ios', bool);
							if (window.StatusBar && lib.device == 'ios') {
								if (bool != 'off' && bool != 'auto') {
									if (lib.config.show_statusbar_ios == 'default') {
										window.StatusBar.overlaysWebView(false);
										document.body.classList.remove('statusbar');
									}
									else {
										window.StatusBar.overlaysWebView(true);
										document.body.classList.add('statusbar');
									}
									window.StatusBar.backgroundColorByName('black');
									window.StatusBar.show();
								}
								else {
									document.body.classList.remove('statusbar');
									window.StatusBar.hide();
								}
							}
						}
					},
					show_card_prompt: {
						name: '显示出牌信息',
						intro: '出牌时在使用者上显示卡牌名称',
						init: true,
						unfrequent: true,
					},
					hide_card_prompt_basic: {
						name: '隐藏基本牌信息',
						intro: '不显示基本牌名称',
						init: false,
						unfrequent: true,
					},
					hide_card_prompt_equip: {
						name: '隐藏装备牌信息',
						intro: '不显示装备牌名称',
						init: false,
						unfrequent: true,
					},
					show_phase_prompt: {
						name: '显示阶段信息',
						intro: '在当前回合不同阶段开始时显示阶段名称',
						init: true,
						unfrequent: true,
					},
					show_phaseuse_prompt: {
						name: '出牌阶段提示',
						intro: '在你出牌时显示提示文字',
						init: true,
						unfrequent: true,
					},
					auto_popped_config: {
						name: '自动弹出选项',
						intro: '鼠标移至选项按钮时弹出模式选择菜单',
						init: true,
						unfrequent: true,
					},
					auto_popped_history: {
						name: '自动弹出历史',
						intro: '鼠标移至暂停按钮时弹出历史记录菜单',
						init: false,
						unfrequent: true,
					},
					show_round_menu: {
						name: '显示触屏按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							if (get.is.nomenu('show_round_menu', bool)) return false;
							game.saveConfig('show_round_menu', bool);
							if (bool && ui.roundmenu) {
								ui.roundmenu.style.display = '';
							}
							else {
								ui.roundmenu.style.display = 'none';
								alert('关闭触屏按钮后可通过手势打开菜单（默认为下划）')
							}
						}
					},
					remember_round_button: {
						name: '记住按钮位置',
						intro: '重新开始后触屏按钮将保存的上一局的位置',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('remember_round_button', bool);
							if (!bool) {
								ui.click.resetround();
							}
						}
					},
					remember_dialog: {
						name: '记住对话框位置',
						intro: '移动对话框后新的对话框也将在移动后的位置显示',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('remember_dialog', bool);
							if (!bool) {
								if (ui.dialog) {
									var dialog = ui.dialog;
									dialog.style.transform = '';
									dialog._dragtransform = [0, 0];
									dialog.style.transition = 'all 0.3s';
									dialog._dragtouches;
									dialog._dragorigin;
									dialog._dragorigintransform;
									setTimeout(function () {
										dialog.style.transition = '';
									}, 500);
								}
								game.saveConfig('dialog_transform', [0, 0]);
							}
						}
					},
					transparent_dialog: {
						name: '堆叠对话框虚化',
						init: false,
						intro: '当具有static属性的对话框堆叠（如五谷丰登对话框中提示无懈可击）时，将后方的对话框变为半透明',
						onclick: function (bool) {
							game.saveConfig('transparent_dialog', bool);
							if (bool) {
								for (var i = 0; i < ui.dialogs.length; i++) {
									if (ui.dialogs[i] != ui.dialog && ui.dialogs[i].static) {
										ui.dialogs[i].unfocus();
									}
								}
							}
							else {
								for (var i = 0; i < ui.dialogs.length; i++) {
									if (ui.dialogs[i] != ui.dialog && ui.dialogs[i].static) {
										ui.dialogs[i].refocus();
									}
								}
							}
						}
					},
					mark_identity_style: {
						name: '标记身份操作',
						intro: '设置单击身份按钮时的操作',
						unfrequent: true,
						init: 'menu',
						item: {
							menu: '菜单',
							click: '单击',
						},
					},
					character_dialog_tool: {
						name: '自由选将显示',
						intro: '点击自由选将时默认显示的条目',
						init: '最近',
						item: {
							'收藏': '收藏',
							'最近': '最近',
							'all': '全部'
						},
						unfrequent: true,
					},
					recent_character_number: {
						name: '最近使用武将',
						intro: '自由选将对话框中最近使用武将的数量',
						init: '12',
						item: {
							'6': '6',
							'12': '12',
							'20': '24',
							'30': '36',
						},
						unfrequent: true
					},
					popequip: {
						name: '触屏装备选择',
						intro: '设置触屏布局中选择装备的方式',
						init: true,
						unfrequent: true,
					},
					filternode_button: {
						name: '触屏筛选按钮',
						intro: '设置自由选将对话框中筛选按钮的样式',
						init: true,
						unfrequent: true,
					},
					show_charactercard: {
						name: '显示武将资料',
						intro: '在武将界面单击时弹出武将资料卡',
						init: true,
						unfrequent: true
					},
					show_favourite: {
						name: '显示添加收藏',
						intro: '在角色的右键菜单中显示添加收藏',
						init: false,
						unfrequent: true
					},
					show_favmode: {
						name: '显示模式收藏',
						intro: '快捷菜单中显示收藏模式',
						init: true,
						unfrequent: true
					},
					show_favourite_menu: {
						name: '显示收藏菜单',
						intro: '在选项-武将中显示收藏一栏',
						init: true,
						unfrequent: true
					},
					show_ban_menu: {
						name: '显示禁将菜单',
						intro: '在选项-武将中显示禁将一栏',
						init: true,
						unfrequent: true
					},
					right_range: {
						name: '显示距离信息',
						intro: '在角色的右键菜单中显示距离等信息',
						init: true,
						unfrequent: true
					},
					hide_card_image: {
						name: '隐藏卡牌背景',
						intro: '所有卡牌将使用文字作为背景',
						init: false,
						unfrequent: true,
						restart: true,
					},
					show_name: {
						name: '显示角色名称',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_name', bool);
							if (bool) {
								ui.arena.classList.remove('hide_name');
							}
							else {
								ui.arena.classList.add('hide_name');
							}
						}
					},
					show_replay: {
						name: '显示重来按钮',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_replay', bool);
							if (lib.config.show_replay) {
								ui.replay.style.display = '';
							}
							else {
								ui.replay.style.display = 'none';
							}
						}
					},
					show_playerids: {
						name: '显示身份按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_playerids', bool);
							if (lib.config.show_playerids) {
								ui.playerids.style.display = '';
							}
							else {
								ui.playerids.style.display = 'none';
							}
						}
					},
					show_sortcard: {
						name: '显示整理手牌按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_sortcard', bool);
							if (lib.config.show_sortcard) {
								ui.sortCard.style.display = '';
							}
							else {
								ui.sortCard.style.display = 'none';
							}
						}
					},
					show_pause: {
						name: '显示暂停按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_pause', bool);
							if (lib.config.show_pause) {
								ui.pause.style.display = '';
							}
							else {
								ui.pause.style.display = 'none';
							}
						}
					},
					show_auto: {
						name: '显示托管按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_auto', bool);
							if (lib.config.show_auto) {
								ui.auto.style.display = '';
							}
							else {
								ui.auto.style.display = 'none';
							}
						}
					},
					show_volumn: {
						name: '显示音量按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_volumn', bool);
							if (lib.config.show_volumn) {
								ui.volumn.style.display = '';
							}
							else {
								ui.volumn.style.display = 'none';
							}
						}
					},
					show_cardpile: {
						name: '显示牌堆按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_cardpile', bool);
							if (bool) {
								ui.cardPileButton.style.display = '';
							}
							else {
								ui.cardPileButton.style.display = 'none';
							}
						}
					},
					show_cardpile_number: {
						name: '显示剩余牌数',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_cardpile_number', bool);
							if (bool) {
								ui.cardPileNumber.style.display = '';
							}
							else {
								ui.cardPileNumber.style.display = 'none';
							}
						}
					},
					show_handcardbutton: {
						name: '显示手牌按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_handcardbutton', bool);
						}
					},
					show_giveup: {
						name: '显示投降按钮',
						init: true,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_giveup', bool);
						}
					},
					show_wuxie: {
						name: '显示无懈按钮',
						intro: '在右上角显示不询问无懈',
						init: false,
						unfrequent: true,
						onclick: function (bool) {
							game.saveConfig('show_wuxie', bool);
							if (lib.config.show_wuxie) {
								ui.wuxie.style.display = '';
							}
							else {
								ui.wuxie.style.display = 'none';
							}
						}
					},
					wuxie_right: {
						name: '无懈按钮靠左',
						init: true,
						unfrequent: true,
					},
					show_discardpile: {
						name: '暂停时显示弃牌堆',
						init: false,
						unfrequent: true,
					},
					show_extensionmaker: {
						name: '显示制作扩展',
						init: true,
						unfrequent: true,
					},
					show_extensionshare: {
						name: '显示分享扩展',
						init: true,
						unfrequent: true,
					}
				}
			},
			audio: {
				name: '音效',
				config: {
					update: function (config, map) {
						if (lib.config.background_music == 'music_custom' && (lib.device || lib.node)) {
							map.import_music.show();
						}
						else {
							map.import_music.hide();
						}
						map.clear_background_music[get.is.object(lib.config.customBackgroundMusic) ? 'show' : 'hide']();
						ui.background_music_setting = map.background_music;
						map.background_music._link.config.updatex.call(map.background_music, []);
					},
					background_music: {
						updatex: function () {
							this.lastChild.innerHTML = this._link.config.item[lib.config.background_music];
							var menu = this._link.menu;
							for (var i = 0; i < menu.childElementCount; i++) {
								if (!['music_off', 'music_custom', 'music_random'].concat(lib.config.all.background_music).contains(menu.childNodes[i]._link)) menu.childNodes[i].delete();
							}
						},
						name: '背景音乐',
						init: true,
						item: {
							music_default: '默认',
						},
						onclick: function (item) {
							game.saveConfig('background_music', item);
							game.playBackgroundMusic();
						}
					},
					import_music: {
						name: '<div style="white-space:nowrap;width:calc(100% - 5px)">' +
							'<input type="file" style="width:calc(100% - 40px)" accept="audio/*">' +
							'<button style="width:40px">确定</button></div>',
						clear: true,
					},
					background_audio: {
						name: '游戏音效',
						init: true,
					},
					background_speak: {
						name: '人物配音',
						init: true,
					},
					equip_audio: {
						name: '装备配音',
						init: false,
					},
					repeat_audio: {
						name: '播放重复语音',
						init: false,
					},
					volumn_audio: {
						name: '音效音量',
						init: 8,
						item: {
							'0': '〇',
							'1': '一',
							'2': '二',
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'7': '七',
							'8': '八',
						},
						onclick: function (volume) {
							game.saveConfig('volumn_audio', parseInt(volume));
						}
					},
					volumn_background: {
						name: '音乐音量',
						init: 8,
						item: {
							'0': '〇',
							'1': '一',
							'2': '二',
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'7': '七',
							'8': '八',
						},
						onclick: function (volume) {
							game.saveConfig('volumn_background', parseInt(volume));
							ui.backgroundMusic.volume = volume / 8;
						}
					},
					clear_background_music: {
						name: '清除自定义背景音乐',
						clear: true,
						onclick: function () {
							if (confirm('是否清除已导入的所有自定义背景音乐？（该操作不可撤销！）')) {
								for (var i in lib.config.customBackgroundMusic) {
									lib.config.all.background_music.remove(i);
									if (i.indexOf('cdv_') == 0) {
										game.removeFile('audio/background/' + i + '.mp3');
									}
									else {
										game.deleteDB('audio', i);
									}
								}
								lib.config.customBackgroundMusic = null;
								game.saveConfig('customBackgroundMusic', null);
								game.saveConfig('background_music', 'music_off');
								if (!_status._aozhan) game.playBackgroundMusic();
							}
						},
					},
				}
			},
			skill: {
				name: '技能',
				config: {
					update: function (config, map) {
						for (var i in map) {
							if (map[i]._link.config.type == 'autoskill') {
								if (!lib.config.autoskilllist.contains(i)) {
									map[i].classList.add('on');
								}
								else {
									map[i].classList.remove('on');
								}
							}
							else if (map[i]._link.config.type == 'banskill') {
								if (!lib.config.forbidlist.contains(i)) {
									map[i].classList.add('on');
								}
								else {
									map[i].classList.remove('on');
								}
							}
						}
					}
				}
			},
			others: {
				name: '其它',
				config: {
					// reset_database:{
					// 	name:'重置游戏',
					// 	onclick:function(){
					// 		var node=this;
					// 		if(node._clearing){
					// 			if(indexedDB) indexedDB.deleteDatabase(lib.configprefix+'data');
					// 			game.reload();
					// 			return;
					// 		}
					// 		node._clearing=true;
					// 		node.innerHTML='单击以确认 (3)';
					// 		setTimeout(function(){
					// 			node.innerHTML='单击以确认 (2)';
					// 			setTimeout(function(){
					// 				node.innerHTML='单击以确认 (1)';
					// 				setTimeout(function(){
					// 					node.innerHTML='重置游戏录像';
					// 					delete node._clearing;
					// 				},1000);
					// 			},1000);
					// 		},1000);
					// 	},
					// 	clear:true
					// },
					reset_game: {
						name: '重置游戏设置',
						onclick: function () {
							var node = this;
							if (node._clearing) {
								var noname_inited = localStorage.getItem('noname_inited');
								var onlineKey = localStorage.getItem(lib.configprefix + 'key');
								localStorage.clear();
								if (noname_inited) {
									localStorage.setItem('noname_inited', noname_inited);
								}
								if (onlineKey) {
									localStorage.setItem(lib.configprefix + 'key', onlineKey);
								}
								game.deleteDB('config');
								game.deleteDB('data');
								game.reload();
								return;
							}
							node._clearing = true;
							node.firstChild.innerHTML = '单击以确认 (3)';
							setTimeout(function () {
								node.firstChild.innerHTML = '单击以确认 (2)';
								setTimeout(function () {
									node.firstChild.innerHTML = '单击以确认 (1)';
									setTimeout(function () {
										node.firstChild.innerHTML = '重置游戏设置';
										delete node._clearing;
									}, 1000);
								}, 1000);
							}, 1000);
						},
						clear: true
					},
					reset_hiddenpack: {
						name: '重置隐藏内容',
						onclick: function () {
							if (this.firstChild.innerHTML != '已重置') {
								this.firstChild.innerHTML = '已重置'
								game.saveConfig('hiddenModePack', []);
								game.saveConfig('hiddenCharacterPack', []);
								game.saveConfig('hiddenCardPack', []);
								game.saveConfig('hiddenPlayPack', []);
								game.saveConfig('hiddenBackgroundPack', []);
								var that = this;
								setTimeout(function () {
									that.firstChild.innerHTML = '重置隐藏内容';
									setTimeout(function () {
										if (confirm('是否重新启动使改变生效？')) {
											game.reload();
										}
									});
								}, 500);
							}
						},
						clear: true
					},
					reset_tutorial: {
						name: '重置新手向导',
						onclick: function () {
							if (this.firstChild.innerHTML != '已重置') {
								this.firstChild.innerHTML = '已重置'
								game.saveConfig('new_tutorial', false);
								game.saveConfig('prompt_hidebg');
								game.saveConfig('prompt_hidepack');
								var that = this;
								setTimeout(function () {
									that.firstChild.innerHTML = '重置新手向导';
								}, 500);
							}
						},
						clear: true
					},
					import_data: {
						name: '导入游戏设置',
						onclick: function () {
							ui.import_data_button.classList.toggle('hidden');
						},
						clear: true
					},
					import_data_button: {
						name: '<div style="white-space:nowrap;width:calc(100% - 10px)">' +
							'<input type="file" style="width:calc(100% - 40px)">' +
							'<button style="width:40px">确定</button></div>',
						clear: true,
					},
					export_data: {
						name: '导出游戏设置',
						onclick: function () {
							var data;
							var export_data = function (data) {
								game.export(lib.init.encode(JSON.stringify(data)), '无名杀 - 数据 - ' + (new Date()).toLocaleString());
							}
							if (!lib.db) {
								data = {};
								for (var i in localStorage) {
									if (i.indexOf(lib.configprefix) == 0) {
										data[i] = localStorage[i];
									}
								}
								export_data(data);
							}
							else {
								game.getDB('config', null, function (data1) {
									game.getDB('data', null, function (data2) {
										export_data({
											config: data1,
											data: data2
										});
									});
								});
							}

						},
						clear: true
					},
					redownload_game: {
						name: '重新下载游戏',
						onclick: function () {
							var node = this;
							if (node._clearing) {
								localStorage.removeItem('noname_inited');
								game.reload();
								return;
							}
							node._clearing = true;
							node.firstChild.innerHTML = '单击以确认 (3)';
							setTimeout(function () {
								node.firstChild.innerHTML = '单击以确认 (2)';
								setTimeout(function () {
									node.firstChild.innerHTML = '单击以确认 (1)';
									setTimeout(function () {
										node.firstChild.innerHTML = '重新下载游戏';
										delete node._clearing;
									}, 1000);
								}, 1000);
							}, 1000);
						},
						clear: true
					},
					update: function (config, map) {
						if (lib.device || lib.node) {
							map.redownload_game.show();
						}
						else {
							map.redownload_game.hide();
						}
					}
					// trim_game:{
					// 	name:'隐藏非官方扩展包',
					// 	onclick:function(){
					// 		if(this.innerHTML!='已隐藏'){
					// 			this.innerHTML='已隐藏';
					//      						 var pack=lib.config.all.cards.slice(0);
					//      						 if(Array.isArray(lib.config.hiddenCardPack)){
					//      									  for(var i=0;i<lib.config.hiddenCardPack.length;i++){
					//      															pack.add(lib.config.hiddenCardPack[i]);
					//      									  }
					//      						 }
					//      						 for(var i=0;i<pack.length;i++){
					//      									  if(lib.config.all.sgscards.contains(pack[i])){
					//      															pack.splice(i--,1);
					//      									  }
					//      						 }
					// 			game.saveConfig('hiddenCardPack',pack);
					//
					//      						 var pack=lib.config.all.characters.slice(0);
					//      						 if(Array.isArray(lib.config.hiddenCharacterPack)){
					//      									  for(var i=0;i<lib.config.hiddenCharacterPack.length;i++){
					//      															pack.add(lib.config.hiddenCharacterPack[i]);
					//      									  }
					//      						 }
					//      						 for(var i=0;i<pack.length;i++){
					//      									  if(lib.config.all.sgscharacters.contains(pack[i])){
					//      															pack.splice(i--,1);
					//      									  }
					//      						 }
					// 			game.saveConfig('hiddenCharacterPack',pack);
					//
					//      						 var pack=lib.config.all.mode.slice(0);
					//      						 if(Array.isArray(lib.config.hiddenModePack)){
					//      									  for(var i=0;i<lib.config.hiddenModePack.length;i++){
					//      															pack.add(lib.config.hiddenModePack[i]);
					//      									  }
					//      						 }
					//      						 for(var i=0;i<pack.length;i++){
					//      									  if(lib.config.all.sgsmodes.contains(pack[i])){
					//      															pack.splice(i--,1);
					//      									  }
					//      						 }
					// 			game.saveConfig('hiddenModePack',pack);
					//
					// 			var that=this;
					// 			setTimeout(function(){
					// 				that.innerHTML='隐藏非官方扩展包';
					// 			},500);
					// 		}
					// 	},
					// 	clear:true
					// }
				}
			}
		},
		extensionMenu: {
			cardpile: {
				enable: {
					name: '开启',
					init: false,
					restart: true,
				},
				intro: {
					name: '将杀闪等牌在牌堆中的比例维持在与军争牌堆相同，防止开启扩展包后被过多地稀释',
					clear: true,
					nopointer: true,
				},
				sha: {
					name: '杀',
					init: '1',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				huosha: {
					name: '火杀',
					init: '1',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				leisha: {
					name: '雷杀',
					init: '1',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				shan: {
					name: '闪',
					init: '1',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				tao: {
					name: '桃',
					init: '0',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				jiu: {
					name: '酒',
					init: '0',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				wuxie: {
					name: '无懈可击',
					init: '0.5',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				nanman: {
					name: '南蛮入侵',
					init: '0',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				wanjian: {
					name: '万箭齐发',
					init: '0',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				guohe: {
					name: '过河拆桥',
					init: '0',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				shunshou: {
					name: '顺手牵羊',
					init: '0',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				tiesuo: {
					name: '铁索连环',
					init: '0',
					item: {
						'1': '补充全部',
						'0.5': '补充一半',
						'0': '不补充'
					}
				},
				hide: {
					name: '隐藏此扩展',
					clear: true,
					onclick: function () {
						if (this.firstChild.innerHTML == '隐藏此扩展') {
							this.firstChild.innerHTML = '此扩展将在重启后隐藏';
							lib.config.hiddenPlayPack.add('cardpile');
							if (!lib.config.prompt_hidepack) {
								alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
								game.saveConfig('prompt_hidepack', true);
							}
						}
						else {
							this.firstChild.innerHTML = '隐藏此扩展';
							lib.config.hiddenPlayPack.remove('cardpile');
						}
						game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
					}
				},
			},
			boss: {
				enable: {
					name: '开启',
					init: false,
					restart: true,
					onswitch: function (bool) {
						if (bool) {
							var storage = { boss: {}, versus: {}, translate: {} };
							var loadversus = function () {
								game.loadModeAsync('versus', function (mode) {
									for (var i in mode.translate) {
										storage.translate[i] = mode.translate[i];
									}
									for (var i in mode.jiangeboss) {
										if (mode.jiangeboss[i][4].contains('bossallowed')) {
											storage.versus[i] = mode.jiangeboss[i];
										}
									}
									localStorage.setItem('boss_storage_playpackconfig', JSON.stringify(storage));
								});
							};
							game.loadModeAsync('boss', function (mode) {
								for (var i in mode.translate) {
									storage.translate[i] = mode.translate[i];
								}
								for (var i in mode.characterPack.mode_boss) {
									if (mode.characterPack.mode_boss[i][4].contains('bossallowed')) {
										storage.boss[i] = mode.characterPack.mode_boss[i];
									}
								}
								loadversus();
							});
						}
						else {
							localStorage.removeItem('boss_storage_playpackconfig');
						}
					}
				},
				intro: {
					name: '将剑阁和挑战模式的武将添加到其它模式',
					clear: true,
					nopointer: true,
				},
				enableai: {
					name: 'AI可选',
					init: false
				},
				hide: {
					name: '隐藏此扩展',
					clear: true,
					onclick: function () {
						if (this.firstChild.innerHTML == '隐藏此扩展') {
							this.firstChild.innerHTML = '此扩展将在重启后隐藏';
							lib.config.hiddenPlayPack.add('boss');
							if (!lib.config.prompt_hidepack) {
								alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
								game.saveConfig('prompt_hidepack', true);
							}
						}
						else {
							this.firstChild.innerHTML = '隐藏此扩展';
							lib.config.hiddenPlayPack.remove('boss');
						}
						game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
					}
				},
			},
			wuxing: {
				enable: {
					name: '开启',
					init: false,
					restart: true,
				},
				intro: {
					name: '每名角色和部分卡牌在游戏开始时随机获得一个属性',
					clear: true,
					nopointer: true,
				},
				num: {
					name: '带属性卡牌',
					init: '0.3',
					item: {
						'0.1': '10%',
						'0.2': '20%',
						'0.3': '30%',
						'0.5': '50%',
					}
				},
				hide: {
					name: '隐藏此扩展',
					clear: true,
					onclick: function () {
						if (this.firstChild.innerHTML == '隐藏此扩展') {
							this.firstChild.innerHTML = '此扩展将在重启后隐藏';
							lib.config.hiddenPlayPack.add('wuxing');
							if (!lib.config.prompt_hidepack) {
								alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
								game.saveConfig('prompt_hidepack', true);
							}
						}
						else {
							this.firstChild.innerHTML = '隐藏此扩展';
							lib.config.hiddenPlayPack.remove('wuxing');
						}
						game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
					}
				},
			},
			coin: {
				enable: {
					name: '开启',
					init: false,
					restart: true,
					onclick: function (bool) {
						if (bool) {
							lib.config.plays.add('coin');
						}
						else {
							lib.config.plays.remove('coin');
						}
						game.saveConfig('plays', lib.config.plays);
					}
				},
				intro: {
					name: '每完成一次对局，可获得一定数量的金币；金币可用于购买游戏特效',
					clear: true,
					nopointer: true,
				},
				display: {
					name: '金币显示',
					init: 'text',
					item: {
						symbol: '符号',
						text: '文字'
					},
					onclick: function (item) {
						game.saveConfig('coin_display_playpackconfig', item);
						if (game.changeCoin) game.changeCoin(0);
					}
				},
				canvas: {
					name: '特效置顶',
					init: false,
					onclick: function (bool) {
						game.saveConfig('coin_canvas_playpackconfig', bool);
						if (bool) {
							ui.window.classList.add('canvas_top');
						}
						else {
							ui.window.classList.remove('canvas_top');
						}
					}
				},
				hide: {
					name: '隐藏此扩展',
					clear: true,
					onclick: function () {
						if (this.firstChild.innerHTML == '隐藏此扩展') {
							this.firstChild.innerHTML = '此扩展将在重启后隐藏';
							lib.config.hiddenPlayPack.add('coin');
							if (!lib.config.prompt_hidepack) {
								alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
								game.saveConfig('prompt_hidepack', true);
							}
						}
						else {
							this.firstChild.innerHTML = '隐藏此扩展';
							lib.config.hiddenPlayPack.remove('coin');
						}
						game.saveConfig('hiddenPlayPack', lib.config.hiddenPlayPack);
					}
				},
			},
		},
		mode: {
			identity: {
				name: '身份',
				connect: {
					update: function (config, map) {
						if (config.connect_identity_mode == 'zhong') {
							map.connect_player_number.hide();
							map.connect_enhance_zhu.hide();
							map.connect_double_nei.hide();
							map.connect_zhong_card.show();
							map.connect_special_identity.hide();
							map.connect_double_character.show();
						}
						else if (config.connect_identity_mode == 'purple') {
							map.connect_player_number.hide();
							map.connect_enhance_zhu.hide();
							map.connect_double_nei.hide();
							map.connect_zhong_card.hide();
							map.connect_special_identity.hide();
							map.connect_double_character.hide();
						}
						else {
							map.connect_double_character.show();
							map.connect_player_number.show();
							map.connect_enhance_zhu.show();
							if (config.connect_player_number != '2') {
								map.connect_double_nei.show();
							}
							else {
								map.connect_double_nei.hide();
							}
							map.connect_zhong_card.hide();

							if (config.connect_player_number == '8') {
								map.connect_special_identity.show();
							}
							else {
								map.connect_special_identity.hide();
							}
						}
					},
					connect_identity_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '标准',
							zhong: '明忠',
							purple: '3v3v2',
						},
						restart: true,
						frequent: true,
						intro: '明忠模式和3v3v2模式详见帮助'
					},
					connect_player_number: {
						name: '游戏人数',
						init: '8',
						item: {
							'2': '两人',
							'3': '三人',
							'4': '四人',
							'5': '五人',
							'6': '六人',
							'7': '七人',
							'8': '八人'
						},
						frequent: true,
						restart: true,
					},
					connect_zhong_card: {
						name: '明忠卡牌替换',
						init: true,
						frequent: true,
						restart: true
					},
					connect_double_nei: {
						name: '双内奸',
						init: false,
						restart: true,
						// frequent:true,
						intro: '开启后游戏中将有两个内奸（内奸胜利条件仍为主内1v1时击杀主公）'
					},
					connect_double_character: {
						name: '双将模式',
						init: false,
						frequent: true,
						restart: true,
					},
					connect_change_card: {
						name: '启用手气卡',
						init: false,
						frequent: true,
						restart: true,
					},
					connect_special_identity: {
						name: '特殊身份',
						init: false,
						restart: true,
						frequent: true,
						intro: '开启后游戏中将增加军师、大将、贼首三个身份'
					},
					// connect_ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// connect_ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
					connect_enhance_zhu: {
						name: '加强主公',
						init: false,
						restart: true,
						intro: '为主公增加一个额外技能'
					},
				},
				config: {
					update: function (config, map) {
						if (config.identity_mode == 'zhong') {
							map.player_number.hide();
							map.enhance_zhu.hide();
							map.double_nei.hide();
							map.auto_identity.hide();
							map.choice_zhu.hide();
							map.choice_zhong.hide();
							map.choice_nei.hide();
							map.choice_fan.hide();
							map.ban_identity.hide();
							map.ban_identity2.hide();
							map.ban_identity3.hide();
							map.zhong_card.show();
							map.special_identity.hide();
							map.choose_group.show();
							map.change_choice.show();
							map.auto_mark_identity.show();
							map.double_character.show();
							map.free_choose.show();
							map.change_identity.show();
							if (config.double_character) {
								map.double_hp.show();
							}
							else {
								map.double_hp.hide();
							}
						}
						else if (config.identity_mode == 'purple') {
							map.player_number.hide();
							map.enhance_zhu.hide();
							map.double_nei.hide();
							map.auto_identity.hide();
							map.choice_zhu.hide();
							map.choice_zhong.hide();
							map.choice_nei.hide();
							map.choice_fan.hide();
							map.ban_identity.hide();
							map.ban_identity2.hide();
							map.ban_identity3.hide();
							map.zhong_card.hide();
							map.special_identity.hide();
							map.double_character.hide();
							map.double_hp.hide();
							map.choose_group.hide();
							map.auto_mark_identity.hide();
							map.change_choice.hide();
							map.free_choose.hide();
							map.change_identity.hide();
						}
						else {
							map.player_number.show();
							map.enhance_zhu.show();
							map.auto_identity.show();
							if (config.player_number != '2') {
								map.double_nei.show();
							}
							else {
								map.double_nei.hide();
							}
							map.choice_zhu.show();
							map.choice_zhong.show();
							map.choice_nei.show();
							map.choice_fan.show();
							map.ban_identity.show();
							if (config.ban_identity == 'off') {
								map.ban_identity2.hide();
							}
							else {
								map.ban_identity2.show();
							}
							if (config.ban_identity == 'off' || config.ban_identity2 == 'off') {
								map.ban_identity3.hide();
							}
							else {
								map.ban_identity3.show();
							}
							map.zhong_card.hide();
							map.choose_group.show();
							map.auto_mark_identity.show();
							map.change_choice.show();
							map.free_choose.show();
							map.change_identity.show();
							if (config.player_number == '8') {
								map.special_identity.show();
							}
							else {
								map.special_identity.hide();
							}
							map.double_character.show();
							if (config.double_character) {
								map.double_hp.show();
							}
							else {
								map.double_hp.hide();
							}
						}
					},
					identity_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '标准',
							zhong: '明忠',
							purple: '3v3v2',
						},
						restart: true,
						frequent: true,
						intro: '明忠模式详见帮助'
					},
					player_number: {
						name: '游戏人数',
						init: '8',
						item: {
							'2': '两人',
							'3': '三人',
							'4': '四人',
							'5': '五人',
							'6': '六人',
							'7': '七人',
							'8': '八人'
						},
						frequent: true,
						restart: true,
					},
					double_nei: {
						name: '双内奸',
						init: false,
						restart: true,
						frequent: true,
						intro: '开启后游戏中将有两个内奸（内奸胜利条件仍为主内1v1时击杀主公）'
					},
					choose_group: {
						name: '神武将选择势力',
						init: true,
						restart: true,
						frequent: true,
						intro: '若开启此选项，选择神武将的玩家需在亮出自己的武将牌之前为自己选择一个势力。'
					},
					double_character: {
						name: '双将模式',
						init: false,
						frequent: true,
						restart: true,
					},
					special_identity: {
						name: '特殊身份',
						init: false,
						restart: true,
						frequent: true,
						intro: '开启后游戏中将增加军师、大将、贼首三个身份'
					},
					zhong_card: {
						name: '明忠卡牌替换',
						init: true,
						frequent: true,
						restart: true
					},
					double_hp: {
						name: '双将体力上限',
						init: 'pingjun',
						item: {
							hejiansan: '和减三',
							pingjun: '平均值',
							zuidazhi: '最大值',
							zuixiaozhi: '最小值',
							zonghe: '相加',
						},
						restart: true,
					},
					auto_identity: {
						name: '自动显示身份',
						item: {
							off: '关闭',
							one: '一轮',
							two: '两轮',
							three: '三轮',
							always: '始终'
						},
						init: 'off',
						onclick: function (bool) {
							game.saveConfig('auto_identity', bool, this._link.config.mode);
							if (get.config('identity_mode') == 'zhong') return;
							var num;
							switch (bool) {
								case '一轮': num = 1; break;
								case '两轮': num = 2; break;
								case '三轮': num = 3; break;
								default: num = 0; break;
							}
							if (num & !_status.identityShown && game.phaseNumber > game.players.length * num && game.showIdentity) {
								_status.identityShown = true;
								game.showIdentity(false);
							}
						},
						intro: '游戏进行若干轮将自动显示所有角色的身份',
					},
					auto_mark_identity: {
						name: '自动标记身份',
						init: true,
						intro: '根据角色的出牌行为自动标记可能的身份',
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
					enhance_zhu: {
						name: '加强主公',
						init: false,
						restart: true,
						intro: '为主公增加一个额外技能'
					},
					free_choose: {
						name: '自由选将',
						init: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						}
					},
					change_identity: {
						name: '自由选择身份和座位',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_identity', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							var dialog;
							if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
							else dialog = _status.event.dialog;
							if (!_status.brawl || !_status.brawl.noAddSetting) {
								if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
								else _status.event.getParent().removeSetting(dialog);
							}
							ui.update();
						}
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						}
					},
					change_card: {
						name: '开启手气卡',
						init: 'disabled',
						item: {
							disabled: '禁用',
							once: '一次',
							twice: '两次',
							unlimited: '无限',
						},
					},
					continue_game: {
						name: '显示再战',
						init: false,
						onclick: function (bool) {
							game.saveConfig('continue_game', bool, this._link.config.mode);
							if (get.config('continue_game')) {
								if (!ui.continue_game && _status.over && !_status.brawl) {
									ui.continue_game = ui.create.control('再战', game.reloadCurrent);
								}
							}
							else if (ui.continue_game) {
								ui.continue_game.close();
								delete ui.continue_game;
							}
						},
						intro: '游戏结束后可选择用相同的武将再进行一局游戏'
					},
					dierestart: {
						name: '死亡后显示重来',
						init: true,
						onclick: function (bool) {
							game.saveConfig('dierestart', bool, this._link.config.mode);
							if (get.config('dierestart')) {
								if (!ui.restart && game.me.isDead() && !_status.connectMode) {
									ui.restart = ui.create.control('restart', game.reload);
								}
							}
							else if (ui.restart) {
								ui.restart.close();
								delete ui.restart;
							}
						}
					},
					revive: {
						name: '死亡后显示复活',
						init: false,
						onclick: function (bool) {
							game.saveConfig('revive', bool, this._link.config.mode);
							if (get.config('revive')) {
								if (!ui.revive && game.me.isDead()) {
									ui.revive = ui.create.control('revive', ui.click.dierevive);
								}
							}
							else if (ui.revive) {
								ui.revive.close();
								delete ui.revive;
							}
						}
					},
					ban_identity: {
						name: '屏蔽身份',
						init: 'off',
						item: {
							off: '关闭',
							zhu: '主公',
							zhong: '忠臣',
							nei: '内奸',
							fan: '反贼',
						},
					},
					ban_identity2: {
						name: '屏蔽身份2',
						init: 'off',
						item: {
							off: '关闭',
							zhu: '主公',
							zhong: '忠臣',
							nei: '内奸',
							fan: '反贼',
						},
					},
					ban_identity3: {
						name: '屏蔽身份3',
						init: 'off',
						item: {
							off: '关闭',
							zhu: '主公',
							zhong: '忠臣',
							nei: '内奸',
							fan: '反贼',
						},
					},
					ai_strategy: {
						name: '内奸策略',
						init: 'ai_strategy_1',
						item: {
							ai_strategy_1: '均衡',
							ai_strategy_2: '偏反',
							ai_strategy_3: '偏忠',
							ai_strategy_4: '酱油',
							ai_strategy_5: '天使',
							ai_strategy_6: '仇主',
						},
						intro: '设置内奸对主忠反的态度'
					},
					difficulty: {
						name: 'AI对人类态度',
						init: 'normal',
						item: {
							easy: '友好',
							normal: '一般',
							hard: '仇视',
						},
					},
					choice_zhu: {
						name: '主公候选武将数',
						init: '3',
						restart: true,
						item: {
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'8': '八',
							'10': '十',
						},
					},
					choice_zhong: {
						name: '忠臣候选武将数',
						init: '4',
						restart: true,
						item: {
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'8': '八',
							'10': '十',
						},
					},
					choice_nei: {
						name: '内奸候选武将数',
						init: '5',
						restart: true,
						item: {
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'8': '八',
							'10': '十',
						},
					},
					choice_fan: {
						name: '反贼候选武将数',
						init: '3',
						restart: true,
						item: {
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'8': '八',
							'10': '十',
						},
					},
				}
			},
			guozhan: {
				name: '国战',
				connect: {
					update: function (config, map) {
						if (config.connect_onlyguozhan) {
							map.connect_junzhu.show();
						}
						else {
							map.connect_junzhu.hide();
						}
					},
					connect_player_number: {
						name: '游戏人数',
						init: '8',
						item: {
							'3': '三人',
							'4': '四人',
							'5': '五人',
							'6': '六人',
							'7': '七人',
							'8': '八人'
						},
						frequent: true,
						restart: true,
					},
					connect_initshow_draw: {
						name: '首亮奖励',
						item: {
							'off': '关闭',
							'draw': '摸牌',
							'mark': '标记',
						},
						init: 'mark',
						frequent: true,
						intro: '第一个明置武将牌的角色可获得首亮奖励'
					},
					connect_aozhan: {
						name: '鏖战模式',
						init: true,
						intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。',
						frequent: true,
						restart: true,
					},
					connect_viewnext: {
						name: '观看下家副将',
						init: false,
						intro: '若开启此选项，所有的玩家将在挑选武将后，分发起始手牌之前，分别观看自己下家的副将。',
					},
					connect_zhulian: {
						name: '珠联璧合',
						init: true,
						// frequent:true,
						intro: '主将和副将都明置后，若为特定组合，可获得【珠联璧合】标记'
					},
					connect_guozhanpile: {
						name: '使用国战牌堆',
						init: true,
						frequent: true,
						restart: true,
					},
					connect_onlyguozhan: {
						name: '使用国战武将',
						init: true,
						frequent: true,
						restart: true,
						intro: '开启武将技能将替换为国战版本并禁用非国战武将'
					},
					connect_junzhu: {
						name: '替换君主',
						init: true,
						// frequent:true,
						restart: true,
						intro: '若开启此选项，玩家的第一个回合开始时，若其主武将牌有对应的君主武将牌，则其可以将此武将牌替换为对应的君主武将牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
					},
					connect_change_card: {
						name: '启用手气卡',
						init: false,
						frequent: true,
						restart: true,
					},
					// connect_ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:false,
					// 	restart:true,
					// },
					// connect_ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
				},
				config: {
					update: function (config, map) {
						if (config.onlyguozhan) {
							map.junzhu.show();
						}
						else {
							map.junzhu.hide();
						}
					},
					guozhan_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '标准',
							mingjiang: '明将'
						},
						frequent: true,
					},
					player_number: {
						name: '游戏人数',
						init: '8',
						item: {
							'3': '三人',
							'4': '四人',
							'5': '五人',
							'6': '六人',
							'7': '七人',
							'8': '八人'
						},
						frequent: true,
						restart: true,
					},
					initshow_draw: {
						name: '首亮奖励',
						item: {
							'off': '关闭',
							'draw': '摸牌',
							'mark': '标记',
						},
						init: 'mark',
						frequent: true,
						intro: '第一个明置身份牌的角色可获得摸牌奖励'
					},
					aozhan: {
						name: '鏖战模式',
						init: true,
						frequent: true,
						restart: true,
						intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。',
					},
					viewnext: {
						name: '观看下家副将',
						init: false,
						intro: '若开启此选项，所有的玩家将在挑选武将后，分发起始手牌之前，分别观看自己下家的副将。',
					},
					aozhan_bgm: {
						name: '鏖战背景音乐',
						item: {
							disabled: '不启用',
							online: 'Online',
							rewrite: 'Rewrite',
							chaoming: '潮鸣',
						},
						init: 'rewrite',
						onclick: function (item) {
							game.saveConfig('aozhan_bgm', item, this._link.config.mode);
							if (_status._aozhan == true) game.playBackgroundMusic();
						},
					},
					zhulian: {
						name: '珠联璧合',
						init: true,
						// frequent:true,
						intro: '主将和副将都明置后，若为特定组合，可获得【珠联璧合】标记'
					},
					guozhanpile: {
						name: '使用国战牌堆',
						init: true,
						frequent: true,
						restart: true,
					},
					changeViceType: {
						name: '副将变更方式',
						init: 'default',
						item: {
							default: '发现式',
							online: '随机式',
						},
						frequent: true,
						restart: true,
					},
					onlyguozhan: {
						name: '使用国战武将',
						init: true,
						frequent: true,
						restart: true,
						intro: '开启武将技能将替换为国战版本并禁用非国战武将'
					},
					guozhanSkin: {
						name: '使用国战皮肤',
						init: true,
						frequent: true,
						restart: true,
						intro: '开启此选项后，将会把有国战专属皮肤的武将替换为国战皮肤'
					},
					junzhu: {
						name: '替换君主',
						init: true,
						// frequent:true,
						restart: true,
						intro: '若开启此选项，玩家的第一个回合开始时，若其主武将牌有对应的君主武将牌，则其可以将此武将牌替换为对应的君主武将牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
					},
					double_hp: {
						name: '双将体力上限',
						init: 'pingjun',
						item: {
							hejiansan: '和减三',
							pingjun: '平均值',
							zuidazhi: '最大值',
							zuixiaozhi: '最小值',
							zonghe: '相加',
						},
						restart: true,
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
					free_choose: {
						name: '自由选将',
						init: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						}
					},
					onlyguozhanexpand: {
						name: '默认展开自由选将',
						init: false,
						restart: true,
						intro: '开启后自由选将对话框将默认显示全部武将'
					},
					change_identity: {
						name: '自由选择座位',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_identity', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							var dialog;
							if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
							else dialog = _status.event.dialog;
							if (!_status.brawl || !_status.brawl.noAddSetting) {
								if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
								else _status.event.getParent().removeSetting(dialog);
							}
							ui.update();
						}
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						}
					},
					change_card: {
						name: '开启手气卡',
						init: 'disabled',
						item: {
							disabled: '禁用',
							once: '一次',
							twice: '两次',
							unlimited: '无限',
						}
					},
					continue_game: {
						name: '显示再战',
						init: true,
						intro: '游戏结束后可选择用相同的武将再进行一局游戏',
						onclick: function (bool) {
							game.saveConfig('continue_game', bool, this._link.config.mode);
							if (get.config('continue_game')) {
								if (!ui.continue_game && _status.over && !_status.brawl) {
									ui.continue_game = ui.create.control('再战', game.reloadCurrent);
								}
							}
							else if (ui.continue_game) {
								ui.continue_game.close();
								delete ui.continue_game;
							}
						}
					},
					dierestart: {
						name: '死亡后显示重来',
						init: true,
						onclick: function (bool) {
							game.saveConfig('dierestart', bool, this._link.config.mode);
							if (get.config('dierestart')) {
								if (!ui.restart && game.me.isDead() && !_status.connectMode) {
									ui.restart = ui.create.control('restart', game.reload);
								}
							}
							else if (ui.restart) {
								ui.restart.close();
								delete ui.restart;
							}
						}
					},
					revive: {
						name: '死亡后显示复活',
						init: false,
						onclick: function (bool) {
							game.saveConfig('revive', bool, this._link.config.mode);
							if (get.config('revive')) {
								if (!ui.revive && game.me.isDead()) {
									ui.revive = ui.create.control('revive', ui.click.dierevive);
								}
							}
							else if (ui.revive) {
								ui.revive.close();
								delete ui.revive;
							}
						}
					},
					difficulty: {
						name: 'AI对人类态度',
						init: 'normal',
						item: {
							easy: '友好',
							normal: '一般',
							hard: '仇视',
						}
					},
					choice_num: {
						name: '候选武将数',
						init: '7',
						restart: true,
						item: {
							'5': '五',
							'6': '六',
							'7': '七',
							'8': '八',
							'9': '九',
							'10': '十',
						}
					},
				}
			},
			SNH48: {
				name: '女团大战',
				connect: {
					update: function (config, map) {
						if (config.connect_onlyguozhan) {
							map.connect_junzhu.show();
						} else {
							map.connect_junzhu.hide();
						}
					},
					connect_player_number: {
						name: '游戏人数',
						init: '8',
						item: {
							'3': '三人',
							'4': '四人',
							'5': '五人',
							'6': '六人',
							'7': '七人',
							'8': '八人'
						},
						frequent: true,
						restart: true,
					},
					connect_initshow_draw: {
						name: '首亮奖励',
						item: {
							'off': '关闭',
							'draw': '摸牌',
							'mark': '标记',
						},
						init: 'draw',
						frequent: true,
						intro: '第一个明置成员牌的角色可获得首亮奖励'
					},
					connect_aozhan: {
						name: '鏖战模式',
						init: false,
						intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。',
						frequent: true,
						restart: true,
					},
					connect_viewnext: {
						name: '观看下家副将',
						init: false,
						intro: '若开启此选项，所有的玩家将在挑选成员后，分发起始手牌之前，分别观看自己下家的副将。',
					},
					connect_zhulian: {
						name: '珠联璧合',
						init: false,
						// frequent:true,
						intro: '主将和副将都明置后，若为特定组合，可获得【珠联璧合】标记'
					},
					connect_guozhanpile: {
						name: '使用队战牌堆',
						init: true,
						frequent: true,
						restart: true,
					},
					connect_onlyguozhan: {
						name: '使用队战成员',
						init: true,
						frequent: true,
						restart: true,
						intro: '开启后成员技能将替换为队战版本并禁用非队战成员'
					},
					connect_junzhu: {
						name: '替换队长',
						init: true,
						// frequent:true,
						restart: true,
						intro: '若开启此选项，玩家的第一个回合开始时，若其主成员牌有对应的队长成员牌，则其可以将此成员牌替换为对应的队长成员牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
					},
					// connect_ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:false,
					// 	restart:true,
					// },
					// connect_ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
				},
				config: {
					update: function (config, map) {
						if (config.onlyguozhan) {
							map.junzhu.show();
						} else {
							map.junzhu.hide();
						}
					},
					guozhan_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '标准',
							mingjiang: '明将'
						},
						frequent: true,
					},
					player_number: {
						name: '游戏人数',
						init: '8',
						item: {
							'3': '三人',
							'4': '四人',
							'5': '五人',
							'6': '六人',
							'7': '七人',
							'8': '八人'
						},
						frequent: true,
						restart: true,
					},
					initshow_draw: {
						name: '首亮奖励',
						item: {
							'off': '关闭',
							'draw': '摸牌',
							'mark': '标记',
						},
						init: 'mark',
						frequent: true,
						intro: '第一个明置身份牌的角色可获得摸牌奖励'
					},
					aozhan: {
						name: '鏖战模式',
						init: true,
						frequent: true,
						restart: true,
						intro: '若开启此选项，则将在游戏中引入“鏖战模式”的规则：<br>当游戏中仅剩四名或更少角色时（七人以下游戏时改为三名或更少），若此时全场没有超过一名势力相同的角色，则从一个新的回合开始，游戏进入鏖战模式直至游戏结束。<br>◇在鏖战模式下，【桃】只能当做【杀】或【闪】使用或打出，不能用来回复体力。<br>注：进入鏖战模式后，即使之后有两名或者更多势力相同的角色出现，仍然不会取消鏖战模式。',
					},
					viewnext: {
						name: '观看下家副将',
						init: false,
						intro: '若开启此选项，所有的玩家将在挑选成员后，分发起始手牌之前，分别观看自己下家的副成员。',
					},
					aozhan_bgm: {
						name: '鏖战背景音乐',
						item: {
							disabled: '不启用',
							online: 'Online',
							rewrite: 'Rewrite',
							chaoming: '潮鸣',
						},
						init: 'disabled',
						onclick: function (item) {
							game.saveConfig('aozhan_bgm', item, this._link.config.mode);
							if (_status._aozhan == true) game.playBackgroundMusic();
						},
					},
					zhulian: {
						name: '珠联璧合',
						init: true,
						// frequent:true,
						intro: '主成员和副成员都明置后，若为特定CP组合，可获得【珠联璧合】标记'
					},
					guozhanpile: {
						name: '使用队战牌堆',
						init: true,
						frequent: true,
						restart: true,
					},
					changeViceType: {
						name: '副成员变更方式',
						init: 'default',
						item: {
							default: '发现式',
							online: '随机式',
						},
						frequent: true,
						restart: true,
					},
					onlyguozhan: {
						name: '使用队战成员',
						init: true,
						frequent: true,
						restart: true,
						intro: '开启后成员技能将替换为国战版本并禁用非队战成员'
					},
					guozhanSkin: {
						name: '使用队战皮肤',
						init: true,
						frequent: true,
						restart: true,
						intro: '开启此选项后，将会把有队战专属皮肤的成员替换为队战皮肤'
					},
					junzhu: {
						name: '替换君主',
						init: true,
						// frequent:true,
						restart: true,
						intro: '若开启此选项，玩家的第一个回合开始时，若其主成员牌有对应的队长成员牌，则其可以将此成员牌替换为对应的队长成员牌，然后重新调整体力上限。若玩家的体力上限因此增大，则玩家回复等量的体力。'
					},
					double_hp: {
						name: '双将体力上限',
						init: 'pingjun',
						item: {
							hejiansan: '和减三',
							pingjun: '平均值',
							zuidazhi: '最大值',
							zuixiaozhi: '最小值',
							zonghe: '相加',
						},
						restart: true,
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
					free_choose: {
						name: '自由选将',
						init: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						}
					},
					onlyguozhanexpand: {
						name: '默认展开自由选将',
						init: false,
						restart: true,
						intro: '开启后自由选将对话框将默认显示全部成员'
					},
					change_identity: {
						name: '自由选择座位',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_identity', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							var dialog;
							if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
							else dialog = _status.event.dialog;
							if (!_status.brawl || !_status.brawl.noAddSetting) {
								if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
								else _status.event.getParent().removeSetting(dialog);
							}
							ui.update();
						}
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						}
					},
					change_card: {
						name: '开启手气卡',
						init: 'disabled',
						item: {
							disabled: '禁用',
							once: '一次',
							twice: '两次',
							unlimited: '无限',
						}
					},
					continue_game: {
						name: '显示再战',
						init: true,
						intro: '游戏结束后可选择用相同的成员再进行一局游戏',
						onclick: function (bool) {
							game.saveConfig('continue_game', bool, this._link.config.mode);
							if (get.config('continue_game')) {
								if (!ui.continue_game && _status.over && !_status.brawl) {
									ui.continue_game = ui.create.control('再战', game.reloadCurrent);
								}
							} else if (ui.continue_game) {
								ui.continue_game.close();
								delete ui.continue_game;
							}
						}
					},
					dierestart: {
						name: '死亡后显示重来',
						init: true,
						onclick: function (bool) {
							game.saveConfig('dierestart', bool, this._link.config.mode);
							if (get.config('dierestart')) {
								if (!ui.restart && game.me.isDead() && !_status.connectMode) {
									ui.restart = ui.create.control('restart', game.reload);
								}
							} else if (ui.restart) {
								ui.restart.close();
								delete ui.restart;
							}
						}
					},
					revive: {
						name: '死亡后显示复活',
						init: false,
						onclick: function (bool) {
							game.saveConfig('revive', bool, this._link.config.mode);
							if (get.config('revive')) {
								if (!ui.revive && game.me.isDead()) {
									ui.revive = ui.create.control('revive', ui.click.dierevive);
								}
							} else if (ui.revive) {
								ui.revive.close();
								delete ui.revive;
							}
						}
					},
					difficulty: {
						name: 'AI对人类态度',
						init: 'normal',
						item: {
							easy: '友好',
							normal: '一般',
							hard: '仇视',
						}
					},
					choice_num: {
						name: '候选成员数',
						init: '10',
						restart: true,
						item: {
							'6': '六',
							'8': '八',
							'10': '十',
							'20': '廿',
							'30': '卅',
						}
					},
				}
			},
			versus: {
				name: '对决',
				connect: {
					update: function (config, map) {
						if (config.connect_versus_mode == '1v1') {
							map.connect_choice_num.show();
							map.connect_replace_number.show();
						}
						else {
							map.connect_choice_num.hide();
							map.connect_replace_number.hide();
						}
						if (config.connect_versus_mode == '2v2' || config.connect_versus_mode == '3v3') {
							map.connect_replace_handcard.show();
						}
						else {
							map.connect_replace_handcard.hide();
						}
					},
					connect_versus_mode: {
						name: '游戏模式',
						init: '1v1',
						item: {
							'1v1': '1v1',
							'2v2': '2v2',
							'3v3': '3v3',
							'4v4': '4v4',
							'guandu': '官渡',
						},
						frequent: true
					},
					connect_replace_handcard: {
						name: '四号位保护',
						init: true,
						frequent: true,
						intro: '最后行动的角色起始手牌数+1'
					},
					connect_choice_num: {
						name: '侯选武将数',
						init: '20',
						frequent: true,
						item: {
							'12': '12人',
							'16': '16人',
							'20': '20人',
							'24': '24人',
							'40': '40人',
						}
					},
					connect_replace_number: {
						name: '替补人数',
						init: '2',
						frequent: true,
						item: {
							'0': '无',
							'1': '1人',
							'2': '2人',
							'3': '3人',
							'4': '4人',
							'5': '5人',
						}
					},
					// connect_ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// connect_ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
				},
				config: {
					update: function (config, map) {
						if (config.versus_mode == 'four') {
							map.change_choice.hide();
							map.ladder.show();
							if (config.ladder) {
								map.ladder_monthly.show();
								map.ladder_reset.show();
							}
							else {
								map.ladder_monthly.hide();
								map.ladder_reset.hide();
							}
							map.enable_all.show();
							map.enable_all_cards_four.show();
							map.four_assign.show();
							map.four_phaseswap.show();
							map.expand_dialog.show();
							map.fouralign.show();
						}
						else {
							map.change_choice.show();
							map.ladder.hide();
							map.ladder_monthly.hide();
							map.ladder_reset.hide();
							map.enable_all.hide();
							map.enable_all_cards_four.hide();
							map.four_assign.hide();
							map.four_phaseswap.hide();
							map.expand_dialog.hide();
							map.fouralign.hide();
						}
						if (config.versus_mode == 'three' || config.versus_mode == 'one') {
							map.enable_all_three.show();
							map.enable_all_cards.show();
						}
						else {
							map.enable_all_three.hide();
							map.enable_all_cards.hide();
						}
						if (config.versus_mode == 'jiange' || config.versus_mode == 'two' || config.versus_mode == 'endless' ||
							config.versus_mode == 'three' || config.versus_mode == 'one' || config.versus_mode == 'siguo') {
							map.free_choose.show();
						}
						else {
							map.free_choose.hide();
						}
						if (config.versus_mode == 'jiange') {
							map.double_character_jiange.show();
						}
						else {
							map.double_character_jiange.hide();
						}
						if (config.versus_mode == 'two') {
							map.replace_handcard_two.show();
							map.replace_character_two.show();
							map.two_assign.show();
							map.two_phaseswap.show();
						}
						else {
							map.replace_handcard_two.hide();
							map.replace_character_two.hide();
							map.two_assign.hide();
							map.two_phaseswap.hide();
						}
						if (config.versus_mode == 'two' || config.versus_mode == 'siguo' || config.versus_mode == 'four') {
							if (config.versus_mode == 'four' && (config.four_assign || config.four_phaseswap)) {
								map.change_identity.hide();
							}
							else {
								map.change_identity.show();
							}
						}
						else {
							map.change_identity.hide();
						}
						if (config.versus_mode == 'siguo') {
							map.siguo_character.show();
						}
						else {
							map.siguo_character.hide();
						}
					},
					versus_mode: {
						name: '游戏模式',
						init: 'four',
						item: {
							four: '对抗',
							three: '统率',
							two: '欢乐',
							guandu: '官渡',
							jiange: '剑阁',
							siguo: '四国',
							standard: '自由'
							// endless:'无尽',
							// triple:'血战',
							// one:'<span style="display:inline-block;width:100%;text-align:center">1v1</span>',
						},
						restart: true,
						frequent: true,
					},
					ladder: {
						name: '天梯模式',
						init: true,
						frequent: true,
						restart: true
					},
					ladder_monthly: {
						name: '每月重置天梯',
						init: true,
						frequent: true,
					},
					enable_all: {
						name: '启用全部武将',
						init: false,
						frequent: true,
						restart: true,
					},
					enable_all_cards_four: {
						name: '启用全部卡牌',
						init: false,
						frequent: true,
						restart: true,
					},
					enable_all_three: {
						name: '启用全部武将',
						init: false,
						frequent: true,
						restart: true,
					},
					enable_all_cards: {
						name: '启用全部卡牌',
						init: false,
						frequent: true,
						restart: true,
					},
					four_assign: {
						name: '代替队友选将',
						init: false,
						restart: true,
					},
					four_phaseswap: {
						name: '代替队友行动',
						init: false,
						restart: true,
					},
					two_assign: {
						name: '代替队友选将',
						init: false,
						restart: true,
					},
					two_phaseswap: {
						name: '代替队友行动',
						init: false,
						restart: true,
					},
					free_choose: {
						name: '自由选将',
						init: true,
						frequent: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (!ui.create.cheat2) return;
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						}
					},
					fouralign: {
						name: '自由选择阵型',
						init: false
					},
					change_identity: {
						name: '自由选择座位',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_identity', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (_status.mode == 'four') {
								if (get.config('four_assign') || get.config('four_phaseswap')) return;
								if (bool) {
									if (_status.event.parent.addSetting) {
										_status.event.parent.addSetting();
									}
								}
								else {
									var seats = _status.event.parent.seatsbutton;
									if (seats) {
										while (seats.length) {
											seats.shift().remove();
										}
										delete _status.event.parent.seatsbutton;
									}
								}
							}
							else {
								var dialog;
								if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
								else dialog = _status.event.dialog;
								if (!_status.brawl || !_status.brawl.noAddSetting) {
									if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
									else _status.event.getParent().removeSetting(dialog);
								}
								ui.update();
							}
						}
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						},
						frequent: true,
					},
					double_character_jiange: {
						name: '双将模式',
						init: false,
						frequent: true,
					},
					replace_handcard_two: {
						name: '四号位保护',
						init: true,
						frequent: true,
						intro: '最后行动的角色起始手牌+1'
					},
					replace_character_two: {
						name: '替补模式',
						init: false,
						frequent: true,
						intro: '每个额外选择一名武将，死亡后用该武将代替重新上场，替补武将用完时失败'
					},
					expand_dialog: {
						name: '默认展开选将框',
						intro: '选将框打开时直接显示全部武将（可能使游戏在开始时卡顿）',
						init: false,
					},
					siguo_character: {
						name: '专属武将出场率',
						init: 'increase',
						item: {
							increase: '大概率',
							normal: '默认概率',
							off: '不出现',
						},
						frequent: true
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true
					// },
					ladder_reset: {
						name: '重置天梯数据',
						onclick: function () {
							var node = this;
							if (node._clearing) {
								game.save('ladder', {
									current: 900,
									top: 900,
									month: (new Date()).getMonth()
								});
								ui.ladder.innerHTML = '卫士五';
								clearTimeout(node._clearing);
								node.firstChild.innerHTML = '重置天梯数据';
								delete node._clearing;
								return;
							}
							node.firstChild.innerHTML = '单击以确认 (3)';
							node._clearing = setTimeout(function () {
								node.firstChild.innerHTML = '单击以确认 (2)';
								node._clearing = setTimeout(function () {
									node.firstChild.innerHTML = '单击以确认 (1)';
									node._clearing = setTimeout(function () {
										node.firstChild.innerHTML = '重置天梯数据';
										delete node._clearing;
									}, 1000);
								}, 1000);
							}, 1000);
						},
						clear: true,
					},
				}
			},
			connect: {
				name: '联机',
				config: {
					connect_nickname: {
						name: '联机昵称',
						input: true,
						frequent: true,
					},
					connect_avatar: {
						name: '联机头像',
						init: 'caocao',
						item: {},
						frequent: true,
						onclick: function (item) {
							game.saveConfig('connect_avatar', item);
							game.saveConfig('connect_avatar', item, 'connect');
						}
					},
					hall_ip: {
						name: '联机大厅',
						input: true,
						frequent: true,
					},
					hall_button: {
						name: '联机大厅按钮',
						init: true,
						frequent: true,
						onclick: function (bool) {
							game.saveConfig('hall_button', bool, 'connect');
							if (ui.hall_button) {
								if (bool) {
									ui.hall_button.style.display = '';
								}
								else {
									ui.hall_button.style.display = 'none';
								}
							}
						}
					},
					room_button: {
						name: '创建服务器按钮',
						init: false,
						frequent: true,
						intro: '开启后可创建一个空房间但不加入游戏',
						onclick: function (bool) {
							game.saveConfig('room_button', bool, 'connect');
							if (ui.connectRoom) {
								if (bool) {
									ui.connectRoom.style.display = '';
								}
								else {
									ui.connectRoom.style.display = 'none';
								}
							}
						}
					}
				}
			},
			boss: {
				name: '挑战',
				config: {
					free_choose: {
						name: '自由选将',
						init: true,
						frequent: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						}
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						},
						frequent: true,
					},
					single_control: {
						name: '单人控制',
						init: true,
						frequent: true,
						onclick: function (bool) {
							game.saveConfig('single_control', bool, this._link.config.mode);
							if (ui.single_swap && game.me != game.boss) {
								if (bool) {
									ui.single_swap.style.display = 'none';
								}
								else {
									ui.single_swap.style.display = '';
								}
							}
						},
						intro: '只控制一名角色，其他角色由AI控制'
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
				}
			},
			doudizhu: {
				name: '斗地主',
				connect: {
					update: function (config, map) {
						if (config.connect_doudizhu_mode == 'kaihei' || config.connect_doudizhu_mode == 'huanle') {
							map.connect_double_character.hide();
						}
						else {
							map.connect_double_character.show();
						}
					},
					connect_doudizhu_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '休闲',
							kaihei: '开黑',
							huanle: '欢乐',
						},
						restart: true,
						frequent: true,
					},
					connect_double_character: {
						name: '双将模式',
						init: false,
						frequent: true,
						restart: true,
					},
					connect_change_card: {
						name: '启用手气卡',
						init: false,
						frequent: true,
						restart: true,
					},
				},
				config: {
					update: function (config, map) {
						if (config.doudizhu_mode == 'kaihei' || config.doudizhu_mode == 'huanle') {
							map.double_character.hide();
						}
						else {
							map.double_character.show();
						}
						if (config.double_character && config.doudizhu_mode != 'kaihei' && config.doudizhu_mode != 'huanle') {
							map.double_hp.show();
						}
						else {
							map.double_hp.hide();
						}
					},
					doudizhu_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '休闲',
							kaihei: '开黑',
							huanle: '欢乐',
						},
						restart: true,
						frequent: true,
					},
					double_character: {
						name: '双将模式',
						init: false,
						frequent: true,
						restart: true,
					},
					double_hp: {
						name: '双将体力上限',
						init: 'pingjun',
						item: {
							hejiansan: '和减三',
							pingjun: '平均值',
							zuidazhi: '最大值',
							zuixiaozhi: '最小值',
							zonghe: '相加',
						},
						restart: true,
					},
					free_choose: {
						name: '自由选将',
						init: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						}
					},
					change_identity: {
						name: '自由选择身份和座位',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_identity', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							var dialog;
							if (ui.cheat2 && ui.cheat2.backup) dialog = ui.cheat2.backup;
							else dialog = _status.event.dialog;
							if (!_status.brawl || !_status.brawl.noAddSetting) {
								if (!dialog.querySelector('table') && get.config('change_identity')) _status.event.getParent().addSetting(dialog);
								else _status.event.getParent().removeSetting(dialog);
							}
							ui.update();
						}
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						}
					},
					change_card: {
						name: '开启手气卡',
						init: 'disabled',
						item: {
							disabled: '禁用',
							once: '一次',
							twice: '两次',
							unlimited: '无限',
						},
					},
					continue_game: {
						name: '显示再战',
						init: false,
						onclick: function (bool) {
							game.saveConfig('continue_game', bool, this._link.config.mode);
							if (get.config('continue_game')) {
								if (!ui.continue_game && _status.over && !_status.brawl) {
									ui.continue_game = ui.create.control('再战', game.reloadCurrent);
								}
							}
							else if (ui.continue_game) {
								ui.continue_game.close();
								delete ui.continue_game;
							}
						},
						intro: '游戏结束后可选择用相同的武将再进行一局游戏'
					},
					dierestart: {
						name: '死亡后显示重来',
						init: true,
						onclick: function (bool) {
							game.saveConfig('dierestart', bool, this._link.config.mode);
							if (get.config('dierestart')) {
								if (!ui.restart && game.me.isDead() && !_status.connectMode) {
									ui.restart = ui.create.control('restart', game.reload);
								}
							}
							else if (ui.restart) {
								ui.restart.close();
								delete ui.restart;
							}
						}
					},
					revive: {
						name: '死亡后显示复活',
						init: false,
						onclick: function (bool) {
							game.saveConfig('revive', bool, this._link.config.mode);
							if (get.config('revive')) {
								if (!ui.revive && game.me.isDead()) {
									ui.revive = ui.create.control('revive', ui.click.dierevive);
								}
							}
							else if (ui.revive) {
								ui.revive.close();
								delete ui.revive;
							}
						}
					},
					choice_zhu: {
						name: '地主候选武将数',
						init: '3',
						restart: true,
						item: {
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'8': '八',
							'10': '十',
						},
					},
					choice_fan: {
						name: '农民候选武将数',
						init: '3',
						restart: true,
						item: {
							'3': '三',
							'4': '四',
							'5': '五',
							'6': '六',
							'8': '八',
							'10': '十',
						},
					},
				}
			},
			single: {
				name: '单挑',
				connect: {
					connect_single_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '新1v1',
							dianjiang: '点将单挑',
							changban: '血战长坂坡',
						},
						restart: true,
						frequent: true,
					},
					update: function (config, map) { },
				},
				config: {
					single_mode: {
						name: '游戏模式',
						init: 'normal',
						item: {
							normal: '新1v1',
							dianjiang: '点将单挑',
							changban: '血战长坂坡',
						},
						restart: true,
						frequent: true,
					},
					update: function (config, map) {
					},
				}
			},
			chess: {
				name: '战棋',
				config: {
					chess_mode: {
						name: '游戏模式',
						init: 'combat',
						item: {
							combat: '自由',
							three: '统率',
							leader: '君主',
						},
						restart: true,
						frequent: true,
					},
					update: function (config, map) {
						if (config.chess_mode == 'leader') {
							map.chess_leader_save.show();
							map.chess_leader_clear.show();
							map.chess_character.hide();
						}
						else {
							map.chess_leader_save.hide();
							map.chess_leader_clear.hide();
							map.chess_character.show();
						}
						if (config.chess_mode == 'combat') {
							// map.battle_number.show();
							// map.chess_ordered.show();
							map.free_choose.show();
							map.change_choice.show();
						}
						else {
							// map.battle_number.hide();
							// map.chess_ordered.hide();
							map.free_choose.hide();
							map.change_choice.hide();
						}
						// if(config.chess_mode!='leader'){
						// 	map.ban_weak.show();
						// 	map.ban_strong.show();
						// }
						// else{
						// 	map.ban_weak.hide();
						// 	map.ban_strong.hide();
						// }
					},
					chess_leader_save: {
						name: '选择历程',
						init: 'save1',
						item: {
							save1: '一',
							save2: '二',
							save3: '三',
							save4: '四',
							save5: '五',
						},
						restart: true,
						frequent: true,
					},
					chess_leader_clear: {
						name: '清除进度',
						onclick: function () {
							var node = this;
							if (node._clearing) {
								game.save(get.config('chess_leader_save'), null);
								game.reload();
								return;
							}
							node._clearing = true;
							node.firstChild.innerHTML = '单击以确认 (3)';
							setTimeout(function () {
								node.firstChild.innerHTML = '单击以确认 (2)';
								setTimeout(function () {
									node.firstChild.innerHTML = '单击以确认 (1)';
									setTimeout(function () {
										node.firstChild.innerHTML = '清除进度';
										delete node._clearing;
									}, 1000);
								}, 1000);
							}, 1000);
						},
						clear: true,
						frequent: true,
					},
					// chess_treasure:{
					// 	name:'战场机关',
					// 	init:'0',
					// 	frequent:true,
					// 	item:{
					// 		'0':'关闭',
					// 		'0.1':'较少出现',
					// 		'0.2':'偶尔出现',
					// 		'0.333':'时常出现',
					// 		'0.5':'频繁出现',
					// 	}
					// },
					chess_obstacle: {
						name: '随机路障',
						init: '0.2',
						item: {
							'0': '关闭',
							'0.2': '少量',
							'0.333': '中量',
							'0.5': '大量',
						},
						frequent: true,
					},
					show_range: {
						name: '显示卡牌范围',
						init: true,
					},
					show_distance: {
						name: '显示距离',
						init: true,
					},
					chess_character: {
						name: '战棋武将',
						init: true,
						frequent: true,
					},
					chess_card: {
						name: '战棋卡牌',
						init: true,
						frequent: true,
					},
					free_choose: {
						name: '自由选将',
						init: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						},
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						},
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
					chessscroll_speed: {
						name: '边缘滚动速度',
						init: '20',
						intro: '鼠标移至屏幕边缘时自动滚屏',
						item: {
							'0': '不滚动',
							'10': '10格/秒',
							'20': '20格/秒',
							'30': '30格/秒',
						}
					},
				}
			},
			tafang: {
				name: '塔防',
				config: {
					tafang_turn: {
						name: '游戏胜利',
						init: '10',
						frequent: true,
						item: {
							'10': '十回合',
							'20': '二十回合',
							'30': '三十回合',
							'1000': '无限',
						}
					},
					// tafang_size:{
					// 	name:'战场大小',
					// 	init:'9',
					// 	frequent:true,
					// 	item:{
					// 		'6':'小',
					// 		'9':'中',
					// 		'12':'大',
					// 	}
					// },
					tafang_difficulty: {
						name: '战斗难度',
						init: '2',
						frequent: true,
						item: {
							'1': '简单',
							'2': '普通',
							'3': '困难',
						}
					},
					show_range: {
						name: '显示卡牌范围',
						init: true,
					},
					show_distance: {
						name: '显示距离',
						init: true,
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
					chessscroll_speed: {
						name: '边缘滚动速度',
						intro: '鼠标移至屏幕边缘时自动滚屏',
						init: '20',
						item: {
							'0': '不滚动',
							'10': '10格/秒',
							'20': '20格/秒',
							'30': '30格/秒',
						}
					},
				}
			},
			brawl: {
				name: '乱斗',
				config: {
					huanhuazhizhan: {
						name: '幻化之战',
						init: true,
						frequent: true
					},
					duzhansanguo: {
						name: '毒战三国',
						init: true,
						frequent: true
					},
					daozhiyueying: {
						name: '导师月英',
						init: true,
						frequent: true
					},
					weiwoduzun: {
						name: '唯我独尊',
						init: true,
						frequent: true
					},
					tongxingzhizheng: {
						name: '同姓之争',
						init: true,
						frequent: true
					},
					tongqueduopao: {
						name: '铜雀夺袍',
						init: true,
						frequent: true
					},
					tongjiangmoshi: {
						name: '同将模式',
						init: true,
						frequent: true
					},
					baiyidujiang: {
						name: '白衣渡江',
						init: true,
						frequent: true
					},
					qianlidanji: {
						name: '千里单骑',
						init: true,
						frequent: true
					},
					liangjunduilei: {
						name: '两军对垒',
						init: true,
						frequent: true
					},
					scene: {
						name: '创建场景',
						init: true,
						frequent: true
					}
				}
			},
			stone: {
				name: '炉石',
				config: {
					// update:function(config,map){
					// 	if(config.stone_mode=='deck'){
					// 		// map.deck_length.show();
					// 		// map.deck_repeat.show();
					// 		map.random_length.hide();
					// 		map.skill_bar.show();
					// 	}
					// 	else{
					// 		// map.deck_length.hide();
					// 		// map.deck_repeat.hide();
					// 		map.random_length.show();
					// 		map.skill_bar.hide();
					// 	}
					// },
					// stone_mode:{
					// 	name:'游戏模式',
					// 	init:'deck',
					// 	item:{
					// 		deck:'构筑',
					// 		random:'随机'
					// 	},
					// 	restart:true,
					// 	frequent:true,
					// },
					// deck_length:{
					// 	name:'卡组长度',
					// 	init:'30',
					// 	item:{
					// 		'30':'30张',
					// 		'50':'50张',
					// 		'80':'80张',
					// 	},
					// 	frequent:true,
					// },
					// deck_repeat:{
					// 	name:'重复卡牌',
					// 	init:'2',
					// 	item:{
					// 		'2':'2张',
					// 		'3':'3张',
					// 		'5':'5张',
					// 		'80':'无限',
					// 	},
					// 	frequent:true,
					// },
					// random_length:{
					// 	name:'随从牌数量',
					// 	init:'1/80',
					// 	item:{
					// 		'1/120':'少',
					// 		'1/80':'中',
					// 		'1/50':'多',
					// 	},
					// 	frequent:true,
					// },
					battle_number: {
						name: '出场人数',
						init: '1',
						frequent: true,
						item: {
							'1': '一人',
							'2': '两人',
							'3': '三人',
							'4': '四人',
							'6': '六人',
							'8': '八人',
							'10': '十人',
						},
						onclick: function (num) {
							game.saveConfig('battle_number', num, this._link.config.mode);
							if (_status.connectMode) return;
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (_status.event.getParent().changeDialog) {
								_status.event.getParent().changeDialog();
							}
						},
					},
					mana_mode: {
						name: '行动值变化',
						init: 'inc',
						item: {
							inf: '涨落',
							inc: '递增'
						},
						frequent: true
					},
					skill_bar: {
						name: '怒气值',
						init: true,
						frequent: true,
						restart: true,
					},
					double_character: {
						name: '双将模式',
						init: false,
						frequent: true,
						restart: function () {
							return _status.event.getParent().name != 'chooseCharacter' || _status.event.name != 'chooseButton';
						}
					},
					free_choose: {
						name: '自由选将',
						init: true,
						onclick: function (bool) {
							game.saveConfig('free_choose', bool, this._link.config.mode);
							if (_status.connectMode) return;
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat2 && get.config('free_choose')) ui.create.cheat2();
							else if (ui.cheat2 && !get.config('free_choose')) {
								ui.cheat2.close();
								delete ui.cheat2;
							}
						},
					},
					change_choice: {
						name: '开启换将卡',
						init: true,
						onclick: function (bool) {
							game.saveConfig('change_choice', bool, this._link.config.mode);
							if (_status.connectMode) return;
							if (!_status.event.getParent().showConfig && !_status.event.showConfig) return;
							if (!ui.cheat && get.config('change_choice')) ui.create.cheat();
							else if (ui.cheat && !get.config('change_choice')) {
								ui.cheat.close();
								delete ui.cheat;
							}
						},
					},
					// ban_weak:{
					// 	name:'屏蔽弱将',
					// 	init:true,
					// 	restart:true,
					// },
					// ban_strong:{
					// 	name:'屏蔽强将',
					// 	init:false,
					// 	restart:true,
					// },
				}
			},
		},
		status: {
			running: false,
			canvas: false,
			time: 0,
			reload: 0,
			delayed: 0,
			frameId: 0,
			videoId: 0,
			globalId: 0,
		},
		help: {
			'游戏操作': '<ul><li>长按/鼠标悬停/右键单击显示信息<li>触屏模式中，双指点击切换暂停；下划显示菜单，上划切换托管<li>键盘快捷键<br>' +
				'<table><tr><td>A<td>切换托管<tr><td>W<td>切换不询问无懈<tr><td>空格<td>暂停</table><li>编辑牌堆<br>在卡牌包中修改牌堆后，将自动创建一个临时牌堆，在所有模式中共用，当保存当前牌堆后，临时牌堆被清除。每个模式可设置不同的已保存牌堆，设置的牌堆优先级大于临时牌堆</ul>',
			'游戏命令': '<div style="margin:10px">变量名</div><ul style="margin-top:0"><li>场上角色<br>game.players<li>阵亡角色<br>game.dead' +
				'<li>玩家<br>game.me<li>玩家的上/下家<br>game.me.previous/next' +
				'<li>玩家的上/下家（含阵亡）<br>game.me.previousSeat/<br>nextSeat' +
				'<li>牌堆<br>ui.cardPile<li>弃牌堆<br>ui.discardPile</ul>' +
				'<div style="margin:10px">角色属性</div><ul style="margin-top:0"><li>体力值<br>player.hp' +
				'<li>体力上限<br>player.maxHp<li>身份<br>player.identity<li>手牌<br>player.getCards("h")<li>装备牌<br>player.getCards("e")<li>判定牌<br>player.getCards("j")' +
				'<li>是否存活/横置/翻面<br>player.isAlive()/<br>isLinked()/<br>isTurnedOver()</ul>' +
				'<div style="margin:10px">角色操作</div><ul style="margin-top:0"><li>受到伤害<br>player.damage(source,<br>num)' +
				'<li>回复体力<br>player.recover(num)<li>摸牌<br>player.draw(num)<li>获得牌<br>player.gain(cards)<li>弃牌<br>player.discard(cards)' +
				'<li>使用卡牌<br>player.useCard(card,<br>targets)<li>死亡<br>player.die()<li>复活<br>player.revive(hp)</ul>' +
				'<div style="margin:10px">游戏操作</div><ul style="margin-top:0"><li>在命令框中输出结果<br>game.print(str)<li>清除命令框中的内容<br>cls<li>上一条/下一条输入的内容<br>up/down<li>游戏结束<br>game.over(bool)' +
				'<li>角色资料<br>lib.character<li>卡牌资料<br>lib.card</ul>',
			'游戏名词': '<ul><li>护甲：和体力类似，每点护甲可抵挡一点伤害，但不影响手牌上限' +
				'<li>随从：通过技能获得，拥有独立的技能、手牌区和装备区（共享判定区），出场时替代主武将的位置；随从死亡时自动切换回主武将' +
				'<li>发现：从三张随机亮出的牌中选择一张，若无特殊说明，则获得此牌' +
				'<li>蓄力技：发动时可以增大黄色的数字。若如此做，红色数字于技能的结算过程中改为原来的两倍'
		},
		setIntro: function (node, func, left) {
			if (lib.config.touchscreen) {
				if (left) {
					node.listen(ui.click.touchintro);
				}
				else {
					lib.setLongPress(node, ui.click.intro);
				}
			}
			else {
				if (left) {
					node.listen(ui.click.intro);
				}
				if (lib.config.hover_all) {
					lib.setHover(node, ui.click.hoverplayer);
				}
				if (lib.config.right_info) {
					node.oncontextmenu = ui.click.rightplayer;
				}
			}
			// if(!left){
			// 	lib.setPressure(node,ui.click.rightpressure);
			// }
			if (func) {
				node._customintro = func;
			}
		},
		// setPressure:function(node,func){
		// 	if(window.Pressure){
		// 		window.Pressure.set(node,{change: func}, {polyfill: false});
		// 	}
		// },
		setPopped: function (node, func, width, height, forceclick, paused2) {
			node._poppedfunc = func;
			node._poppedwidth = width;
			node._poppedheight = height;
			if (forceclick) {
				node.forceclick = true;
			}
			if (lib.config.touchscreen || forceclick) {
				node.listen(ui.click.hoverpopped);
			}
			else {
				node.addEventListener('mouseenter', ui.click.hoverpopped);
				// node.addEventListener('mouseleave',ui.click.hoverpopped_leave);
			}
			if (paused2) {
				node._paused2 = true;
			}
		},
		placePoppedDialog: function (dialog, e) {
			if (dialog._place_text) {
				if (dialog._place_text.firstChild.offsetWidth >= 190 ||
					dialog._place_text.firstChild.offsetHeight >= 30) {
					dialog._place_text.style.textAlign = 'left';
					dialog._place_text.style.marginLeft = '14px';
				}
			}
			if (e.touches && e.touches[0]) {
				e = e.touches[0];
			}
			var height = Math.min(ui.window.offsetHeight - 20, dialog.content.scrollHeight);
			if (dialog._mod_height) {
				height += dialog._mod_height;
			}
			dialog.style.height = height + 'px';
			if (e.clientX / game.documentZoom < ui.window.offsetWidth / 2) {
				dialog.style.left = (e.clientX / game.documentZoom + 10) + 'px';
			}
			else {
				dialog.style.left = (e.clientX / game.documentZoom - dialog.offsetWidth - 10) + 'px';
			}
			var idealtop = (e.clientY || 0) / game.documentZoom - dialog.offsetHeight / 2;
			if (typeof idealtop != 'number' || isNaN(idealtop) || idealtop <= 5) {
				idealtop = 5;
			}
			else if (idealtop + dialog.offsetHeight + 10 > ui.window.offsetHeight) {
				idealtop = ui.window.offsetHeight - 10 - dialog.offsetHeight;
			}
			dialog.style.top = idealtop + 'px';
		},
		setHover: function (node, func, hoveration, width) {
			node._hoverfunc = func;
			if (typeof hoveration == 'number') {
				node._hoveration = hoveration;
			}
			if (typeof width == 'number') {
				node._hoverwidth = width
			}
			node.addEventListener('mouseenter', ui.click.mouseenter);
			node.addEventListener('mouseleave', ui.click.mouseleave);
			node.addEventListener('mousedown', ui.click.mousedown);
			node.addEventListener('mousemove', ui.click.mousemove);
			return node;
		},
		setScroll: function (node) {
			node.ontouchstart = ui.click.touchStart;
			node.ontouchmove = ui.click.touchScroll;
			node.style.WebkitOverflowScrolling = 'touch';
			return node;
		},
		setMousewheel: function (node) {
			if (lib.config.mousewheel) node.onmousewheel = ui.click.mousewheel;
		},
		setLongPress: function (node, func) {
			node.addEventListener('touchstart', ui.click.longpressdown);
			node.addEventListener('touchend', ui.click.longpresscancel);
			node._longpresscallback = func;
			return node;
		},
		updateCanvas: function (time) {
			if (lib.canvasUpdates.length === 0) {
				lib.status.canvas = false;
				return false;
			}
			ui.canvas.width = ui.arena.offsetWidth;
			ui.canvas.height = ui.arena.offsetHeight;
			var ctx = ui.ctx;
			ctx.shadowBlur = 5;
			ctx.shadowColor = 'rgba(0,0,0,0.3)';
			ctx.strokeStyle = 'white';
			// ctx.lineCap='round';
			ctx.lineWidth = 3;
			ctx.save();
			for (var i = 0; i < lib.canvasUpdates.length; i++) {
				ctx.restore();
				ctx.save();
				var update = lib.canvasUpdates[i];
				if (!update.starttime) {
					update.starttime = time;
				}
				if (update(time - update.starttime, ctx) === false) {
					lib.canvasUpdates.splice(i--, 1);
				}
			}
		},
		run: function (time) {
			lib.status.time = time;
			for (var i = 0; i < lib.updates.length; i++) {
				if (!lib.updates[i].hasOwnProperty('_time')) {
					lib.updates[i]._time = time;
				}
				if (lib.updates[i](time - lib.updates[i]._time - lib.status.delayed) === false) {
					lib.updates.splice(i--, 1);
				}
			}
			if (lib.updates.length) {
				lib.status.frameId = requestAnimationFrame(lib.run);
			}
			else {
				lib.status.time = 0;
				lib.status.delayed = 0;
			}
		},
		getUTC: function (date) {
			return date.getTime();
		},
		saveVideo: function () {
			if (_status.videoToSave) {
				game.export(lib.init.encode(JSON.stringify(_status.videoToSave)),
					'无名杀 - 录像 - ' + _status.videoToSave.name[0] + ' - ' + _status.videoToSave.name[1]);
			}
		},
		init: {
			init: function () {
				if (typeof __dirname === 'string' && __dirname.length) {
					var dirsplit = __dirname.split('/');
					for (var i = 0; i < dirsplit.length; i++) {
						if (dirsplit[i]) {
							var c = dirsplit[i][0];
							lib.configprefix += /[A-Z]|[a-z]/.test(c) ? c : '_';
						}
					}
					lib.configprefix += '_';
				}
				window.resetGameTimeout = setTimeout(lib.init.reset, parseInt(localStorage.getItem(lib.configprefix + 'loadtime')) || 5000);
				if (window.cordovaLoadTimeout) {
					clearTimeout(window.cordovaLoadTimeout);
					delete window.cordovaLoadTimeout;
				}
				var links = document.head.querySelectorAll('link');
				for (var i = 0; i < links.length; i++) {
					if (links[i].href.indexOf('app/color.css') != -1) {
						links[i].remove();
						break;
					}
				}
				var index = window.location.href.indexOf('index.html?server=');
				if (index != -1) {
					window.isNonameServer = window.location.href.slice(index + 18);
					window.nodb = true;
				}
				else {
					index = localStorage.getItem(lib.configprefix + 'asserver');
					if (index) {
						window.isNonameServer = index;
						window.isNonameServerIp = lib.hallURL;
					}
				}

				var htmlbg = localStorage.getItem(lib.configprefix + 'background');
				if (htmlbg) {
					if (htmlbg[0] == '[') {
						try {
							htmlbg = JSON.parse(htmlbg);
							htmlbg = htmlbg[get.rand(htmlbg.length)];
							if (htmlbg.indexOf('custom_') == 0) {
								throw ('err');
							}
							_status.htmlbg = htmlbg;
						}
						catch (e) {
							htmlbg = null;
						}
					}
					if (htmlbg) {
						document.documentElement.style.backgroundImage = 'url("' + lib.assetURL + 'image/background/' + htmlbg + '.jpg")';
						document.documentElement.style.backgroundSize = 'cover';
						document.documentElement.style.backgroundPosition = '50% 50%';
					}
				}

				lib.get = get;
				lib.ui = ui;
				lib.ai = ai;
				lib.game = game;

				HTMLDivElement.prototype.animate = function (name, time) {
					var that;
					if (get.is.mobileMe(this) && name == 'target') {
						that = ui.mebg;
					}
					else {
						that = this;
					}
					that.classList.add(name);
					setTimeout(function () {
						that.classList.remove(name);
					}, time || 1000);
					return this;
				};
				HTMLDivElement.prototype.hide = function () {
					this.classList.add('hidden');
					return this;
				};
				HTMLDivElement.prototype.unfocus = function () {
					if (lib.config.transparent_dialog) this.classList.add('transparent');
					return this;
				};
				HTMLDivElement.prototype.refocus = function () {
					this.classList.remove('transparent');
					return this;
				};
				HTMLDivElement.prototype.show = function () {
					this.classList.remove('hidden');
					return this;
				};
				HTMLDivElement.prototype.delete = function (time, callback) {
					if (this.timeout) {
						clearTimeout(this.timeout);
						delete this.timeout;
					}
					if (!this._listeningEnd || this._transitionEnded) {
						if (typeof time != 'number') time = 500;
						this.classList.add('removing');
						var that = this;
						this.timeout = setTimeout(function () {
							that.remove();
							that.classList.remove('removing');
							if (typeof callback == 'function') {
								callback();
							}
						}, time);
					}
					else {
						this._onEndDelete = true;
					}
					return this;
				};
				HTMLDivElement.prototype.goto = function (position, time) {
					if (this.timeout) {
						clearTimeout(this.timeout);
						delete this.timeout;
					}

					if (typeof time != 'number') time = 500;
					this.classList.add('removing');

					var that = this;
					this.timeout = setTimeout(function () {
						if (!that.destroyed) {
							position.appendChild(that);
						}
						that.classList.remove('removing');
						delete that.destiny;
					}, time);
					this.destiny = position;
					return this;
				};
				HTMLDivElement.prototype.fix = function () {
					clearTimeout(this.timeout);
					delete this.timeout;
					delete this.destiny;
					this.classList.remove('removing');
					return this;
				};
				HTMLDivElement.prototype.setBackground = function (name, type, ext, subfolder) {
					if (!name) return;
					var src;
					if (ext == 'noskin') {
						ext = '.jpg';
					}
					ext = ext || '.jpg';
					subfolder = subfolder || 'default'
					if (type) {
						var dbimage = null, extimage = null, modeimage = null;
						var nameinfo;
						var gzbool = false;
						var mode = get.mode();
						if (type == 'character') {
							if (lib.characterPack['mode_' + mode] && lib.characterPack['mode_' + mode][name]) {
								if (mode == 'guozhan') {
									if (name.indexOf('gz_shibing') == 0) {
										name = name.slice(3, 11);
									}
									else {
										if (lib.config.mode_config.guozhan.guozhanSkin && lib.character[name] && lib.character[name][4].contains('gzskin')) gzbool = true;
										name = name.slice(3);
									}
								}
								else {
									modeimage = mode;
								}
							}
							else if (lib.character[name]) {
								nameinfo = lib.character[name];
							}
							else if (name.indexOf('::') != -1) {
								name = name.split('::');
								modeimage = name[0];
								name = name[1];
							}
						}
						if (!modeimage && nameinfo && nameinfo[4]) {
							for (var i = 0; i < nameinfo[4].length; i++) {
								if (nameinfo[4][i].indexOf('ext:') == 0) {
									extimage = nameinfo[4][i]; break;
								}
								else if (nameinfo[4][i].indexOf('db:') == 0) {
									dbimage = nameinfo[4][i]; break;
								}
								else if (nameinfo[4][i].indexOf('mode:') == 0) {
									modeimage = nameinfo[4][i].slice(5); break;
								}
								else if (nameinfo[4][i].indexOf('character:') == 0) {
									name = nameinfo[4][i].slice(10); break;
								}
							}
						}
						if (extimage) {
							src = extimage.replace(/ext:/, 'extension/');
						}
						else if (dbimage) {
							this.setBackgroundDB(dbimage.slice(3));
							return this;
						}
						else if (modeimage) {
							src = 'image/mode/' + modeimage + '/character/' + name + ext;
						}
						else if (type == 'character' && lib.config.skin[name] && arguments[2] != 'noskin') {
							src = 'image/skin/' + name + '/' + lib.config.skin[name] + ext;
						}
						else {
							if (type == 'character') {
								src = 'image/character/' + (gzbool ? 'gz_' : '') + name + ext;
							}
							else {
								src = 'image/' + type + '/' + subfolder + '/' + name + ext;
							}
						}
					}
					else {
						src = 'image/' + name + ext;
					}
					this.setBackgroundImage(src);
					this.style.backgroundSize = "cover";
					return this;
				};
				HTMLDivElement.prototype.setBackgroundDB = function (img) {
					var node = this;
					game.getDB('image', img, function (src) {
						node.style.backgroundImage = "url('" + src + "')";
						node.style.backgroundSize = "cover";
					});
				};
				HTMLDivElement.prototype.setBackgroundImage = function (img) {
					this.style.backgroundImage = 'url("' + lib.assetURL + img + '")';
				},
					HTMLDivElement.prototype.listen = function (func) {
						if (lib.config.touchscreen) {
							this.addEventListener('touchend', function (e) {
								if (!_status.dragged) {
									func.call(this, e);
								}
							});
							var fallback = function (e) {
								if (!_status.touchconfirmed) {
									func.call(this, e);
								}
								else {
									this.removeEventListener('click', fallback);
								}
							}
							this.addEventListener('click', fallback);
						}
						else {
							this.addEventListener('click', func);
						}
						return this;
					};
				HTMLDivElement.prototype.listenTransition = function (func, time) {
					var that = this;
					var done = false;
					var callback = function () {
						if (!done) {
							func.call(that);
							done = true;
						}
					};
					this.addEventListener('webkitTransitionEnd', callback);
					return setTimeout(callback, time || 1000);
				};
				HTMLDivElement.prototype.setPosition = function () {
					var position;
					if (arguments.length == 4) {
						position = [];
						for (var i = 0; i < arguments.length; i++) position.push(arguments[i]);
					}
					else if (arguments.length == 1 && Array.isArray(arguments[0]) && arguments[0].length == 4) {
						position = arguments[0];
					}
					else {
						return this;
					}
					var top = 'calc(' + position[0] + '% ';
					if (position[1] > 0) top += '+ ' + position[1] + 'px)';
					else top += '- ' + Math.abs(position[1]) + 'px)';
					var left = 'calc(' + position[2] + '% ';
					if (position[3] > 0) left += '+ ' + position[3] + 'px)';
					else left += '- ' + Math.abs(position[3]) + 'px)';
					this.style.top = top;
					this.style.left = left;
					return this;
				};
				HTMLDivElement.prototype.css = function (style) {
					for (var i in style) {
						if (i == 'innerHTML') {
							this.innerHTML = style[i];
						}
						else {
							this.style[i] = style[i];
						}
					}
					return this;
				};
				HTMLTableElement.prototype.get = function (row, col) {
					if (row < this.childNodes.length) {
						return this.childNodes[row].childNodes[col];
					}
				};
				Array.prototype.numOf = function (item) {
					var num = 0;
					for (var i = 0; i < this.length; i++) {
						if (this[i] == item) num++;
					}
					return num;
				};
				Array.prototype.filterInD = function (pos) {
					if (!pos) pos = 'o';
					var list = [];
					for (var i = 0; i < this.length; i++) {
						if (pos.indexOf(get.position(this[i], true)) != -1) list.push(this[i]);
					}
					return list;
				};
				Array.prototype.find = function (item) {
					return this.indexOf(item);
				};
				Array.prototype.contains = function (item) {
					return this.indexOf(item) != -1;
				};
				Array.prototype.add = function () {
					for (var i = 0; i < arguments.length; i++) {
						if (this.contains(arguments[i])) {
							return false;
						}
						this.push(arguments[i]);
					}
					return this;
				};
				Array.prototype.addArray = function (arr) {
					for (var i = 0; i < arr.length; i++) {
						this.add(arr[i]);
					}
					return this;
				};
				Array.prototype.remove = function (item) {
					if (Array.isArray(item)) {
						for (var i = 0; i < item.length; i++) this.remove(item[i]);
						return;
					}
					var pos = this.find(item);
					if (pos == -1) {
						return false;
					}
					this.splice(pos, 1);
					return this;
				};
				Array.prototype.removeArray = function (arr) {
					for (var i = 0; i < arr.length; i++) {
						this.remove(arr[i]);
					}
					return this;
				};
				Array.prototype.randomGet = function () {
					var arr = this.slice(0);
					for (var i = 0; i < arguments.length; i++) arr.remove(arguments[i]);
					return arr[Math.floor(Math.random() * arr.length)];
				};
				Array.prototype.randomRemove = function (num) {
					if (typeof num == 'number') {
						var list = [];
						for (var i = 0; i < num; i++) {
							if (this.length) {
								list.push(this.randomRemove());
							}
							else {
								break;
							}
						}
						return list;
					}
					else {
						return this.splice(Math.floor(Math.random() * this.length), 1)[0];
					}
				};
				Array.prototype.randomSort = function () {
					var list = [];
					while (this.length) {
						list.push(this.randomRemove());
					}
					for (var i = 0; i < list.length; i++) {
						this.push(list[i]);
					}
					return this;
				};
				Array.prototype.randomGets = function (num) {
					if (num > this.length) {
						num = this.length;
					}
					var arr = this.slice(0);
					var list = [];
					for (var i = 0; i < num; i++) {
						list.push(arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
					}
					return list;
				};
				Array.prototype.sortBySeat = function (target) {
					lib.tempSortSeat = target;
					this.sort(lib.sort.seat);
					delete lib.tempSortSeat;
					return this;
				};
				if (!Array.from) {
					Array.from = function (args) {
						var list = [];
						if (args && args.length) {
							for (var i = 0; i < args.length; i++) {
								list.push(args[i]);
							}
						}
						return list;
					}
				}
				window.onkeydown = function (e) {
					if (!ui.menuContainer || !ui.menuContainer.classList.contains('hidden')) {
						if (e.keyCode == 116 || ((e.ctrlKey || e.metaKey) && e.keyCode == 82)) {
							if (e.shiftKey) {
								if (confirm('是否重置游戏？')) {
									var noname_inited = localStorage.getItem('noname_inited');
									var onlineKey = localStorage.getItem(lib.configprefix + 'key');
									localStorage.clear();
									if (noname_inited) {
										localStorage.setItem('noname_inited', noname_inited);
									}
									if (onlineKey) {
										localStorage.setItem(lib.configprefix + 'key', onlineKey);
									}
									if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
									game.reload();
									return;
								}
							}
							else {
								game.reload();
							}
						}
						else if (e.keyCode == 83 && (e.ctrlKey || e.metaKey)) {
							if (window.saveNonameInput) {
								window.saveNonameInput();
							}
							e.preventDefault();
							e.stopPropagation();
							return false;
						}
						else if (e.keyCode == 74 && (e.ctrlKey || e.metaKey) && lib.node) {
							lib.node.debug();
						}
					}
					else {
						game.closePopped();
						var dialogs = document.querySelectorAll('#window>.dialog.popped:not(.static)');
						for (var i = 0; i < dialogs.length; i++) {
							dialogs[i].delete();
						}
						if (e.keyCode == 32) {
							var node = ui.window.querySelector('pausedbg');
							if (node) {
								node.click();
							}
							else {
								ui.click.pause();
							}
						}
						else if (e.keyCode == 65) {
							if (ui.auto) ui.auto.click();
						}
						else if (e.keyCode == 87) {
							if (ui.wuxie && ui.wuxie.style.display != 'none') {
								ui.wuxie.classList.toggle('glow')
							}
							else if (ui.tempnowuxie) {
								ui.tempnowuxie.classList.toggle('glow')
							}
						}
						else if (e.keyCode == 116 || ((e.ctrlKey || e.metaKey) && e.keyCode == 82)) {
							if (e.shiftKey) {
								if (confirm('是否重置游戏？')) {
									var noname_inited = localStorage.getItem('noname_inited');
									var onlineKey = localStorage.getItem(lib.configprefix + 'key');
									localStorage.clear();
									if (noname_inited) {
										localStorage.setItem('noname_inited', noname_inited);
									}
									if (onlineKey) {
										localStorage.setItem(lib.configprefix + 'key', onlineKey);
									}
									if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
									game.reload();
									return;
								}
							}
							else {
								game.reload();
							}
						}
						else if (e.keyCode == 83 && (e.ctrlKey || e.metaKey)) {
							e.preventDefault();
							e.stopPropagation();
							return false;
						}
						else if (e.keyCode == 74 && (e.ctrlKey || e.metaKey) && lib.node) {
							lib.node.debug();
						}
						// else if(e.keyCode==27){
						// 	if(!ui.arena.classList.contains('paused')) ui.click.config();
						// }
					}
				};
				window.onload = function () {
					if (lib.device) {
						var script = document.createElement('script');
						script.src = 'cordova.js';
						document.body.appendChild(script);
						document.addEventListener('deviceready', function () {
							if (lib.init.cordovaReady) {
								lib.init.cordovaReady();
								delete lib.init.cordovaReady;
							}
						});
					}
					if (_status.packLoaded) {
						delete _status.packLoaded;
						lib.init.onload();
					}
					else {
						_status.windowLoaded = true;
					}
				};
				window.onerror = function (msg, src, line, column, err) {
					var str = msg + '\n' + _status.event.name + ': ' + _status.event.step;
					str += '\n' + _status.event.parent.name + ': ' + _status.event.parent.step;
					str += '\n' + _status.event.parent.parent.name + ': ' + _status.event.parent.parent.step;
					var evt = _status.event;
					if (evt.player || evt.target || evt.source || evt.skill || evt.card) {
						str += '\n-------------'
					}
					if (evt.player) {
						str += '\nplayer: ' + evt.player.name;
					}
					if (evt.target) {
						str += '\ntarget: ' + evt.target.name;
					}
					if (evt.source) {
						str += '\nsource: ' + evt.source.name;
					}
					if (evt.skill) {
						str += '\nskill: ' + evt.skill.name;
					}
					if (evt.card) {
						str += '\ncard: ' + evt.card.name;
					}
					str += '\n-------------';
					str += '\n' + line;
					str += '\n' + column;
					str += '\n' + err.stack;
					alert(str);
					window.ea = Array.from(arguments);
					window.em = msg;
					window.el = line;
					window.ec = column;
					window.eo = err;
					game.print(msg);
					game.print(line);
					game.print(column);
					game.print(err.stack);
					if (!lib.config.errstop) {
						_status.withError = true;
						game.loop();
					}
				};

				if (window.noname_update) {
					lib.version = window.noname_update.version;
					lib.changeLog = window.noname_update.changeLog;
					if (window.noname_update.players) {
						lib.changeLog.push('players://' + JSON.stringify(window.noname_update.players));
					}
					if (window.noname_update.cards) {
						lib.changeLog.push('cards://' + JSON.stringify(window.noname_update.cards));
					}
					delete window.noname_update;
				}
				var noname_inited = localStorage.getItem('noname_inited');
				if (noname_inited && noname_inited !== 'nodejs') {
					var ua = navigator.userAgent.toLowerCase();
					if (ua.indexOf('android') != -1) {
						lib.device = 'android';
					}
					else if (ua.indexOf('iphone') != -1 || ua.indexOf('ipad') != -1) {
						lib.device = 'ios';
					}
					lib.assetURL = noname_inited;
				}

				var config3 = null;
				var proceed = function (config2) {
					if (config3 === null) {
						config3 = config2;
						return;
					}
					if (config2.mode) lib.config.mode = config2.mode;
					if (lib.config.mode_config[lib.config.mode] == undefined) lib.config.mode_config[lib.config.mode] = {};
					for (var i in lib.config.mode_config.global) {
						if (lib.config.mode_config[lib.config.mode][i] == undefined) {
							lib.config.mode_config[lib.config.mode][i] = lib.config.mode_config.global[i];
						}
					}
					if (lib.config.characters) {
						lib.config.defaultcharacters = lib.config.characters.slice(0);
					}
					if (lib.config.cards) {
						lib.config.defaultcards = lib.config.cards.slice(0);
					}
					for (var i in config2) {
						if (i.indexOf('_mode_config') != -1) {
							var thismode = i.substr(i.indexOf('_mode_config') + 13);
							if (!lib.config.mode_config[thismode]) {
								lib.config.mode_config[thismode] = {};
							}
							lib.config.mode_config[thismode][i.substr(0, i.indexOf('_mode_config'))] = config2[i];
						}
						else {
							lib.config[i] = config2[i];
						}
					}
					for (var i in lib.config.translate) {
						lib.translate[i] = lib.config.translate[i];
					}

					lib.config.all.characters = [];
					lib.config.all.cards = [];
					lib.config.all.plays = [];
					lib.config.all.mode = [];

					if (lib.config.debug) {
						lib.init.js(lib.assetURL + 'game', 'asset', function () {
							lib.skin = window.noname_skin_list;
							delete window.noname_skin_list;
							delete window.noname_asset_list;
						});
					}

					if (window.isNonameServer) {
						lib.config.mode = 'connect';
					}
					var pack = window.noname_package;
					delete window.noname_package;
					for (i in pack.character) {
						if (lib.config.hiddenCharacterPack.indexOf(i) == -1) {
							lib.config.all.characters.push(i);
							lib.translate[i + '_character_config'] = pack.character[i];
						}
					}
					for (i in pack.card) {
						if (lib.config.hiddenCardPack.indexOf(i) == -1) {
							lib.config.all.cards.push(i);
							lib.translate[i + '_card_config'] = pack.card[i];
						}
					}
					for (i in pack.play) {
						lib.config.all.plays.push(i);
						lib.translate[i + '_play_config'] = pack.play[i];
					}
					for (i in pack.submode) {
						for (var j in pack.submode[i]) {
							lib.translate[i + '|' + j] = pack.submode[i][j];
						}
					}

					if (!lib.config.gameRecord) {
						lib.config.gameRecord = {};
					}
					for (i in pack.mode) {
						if (lib.config.hiddenModePack.indexOf(i) == -1) {
							lib.config.all.mode.push(i);
							lib.translate[i] = pack.mode[i];
							if (!lib.config.gameRecord[i]) {
								lib.config.gameRecord[i] = { data: {} };
							}
						}
					}
					if (lib.config.all.mode.length == 0) {
						lib.config.all.mode.push('identity');
						lib.translate.identity = '身份';
						if (!lib.config.gameRecord.identity) {
							lib.config.gameRecord.identity = { data: {} };
						}
					}
					if (pack.background) {
						for (i in pack.background) {
							if (lib.config.hiddenBackgroundPack.contains(i)) continue;
							lib.configMenu.appearence.config.image_background.item[i] = pack.background[i];
						}
						for (var i = 0; i < lib.config.customBackgroundPack.length; i++) {
							var link = lib.config.customBackgroundPack[i];
							lib.configMenu.appearence.config.image_background.item[link] = link.slice(link.indexOf('_') + 1);
						}
						lib.configMenu.appearence.config.image_background.item.default = '默认';
					}
					if (pack.music) {
						if (lib.device || typeof window.require == 'function') {
							lib.configMenu.audio.config.background_music.item.music_custom = '自定义音乐';
						}
						lib.config.all.background_music = ['music_default'];
						for (i in pack.music) {
							lib.config.all.background_music.push(i);
							lib.configMenu.audio.config.background_music.item[i] = pack.music[i];
						}
						if (lib.config.customBackgroundMusic) {
							for (i in lib.config.customBackgroundMusic) {
								lib.config.all.background_music.push(i);
								lib.configMenu.audio.config.background_music.item[i] = lib.config.customBackgroundMusic[i];
							}
						}
						lib.configMenu.audio.config.background_music.item.music_random = '随机播放';
						lib.configMenu.audio.config.background_music.item.music_off = '关闭';
					}
					if (pack.theme) {
						for (i in pack.theme) {
							lib.configMenu.appearence.config.theme.item[i] = pack.theme[i];
						}
					}

					if (pack.font) {
						ui.css.fontsheet = lib.init.sheet();
						for (i in pack.font) {
							lib.configMenu.appearence.config.name_font.item[i] = pack.font[i];
							lib.configMenu.appearence.config.identity_font.item[i] = pack.font[i];
							lib.configMenu.appearence.config.cardtext_font.item[i] = pack.font[i];
							lib.configMenu.appearence.config.global_font.item[i] = pack.font[i];
							ui.css.fontsheet.sheet.insertRule("@font-face {font-family: '" + i + "';src: url('" + lib.assetURL + "font/" + i + ".ttf');}", 0);
						}
						lib.configMenu.appearence.config.cardtext_font.item.default = '默认';
						lib.configMenu.appearence.config.global_font.item.default = '默认';
					}

					var ua = navigator.userAgent.toLowerCase();
					if ('ontouchstart' in document) {
						if (!lib.config.totouched) {
							game.saveConfig('totouched', true);
							if (lib.device) {
								game.saveConfig('low_performance', true);
								game.saveConfig('confirm_exit', true);
								game.saveConfig('touchscreen', true);
								game.saveConfig('fold_mode', false);
								if (ua.indexOf('ipad') == -1) {
									game.saveConfig('phonelayout', true);
								}
								else if (lib.device == 'ios') {
									game.saveConfig('show_statusbar_ios', 'overlay');
								}
							}
							else if (confirm('是否切换到触屏模式？（触屏模式可提高触屏设备的响应速度，但无法使用鼠标）')) {
								game.saveConfig('touchscreen', true);
								if (ua.indexOf('iphone') != -1 || ua.indexOf('android') != -1) {
									game.saveConfig('phonelayout', true);
								}
								game.reload();
							}
						}
					}
					else if (lib.config.touchscreen) {
						game.saveConfig('touchscreen', false);
					}
					if (!lib.config.toscrolled && ua.indexOf('macintosh') != -1) {
						game.saveConfig('toscrolled', true);
						game.saveConfig('mousewheel', false);
					}

					var show_splash = lib.config.show_splash;
					if (show_splash == 'off') {
						show_splash = false;
					}
					else if (show_splash == 'init') {
						if (localStorage.getItem('show_splash_off')) {
							show_splash = false;
						}
					}
					localStorage.removeItem('show_splash_off');
					var extensionlist = [];
					if (!localStorage.getItem(lib.configprefix + 'disable_extension')) {
						if (lib.config.extensions && lib.config.extensions.length) {
							window.resetExtension = function () {
								for (var i = 0; i < lib.config.extensions.length; i++) {
									game.saveConfig('extension_' + lib.config.extensions[i] + '_enable', false);
								}
								localStorage.setItem(lib.configprefix + 'disable_extension', true);
							}
						}
						for (var i = 0; i < lib.config.plays.length; i++) {
							if (lib.config.all.plays.indexOf(lib.config.plays[i]) != -1) {
								extensionlist.push(lib.config.plays[i]);
							}
						}
						for (var i = 0; i < lib.config.extensions.length; i++) {
							var extcontent = localStorage.getItem(lib.configprefix + 'extension_' + lib.config.extensions[i]);
							if (extcontent) {
								_status.evaluatingExtension = true;
								try {
									eval(extcontent);
								}
								catch (e) {
									console.log(e);
								}
								_status.evaluatingExtension = false;
							}
							else if (lib.config.mode != 'connect' || show_splash) {
								extensionlist.push(lib.config.extensions[i]);
							}
						}
					}
					else {
						if (lib.config.mode != 'connect' || show_splash) {
							for (var i = 0; i < lib.config.extensions.length; i++) {
								game.import('extension', { name: lib.config.extensions[i] });
							}
						}
					}
					var loadPack = function () {
						var toLoad = lib.config.all.cards.length + lib.config.all.characters.length + 1;
						var packLoaded = function () {
							toLoad--;
							if (toLoad == 0) {
								if (_status.windowLoaded) {
									delete _status.windowLoaded;
									lib.init.onload();
								}
								else {
									_status.packLoaded = true;
								}
							}
						};
						if (localStorage.getItem(lib.configprefix + 'playback')) {
							toLoad++;
							lib.init.js(lib.assetURL + 'mode', lib.config.mode, packLoaded, packLoaded);
						}
						else if ((localStorage.getItem(lib.configprefix + 'directstart') || !show_splash) &&
							lib.config.all.mode.indexOf(lib.config.mode) != -1) {
							toLoad++;
							lib.init.js(lib.assetURL + 'mode', lib.config.mode, packLoaded, packLoaded);
						}
						lib.init.js(lib.assetURL + 'card', lib.config.all.cards, packLoaded, packLoaded);
						lib.init.js(lib.assetURL + 'character', lib.config.all.characters, packLoaded, packLoaded);
						lib.init.js(lib.assetURL + 'character', 'rank', packLoaded, packLoaded);
						// if(lib.device!='ios'&&lib.config.enable_pressure) lib.init.js(lib.assetURL+'game','pressure');
					};

					var layout = lib.config.layout;
					if (lib.layoutfixed.indexOf(lib.config.mode) !== -1) {
						layout = 'mobile';
					}
					if (layout == 'phone') {
						layout = 'mobile';
						game.saveConfig('layout', 'mobile');
						game.saveConfig('phonelayout', true);
					}
					game.layout = layout;
					if (lib.config.image_background_random) {
						if (_status.htmlbg) {
							game.saveConfig('image_background', _status.htmlbg);
						}
						else {
							var list = [];
							for (var i in lib.configMenu.appearence.config.image_background.item) {
								if (i == 'default') continue;
								list.push(i);
							}
							game.saveConfig('image_background', list.randomGet(lib.config.image_background));
						}
						lib.init.background();
					}
					delete _status.htmlbg;

					window.game = game;
					var styleToLoad = 6;
					var styleLoaded = function () {
						styleToLoad--;
						if (styleToLoad == 0) {
							if (extensionlist.length && (lib.config.mode != 'connect' || show_splash)) {
								var extToLoad = extensionlist.length;
								var extLoaded = function () {
									extToLoad--;
									if (extToLoad == 0) {
										loadPack();
									}
								}
								for (var i = 0; i < extensionlist.length; i++) {
									lib.init.js(lib.assetURL + 'extension/' + extensionlist[i], 'extension', extLoaded, (function (i) {
										return function () {
											game.removeExtension(i);
											extToLoad--;
											if (extToLoad == 0) {
												loadPack();
											}
										}
									}(extensionlist[i])));
								}
							}
							else {
								loadPack();
							}
						}
					};
					if (lib.config.layout != 'default') {
						ui.css.layout = lib.init.css(lib.assetURL + 'layout/' + layout, 'layout', styleLoaded);
					}
					else {
						ui.css.layout = lib.init.css();
						styleToLoad--;
					}
					if (get.is.phoneLayout()) {
						ui.css.phone = lib.init.css(lib.assetURL + 'layout/default', 'phone', styleLoaded);
					}
					else {
						ui.css.phone = lib.init.css();
						styleToLoad--;
					}
					ui.css.theme = lib.init.css(lib.assetURL + 'theme/' + lib.config.theme, 'style', styleLoaded);
					ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', lib.config.card_style, styleLoaded);
					ui.css.cardback_style = lib.init.css(lib.assetURL + 'theme/style/cardback', lib.config.cardback_style, styleLoaded);
					ui.css.hp_style = lib.init.css(lib.assetURL + 'theme/style/hp', lib.config.hp_style, styleLoaded);

					if (lib.config.player_style && lib.config.player_style != 'default' && lib.config.player_style != 'custom') {
						var str = '';
						switch (lib.config.player_style) {
							case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
							case 'music': str = 'linear-gradient(#4b4b4b, #464646)'; break;
							case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4))'; break;
						}
						ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:' + str + '}');
					}
					if (lib.config.border_style && lib.config.border_style != 'default' && lib.config.border_style != 'custom' && lib.config.border_style != 'auto') {
						ui.css.border_stylesheet = lib.init.sheet();
						var bstyle = lib.config.border_style;
						if (bstyle.indexOf('dragon_') == 0) {
							bstyle = bstyle.slice(7);
						}
						ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg,#window #arena.long.mobile:not(.fewplayer) .player[data-position="0"]>.framebg{display:block;background-image:url("' + lib.assetURL + 'theme/style/player/' + bstyle + '1.png")}', 0);
						ui.css.border_stylesheet.sheet.insertRule('#window #arena.long:not(.fewplayer) .player>.framebg, #arena.oldlayout .player>.framebg{background-image:url("' + lib.assetURL + 'theme/style/player/' + bstyle + '3.png")}', 0);
						ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
					}
					if (lib.config.control_style && lib.config.control_style != 'default' && lib.config.control_style != 'custom') {
						var str = '';
						switch (lib.config.control_style) {
							case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood.jpg")'; break;
							case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
							case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
						}
						if (lib.config.control_style == 'wood') {
							ui.css.control_stylesheet = lib.init.sheet('#window .control,#window .menubutton,#window #system>div>div,#window #system>div>.pressdown2{background-image:' + str + '}');
						}
						else {
							ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:' + str + '}');
						}
					}
					if (lib.config.menu_style && lib.config.menu_style != 'default' && lib.config.menu_style != 'custom') {
						var str = '';
						switch (lib.config.menu_style) {
							case 'wood': str = 'url("' + lib.assetURL + 'theme/woodden/wood2.png")'; break;
							case 'music': str = 'linear-gradient(#4b4b4b, #464646);color:white;text-shadow:black 0 0 2px'; break;
							case 'simple': str = 'linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4));color:white;text-shadow:black 0 0 2px'; break;
						}
						ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:' + str + '}');
					}

					lib.config.duration = 500;

					if (!lib.config.touchscreen) {
						document.addEventListener('mousewheel', ui.click.windowmousewheel, { passive: true });
						document.addEventListener('mousemove', ui.click.windowmousemove);
						document.addEventListener('mousedown', ui.click.windowmousedown);
						document.addEventListener('mouseup', ui.click.windowmouseup);
						document.addEventListener('contextmenu', ui.click.right);
					}
					else {
						document.addEventListener('touchstart', ui.click.touchconfirm);
						document.addEventListener('touchstart', ui.click.windowtouchstart);
						document.addEventListener('touchend', ui.click.windowtouchend);
						document.addEventListener('touchmove', ui.click.windowtouchmove);
					}
				};
				var proceed2 = function () {
					if (config3) {
						proceed(config3);
					}
					else {
						config3 = true;
					}
				};

				ui.css = {
					menu: lib.init.css(lib.assetURL + 'layout/default', 'menu', function () {
						ui.css.default = lib.init.css(lib.assetURL + 'layout/default', 'layout');
						proceed2();
					})
				};

				if (lib.device) {
					lib.init.cordovaReady = function () {
						if (lib.device == 'android') {
							document.addEventListener("pause", function () {
								if (!_status.paused2 && !_status.event.isMine()) {
									ui.click.pause();
								}
								if (ui.backgroundMusic) {
									ui.backgroundMusic.pause();
								}
							});
							document.addEventListener("resume", function () {
								if (ui.backgroundMusic) {
									ui.backgroundMusic.play();
								}
							});
							document.addEventListener("backbutton", function () {
								if (ui.arena && ui.arena.classList.contains('menupaused')) {
									if (window.saveNonameInput) {
										window.saveNonameInput();
									}
									else {
										ui.click.configMenu();
									}
								}
								else if (lib.config.confirm_exit) {
									navigator.notification.confirm(
										'是否退出游戏？',
										function (index) {
											switch (index) {
												case 2: game.saveConfig('null'); game.reload(); break;
												case 3: navigator.app.exitApp(); break;
											}
										},
										'确认退出',
										['取消', '重新开始', '退出']
									);
								}
								else {
									navigator.app.exitApp();
								}
							});
						}
						game.download = function (url, folder, onsuccess, onerror, dev, onprogress) {
							if (url.indexOf('http') != 0) {
								url = get.url(dev) + url;
							}
							var fileTransfer = new FileTransfer();
							folder = lib.assetURL + folder;
							if (onprogress) {
								fileTransfer.onprogress = function (progressEvent) {
									onprogress(progressEvent.loaded, progressEvent.total);
								};
							}
							lib.config.brokenFile.add(folder);
							game.saveConfigValue('brokenFile');
							fileTransfer.download(encodeURI(url), encodeURI(folder), function () {
								lib.config.brokenFile.remove(folder);
								game.saveConfigValue('brokenFile');
								if (onsuccess) {
									onsuccess();
								}
							}, onerror);
						};
						game.readFile = function (filename, callback, onerror) {
							window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
								entry.getFile(filename, {}, function (fileEntry) {
									fileEntry.file(function (fileToLoad) {
										var fileReader = new FileReader();
										fileReader.onload = function (e) {
											callback(e.target.result);
										};
										fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
									}, onerror);
								}, onerror);
							}, onerror);
						};
						game.writeFile = function (data, path, name, callback) {
							game.ensureDirectory(path, function () { });
							if (Object.prototype.toString.call(data) == '[object File]') {
								var fileReader = new FileReader();
								fileReader.onload = function (e) {
									game.writeFile(e.target.result, path, name, callback);
								};
								fileReader.readAsArrayBuffer(data, "UTF-8");
							}
							else {
								window.resolveLocalFileSystemURL(lib.assetURL + path, function (entry) {
									entry.getFile(name, { create: true }, function (fileEntry) {
										fileEntry.createWriter(function (fileWriter) {
											fileWriter.onwriteend = callback;
											fileWriter.write(data);
										});
									});
								});
							}
						};
						game.removeFile = function (dir, callback) {
							window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
								entry.getFile(dir, {}, function (fileEntry) {
									fileEntry.remove();
									if (callback) {
										callback();
									}
								});
							});
						};
						game.getFileList = function (dir, callback) {
							var files = [], folders = [];
							window.resolveLocalFileSystemURL(lib.assetURL + dir, function (entry) {
								var dirReader = entry.createReader();
								var entries = [];
								var readEntries = function () {
									dirReader.readEntries(function (results) {
										if (!results.length) {
											entries.sort();
											for (var i = 0; i < entries.length; i++) {
												if (entries[i].isDirectory) {
													folders.push(entries[i].name);
												}
												else {
													files.push(entries[i].name);
												}
											}
											callback(folders, files);
										}
										else {
											entries = entries.concat(Array.from(results));
											readEntries();
										}
									});
								};
								readEntries();
							});
						};
						game.ensureDirectory = function (list, callback, file) {
							var directorylist;
							var num = 0;
							if (file) {
								num = 1;
							}
							if (typeof list == 'string') {
								directorylist = [list];
							}
							else {
								var directorylist = list.slice(0);
							}
							window.resolveLocalFileSystemURL(lib.assetURL, function (rootEntry) {
								var access = function (entry, dir, callback) {
									if (dir.length <= num) {
										callback();
									}
									else {
										var str = dir.shift();
										entry.getDirectory(str, { create: false }, function (entry) {
											access(entry, dir, callback);
										}, function () {
											entry.getDirectory(str, { create: true }, function (entry) {
												access(entry, dir, callback);
											});
										});
									}
								}
								var createDirectory = function () {
									if (directorylist.length) {
										access(rootEntry, directorylist.shift().split('/'), createDirectory);
									}
									else {
										callback();
									}
								};
								createDirectory();
							});
						}
						if (ui.updateUpdate) {
							ui.updateUpdate();
						}
						var showbar = function () {
							if (window.StatusBar) {
								if (lib.device == 'android') {
									if (lib.config.show_statusbar_android) {
										window.StatusBar.overlaysWebView(false);
										window.StatusBar.backgroundColorByName('black');
										window.StatusBar.show();
									}
								}
								else if (lib.device == 'ios') {
									if (lib.config.show_statusbar_ios != 'off' && lib.config.show_statusbar_ios != 'auto') {
										if (lib.config.show_statusbar_ios == 'default') {
											window.StatusBar.overlaysWebView(false);
										}
										else {
											window.StatusBar.overlaysWebView(true);
										}
										window.StatusBar.backgroundColorByName('black');
										window.StatusBar.show();
									}
								}
							}
						}
						if (lib.arenaReady) {
							lib.arenaReady.push(showbar);
						}
						else {
							showbar();
						}
					}
				}
				else if (typeof window.require == 'function') {
					lib.node = {
						fs: require('fs'),
						debug: function () {
							require('electron').remote.getCurrentWindow().toggleDevTools();
						}
					};
					game.download = function (url, folder, onsuccess, onerror, dev, onprogress) {
						if (url.indexOf('http') != 0) {
							url = get.url(dev) + url;
						}
						game.ensureDirectory(folder, function () {
							try {
								var file = lib.node.fs.createWriteStream(__dirname + '/' + folder);
							}
							catch (e) {
								onerror();
							}
							lib.config.brokenFile.add(folder);
							game.saveConfigValue('brokenFile');
							if (!lib.node.http) lib.node.http = require('http');
							if (!lib.node.https) lib.node.https = require('https');
							var opts = require('url').parse(encodeURI(url));
							opts.headers = { 'User-Agent': 'AppleWebkit' };
							var request = (url.indexOf('https') == 0 ? lib.node.https : lib.node.http).get(opts, function (response) {
								var stream = response.pipe(file);
								stream.on('finish', function () {
									lib.config.brokenFile.remove(folder);
									game.saveConfigValue('brokenFile');
									if (onsuccess) {
										onsuccess();
									}
								});
								stream.on('error', onerror);
								if (onprogress) {
									var streamInterval = setInterval(function () {
										if (stream.closed) {
											clearInterval(streamInterval);
										}
										else {
											onprogress(stream.bytesWritten);
										}
									}, 200);
								}
							});
						}, true);
					};
					game.readFile = function (filename, callback, onerror) {
						lib.node.fs.readFile(__dirname + '/' + filename, function (err, data) {
							if (err) {
								onerror(err);
							}
							else {
								callback(data);
							}
						});
					};
					game.writeFile = function (data, path, name, callback) {
						game.ensureDirectory(path, function () { });
						if (Object.prototype.toString.call(data) == '[object File]') {
							var fileReader = new FileReader();
							fileReader.onload = function (e) {
								game.writeFile(e.target.result, path, name, callback);
							};
							fileReader.readAsArrayBuffer(data, "UTF-8");
						}
						else {
							get.zip(function (zip) {
								zip.file('i', data);
								lib.node.fs.writeFile(__dirname + '/' + path + '/' + name, zip.files.i.asNodeBuffer(), null, callback);
							});
						}
					};
					game.removeFile = function (filename, callback) {
						lib.node.fs.unlink(__dirname + '/' + filename, callback || function () { });
					};
					game.getFileList = function (dir, callback) {
						var files = [], folders = [];
						dir = __dirname + '/' + dir;
						lib.node.fs.readdir(dir, function (err, filelist) {
							for (var i = 0; i < filelist.length; i++) {
								if (filelist[i][0] != '.' && filelist[i][0] != '_') {
									if (lib.node.fs.statSync(dir + '/' + filelist[i]).isDirectory()) {
										folders.push(filelist[i]);
									}
									else {
										files.push(filelist[i]);
									}
								}
							}
							callback(folders, files);
						});
					};
					game.ensureDirectory = function (list, callback, file) {
						var directorylist;
						var num = 0;
						if (file) {
							num = 1;
						}
						if (typeof list == 'string') {
							directorylist = [list];
						}
						else {
							var directorylist = list.slice(0);
						}
						var access = function (str, dir, callback) {
							if (dir.length <= num) {
								callback();
							}
							else {
								str += '/' + dir.shift();
								lib.node.fs.access(__dirname + str, function (e) {
									if (e) {
										try {
											lib.node.fs.mkdir(__dirname + str, function () {
												access(str, dir, callback);
											});
										}
										catch (e) {
											console.log(e);
										}
									}
									else {
										access(str, dir, callback);
									}
								});
							}
						}
						var createDirectory = function () {
							if (directorylist.length) {
								access('', directorylist.shift().split('/'), createDirectory);
							}
							else {
								callback();
							}
						};
						createDirectory();
					};
					if (ui.updateUpdate) {
						ui.updateUpdate();
					}
				}
				else {
					window.onbeforeunload = function () {
						if (lib.config.confirm_exit && !_status.reloading) {
							return '是否离开游戏？'
						}
						else {
							return null;
						}
					}
				}

				lib.config = window.config;
				lib.configOL = {};
				delete window.config;
				var config2;
				if (localStorage.getItem(lib.configprefix + 'nodb')) {
					window.nodb = true;
				}
				if (window.indexedDB && !window.nodb) {
					var request = window.indexedDB.open(lib.configprefix + 'data', 4);
					request.onupgradeneeded = function (e) {
						var db = e.target.result;
						if (!db.objectStoreNames.contains('video')) {
							db.createObjectStore('video', { keyPath: 'time' });
						}
						if (!db.objectStoreNames.contains('image')) {
							db.createObjectStore('image');
						}
						if (!db.objectStoreNames.contains('audio')) {
							db.createObjectStore('audio');
						}
						if (!db.objectStoreNames.contains('config')) {
							db.createObjectStore('config');
						}
						if (!db.objectStoreNames.contains('data')) {
							db.createObjectStore('data');
						}
					};
					request.onsuccess = function (e) {
						lib.db = e.target.result;
						game.getDB('config', null, function (obj) {
							if (!obj.storageImported) {
								try {
									config2 = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
									if (!config2 || typeof config2 != 'object') throw 'err'
								}
								catch (err) {
									config2 = {};
								}
								for (var i in config2) {
									game.saveConfig(i, config2[i]);
								}
								for (var i in lib.mode) {
									try {
										config2 = JSON.parse(localStorage.getItem(lib.configprefix + i));
										if (!config2 || typeof config2 != 'object' || get.is.empty(config2)) throw 'err'
									}
									catch (err) {
										config2 = false;
									}
									localStorage.removeItem(lib.configprefix + i);
									if (config2) {
										game.putDB('data', i, config2);
									}
								}
								game.saveConfig('storageImported', true);
								lib.init.background();
								localStorage.removeItem(lib.configprefix + 'config');
							}
							else {
								config2 = obj;
							}
							proceed(config2);
						});
					}
				}
				else {
					try {
						config2 = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
						if (!config2 || typeof config2 != 'object') throw 'err'
					}
					catch (err) {
						config2 = {};
						localStorage.setItem(lib.configprefix + 'config', JSON.stringify({}));
					}
					proceed(config2);
				}
			},
			reset: function () {
				if (window.inSplash) return;
				if (window.resetExtension) {
					if (confirm('游戏似乎未正常载入，是否禁用扩展并重新打开？')) {
						window.resetExtension();
						window.location.reload();
					}
				}
				else {
					if (lib.device) {
						if (navigator.notification) {
							navigator.notification.confirm(
								'游戏似乎未正常载入，是否重置游戏？',
								function (index) {
									if (index == 2) {
										localStorage.removeItem('noname_inited');
										window.location.reload();
									}
									else if (index == 3) {
										var noname_inited = localStorage.getItem('noname_inited');
										var onlineKey = localStorage.getItem(lib.configprefix + 'key');
										localStorage.clear();
										if (noname_inited) {
											localStorage.setItem('noname_inited', noname_inited);
										}
										if (onlineKey) {
											localStorage.setItem(lib.configprefix + 'key', onlineKey);
										}
										if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
										setTimeout(function () {
											window.location.reload();
										}, 200);
									}
								},
								'确认退出',
								['取消', '重新下载', '重置设置']
							);
						}
						else {
							if (confirm('游戏似乎未正常载入，是否重置游戏？')) {
								localStorage.removeItem('noname_inited');
								window.location.reload();
							}
						}
					}
					else {
						if (confirm('游戏似乎未正常载入，是否重置游戏？')) {
							var onlineKey = localStorage.getItem(lib.configprefix + 'key');
							localStorage.clear();
							if (onlineKey) {
								localStorage.setItem(lib.configprefix + 'key', onlineKey);
							}
							if (indexedDB) indexedDB.deleteDatabase(lib.configprefix + 'data');
							setTimeout(function () {
								window.location.reload();
							}, 200);
						}
					}
				}
			},
			onload: function () {
				ui.updated();
				game.documentZoom = game.deviceZoom;
				if (game.documentZoom != 1) {
					ui.updatez();
				}
				ui.background = ui.create.div('.background');
				ui.background.style.backgroundSize = "cover";
				ui.background.style.backgroundPosition = '50% 50%';
				if (lib.config.image_background && lib.config.image_background != 'default' && lib.config.image_background.indexOf('custom_') != 0) {
					ui.background.setBackgroundImage('image/background/' + lib.config.image_background + '.jpg');
					if (lib.config.image_background_blur) {
						ui.background.style.filter = 'blur(8px)';
						ui.background.style.webkitFilter = 'blur(8px)';
						ui.background.style.transform = 'scale(1.05)';
					}
				}
				document.documentElement.style.backgroundImage = '';
				document.documentElement.style.backgroundSize = '';
				document.documentElement.style.backgroundPosition = '';
				document.body.insertBefore(ui.background, document.body.firstChild);
				document.body.onresize = ui.updatexr;
				if (lib.config.touchscreen) {
					document.body.addEventListener('touchstart', function (e) {
						this.startX = e.touches[0].clientX / game.documentZoom;
						this.startY = e.touches[0].clientY / game.documentZoom;
						_status.dragged = false;
					});
					document.body.addEventListener('touchmove', function (e) {
						if (_status.dragged) return;
						if (Math.abs(e.touches[0].clientX / game.documentZoom - this.startX) > 10 ||
							Math.abs(e.touches[0].clientY / game.documentZoom - this.startY) > 10) {
							_status.dragged = true;
						}
					});
				}

				if (lib.config.image_background.indexOf('custom_') == 0) {
					ui.background.style.backgroundImage = "none";
					game.getDB('image', lib.config.image_background, function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							var data = fileLoadedEvent.target.result;
							ui.background.style.backgroundImage = 'url(' + data + ')';
							if (lib.config.image_background_blur) {
								ui.background.style.filter = 'blur(8px)';
								ui.background.style.webkitFilter = 'blur(8px)';
								ui.background.style.transform = 'scale(1.05)';
							}
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}
				if (lib.config.card_style == 'custom') {
					game.getDB('image', 'card_style', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.card_stylesheet) {
								ui.css.card_stylesheet.remove();
							}
							ui.css.card_stylesheet = lib.init.sheet('.card:not(*:empty){background-image:url(' + fileLoadedEvent.target.result + ')}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}
				if (lib.config.cardback_style == 'custom') {
					game.getDB('image', 'cardback_style', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.cardback_stylesheet) {
								ui.css.cardback_stylesheet.remove();
							}
							ui.css.cardback_stylesheet = lib.init.sheet('.card:empty,.card.infohidden{background-image:url(' + fileLoadedEvent.target.result + ')}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
					game.getDB('image', 'cardback_style2', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.cardback_stylesheet2) {
								ui.css.cardback_stylesheet2.remove();
							}
							ui.css.cardback_stylesheet2 = lib.init.sheet('.card.infohidden:not(.infoflip){background-image:url(' + fileLoadedEvent.target.result + ')}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}
				if (lib.config.hp_style == 'custom') {
					game.getDB('image', 'hp_style1', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.hp_stylesheet1) {
								ui.css.hp_stylesheet1.remove();
							}
							ui.css.hp_stylesheet1 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="high"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
					game.getDB('image', 'hp_style2', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.hp_stylesheet2) {
								ui.css.hp_stylesheet2.remove();
							}
							ui.css.hp_stylesheet2 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="mid"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
					game.getDB('image', 'hp_style3', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.hp_stylesheet3) {
								ui.css.hp_stylesheet3.remove();
							}
							ui.css.hp_stylesheet3 = lib.init.sheet('.hp:not(.text):not(.actcount)[data-condition="low"]>div:not(.lost){background-image:url(' + fileLoadedEvent.target.result + ')}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
					game.getDB('image', 'hp_style4', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.hp_stylesheet4) {
								ui.css.hp_stylesheet4.remove();
							}
							ui.css.hp_stylesheet4 = lib.init.sheet('.hp:not(.text):not(.actcount)>.lost{background-image:url(' + fileLoadedEvent.target.result + ')}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}
				if (lib.config.player_style == 'custom') {
					ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:none;background-size:100% 100%;}');
					game.getDB('image', 'player_style', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.player_stylesheet) {
								ui.css.player_stylesheet.remove();
							}
							ui.css.player_stylesheet = lib.init.sheet('#window .player{background-image:url("' + fileLoadedEvent.target.result + '");background-size:100% 100%;}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}
				if (lib.config.border_style == 'custom') {
					game.getDB('image', 'border_style', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.border_stylesheet) {
								ui.css.border_stylesheet.remove();
							}
							ui.css.border_stylesheet = lib.init.sheet();
							ui.css.border_stylesheet.sheet.insertRule('#window .player>.framebg{display:block;background-image:url("' + fileLoadedEvent.target.result + '")}', 0);
							ui.css.border_stylesheet.sheet.insertRule('.player>.count{z-index: 3 !important;border-radius: 2px !important;text-align: center !important;}', 0);
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}
				if (lib.config.control_style == 'custom') {
					game.getDB('image', 'control_style', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.control_stylesheet) {
								ui.css.control_stylesheet.remove();
							}
							ui.css.control_stylesheet = lib.init.sheet('#window .control,.menubutton:not(.active):not(.highlight):not(.red):not(.blue),#window #system>div>div{background-image:url("' + fileLoadedEvent.target.result + '")}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}
				if (lib.config.menu_style == 'custom') {
					game.getDB('image', 'menu_style', function (fileToLoad) {
						if (!fileToLoad) return;
						var fileReader = new FileReader();
						fileReader.onload = function (fileLoadedEvent) {
							if (ui.css.menu_stylesheet) {
								ui.css.menu_stylesheet.remove();
							}
							ui.css.menu_stylesheet = lib.init.sheet('html #window>.dialog.popped,html .menu,html .menubg{background-image:url("' + fileLoadedEvent.target.result + '");background-size:cover}');
						};
						fileReader.readAsDataURL(fileToLoad, "UTF-8");
					});
				}

				var proceed2 = function () {
					var mode = lib.imported.mode;
					var card = lib.imported.card;
					var character = lib.imported.character;
					var play = lib.imported.play;
					delete window.game;
					var i, j, k;
					for (i in mode[lib.config.mode].element) {
						if (!lib.element[i]) lib.element[i] = [];
						for (j in mode[lib.config.mode].element[i]) {
							if (j == 'init') {
								if (!lib.element[i].inits) lib.element[i].inits = [];
								lib.element[i].inits.push(mode[lib.config.mode].element[i][j]);
							}
							else {
								lib.element[i][j] = mode[lib.config.mode].element[i][j];
							}
						}
					}
					for (i in mode[lib.config.mode].ai) {
						if (typeof mode[lib.config.mode].ai[i] == 'object') {
							if (ai[i] == undefined) ai[i] = {};
							for (j in mode[lib.config.mode].ai[i]) {
								ai[i][j] = mode[lib.config.mode].ai[i][j];
							}
						}
						else {
							ai[i] = mode[lib.config.mode].ai[i];
						}
					}
					for (i in mode[lib.config.mode].ui) {
						if (typeof mode[lib.config.mode].ui[i] == 'object') {
							if (ui[i] == undefined) ui[i] = {};
							for (j in mode[lib.config.mode].ui[i]) {
								ui[i][j] = mode[lib.config.mode].ui[i][j];
							}
						}
						else {
							ui[i] = mode[lib.config.mode].ui[i];
						}
					}
					for (i in mode[lib.config.mode].game) {
						game[i] = mode[lib.config.mode].game[i];
					}
					for (i in mode[lib.config.mode].get) {
						get[i] = mode[lib.config.mode].get[i];
					}
					lib.init.start = mode[lib.config.mode].start;
					lib.init.startBefore = mode[lib.config.mode].startBefore;
					if (game.onwash) {
						lib.onwash.push(game.onwash);
						delete game.onwash;
					}
					if (game.onover) {
						lib.onover.push(game.onover);
						delete game.onover;
					}
					lib.config.banned = lib.config[lib.config.mode + '_banned'] || [];
					lib.config.bannedcards = lib.config[lib.config.mode + '_bannedcards'] || [];

					lib.rank = window.noname_character_rank;
					delete window.noname_character_rank;
					for (i in mode[lib.config.mode]) {
						if (i == 'element') continue;
						if (i == 'game') continue;
						if (i == 'ai') continue;
						if (i == 'ui') continue;
						if (i == 'get') continue;
						if (i == 'config') continue;
						if (i == 'onreinit') continue;
						if (i == 'start') continue;
						if (i == 'startBefore') continue;
						if (lib[i] == undefined) lib[i] = (Array.isArray(mode[lib.config.mode][i])) ? [] : {};
						for (j in mode[lib.config.mode][i]) {
							lib[i][j] = mode[lib.config.mode][i][j];
						}
					}
					if (typeof mode[lib.config.mode].init == 'function') {
						mode[lib.config.mode].init();
					}

					var connectCharacterPack = [];
					var connectCardPack = [];
					for (i in character) {
						if (character[i].character) {
							lib.characterPack[i] = character[i].character
						}
						for (j in character[i]) {
							if (j == 'mode' || j == 'forbid') continue;
							if (j == 'connect') {
								connectCharacterPack.push(i);
								continue;
							}
							if (j == 'character' && !lib.config.characters.contains(i) && lib.config.mode != 'connect') {
								if (lib.config.mode == 'chess' && get.config('chess_mode') == 'leader') {
									for (k in character[i][j]) {
										lib.hiddenCharacters.push(k);
									}
								}
								else if (lib.config.mode != 'boss' || i != 'boss') {
									continue;
								}
							}
							if (Array.isArray(lib[j]) && Array.isArray(character[i][j])) {
								lib[j].addArray(character[i][j]);
								continue;
							}
							for (k in character[i][j]) {
								if (j == 'character') {
									if (!character[i][j][k][4]) {
										character[i][j][k][4] = [];
									}
									if (character[i][j][k][4].contains('boss') ||
										character[i][j][k][4].contains('hiddenboss')) {
										lib.config.forbidai.add(k);
									}
									if (lib.config.forbidai_user && lib.config.forbidai_user.contains(k)) {
										lib.config.forbidai.add(k);
									}
									for (var l = 0; l < character[i][j][k][3].length; l++) {
										lib.skilllist.add(character[i][j][k][3][l]);
									}
								}
								if (j == 'skill' && k[0] == '_' && (!lib.config.characters.contains(i) || (lib.config.mode == 'connect' && !character[i].connect))) {
									continue;
								}
								if (j == 'translate' && k == i) {
									lib[j][k + '_character_config'] = character[i][j][k];
								}
								else {
									if (lib[j][k] == undefined) {
										if (j == 'skill' && lib.config.mode == 'connect' && !character[i].connect) {
											lib[j][k] = {
												nopop: character[i][j][k].nopop,
												derivation: character[i][j][k].derivation
											};
										}
										else {
											lib[j][k] = character[i][j][k];
										}
										if (j == 'card' && lib[j][k].derivation) {
											if (!lib.cardPack.mode_derivation) {
												lib.cardPack.mode_derivation = [k];
											}
											else {
												lib.cardPack.mode_derivation.push(k);
											}
										}
									}
									else if (Array.isArray(lib[j][k]) && Array.isArray(character[i][j][k])) {
										lib[j][k].addArray(character[i][j][k]);
									}
									else {
										console.log('dublicate ' + j + ' in character ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + character[i][j][k]);
									}
								}
							}
						}
					}
					var connect_avatar_list = [];
					for (var i in lib.character) {
						connect_avatar_list.push(i);
					}
					connect_avatar_list.sort(lib.sort.capt);
					for (var i = 0; i < connect_avatar_list.length; i++) {
						var ia = connect_avatar_list[i];
						lib.mode.connect.config.connect_avatar.item[ia] = lib.translate[ia];
					}
					if (lib.config.mode != 'connect') {
						var pilecfg = lib.config.customcardpile[get.config('cardpilename') || '当前牌堆'];
						if (pilecfg) {
							lib.config.bannedpile = get.copy(pilecfg[0] || {});
							lib.config.addedpile = get.copy(pilecfg[1] || {});
						}
						else {
							lib.config.bannedpile = {};
							lib.config.addedpile = {};
						}
					}
					else {
						lib.cardPackList = {};
					}
					for (i in card) {
						lib.cardPack[i] = [];
						if (card[i].card) {
							for (var j in card[i].card) {
								if (!card[i].card[j].hidden && card[i].translate[j + '_info']) {
									lib.cardPack[i].push(j);
								}
							}
						}
						for (j in card[i]) {
							if (j == 'mode' || j == 'forbid') continue;
							if (j == 'connect') {
								connectCardPack.push(i);
								continue;
							}
							if (j == 'list') {
								if (lib.config.mode == 'connect') {
									lib.cardPackList[i] = card[i][j];
								}
								else {
									if (lib.config.cards.contains(i)) {
										var pile;
										if (typeof card[i][j] == 'function') {
											pile = card[i][j]();
										}
										else {
											pile = card[i][j];
										}
										lib.cardPile[i] = pile.slice(0);
										if (lib.config.bannedpile[i]) {
											for (var k = 0; k < lib.config.bannedpile[i].length; k++) {
												pile[lib.config.bannedpile[i][k]] = null;
											}
										}
										for (var k = 0; k < pile.length; k++) {
											if (!pile[k]) {
												pile.splice(k--, 1);
											}
										}
										if (lib.config.addedpile[i]) {
											for (var k = 0; k < lib.config.addedpile[i].length; k++) {
												pile.push(lib.config.addedpile[i][k]);
											}
										}
										lib.card.list = lib.card.list.concat(pile);
									}
								}
							}
							else {
								for (k in card[i][j]) {
									if (j == 'skill' && k[0] == '_' && (!lib.config.cards.contains(i) || (lib.config.mode == 'connect' && !card[i].connect))) {
										continue;
									}
									if (j == 'translate' && k == i) {
										lib[j][k + '_card_config'] = card[i][j][k];
									}
									else {
										if (lib[j][k] == undefined) {
											if (j == 'skill' && lib.config.mode == 'connect' && !card[i].connect) {
												lib[j][k] = {
													nopop: card[i][j][k].nopop,
													derivation: card[i][j][k].derivation
												};
											}
											else {
												lib[j][k] = card[i][j][k];
											}
										}
										else console.log('dublicate ' + j + ' in card ' + i + ':\n' + k + '\n' + lib[j][k] + '\n' + card[i][j][k]);
										if (j == 'card' && lib[j][k].derivation) {
											if (!lib.cardPack.mode_derivation) {
												lib.cardPack.mode_derivation = [k];
											}
											else {
												lib.cardPack.mode_derivation.push(k);
											}
										}
									}
								}
							}
						}
					}
					if (lib.cardPack.mode_derivation) {
						for (var i = 0; i < lib.cardPack.mode_derivation.length; i++) {
							if (typeof lib.card[lib.cardPack.mode_derivation[i]].derivation == 'string' && !lib.character[lib.card[lib.cardPack.mode_derivation[i]].derivation]) {
								lib.cardPack.mode_derivation.splice(i--, 1);
							}
							else if (typeof lib.card[lib.cardPack.mode_derivation[i]].derivationpack == 'string' && !lib.config.cards.contains(lib.card[lib.cardPack.mode_derivation[i]].derivationpack)) {
								lib.cardPack.mode_derivation.splice(i--, 1);
							}
						}
						if (lib.cardPack.mode_derivation.length == 0) {
							delete lib.cardPack.mode_derivation;
						}
					}
					if (lib.config.mode != 'connect') {
						for (i in play) {
							if (lib.config.hiddenPlayPack.contains(i)) continue;
							if (play[i].forbid && play[i].forbid.contains(lib.config.mode)) continue;
							if (play[i].mode && play[i].mode.contains(lib.config.mode) == false) continue;
							for (j in play[i].element) {
								if (!lib.element[j]) lib.element[j] = [];
								for (k in play[i].element[j]) {
									if (k == 'init') {
										if (!lib.element[j].inits) lib.element[j].inits = [];
										lib.element[j].inits.push(play[i].element[j][k]);
									}
									else {
										lib.element[j][k] = play[i].element[j][k];
									}
								}
							}
							for (j in play[i].ui) {
								if (typeof play[i].ui[j] == 'object') {
									if (ui[j] == undefined) ui[j] = {};
									for (k in play[i].ui[j]) {
										ui[j][k] = play[i].ui[j][k];
									}
								}
								else {
									ui[j] = play[i].ui[j];
								}
							}
							for (j in play[i].game) {
								game[j] = play[i].game[j];
							}
							for (j in play[i].get) {
								get[j] = play[i].get[j];
							}
							for (j in play[i]) {
								if (j == 'mode' || j == 'forbid' || j == 'init' || j == 'element' ||
									j == 'game' || j == 'get' || j == 'ui' || j == 'arenaReady') continue;
								for (k in play[i][j]) {
									if (j == 'translate' && k == i) {
										// lib[j][k+'_play_config']=play[i][j][k];
									}
									else {
										if (lib[j][k] != undefined) {
											console.log('dublicate ' + j + ' in play ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + play[i][j][k]);
										}
										lib[j][k] = play[i][j][k];
									}
								}
							}
							if (typeof play[i].init == 'function') play[i].init();
							if (typeof play[i].arenaReady == 'function') lib.arenaReady.push(play[i].arenaReady);
						}
					}

					lib.connectCharacterPack = [];
					lib.connectCardPack = [];
					for (var i = 0; i < lib.config.all.characters.length; i++) {
						var packname = lib.config.all.characters[i];
						if (connectCharacterPack.contains(packname)) {
							lib.connectCharacterPack.push(packname)
						}
					}
					for (var i = 0; i < lib.config.all.cards.length; i++) {
						var packname = lib.config.all.cards[i];
						if (connectCardPack.contains(packname)) {
							lib.connectCardPack.push(packname)
						}
					}
					if (lib.config.mode != 'connect') {
						for (i = 0; i < lib.card.list.length; i++) {
							if (lib.card.list[i][2] == 'huosha') {
								lib.card.list[i] = lib.card.list[i].slice(0);
								lib.card.list[i][2] = 'sha';
								lib.card.list[i][3] = 'fire';
							}
							else if (lib.card.list[i][2] == 'leisha') {
								lib.card.list[i] = lib.card.list[i].slice(0);
								lib.card.list[i][2] = 'sha';
								lib.card.list[i][3] = 'thunder';
							}
							if (!lib.card[lib.card.list[i][2]]) {
								lib.card.list.splice(i, 1); i--;
							}
							else if (lib.card[lib.card.list[i][2]].mode &&
								lib.card[lib.card.list[i][2]].mode.contains(lib.config.mode) == false) {
								lib.card.list.splice(i, 1); i--;
							}
						}
					}

					if (lib.config.mode == 'connect') {
						_status.connectMode = true;
					}
					if (window.isNonameServer) {
						lib.cheat.i();
					}
					else if (lib.config.dev && (!_status.connectMode || lib.config.debug)) {
						lib.cheat.i();
					}
					lib.config.sort_card = get.sortCard(lib.config.sort);
					delete lib.imported.character;
					delete lib.imported.card;
					delete lib.imported.mode;
					delete lib.imported.play;
					for (var i in lib.init) {
						if (i.indexOf('setMode_') == 0) {
							delete lib.init[i];
						}
					}
					if (!_status.connectMode) {
						for (var i = 0; i < lib.extensions.length; i++) {
							try {
								_status.extension = lib.extensions[i][0];
								_status.evaluatingExtension = lib.extensions[i][3];
								lib.extensions[i][1](lib.extensions[i][2], lib.extensions[i][4]);
								if (lib.extensions[i][4]) {
									if (lib.extensions[i][4].character) {
										for (var j in lib.extensions[i][4].character.character) {
											game.addCharacterPack(get.copy(lib.extensions[i][4].character));
											break;
										}
									}
									if (lib.extensions[i][4].card) {
										for (var j in lib.extensions[i][4].card.card) {
											game.addCardPack(get.copy(lib.extensions[i][4].card));
											break;
										}
									}
									if (lib.extensions[i][4].skill) {
										for (var j in lib.extensions[i][4].skill.skill) {
											game.addSkill(j, lib.extensions[i][4].skill.skill[j],
												lib.extensions[i][4].skill.translate[j], lib.extensions[i][4].skill.translate[j + '_info']);
										}
									}
								}
								delete _status.extension;
								delete _status.evaluatingExtension;
							}
							catch (e) {
								console.log(e);
							}
						}
					}
					delete lib.extensions;

					if (lib.init.startBefore) {
						lib.init.startBefore();
						delete lib.init.startBefore;
					}
					ui.create.arena();
					game.createEvent('game', false).setContent(lib.init.start);
					if (lib.mode[lib.config.mode] && lib.mode[lib.config.mode].fromextension) {
						var startstr = mode[lib.config.mode].start.toString();
						if (startstr.indexOf('onfree') == -1) {
							setTimeout(lib.init.onfree, 500);
						}
					}
					delete lib.init.start;
					game.loop();
				}
				var proceed = function () {
					if (!lib.db) {
						try {
							lib.storage = JSON.parse(localStorage.getItem(lib.configprefix + lib.config.mode));
							if (typeof lib.storage != 'object') throw ('err');
							if (lib.storage == null) throw ('err');
						}
						catch (err) {
							lib.storage = {};
							localStorage.setItem(lib.configprefix + lib.config.mode, "{}");
						}
						proceed2();
					}
					else {
						game.getDB('data', lib.config.mode, function (obj) {
							lib.storage = obj || {};
							proceed2();
						});
					}
				};
				if (!lib.imported.mode || !lib.imported.mode[lib.config.mode]) {
					window.inSplash = true;
					clearTimeout(window.resetGameTimeout);
					delete window.resetGameTimeout;
					var clickedNode = false;
					var clickNode = function () {
						if (clickedNode) return;
						this.classList.add('clicked');
						clickedNode = true;
						lib.config.mode = this.link;
						game.saveConfig('mode', this.link);
						if (this.link == 'connect') {
							localStorage.setItem(lib.configprefix + 'directstart', true);
							game.reload();
						}
						else {
							if (game.layout != 'mobile' && lib.layoutfixed.indexOf(lib.config.mode) !== -1) {
								game.layout = 'mobile';
								ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
							}
							else if (game.layout == 'mobile' && lib.config.layout != 'mobile' && lib.layoutfixed.indexOf(lib.config.mode) === -1) {
								game.layout = lib.config.layout;
								if (game.layout == 'default') {
									ui.css.layout.href = '';
								}
								else {
									ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
								}
							}
							splash.delete(1000);
							delete window.inSplash;
							window.resetGameTimeout = setTimeout(lib.init.reset, 5000);

							this.listenTransition(function () {
								lib.init.js(lib.assetURL + 'mode', lib.config.mode, proceed);
							}, 500);
						}
					}
					var downNode = function () {
						this.classList.add('glow');
					}
					var upNode = function () {
						this.classList.remove('glow');
					}
					var splash = ui.create.div('#splash', document.body);
					if (lib.config.touchscreen) {
						splash.classList.add('touch');
						lib.setScroll(splash);
					}
					if (lib.config.player_border != 'wide') {
						splash.classList.add('slim');
					}
					splash.dataset.radius_size = lib.config.radius_size;
					for (var i = 0; i < lib.config.all.mode.length; i++) {
						var node = ui.create.div('.hidden', splash, clickNode);
						node.link = lib.config.all.mode[i];
						ui.create.div(node, '.splashtext', get.verticalStr(get.translation(lib.config.all.mode[i])));
						if (lib.config.all.stockmode.indexOf(lib.config.all.mode[i]) != -1) {
							ui.create.div(node, '.avatar').setBackgroundImage('image/splash/' + lib.config.all.mode[i] + '.jpg');
						}
						else {
							var avatarnode = ui.create.div(node, '.avatar');
							var avatarbg = lib.mode[lib.config.all.mode[i]].splash;
							if (avatarbg.indexOf('ext:') == 0) {
								avatarnode.setBackgroundImage(avatarbg.replace(/ext:/, 'extension/'));
							}
							else {
								avatarnode.setBackgroundDB(avatarbg);
							}
						}
						if (!lib.config.touchscreen) {
							node.addEventListener('mousedown', downNode);
							node.addEventListener('mouseup', upNode);
							node.addEventListener('mouseleave', upNode);
						}
						setTimeout((function (node) {
							return function () {
								node.show();
							}
						}(node)), i * 100);
					}
					if (lib.config.mousewheel) {
						splash.onmousewheel = ui.click.mousewheel;
					}
				}
				else {
					proceed();
				}
				localStorage.removeItem(lib.configprefix + 'directstart');
				delete lib.init.init;
			},
			startOnline: function () {
				'step 0'
				event._resultid = null;
				event._result = null;
				game.pause();
				'step 1'
				if (result) {
					if (event._resultid) {
						result.id = event._resultid;
					}
					game.send('result', result);
				}
				event.goto(0);
			},
			onfree: function () {
				if (lib.onfree) {
					clearTimeout(window.resetGameTimeout);
					delete window.resetGameTimeout;
					if (!game.syncMenu) {
						delete window.resetExtension;
						localStorage.removeItem(lib.configprefix + 'disable_extension');
					}

					if (game.removeFile && lib.config.brokenFile.length) {
						while (lib.config.brokenFile.length) {
							game.removeFile(lib.config.brokenFile.shift());
						}
						game.saveConfigValue('brokenFile');
					}

					var onfree = lib.onfree;
					delete lib.onfree;
					var loop = function () {
						if (onfree.length) {
							(onfree.shift())();
							setTimeout(loop, 100);
						}
					};
					setTimeout(loop, 500);
				}
			},
			connection: function (ws) {
				var client = {
					ws: ws,
					id: ws.wsid || get.id(),
					closed: false
				};
				lib.node.clients.push(client);
				for (var i in lib.element.client) {
					client[i] = lib.element.client[i];
				}
				if (window.isNonameServer) {
					document.querySelector('#server_count').innerHTML = lib.node.clients.length;
				}
				ws.on('message', function (messagestr) {
					var message;
					try {
						message = JSON.parse(messagestr);
						if (!Array.isArray(message) ||
							typeof lib.message.server[message[0]] !== 'function') {
							throw ('err');
						}
						for (var i = 1; i < message.length; i++) {
							message[i] = get.parsedResult(message[i]);
						}
					}
					catch (e) {
						console.log(e);
						console.log('invalid message: ' + messagestr);
						return;
					}
					lib.message.server[message.shift()].apply(client, message);
				});
				ws.on('close', function () {
					client.close();
				});
				client.send('opened');
			},
			sheet: function () {
				var style = document.createElement('style');
				document.head.appendChild(style);
				for (var i = 0; i < arguments.length; i++) {
					if (typeof arguments[i] == 'string') {
						style.sheet.insertRule(arguments[i], 0);
					}
				}
				return style;
			},
			css: function (path, file, before) {
				var style = document.createElement("link");
				style.rel = "stylesheet";
				if (path) {
					style.href = path + '/' + file + ".css";
				}
				if (typeof before == 'function') {
					style.addEventListener('load', before);
					document.head.appendChild(style);
				}
				else if (before) {
					document.head.insertBefore(style, before);
				}
				else {
					document.head.appendChild(style);
				}
				return style;
			},
			js: function (path, file, onload, onerror) {
				if (path[path.length - 1] == '/') {
					path = path.slice(0, path.length - 1);
				}
				if (path == lib.assetURL + 'mode' && lib.config.all.stockmode.indexOf(file) == -1) {
					lib.init['setMode_' + file]();
					onload();
					return;
				}
				if (Array.isArray(file)) {
					for (var i = 0; i < file.length; i++) {
						lib.init.js(path, file[i], onload, onerror);
					}
				}
				else {
					var script = document.createElement('script');
					if (!file) {
						script.src = path;
					}
					else {
						script.src = path + '/' + file + ".js";
					}
					if (path.indexOf('http') == 0) {
						script.src += '?rand=' + get.id();
						script.addEventListener('load', function () {
							script.remove();
						});
					}
					document.head.appendChild(script);
					if (typeof onload == 'function') {
						script.addEventListener('load', onload);
						script.addEventListener('error', onerror);
					}
					return script;
				}
			},
			req: function (str, onload, onerror, master) {
				var sScriptURL;
				if (str.indexOf('http') == 0) {
					sScriptURL = str;
				}
				else {
					var url = get.url(master);
					if (url[url.length - 1] != '/') {
						url += '/';
					}
					sScriptURL = url + str;
				}
				var oReq = new XMLHttpRequest();
				if (onload) oReq.addEventListener("load", onload);
				if (onerror) oReq.addEventListener("error", onerror);
				oReq.open("GET", sScriptURL);
				oReq.send();
			},
			json: function (url, onload, onerror) {
				var oReq = new XMLHttpRequest();
				if (onload) oReq.addEventListener("load", function () {
					var result;
					try {
						result = JSON.parse(this.responseText);
						if (!result) {
							throw ('err');
						}
					}
					catch (e) {
						onerror();
						return;
					}
					onload(result);
				});
				if (onerror) oReq.addEventListener("error", onerror);
				oReq.open("GET", url);
				oReq.send();
			},
			cssstyles: function () {
				if (ui.css.styles) {
					ui.css.styles.remove();
				}
				ui.css.styles = lib.init.sheet();
				ui.css.styles.sheet.insertRule('#arena .player>.name,#arena .button.character>.name {font-family: ' + (lib.config.name_font || 'xinwei') + ',xinwei}', 0);
				ui.css.styles.sheet.insertRule('#arena .player .identity>div {font-family: ' + (lib.config.identity_font || 'huangcao') + ',xinwei}', 0);
				ui.css.styles.sheet.insertRule('.button.character.newstyle>.identity {font-family: ' + (lib.config.identity_font || 'huangcao') + ',xinwei}', 0);
				if (lib.config.cardtext_font && lib.config.cardtext_font != 'default') {
					ui.css.styles.sheet.insertRule('.card div:not(.info):not(.background) {font-family: ' + lib.config.cardtext_font + ';}', 0);
				}
				if (lib.config.global_font && lib.config.global_font != 'default') {
					ui.css.styles.sheet.insertRule('#window {font-family: ' + lib.config.global_font + ',xinwei}', 0);
					ui.css.styles.sheet.insertRule('#window #control{font-family: STHeiti,SimHei,Microsoft JhengHei,Microsoft YaHei,WenQuanYi Micro Hei,Helvetica,Arial,sans-serif}', 0);
				}
				switch (lib.config.glow_phase) {
					case 'yellow': ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgb(217, 152, 62) 0 0 15px, rgb(217, 152, 62) 0 0 15px !important;}', 0); break;
					case 'green': ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgba(10, 155, 67, 1) 0 0 15px, rgba(10, 155, 67, 1) 0 0 15px !important;}', 0); break;
					case 'purple': ui.css.styles.sheet.insertRule('#arena .player:not(.selectable):not(.selected).glow_phase {box-shadow: rgba(0, 0, 0, 0.3) 0 0 0 1px, rgb(189, 62, 170) 0 0 15px, rgb(189, 62, 170) 0 0 15px !important;}', 0); break;
				}
			},
			layout: function (layout, nosave) {
				if (!nosave) game.saveConfig('layout', layout);
				game.layout = layout;
				ui.arena.hide();
				setTimeout(function () {
					if (game.layout == 'default') {
						ui.css.layout.href = '';
					}
					else {
						ui.css.layout.href = lib.assetURL + 'layout/' + game.layout + '/layout.css';
					}
					if (game.layout == 'mobile' || game.layout == 'long') {
						ui.arena.classList.add('mobile');
					}
					else {
						ui.arena.classList.remove('mobile');
					}
					if (game.layout == 'mobile' || game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova') {
						if (game.me && game.me.node.handcards2.childNodes.length) {
							while (game.me.node.handcards2.childNodes.length) {
								game.me.node.handcards1.appendChild(game.me.node.handcards2.firstChild);
							}
						}
					}
					if (game.layout == 'default') {
						ui.arena.classList.add('oldlayout');
					}
					else {
						ui.arena.classList.remove('oldlayout');
					}
					if (lib.config.cardshape == 'oblong' && (game.layout == 'long' || game.layout == 'mobile' || game.layout == 'long2' || game.layout == 'nova')) {
						ui.arena.classList.add('oblongcard');
						ui.window.classList.add('oblongcard');
					}
					else {
						ui.arena.classList.remove('oblongcard');
						ui.window.classList.remove('oblongcard');
					}
					if (lib.config.textequip == 'text' && (game.layout == 'long' || game.layout == 'mobile')) {
						ui.arena.classList.add('textequip');
					}
					else {
						ui.arena.classList.remove('textequip');
					}
					if (get.is.phoneLayout()) {
						ui.css.phone.href = lib.assetURL + 'layout/default/phone.css';
						ui.arena.classList.add('phone');
					}
					else {
						ui.css.phone.href = '';
						ui.arena.classList.remove('phone');
					}
					for (var i = 0; i < game.players.length; i++) {
						if (get.is.linked2(game.players[i])) {
							if (game.players[i].classList.contains('linked')) {
								game.players[i].classList.remove('linked');
								game.players[i].classList.add('linked2');
							}
						}
						else {
							if (game.players[i].classList.contains('linked2')) {
								game.players[i].classList.remove('linked2');
								game.players[i].classList.add('linked');
							}
						}
					}
					if (game.layout == 'long' || game.layout == 'long2') {
						ui.arena.classList.add('long');
					}
					else {
						ui.arena.classList.remove('long');
					}
					if (lib.config.player_border != 'wide' || game.layout == 'long' || game.layout == 'long2') {
						ui.arena.classList.add('slim_player');
					}
					else {
						ui.arena.classList.remove('slim_player');
					}
					if (lib.config.player_border == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
						ui.arena.classList.add('lslim_player');
					}
					else {
						ui.arena.classList.remove('lslim_player');
					}
					if (lib.config.player_border == 'slim') {
						ui.arena.classList.add('uslim_player');
					}
					else {
						ui.arena.classList.remove('uslim_player');
					}
					if (lib.config.player_border == 'narrow') {
						ui.arena.classList.add('mslim_player');
					}
					else {
						ui.arena.classList.remove('mslim_player');
					}
					ui.updatej();
					ui.updatem();
					setTimeout(function () {
						ui.arena.show();
						if (game.me) game.me.update();
						setTimeout(function () {
							ui.updatex();
						}, 500);
						setTimeout(function () {
							ui.updatec();
						}, 1000);
					}, 100);
				}, 500);
			},
			background: function () {
				if (lib.config.image_background_random) {
					var list = [];
					for (var i in lib.configMenu.appearence.config.image_background.item) {
						if (i == 'default') continue;
						list.push(i);
					}
					list.remove(lib.config.image_background);
					localStorage.setItem(lib.configprefix + 'background', JSON.stringify(list));
				}
				else if (lib.config.image_background && lib.config.image_background != 'default' && lib.config.image_background.indexOf('custom_') != 0) {
					localStorage.setItem(lib.configprefix + 'background', lib.config.image_background);
				}
				else if (lib.config.image_background == 'default' && lib.config.theme == 'simple') {
					localStorage.setItem(lib.configprefix + 'background', 'ol_bg');
				}
				else {
					localStorage.removeItem(lib.configprefix + 'background');
				}
			},
			parsex: function (func) {
				var k;
				var str = '(';
				str += func.toString();
				if (str.indexOf('step 0') == -1) {
					str = str.replace(/\{/, '{{if(event.step==1) {event.finish();return;}');
				}
				else {
					for (k = 1; k < 99; k++) {
						if (str.indexOf('step ' + k) == -1) break;
						str = str.replace(new RegExp("'step " + k + "'", 'g'), "break;case " + k + ":");
						str = str.replace(new RegExp('"step ' + k + '"', 'g'), "break;case " + k + ":");
					}
					str = str.replace(/'step 0'|"step 0"/, 'if(event.step==' + k + ') {event.finish();return;}switch(step){case 0:');
				}
				str += '})';
				return str;
			},
			parse: function (func) {
				var str = func.toString();
				str = str.slice(str.indexOf('{') + 1);
				if (str.indexOf('step 0') == -1) {
					str = '{if(event.step==1) {event.finish();return;}' + str;
				}
				else {
					for (var k = 1; k < 99; k++) {
						if (str.indexOf('step ' + k) == -1) break;
						str = str.replace(new RegExp("'step " + k + "'", 'g'), "break;case " + k + ":");
						str = str.replace(new RegExp('"step ' + k + '"', 'g'), "break;case " + k + ":");
					}
					str = str.replace(/'step 0'|"step 0"/, 'if(event.step==' + k + ') {event.finish();return;}switch(step){case 0:');
				}
				return (new Function('event', 'step', 'source', 'player', 'target', 'targets',
					'card', 'cards', 'skill', 'forced', 'num', 'trigger', 'result',
					'_status', 'lib', 'game', 'ui', 'get', 'ai', str));
			},
			eval: function (func) {
				if (typeof func == 'function') {
					return eval('(' + func.toString() + ')');
				}
				else if (typeof func == 'object') {
					for (var i in func) {
						if (func.hasOwnProperty(i)) {
							func[i] = lib.init.eval(func[i]);
						}
					}
				}
				return func;
			},
			encode: function (strUni) {
				var strUtf = strUni.replace(
					/[\u0080-\u07ff]/g, function (c) {
						var cc = c.charCodeAt(0);
						return String.fromCharCode(0xc0 | cc >> 6, 0x80 | cc & 0x3f);
					});
				strUtf = strUtf.replace(
					/[\u0800-\uffff]/g, function (c) {
						var cc = c.charCodeAt(0);
						return String.fromCharCode(0xe0 | cc >> 12, 0x80 | cc >> 6 & 0x3F, 0x80 | cc & 0x3f);
					});
				return btoa(strUtf);
			},
			decode: function (str) {
				var strUtf = atob(str);
				var strUni = strUtf.replace(
					/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (c) {
						var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
						return String.fromCharCode(cc);
					});
				strUni = strUni.replace(
					/[\u00c0-\u00df][\u0080-\u00bf]/g, function (c) {
						var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
						return String.fromCharCode(cc);
					});
				return strUni;
			},
			stringify: function (obj) {
				var str = '{'
				for (var i in obj) {
					str += '"' + i + '":'
					if (Object.prototype.toString.call(obj[i]) == '[object Object]') {
						str += lib.init.stringify(obj[i]);
					}
					else if (typeof obj[i] == 'function') {
						str += obj[i].toString();
					}
					else {
						str += JSON.stringify(obj[i]);
					}
					str += ','
				}
				str += '}';
				return str;
			},
			stringifySkill: function (obj) {
				var str = '';
				for (var i in obj) {
					str += i + ':'
					if (Object.prototype.toString.call(obj[i]) == '[object Object]') {
						str += '{\n' + lib.init.stringifySkill(obj[i]) + '}';
					}
					else if (typeof obj[i] == 'function') {
						str += obj[i].toString().replace(/\t/g, '');
					}
					else {
						str += JSON.stringify(obj[i]);
					}
					str += ',\n'
				}
				return str;
			}
		},
		cheat: {
			i: function () {
				window.cheat = lib.cheat;
				window.game = game;
				window.ui = ui;
				window.get = get;
				window.ai = ai;
				window.lib = lib;
				window._status = _status;
			},
			dy: function () {
				var next = game.me.next;
				for (var i = 0; i < 10; i++) {
					if (next.identity != 'zhu') {
						break;
					}
					next = next.next;
				}
				next.die();
			},
			x: function () {
				var gl = function (dir, callback) {
					var files = [], folders = [];
					dir = '/Users/widget/Documents/extension/' + dir;
					lib.node.fs.readdir(dir, function (err, filelist) {
						for (var i = 0; i < filelist.length; i++) {
							if (filelist[i][0] != '.' && filelist[i][0] != '_') {
								if (lib.node.fs.statSync(dir + '/' + filelist[i]).isDirectory()) {
									folders.push(filelist[i]);
								}
								else {
									files.push(filelist[i]);
								}
							}
						}
						callback(folders, files);
					});
				}
				var args = Array.from(arguments);
				for (var i = 0; i < args.length; i++) {
					args[i] = args[i][0];
				}
				gl('', function (list) {
					if (args.length) {
						for (var i = 0; i < list.length; i++) {
							if (!args.contains(list[i][0])) {
								list.splice(i--, 1);
							}
						}
					}
					if (list.length) {
						for (var i = 0; i < list.length; i++) {
							(function (str) {
								gl(str, function (folders, files) {
									if (files.length > 1) {
										for (var i = 0; i < files.length; i++) {
											if (files[i].indexOf('extension.js') != -1) {
												files.splice(i--, 1);
											}
											else {
												if (i % 5 == 0) {
													str += '\n\t\t\t';
												}
												str += '"' + files[i] + '",';
											}
										}
										console.log(str.slice(0, str.length - 1));
									}
								});
							}(list[i]));
						}
					}
				});
			},
			cfg: function () {
				var mode = lib.config.all.mode.slice(0);
				mode.remove('connect');
				mode.remove('brawl');
				var banned = ['shen_guanyu', 'shen_caocao', 'caopi', 're_daqiao', 'caorui',
					'daqiao', 'lingcao', 'liuzan', 'lusu', 'luxun', 'yanwen', 'zhouyu', 'ns_wangyue', 'gw_yenaifa',
					'old_caozhen', 'swd_jiangziya', 'xuhuang', 'maliang', 'guojia', 'simayi', 'swd_kangnalishi', 'hs_siwangzhiyi', 'hs_nozdormu', 'old_zhuzhi'];
				var bannedcards = ['zengbin'];
				var favs = ["hs_tuoqi", "hs_siwangxianzhi", "hs_xukongzhiying", "hs_hsjiasha", "gjqt_xieyi", "gjqt_yunwuyue", "gjqt_beiluo",
					"gjqt_cenying", "shen_lvmeng", "shen_zhaoyun", "shen_zhugeliang", "ow_ana", "chenlin", "ns_guanlu", "hs_guldan", "swd_guyue",
					"pal_jiangyunfan", "mtg_jiesi", "swd_lanyin", "pal_liumengli", "swd_muyun", "pal_nangonghuang", "swd_muyue", "pal_murongziying",
					"swd_qiner", "pal_shenqishuang", "hs_taisi", "wangji", "pal_xingxuan", "xunyou", "hs_yelise", "pal_yuejinzhao", "pal_yueqi",
					"gjqt_yuewuyi", "swd_yuxiaoxue", "ow_zhaliya", "zhangchunhua", "hs_zhihuanhua", "swd_zhiyin", "old_zhonghui", "gjqt_bailitusu",
					"hs_barnes", "ow_dva", "swd_hengai", "pal_jushifang", "hs_kazhakusi", "hs_lafamu", "ow_liekong", "hs_lreno", "pal_mingxiu",
					"swd_murongshi", "gw_oudimu", "gjqt_ouyangshaogong", "hs_pyros", "qinmi", "gw_sanhanya", "hs_selajin", "swd_shuwaner",
					"swd_situqiang", "hs_xialikeer", "pal_xuejian", "swd_yuchiyanhong", "swd_yuwentuo", "swd_zhaoyun", "zhugeliang", "gw_aigeleisi",
					"gw_aimin", "gjqt_aruan", "hs_aya", "swd_cheyun", "swd_chenjingchou", "gw_diandian", "swd_huzhongxian", "hs_jinglinglong",
					"hs_kaituozhe", "hs_kalimosi", "gw_linjing", "ow_luxiao", "re_luxun", "hs_morgl", "swd_sikongyu", "hs_sthrall", "sunquan",
					"sunshangxiang", "gw_yioufeisisp", "gw_yisilinni", "hs_yogg", "hs_ysera", "pal_yuntianhe", "zhugejin", "zhugeke", "gw_zhuoertan",
					"hs_anduin", "swd_anka", "ow_banzang", "ow_chanyata", "diaochan", "swd_duguningke", "sp_diaochan", "hetaihou", "ns_huamulan",
					"swd_huanglei", "swd_huanyuanzhi", "re_huatuo", "gw_huoge", "pal_jiangcheng", "yj_jushou", "swd_kendi", "yxs_libai",
					"mtg_lilianna", "xin_liru", "liuxie", "pal_lixiaoyao", "pal_longkui", "ns_nanhua", "swd_qi", "swd_septem", "gw_shasixiwusi",
					"ow_tianshi", "swd_weida", "gjqt_xiayize", "swd_xiyan", "hs_xsylvanas", "hs_yelinlonghou", "ow_yuanshi", "zuoci"];
				var vintage = ['tianjian', 'shuiyun', 'zhuyue', 'zhimeng', 'poyun', 'qianfang', 'xfenxin', 'danqing', 'ywuhun', 'tianwu', 'xuelu',
					'shahun', 'yuling', 'duhun', 'liaoyuan', 'touxi', 'wangchen', 'poyue', 'kunlunjing', 'huanhun', 'yunchou', 'tuzhen', 'cyqiaoxie',
					'mufeng', 'duanyi', 'guozao', 'yaotong', 'pozhen', 'tanlin', 'susheng', 'jikong', 'shouyin', 'jilve', 'hxunzhi', 'huodan', 'shanxian',
					'ziyu', 'kuoyin', 'feiren', 'zihui', 'jidong', 'baoxue', 'aqianghua', 'maoding', 'bfengshi', 'zhongdun', 'pingzhang', 'maichong',
					'guozai', 'jingxiang', 'yuelu', 'liechao', 'fengnu', 'hanshuang', 'enze', 'malymowang', 'xshixin', 'qingzun'];
				var favmodes = ["versus|three", "versus|four", "versus|two", "chess|combat"];
				for (var i = 0; i < mode.length; i++) {
					game.saveConfig(mode[i] + '_banned', banned);
					game.saveConfig(mode[i] + '_bannedcards', bannedcards);
				}
				var characters = lib.config.all.characters.slice(0);
				characters.remove('standard');
				characters.remove('old');
				game.saveConfig('vintageSkills', vintage);
				game.saveConfig('favouriteCharacter', favs);
				game.saveConfig('favouriteMode', favmodes);
				game.saveConfig('theme', 'simple');
				game.saveConfig('player_border', 'slim');
				game.saveConfig('cards', lib.config.all.cards);
				game.saveConfig('characters', characters);
				game.saveConfig('change_skin', false);
				game.saveConfig('show_splash', 'off');
				game.saveConfig('show_favourite', false);
				game.saveConfig('animation', false);
				game.saveConfig('hover_all', false);
				game.saveConfig('asset_version', 'v1.9');
				// game.saveConfig('characters',lib.config.all.characters);
				// game.saveConfig('cards',lib.config.all.cards);
				game.saveConfig('plays', ['cardpile']);
				game.saveConfig('skip_shan', false);
				game.saveConfig('tao_enemy', true);
				game.saveConfig('layout', 'long2');
				game.saveConfig('hp_style', 'ol');
				game.saveConfig('background_music', 'music_off');
				game.saveConfig('background_audio', false);
				game.saveConfig('background_speak', false);
				game.saveConfig('show_volumn', false);
				game.saveConfig('show_replay', true);
				game.saveConfig('autostyle', true);
				game.saveConfig('debug', true);
				game.saveConfig('dev', true);
				if (!lib.device) {
					game.saveConfig('sync_speed', false);
				}
				game.reload();
			},
			o: function () {
				ui.arena.classList.remove('observe');
			},
			pt: function () {
				var list = Array.from(arguments);
				while (list.length) {
					var card = cheat.gn(list.pop());
					if (card) ui.cardPile.insertBefore(card, ui.cardPile.firstChild);
				}
			},
			q: function () {
				// if(lib.config.layout!='mobile') lib.init.layout('mobile');
				if (arguments.length == 0) {
					var style = ui.css.card_style;
					if (lib.config.card_style != 'simple') {
						lib.config.card_style = 'simple';
						ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', 'simple');
					}
					else {
						lib.config.card_style = 'default';
						ui.css.card_style = lib.init.css(lib.assetURL + 'theme/style/card', 'default');
					}
					style.remove();
				}
				else {
					for (var i = 0; i < arguments.length; i++) {
						cheat.g(arguments[i]);
					}
				}
				ui.arena.classList.remove('selecting');
				ui.arena.classList.remove('tempnoe');
			},
			p: function (name, i, skin) {
				var list = ['swd', 'hs', 'pal', 'gjqt', 'ow', 'gw'];
				if (!lib.character[name]) {
					for (var j = 0; j < list.length; j++) {
						if (lib.character[list[j] + '_' + name]) {
							name = list[j] + '_' + name; break;
						}
					}
				}
				if (skin) {
					lib.config.skin[name] = skin
				}
				var target;
				if (typeof i == 'number') {
					target = game.players[i];
				}
				else {
					target = game.me.next;
				}
				if (!lib.character[name]) {
					target.node.avatar.setBackground(name, 'character');
					target.node.avatar.show();
				}
				else {
					target.init(name);
				}
				if (i === true) {
					if (lib.config.layout == 'long2') {
						lib.init.layout('mobile');
					}
					else {
						lib.init.layout('long2');
					}
				}
			},
			e: function () {
				var cards = [], target;
				for (var i = 0; i < arguments.length; i++) {
					if (get.itemtype(arguments[i]) == 'player') {
						target = arguments[i];
					}
					else {
						cards.push(game.createCard(arguments[i]));
					}
				}
				if (!cards.length) {
					cards.push(game.createCard('qilin'));
					cards.push(game.createCard('bagua'));
					cards.push(game.createCard('dilu'));
					cards.push(game.createCard('chitu'));
					cards.push(game.createCard('muniu'));
				}
				target = target || game.me;
				for (var i = 0; i < cards.length; i++) {
					var card = target.getEquip(cards[i]);
					if (card) {
						card.discard();
						target.removeEquipTrigger(card);
					}
					target.$equip(cards[i]);
				}
			},
			c: function () {
				(function () {
					var a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
					var sa = 0, sb = 0, sc = 0, sd = 0, se = 0, sf = 0;
					var z1 = z2 = z3 = z4 = z5 = z6 = z7 = z8 = z9 = z10 = z11 = z12 = z13 = 0;
					var x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x10 = x11 = x12 = x13 = 0;
					for (var i in lib.character) {
						switch (lib.character[i][1]) {
							case 'wei':
								a++;
								if (lib.config.banned.contains(i)) sa++;
								break;
							case 'shu':
								b++;
								if (lib.config.banned.contains(i)) sb++;
								break;
							case 'wu':
								c++;
								if (lib.config.banned.contains(i)) sc++;
								break;
							case 'qun':
								d++;
								if (lib.config.banned.contains(i)) sd++;
								break;
							case 'western':
								e++;
								if (lib.config.banned.contains(i)) se++;
								break;
							case 'key':
								f++;
								if (lib.config.banned.contains(i)) sf++;
								break;
							case 'S':
								x1++;
								if (lib.config.banned.contains(i)) z1++;
								break;
							case 'N':
								x2++;
								if (lib.config.banned.contains(i)) z2++;
								break;
							case 'H':
								x3++;
								if (lib.config.banned.contains(i)) z3++;
								break;
							case 'X':
								x4++;
								if (lib.config.banned.contains(i)) z4++;
								break;
							case 'B':
								x5++;
								if (lib.config.banned.contains(i)) z5++;
								break;
							case 'E':
								x6++;
								if (lib.config.banned.contains(i)) z6++;
								break;
							case 'J':
								x7++;
								if (lib.config.banned.contains(i)) z7++;
								break;
							case 'G':
								x8++;
								if (lib.config.banned.contains(i)) z8++;
								break;
							case 'N3':
								x9++;
								if (lib.config.banned.contains(i)) z9++;
								break;
							case 'Z':
								x10++;
								if (lib.config.banned.contains(i)) z10++;
								break;
							case 'guan':
								x11++;
								if (lib.config.banned.contains(i)) z11++;
								break;
							case 'C':
								x12++;
								if (lib.config.banned.contains(i)) z12++;
								break;
							case 'K':
								x13++;
								if (lib.config.banned.contains(i)) z13++;
								break;
						}
					}
					console.log('魏：' + (a - sa) + '/' + a);
					console.log('蜀：' + (b - sb) + '/' + b);
					console.log('吴：' + (c - sc) + '/' + c);
					console.log('群：' + (d - sd) + '/' + d);
					console.log('西：' + (e - se) + '/' + e);
					console.log('键：' + (f - sf) + '/' + f);
					console.log('已启用：' + ((a + b + c + d + e + f) - (sa + sb + sc + sd + se + sf)) + '/' + (a + b + c + d + e + f));
				}());
				(function () {
					var a = 0,
						b = 0,
						c = 0,
						d = 0;
					var aa = 0,
						bb = 0,
						cc = 0,
						dd = 0;
					var sa = 0,
						sb = 0,
						sc = 0,
						sd = 0;
					var sha = 0,
						shan = 0,
						tao = 0,
						jiu = 0,
						wuxie = 0,
						heisha = 0,
						hongsha = 0;
					var num = {
						1: 0,
						2: 0,
						3: 0,
						4: 0,
						5: 0,
						6: 0,
						7: 0,
						8: 0,
						9: 0,
						10: 0,
						11: 0,
						12: 0,
						13: 0
					};
					for (var i in lib.card) {
						if (get.objtype(lib.card[i]) == 'object' && lib.translate[i + '_info']) {
							switch (lib.card[i].type) {
								case 'basic': a++; break;
								case 'trick': b++; break;
								case 'equip': c++; break;
								default: d++; break;
							}
						}
					}
					for (var i = 0; i < lib.card.list.length; i++) {
						if (typeof lib.card[lib.card.list[i][2]] == 'object') {
							switch (lib.card[lib.card.list[i][2]].type) {
								case 'basic': aa++; break;
								case 'trick': case 'delay': bb++; break;
								case 'equip': cc++; break;
								default: dd++; break;
							}
							switch (lib.card.list[i][0]) {
								case 'heart': sa++; break;
								case 'diamond': sb++; break;
								case 'club': sc++; break;
								case 'spade': sd++; break;
							}
							if (lib.card.list[i][2] == 'sha') {
								sha++;
								if (lib.card.list[i][0] == 'club' || lib.card.list[i][0] == 'spade') {
									heisha++;
								}
								else {
									hongsha++;
								}
							}
							if (lib.card.list[i][2] == 'shan') {
								shan++;
							}
							if (lib.card.list[i][2] == 'tao') {
								tao++;
							}
							if (lib.card.list[i][2] == 'jiu') {
								jiu++;
							}
							if (lib.card.list[i][2] == 'wuxie') {
								wuxie++;
							}
							num[lib.card.list[i][1]]++;
						}
					}
					var str = '基本牌' + aa + '； ' + '锦囊牌' + bb + '； ' + '装备牌' + cc + '； ' + '其它牌' + dd
					console.log(str);
					str = '红桃牌' + sa + '； ' + '方片牌' + sb + '； ' + '梅花牌' + sc + '； ' + '黑桃牌' + sd
					console.log(str);
					str = '杀' + sha + '； ' + '黑杀' + heisha + '； ' + '红杀' + hongsha + '； ' + '闪' + shan + '； ' + '桃' + tao + '； ' + '酒' + jiu + '； ' + '无懈' + wuxie
					console.log(str);
					if (arguments[1]) {
						for (var i = 1; i <= 13; i++) {
							if (i < 10) {
								console.log(i + ' ', num[i]);
							}
							else {
								console.log(i, num[i]);
							}
						}
					}
					var arr = [];
					for (var i = 1; i <= 13; i++) {
						arr.push(num[i]);
					}
					console.log((a + b + c + d) + '/' + (aa + bb + cc + dd), ...arr)
				}());
			},
			id: function () {
				game.showIdentity();
			},
			b: function () {
				if (!ui.dialog || !ui.dialog.buttons) return;
				for (var i = 0; i < Math.min(arguments.length, ui.dialog.buttons.length); i++) {
					ui.dialog.buttons[i].link = arguments[i];
				}
			},
			uy: function (me) {
				if (me) {
					game.me.useCard({ name: 'spell_yexinglanghun' }, game.me);
				}
				else {
					var enemy = game.me.getEnemy();
					enemy.useCard({ name: 'spell_yexinglanghun' }, enemy);
				}
			},
			gs: function (name, act) {
				var card = game.createCard('spell_' + (name || 'yexinglanghun'));
				game.me.node.handcards1.appendChild(card);
				if (!act) {
					game.me.actused = -99;
				}
				ui.updatehl();
				delete _status.event._cardChoice;
				delete _status.event._targetChoice;
				delete _status.event._skillChoice;
				setTimeout(game.check, 300);
			},
			gc: function (name, act) {
				var card = game.createCard('stone_' + (name || 'falifulong') + '_stonecharacter');
				game.me.node.handcards1.appendChild(card);
				if (!act) {
					game.me.actused = -99;
				}
				ui.updatehl();
				delete _status.event._cardChoice;
				delete _status.event._targetChoice;
				delete _status.event._skillChoice;
				setTimeout(game.check, 300);
			},
			a: function (bool) {
				if (lib.config.test_game) {
					game.saveConfig('test_game');
				}
				else {
					if (bool) {
						if (typeof bool === 'string') {
							game.saveConfig('test_game', bool);
						}
						else {
							game.saveConfig('test_game', '_');
						}
					}
					else {
						game.saveConfig('test_game', true);
					}
				}
				game.reload();
			},
			as: function () {
				ui.window.classList.remove('testing');
				var bg = ui.window.querySelector('.pausedbg');
				if (bg) {
					bg.remove();
				}
			},
			uj: function () {
				cheat.e('qilin');
				game.me.next.useCard({ name: 'jiedao' }, [game.me, game.me.previous]);
			},
			u: function () {
				var card = { name: 'sha' }, source = game.me.next, targets = [];
				for (var i = 0; i < arguments.length; i++) {
					if (get.itemtype(arguments[i]) == 'player') {
						source = arguments[i];
					}
					else if (Array.isArray(arguments[i])) {
						targets = arguments[i];
					}
					else if (typeof arguments[i] == 'object' && arguments[i]) {
						card = arguments[i];
					}
					else if (typeof arguments[i] == 'string') {
						card = { name: arguments[i] }
					}
				}
				if (!targets.length) targets.push(game.me);
				source.useCard(game.createCard(card.name, card.suit, card.number, card.nature), targets);
			},
			r: function (bool) {
				var list = ['s', 'ap', 'a', 'am', 'bp', 'b', 'bm', 'c', 'd'];
				var str = '';
				for (var i = 0; i < list.length; i++) {
					if (str) str += ' 、 ';
					str += list[i] + '-' + lib.rank[list[i]].length;
				}
				console.log(str);
				for (var i in lib.characterPack) {
					if (!bool && lib.config.all.sgscharacters.contains(i)) continue;
					var map = {};
					var str = '';
					for (var j in lib.characterPack[i]) {
						var rank = get.rank(j);
						if (!map[rank]) {
							map[rank] = 1;
						}
						else {
							map[rank]++;
						}
					}
					for (var j = 0; j < list.length; j++) {
						if (map[list[j]]) {
							if (str) str += ' 、 ';
							str += list[j] + '-' + map[list[j]];
						}
					}
					if (str) {
						console.log(lib.translate[i + '_character_config'] + '：' + str);
					}
				}

				var list = lib.rank.s.concat(lib.rank.ap).concat(lib.rank.a).concat(lib.rank.am).
					concat(lib.rank.bp).concat(lib.rank.b).concat(lib.rank.bm).concat(lib.rank.c).concat(lib.rank.d);
				for (var i in lib.character) {
					if (lib.config.forbidai.contains(i)) continue;
					if (i.indexOf('boss_') != 0 && i.indexOf('tafang_') != 0 && !list.contains(i)) console.log(get.translation(i), i);
				}
			},
			h: function (player) {
				console.log(get.translation(player.getCards('h')));
			},
			g: function () {
				for (var i = 0; i < arguments.length; i++) {
					if (i > 0 && typeof arguments[i] == 'number') {
						for (var j = 0; j < arguments[i] - 1; j++) {
							cheat.gx(arguments[i - 1]);
						}
					}
					else {
						cheat.gx(arguments[i]);
					}
				}
			},
			ga: function (type) {
				for (var i in lib.card) {
					if (lib.card[i].type == type || lib.card[i].subtype == type) {
						cheat.g(i);
					}
				}
			},
			gg: function () {
				for (var i = 0; i < game.players.length; i++) {
					for (var j = 0; j < arguments.length; j++) {
						cheat.gx(arguments[j], game.players[i]);
					}
				}
			},
			gx: function (name, target) {
				target = target || game.me;
				var card = cheat.gn(name);
				if (!card) return;
				target.node.handcards1.appendChild(card);
				delete _status.event._cardChoice;
				delete _status.event._targetChoice;
				delete _status.event._skillChoice;
				game.check();
				target.update();
				ui.updatehl();
			},
			gn: function (name) {
				var nature = null;
				var suit = null;
				var suits = ['club', 'spade', 'diamond', 'heart'];
				for (var i = 0; i < suits.length; i++) {
					if (name.indexOf(suits[i]) == 0) {
						suit = suits[i];
						name = name.slice(suits[i].length);
						break;
					}
				}
				if (name.indexOf('red') == 0) {
					name = name.slice(3);
					suit = ['diamond', 'heart'].randomGet();
				}
				if (name.indexOf('black') == 0) {
					name = name.slice(5);
					suit = ['spade', 'club'].randomGet();
				}

				if (name == 'huosha') {
					name = 'sha';
					nature = 'fire';
				}
				else if (name == 'leisha') {
					name = 'sha';
					nature = 'thunder';
				}
				if (!lib.card[name]) {
					return null;
				}
				return game.createCard(name, suit, null, nature);
			},
			ge: function (target) {
				if (target) {
					cheat.gx('zhuge', target);
					cheat.gx('qinglong', target);
					cheat.gx('bagua', target);
					cheat.gx('dilu', target);
					cheat.gx('chitu', target);
					cheat.gx('muniu', target);
				}
				else {
					cheat.g('zhuge');
					cheat.g('qinglong');
					cheat.g('bagua');
					cheat.g('dilu');
					cheat.g('chitu');
					cheat.g('muniu');
				}
			},
			gj: function () {
				cheat.g('shandian');
				cheat.g('huoshan');
				cheat.g('hongshui');
				cheat.g('lebu');
				cheat.g('bingliang');
				cheat.g('guiyoujie');
			},
			gf: function () {
				for (var i in lib.card) {
					if (lib.card[i].type == 'food') {
						cheat.g(i);
					}
				}
			},
			d: function (num, target) {
				if (num == undefined) num = 1;
				var cards = get.cards(num);
				for (var i = 0; i < num; i++) {
					var card = cards[i];
					game.me.node.handcards1.appendChild(card);
					delete _status.event._cardChoice;
					delete _status.event._targetChoice;
					delete _status.event._skillChoice;
					game.check();
					game.me.update();
					ui.updatehl();
				}
			},
			s: function () {
				for (var i = 0; i < arguments.length; i++) {
					game.me.addSkill(arguments[i], true);
				}
				delete _status.event._cardChoice;
				delete _status.event._targetChoice;
				delete _status.event._skillChoice;
				game.check();
			},
			t: function (num) {
				if (game.players.contains(num)) {
					num = game.players.indexOf(num);
				}
				if (num == undefined) {
					for (var i = 0; i < game.players.length; i++) cheat.t(i);
					return;
				}
				var player = game.players[num];
				var cards = player.getCards('hej');
				for (var i = 0; i < cards.length; i++) {
					cards[i].discard();
				}
				player.removeEquipTrigger();
				player.update();
			},
			to: function () {
				for (var i = 0; i < game.players.length; i++) {
					if (game.players[i] != game.me) {
						cheat.t(i);
					}
				}
			},
			tm: function () {
				for (var i = 0; i < game.players.length; i++) {
					if (game.players[i] == game.me) {
						cheat.t(i);
					}
				}
			},
			k: function (i) {
				if (i == undefined) i = 1;
				game.players[i].hp = 1;
				cheat.t(i);
				cheat.g('juedou');
			},
			z: function (name) {
				switch (name) {
					case 'cc': name = 're_caocao'; break;
					case 'lb': name = 're_liubei'; break;
					case 'sq': name = 'sunquan'; break;
					case 'dz': name = 'dongzhuo'; break;
					case 'ys': name = 're_yuanshao'; break;
					case 'zj': name = 'sp_zhangjiao'; break;
					case 'ls': name = 'liushan'; break;
					case 'sc': name = 'sunce'; break;
					case 'cp': name = 'caopi'; break;
					case 'cr': name = 'caorui'; break;
					case 'sx': name = 'sunxiu'; break;
					case 'lc': name = 'liuchen'; break;
					case 'sh': name = 'sunhao'; break;
				}
				game.zhu.init(name);
				game.zhu.maxHp++;
				game.zhu.hp++;
				game.zhu.update();
			},
		},
		translate: {
			'default': "默认",
			special: '特殊',
			zhenfa: '阵法',
			aozhan: "鏖战",
			"aozhan_info": "",
			mode_derivation_card_config: '衍生',
			mode_banned_card_config: '禁卡',
			mode_favourite_character_config: '收藏',
			mode_banned_character_config: '禁将',
			heart: "♥︎",
			diamond: "♦︎",
			spade: "♠︎",
			club: "♣︎",
			ghujia: '护甲',
			ghujia_bg: '甲',
			heart2: "红桃",
			diamond2: "方片",
			spade2: "黑桃",
			club2: "梅花",
			red: '红色',
			black: '黑色',
			ok: "确定",
			ok2: "确定",
			cancel: "取消",
			cancel2: "取消",
			restart: "重新开始",
			setting: "设置",
			start: "开始",
			random: "随机",
			_out: '无效',
			agree: '同意',
			refuse: '拒绝',
			fire: "火",
			thunder: "雷",
			poison: "毒",
			S: 'S',
			N: 'N',
			H: 'H',
			X: 'X',
			B: 'B',
			E: 'E',
			J: 'J',
			G: 'G',
			N3: 'N3',
			Z: 'Z',
			C: 'C',
			K: 'K',
			ye: '野',
			guan: '官',
			FT: 'Ft',
			wei: '魏',
			shu: '蜀',
			wu: '吴',
			qun: '群',
			shen: '神',
			western: '西',
			key: '键',
			wei2: '魏国',
			shu2: '蜀国',
			wu2: '吴国',
			qun2: '群雄',
			shen2: '神明',
			western2: '西方',
			key2: 'KEY',
			male: '男',
			female: '女',
			mad: '混乱',
			mad_bg: '疯',
			draw_card: '摸牌',
			discard_card: '弃牌',
			take_damage: '受伤害',
			reset_character: '复原武将牌',
			recover_hp: '回复体力',
			lose_hp: '流失体力',
			get_damage: '受伤害',
			weiColor: "#b0d0e2",
			shuColor: "#ffddb9",
			wuColor: "#b2d9a9",
			qunColor: "#f6f6f6",
			shenColor: "#ffe14c",
			westernColor: "#ffe14c",
			keyColor: "#c9b1fd",
			basic: '基本',
			equip: '装备',
			trick: '锦囊',
			delay: '延时锦囊',
			character: '角色',
			revive: '复活',
			equip1: '武器',
			equip2: '防具',
			equip3: '防御马',
			equip4: '攻击马',
			equip5: '宝物',
			zero: '零',
			one: '一',
			two: '二',
			three: '三',
			four: '四',
			five: '五',
			six: '六',
			seven: '七',
			eight: '八',
			nine: '九',
			ten: '十',
			'SNH48': "SNH48",
			_chongzhu: '重铸',
			_lianhuan: '连环',
			_lianhuan2: '连环',
			_kamisha: '神杀',
			qianxing: '潜行',
			mianyi: '免疫',
			fengyin: '封印',
			baiban: '白板',
			_disableJudge: "判定区",

			guojia_emotion: '郭嘉表情',
			zhenji_emotion: '甄姬表情',
			shibing_emotion: '士兵表情',
			xiaosha_emotion: '小杀表情',
			xiaotao_emotion: '小桃表情',

			pause: '暂停',
			config: '选项',
			auto: '托管',

			unknown: '无名氏',
			unknown0: '一号位',
			unknown1: '二号位',
			unknown2: '三号位',
			unknown3: '四号位',
			unknown4: '五号位',
			unknown5: '六号位',
			unknown6: '七号位',
			unknown7: '八号位',
		},
		element: {
			content: {
				emptyEvent: function () {
					event.trigger(event.name);
				},
				chooseUseTarget: function () {
					'step 0'
					if (get.is.object(card) && !event.viewAs) card.isCard = true;
					if (cards && get.itemtype(card) != 'card') {
						card = get.copy(card);
						card.cards = cards.slice(0);
						event.card = card;
					}
					if (!lib.filter.cardEnabled(card, player) || (event.addCount !== false && !lib.filter.cardUsable(card, player))) {
						event.result = { bool: false };
						event.finish();
						return;
					}
					var info = get.info(card);
					var range;
					if (!info.notarget) {
						var select = get.copy(info.selectTarget);
						if (select == undefined) {
							range = [1, 1];
						}
						else if (typeof select == 'number') range = [select, select];
						else if (get.itemtype(select) == 'select') range = select;
						else if (typeof select == 'function') range = select(card, player);
						game.checkMod(card, player, range, 'selectTarget', player);
					}
					if (info.notarget || range[1] == -1) {
						if (!info.notarget && range[1] == -1) {
							for (var i = 0; i < targets.length; i++) {
								if (!player.canUse(card, targets[i], event.nodistance ? false : null)) {
									targets.splice(i--, 1);
								}
							}
							if (targets.length) {
								event.targets2 = targets;
							}
							else {
								event.finish();
								return;
							}
						}
						else event.targets2 = [];
						if (event.forced) {
							event._result = { bool: true };
						}
						else {
							var next = player.chooseBool();
							next.set('prompt', event.prompt || ('是否' + (event.targets2.length ? '对' : '') + get.translation(event.targets2) + '使用' + get.translation(card) + '?'));
							if (event.prompt2) next.set('prompt2', event.prompt2);
							next.ai = function () {
								var eff = 0;
								for (var i = 0; i < event.targets2.length; i++) {
									eff += get.effect(event.targets2[i], card, player, player);
								}
								return eff > 0;
							};
						}
					}
					else {
						var next = player.chooseTarget();
						next.set('_get_card', card);
						next.set('filterTarget', function (card, player, target) {
							if (!_status.event.targets.contains(target)) return false;
							return lib.filter[_status.event.nodistance ? 'targetEnabled' : 'filterTarget'].apply(this, arguments);
						});
						next.set('ai', event.ai || get.effect_use);
						next.set('selectTarget', event.selectTarget || lib.filter.selectTarget);
						if (event.nodistance) next.set('nodistance', true);
						if (event.forced) next.set('forced', true);
						next.set('targets', targets);
						next.set('prompt', event.prompt || ('选择' + get.translation(card) + '的目标'));
						if (event.prompt2) next.set('prompt2', event.prompt2);
					}
					'step 1'
					if (result.bool) {
						event.result = {
							bool: true,
							targets: event.targets2 || result.targets,
						};
						if (event.logSkill) {
							if (typeof event.logSkill == 'string') {
								player.logSkill(event.logSkill);
							}
							else if (Array.isArray(event.logSkill)) {
								player.logSkill.apply(player, event.logSkill);
							}
						}
						var next = player.useCard(card, event.targets2 || result.targets);
						if (cards) next.cards = cards.slice(0);
						if (event.nopopup) next.nopopup = true;
						if (event.animate === false) next.animate = false;
						if (event.throw === false) next.throw = false;
						if (event.addCount === false) next.addCount = false;
						if (event.noTargetDelay) next.targetDelay = false;
						if (event.nodelayx) next.delayx = false;
					}
					else event.result = { bool: false };
				},
				chooseToDuiben: function () {
					'step 0'
					game.log(player, '对', target, '发起了', '#y对策');
					if (_status.connectMode) {
						player.chooseButtonOL([
							[player, ['对策：请选择一种防御对策', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true],
							[target, ['对策：请选择一种进攻之策', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true]
						], function () { }, function () { return 1 + Math.random() }).set('switchToAuto', function () {
							_status.event.result = 'ai';
						}).set('processAI', function () {
							var buttons = _status.event.dialog.buttons;
							return {
								bool: true,
								links: [buttons.randomGet().link],
							}
						});
					}
					'step 1'
					if (_status.connectMode) {
						event.mes = result[player.playerid].links[0][2];
						event.tes = result[target.playerid].links[0][2];
						event.goto(4);
					}
					else {
						player.chooseButton(['对策：请选择一种防御对策', [[['', '', 'db_def2'], ['', '', 'db_def1']], 'vcard']], true).ai = function () { return 1 + Math.random() };
					}
					'step 2'
					event.mes = result.links[0][2];
					target.chooseButton(['对策：请选择一种进攻之策', [[['', '', 'db_atk1'], ['', '', 'db_atk2']], 'vcard']], true).ai = function () { return 1 + Math.random() };
					'step 3'
					event.tes = result.links[0][2];
					'step 4'
					game.broadcast(function () {
						ui.arena.classList.add('thrownhighlight');
					});
					ui.arena.classList.add('thrownhighlight');
					game.addVideo('thrownhighlight1');
					target.$compare(game.createCard(event.tes, '', ''), player, game.createCard(event.mes, '', ''));
					game.log(target, '选择的进攻之策为', '#g' + get.translation(event.tes));
					game.log(player, '选择的防御对策为', '#g' + get.translation(event.mes));
					game.delay(0, 1500);
					'step 5'
					var mes = event.mes.slice(6);
					var tes = event.tes.slice(6);
					var str;
					if (mes == tes) {
						str = get.translation(player) + '对策成功';
						player.popup('胜', 'wood');
						target.popup('负', 'fire');
						game.log(player, '#g胜');
						event.result = { bool: true };
					}
					else {
						str = get.translation(player) + '对策失败';
						target.popup('胜', 'wood');
						player.popup('负', 'fire');
						game.log(target, '#g胜');
						event.result = { bool: false };
					}
					game.broadcastAll(function (str) {
						var dialog = ui.create.dialog(str);
						dialog.classList.add('center');
						setTimeout(function () {
							dialog.close();
						}, 1000);
					}, str);
					game.delay(2);
					'step 6'
					game.broadcastAll(function () {
						ui.arena.classList.remove('thrownhighlight');
					});
					game.addVideo('thrownhighlight2');
					if (event.clear !== false) {
						game.broadcastAll(ui.clear);
					}
				},
				chooseToPSS: function () {
					'step 0'
					game.log(player, '对', target, '发起了猜拳');
					if (_status.connectMode) {
						player.chooseButtonOL([
							[player, ['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true],
							[target, ['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true]
						], function () { }, function () { return 1 + Math.random() }).set('switchToAuto', function () {
							_status.event.result = 'ai';
						}).set('processAI', function () {
							var buttons = _status.event.dialog.buttons;
							return {
								bool: true,
								links: [buttons.randomGet().link],
							}
						});
					}
					'step 1'
					if (_status.connectMode) {
						event.mes = result[player.playerid].links[0][2];
						event.tes = result[target.playerid].links[0][2];
						event.goto(4);
					}
					else {
						player.chooseButton(['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true).ai = function () { return 1 + Math.random() };
					}
					'step 2'
					event.mes = result.links[0][2];
					target.chooseButton(['猜拳：请选择一种手势', [[['', '', 'pss_stone'], ['', '', 'pss_scissor'], ['', '', 'pss_paper']], 'vcard']], true).ai = function () { return 1 + Math.random() };
					'step 3'
					event.tes = result.links[0][2];
					'step 4'
					game.broadcast(function () {
						ui.arena.classList.add('thrownhighlight');
					});
					ui.arena.classList.add('thrownhighlight');
					game.addVideo('thrownhighlight1');
					player.$compare(game.createCard(event.mes, '', ''), target, game.createCard(event.tes, '', ''));
					game.log(player, '选择的手势为', '#g' + get.translation(event.mes));
					game.log(target, '选择的手势为', '#g' + get.translation(event.tes));
					game.delay(0, 1500);
					'step 5'
					var mes = event.mes.slice(4);
					var tes = event.tes.slice(4);
					var str;
					if (mes == tes) {
						str = '二人平局';
						player.popup('平', 'metal');
						target.popup('平', 'metal');
						game.log('猜拳的结果为', '#g平局');
						event.result = { tie: true };
					}
					else {
						if ({ paper: 'stone', scissor: 'paper', stone: 'scissor' }[mes] == tes) {
							str = get.translation(player) + '胜利';
							player.popup('胜', 'wood');
							target.popup('负', 'fire');
							game.log(player, '#g胜');
							event.result = { bool: true };
						}
						else {
							str = get.translation(target) + '胜利';
							target.popup('胜', 'wood');
							player.popup('负', 'fire');
							game.log(target, '#g胜');
							event.result = { bool: false };
						}
					}
					game.broadcastAll(function (str) {
						var dialog = ui.create.dialog(str);
						dialog.classList.add('center');
						setTimeout(function () {
							dialog.close();
						}, 1000);
					}, str);
					game.delay(2);
					'step 6'
					game.broadcastAll(function () {
						ui.arena.classList.remove('thrownhighlight');
					});
					game.addVideo('thrownhighlight2');
					if (event.clear !== false) {
						game.broadcastAll(ui.clear);
					}
				},
				cardsDiscard: function () {
					game.getGlobalHistory().cardMove.push(event);
					for (var i = 0; i < cards.length; i++) {
						cards[i].discard();
					}
				},
				orderingDiscard: function () {
					var cards = event.relatedEvent.orderingCards;
					for (var i = 0; i < cards.length; i++) {
						if (get.position(cards[i], true) != 'o') cards.splice(i--, 1);
					}
					if (cards.length) game.cardsDiscard(cards);
				},
				cardsGotoOrdering: function () {
					game.getGlobalHistory().cardMove.push(event);
					for (var i = 0; i < cards.length; i++) {
						cards[i].fix();
						ui.ordering.appendChild(cards[i]);
					}
					var evt = event.relatedEvent || event.getParent();
					if (!evt.orderingCards) evt.orderingCards = [];
					if (!event.noOrdering && !event.cardsOrdered) {
						event.cardsOrdered = true;
						var next = game.createEvent('orderingDiscard', false, evt.getParent());
						next.relatedEvent = evt;
						next.setContent('orderingDiscard');
					}
					if (!event.noOrdering) evt.orderingCards.addArray(cards);
				},
				cardsGotoSpecial: function () {
					game.getGlobalHistory().cardMove.push(event);
					for (var i = 0; i < cards.length; i++) {
						cards[i].fix();
						ui.special.appendChild(cards[i]);
					}
					if (event.notrigger !== true) event.trigger('addCardToStorage');
				},
				chooseToEnable: function () {
					'step 0'
					var list = [];
					for (var i = 1; i < 6; i++) {
						if (!player.isDisabled(i)) continue;
						list.push('equip' + i);
					}
					if (!list.length) event.finish();
					else {
						event.list = list;
						var next = player.chooseControl(list);
						next.set('prompt', '请选择恢复一个装备栏');
						if (!event.ai) event.ai = function (event, player, list) {
							return list.randomGet();
						}
						event.ai = event.ai(event.getParent(), player, list);
						next.ai = function () {
							return event.ai;
						};
					}
					'step 1'
					event.result = { control: result.control };
					player.enableEquip(result.control);
				},
				chooseToDisable: function () {
					'step 0'
					var list = [];
					for (var i = 1; i < 7; i++) {
						if ((i == 3 || i == 4) && event.horse) continue;
						if (i == 6 && !event.horse) continue;
						if (player.isDisabled(i)) continue;
						list.push('equip' + i);
					}
					if (!list.length) event.finish();
					else {
						event.list = list;
						var next = player.chooseControl(list);
						next.set('prompt', '请选择废除一个装备栏');
						if (!event.ai) event.ai = function (event, player, list) {
							return list.randomGet();
						}
						event.ai = event.ai(event.getParent(), player, list);
						next.ai = function () {
							return event.ai;
						};
					}
					'step 1'
					event.result = { control: result.control };
					if (result.control == 'equip6') {
						player.disableEquip(3);
						player.disableEquip(4);
					}
					else player.disableEquip(result.control);
				},
				swapEquip: function () {
					"step 0"
					game.log(player, '和', target, '交换了装备区中的牌')
					var e1 = player.getCards('e');
					var todis1 = [];
					for (var i = 0; i < e1.length; i++) {
						if (target.isDisabled(get.subtype(e1[i]))) todis1.push(e1[i]);
					}
					player.discard(todis1);
					var e2 = target.getCards('e');
					var todis2 = [];
					for (var i = 0; i < e2.length; i++) {
						if (player.isDisabled(get.subtype(e2[i]))) todis1.push(e2[i]);
					}
					target.discard(todis2);
					"step 1"
					event.cards = [player.getCards('e'), target.getCards('e')];
					player.lose(event.cards[0], ui.ordering, 'visible');
					target.lose(event.cards[1], ui.ordering, 'visible');
					if (event.cards[0].length) player.$give(event.cards[0], target, false);
					if (event.cards[1].length) target.$give(event.cards[1], player, false);
					"step 2"
					for (var i = 0; i < event.cards[1].length; i++) {
						player.equip(event.cards[1][i]);
					}
					for (var i = 0; i < event.cards[0].length; i++) {
						target.equip(event.cards[0][i]);
					}
				},
				disableEquip: function () {
					if (!player.isDisabled(event.pos)) {
						var cards = player.getCards('e', function (card) {
							var subtype = get.subtype(card);
							if (subtype == event.pos) return true;
							if (subtype == 'equip6' && ['equip3', 'equip4'].contains(event.pos)) return true;
							return false;
						});
						if (cards.length) player.discard(cards).delay = false;
						game.log(player, '废除了', get.translation(event.pos), '栏');
						player.$disableEquip(event.pos);
					}
				},
				enableEquip: function () {
					if (player.isDisabled(event.pos)) {
						player.syncStorage('_disableEquip');
						game.log(player, '恢复了', get.translation(event.pos), '栏');
						player.$enableEquip(event.pos);
					};
				},
				disableJudge: function () {
					'step 0'
					game.log(player, '废除了判定区');
					var js = player.getCards('j');
					if (js.length) player.discard(js);
					player.storage._disableJudge = true;
					//player.markSkill('_disableJudge');
					'step 1'
					game.broadcastAll(function (player, card) {
						player.$disableJudge();
					}, player);
				},
				enableJudge: function () {
					if (!player.storage._disableJudge) return;
					game.log(player, '恢复了判定区');
					game.broadcastAll(function (player) {
						player.$enableJudge();
					}, player);
				},
				/*----分界线----*/
				phasing: function () {
					'step 0'
					while (ui.dialogs.length) {
						ui.dialogs[0].close();
					}
					if (!player.noPhaseDelay && lib.config.show_phase_prompt) {
						player.popup('回合开始');
					}
					if (lib.config.glow_phase) {
						if (_status.currentPhase) {
							_status.currentPhase.classList.remove('glow_phase');
							game.broadcast(function (player) {
								player.classList.remove('glow_phase');
							}, _status.currentPhase);
						}
						player.classList.add('glow_phase');
						game.broadcast(function (player) {
							player.classList.add('glow_phase');
						}, player);
					}
					_status.currentPhase = player;
					_status.discarded = [];
					game.phaseNumber++;
					player.phaseNumber++;
					game.syncState();
					game.addVideo('phaseChange', player);
					if (game.phaseNumber == 1 && lib.configOL.observe) {
						lib.configOL.observeReady = true;
						game.send('server', 'config', lib.configOL);
					}
					game.log();
					game.log(player, '的回合开始');
					player._noVibrate = true;
					if (get.config('identity_mode') != 'zhong' && get.config('identity_mode') != 'purple' && !_status.connectMode) {
						var num;
						switch (get.config('auto_identity')) {
							case 'one': num = 1; break;
							case 'two': num = 2; break;
							case 'three': num = 3; break;
							case 'always': num = -1; break;
							default: num = 0; break;
						}
						if (num && !_status.identityShown && game.phaseNumber > game.players.length * num && game.showIdentity) {
							if (!_status.video) player.popup('显示身份');
							_status.identityShown = true;
							game.showIdentity(false);
						}
					}
					player.ai.tempIgnore = [];
					_status.globalHistory.push({
						cardMove: [],
						custom: [],
					});
					game.countPlayer2(function (current) {
						current.actionHistory.push({ useCard: [], respond: [], skipped: [], lose: [], gain: [], sourceDamage: [], damage: [], custom: [] });
						current.stat.push({ card: {}, skill: {} });
						if (event.parent._roundStart) {
							current.getHistory().isRound = true;
							current.getStat().isRound = true;
						}
					});
					player.getHistory().isMe = true;
					player.getStat().isMe = true;
					if (event.parent._roundStart) {
						game.getGlobalHistory().isRound = true;
					}
					if (ui.land && ui.land.player == player) {
						game.addVideo('destroyLand');
						ui.land.destroy();
					}
					'step 1'
					event.trigger('phaseBeginStart');
				},
				toggleSubPlayer: function () {
					'step 0'
					var list = event.list || player.storage.subplayer.skills.slice(0);
					list.remove(player.storage.subplayer.name2);
					event.list = list;
					if (!event.directresult) {
						if (list.length > 1) {
							var dialog = ui.create.dialog('更换一个随从', 'hidden');
							dialog.add([list, 'character']);
							player.chooseButton(dialog, true);
						}
						else if (list.length == 1) {
							event.directresult = list[0];
						}
						else {
							event.finish();
						}
					}
					else {
						if (!list.contains(event.directresult)) {
							event.finish();
						}
					}
					'step 1'
					if (!event.directresult) {
						if (result && result.bool && result.links[0]) {
							event.directresult = result.links[0];
						}
						else {
							event.finish();
							return;
						}
					}
					if (player.storage.subplayer) {
						var current = player.storage.subplayer.name2;
						if (event.directresult == current) {
							event.finish();
							return;
						}
						player.storage[current].hp = player.hp;
						player.storage[current].maxHp = player.maxHp;
						player.storage[current].hs = player.getCards('h');
						player.storage[current].es = player.getCards('e');
						player.lose(player.getCards('he'), ui.special)._triggered = null;

						var cfg = player.storage[event.directresult];
						player.storage.subplayer.name2 = event.directresult;
						player.reinit(current, event.directresult, [
							cfg.hp,
							cfg.maxHp
						]);
						if (cfg.hs.length) player.directgain(cfg.hs);
						if (cfg.es.length) player.directequip(cfg.es);
					}
				},
				exitSubPlayer: function () {
					'step 0'
					if (player.storage.subplayer) {
						var current = player.storage.subplayer.name2;
						if (event.remove) {
							player.lose(player.getCards('he'), ui.discardPile)._triggered = null;
						}
						else {
							player.storage[current].hp = player.hp;
							player.storage[current].maxHp = player.maxHp;
							player.storage[current].hs = player.getCards('h');
							player.storage[current].es = player.getCards('e');
							player.lose(player.getCards('he'), ui.special)._triggered = null;
						}
						player.reinit(current, player.storage.subplayer.name, [
							player.storage.subplayer.hp,
							player.storage.subplayer.maxHp
						]);
						player.update();
						if (event.remove) {
							if (player.storage[current].onremove) {
								player.storage[current].onremove(player);
							}
							delete player.storage[current];
							player.storage.subplayer.skills.remove(current);
							game.log(player, '牺牲了随从', '#g' + current);
						}
						else {
							game.log(player, '收回了随从', '#g' + current);
						}
						player.addSkill(player.storage.subplayer.skills);
					}
					'step 1'
					if (player.storage.subplayer) {
						player.directgain(player.storage.subplayer.hs);
						player.directequip(player.storage.subplayer.es);
					}
					player.removeSkill('subplayer');
					'step 2'
					if (event.remove) {
						event.trigger('subPlayerDie');
					}
				},
				callSubPlayer: function () {
					'step 0'
					var list = player.getSubPlayers(event.tag);
					event.list = list;
					if (!event.directresult) {
						if (list.length > 1) {
							var dialog = ui.create.dialog('调遣一个随从', 'hidden');
							dialog.add([list, 'character']);
							player.chooseButton(dialog, true);
						}
						else if (list.length == 1) {
							event.directresult = list[0];
						}
						else {
							event.finish();
						}
					}
					else {
						if (!list.contains(event.directresult)) {
							event.finish();
						}
					}
					'step 1'
					if (!event.directresult) {
						if (result && result.bool && result.links[0]) {
							event.directresult = result.links[0];
						}
						else {
							event.finish();
							return;
						}
					}
					if (event.directresult) {
						var cfg = player.storage[event.directresult];
						var source = cfg.source || player.name;
						var name = event.directresult;
						game.log(player, '调遣了随从', '#g' + name);
						player.storage.subplayer = {
							name: source,
							name2: event.directresult,
							hp: player.hp,
							maxHp: player.maxHp,
							skills: event.list.slice(0),
							hs: player.getCards('h'),
							es: player.getCards('e'),
							intro2: cfg.intro2
						}
						player.removeSkill(event.list);
						player.reinit(source, name, [cfg.hp, cfg.maxHp]);
						player.addSkill('subplayer');
						player.lose(player.getCards('he'), ui.special)._triggered = null;
						if (cfg.hs.length) player.directgain(cfg.hs);
						if (cfg.es.length) player.directequip(cfg.es);
					}
					'step 2'
					game.delay();
				},
				reverseOrder: function () {
					"step 0"
					game.delay();
					"step 1"
					var choice;
					if (get.tag(card, 'multineg')) {
						choice = (player.previous.side == player.side) ? '逆时针' : '顺时针';
					}
					else {
						choice = (player.next.side == player.side) ? '逆时针' : '顺时针';
					}
					player.chooseControl('顺时针', '逆时针', function (event, player) {
						return _status.event.choice || '逆时针';
					}).set('prompt', '选择' + get.translation(card) + '的结算方向').set('choice', choice).set('forceDie', true);
					"step 2"
					if (result && result.control == '顺时针') {
						var evt = event.getParent();
						evt.fixedSeat = true;
						evt.targets.sortBySeat();
						evt.targets.reverse();
						if (evt.targets[evt.targets.length - 1] == player) {
							evt.targets.unshift(evt.targets.pop());
						}
					}
				},
				addJudgeCard: function () {
					if (lib.filter.judge(card, player, target) && cards.length && get.position(cards[0], true) == 'o') target.addJudge(card, cards);
				},
				equipCard: function () {
					if (cards.length && get.position(cards[0], true) == 'o') target.equip(cards[0]);
				},
				gameDraw: function () {
					"step 0"
					if (_status.brawl && _status.brawl.noGameDraw) {
						event.finish();
						return;
					}
					var end = player;
					var numx = num;
					do {
						if (typeof num == 'function') {
							numx = num(player);
						}
						player.directgain(get.cards(numx));
						if (player.singleHp === true && get.mode() != 'guozhan') {
							player.doubleDraw();
						}
						player = player.next;
					}
					while (player != end);
					event.changeCard = get.config('change_card');
					if (_status.connectMode || lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && lib.config.mode != 'doudizhu') {
						event.changeCard = 'disabled';
					}
					"step 1"
					if (event.changeCard != 'disabled' && !_status.auto) {
						event.dialog = ui.create.dialog('是否使用手气卡？');
						ui.create.confirm('oc');
						event.custom.replace.confirm = function (bool) {
							_status.event.bool = bool;
							game.resume();
						}
					}
					else {
						event.finish();
					}
					"step 2"
					if (event.changeCard == 'once') {
						event.changeCard = 'disabled';
					}
					else if (event.changeCard == 'twice') {
						event.changeCard = 'once';
					}
					else if (event.changeCard == 'disabled') {
						event.bool = false;
						return;
					}
					_status.imchoosing = true;
					event.switchToAuto = function () {
						_status.event.bool = false;
						game.resume();
					}
					game.pause();
					"step 3"
					_status.imchoosing = false;
					if (event.bool) {
						if (game.changeCoin) {
							game.changeCoin(-3);
						}
						var hs = game.me.getCards('h');
						game.addVideo('lose', game.me, [get.cardsInfo(hs), [], []]);
						for (var i = 0; i < hs.length; i++) {
							hs[i].discard(false);
						}
						game.me.directgain(get.cards(hs.length));
						event.goto(2);
					}
					else {
						if (event.dialog) event.dialog.close();
						if (ui.confirm) ui.confirm.close();
						event.finish();
					}
				},
				phaseLoop: function () {
					"step 0"
					for (var i = 0; i < lib.onphase.length; i++) {
						lib.onphase[i]();
					}
					player.phase();
					"step 1"
					if (!game.players.contains(event.player.next)) {
						event.player = game.findNext(event.player.next);
					}
					else {
						event.player = event.player.next;
					}
					event.goto(0);
				},
				loadPackage: function () {
					'step 0'
					if (event.packages.length) {
						window.game = game;
						var pack = event.packages.shift().split('/');
						lib.init.js(lib.assetURL + pack[0], pack[1], game.resume);
						game.pause();
					}
					else {
						event.finish();
					}
					'step 1'
					if (!lib.config.dev) delete window.game;
					var character = lib.imported.character;
					var card = lib.imported.card;
					var i, j, k;
					for (i in character) {
						if (character[i].character) {
							lib.characterPack[i] = character[i].character;
						}
						if (character[i].forbid && character[i].forbid.contains(lib.config.mode)) continue;
						if (character[i].mode && character[i].mode.contains(lib.config.mode) == false) continue;

						if (Array.isArray(lib[j]) && Array.isArray(character[i][j])) {
							lib[j].addArray(character[i][j]);
							continue;
						}
						for (j in character[i]) {
							if (j == 'mode' || j == 'forbid' || j == 'characterSort') continue;
							for (k in character[i][j]) {
								if (j == 'character') {
									if (!character[i][j][k][4]) {
										character[i][j][k][4] = [];
									}
									if (character[i][j][k][4].contains('boss') ||
										character[i][j][k][4].contains('hiddenboss')) {
										lib.config.forbidai.add(k);
									}
									if (lib.config.forbidai_user && lib.config.forbidai_user.contains(k)) {
										lib.config.forbidai.add(k);
									}
									for (var l = 0; l < character[i][j][k][3].length; l++) {
										lib.skilllist.add(character[i][j][k][3][l]);
									}
								}
								if (j == 'translate' && k == i) {
									lib[j][k + '_character_config'] = character[i][j][k];
								}
								else {
									if (lib[j][k] == undefined) {
										lib[j][k] = character[i][j][k];
									}
									else if (Array.isArray(lib[j][k]) && Array.isArray(character[i][j][k])) {
										lib[j][k].addArray(character[i][j][k]);
									}
									else {
										console.log('dublicate ' + j + ' in character ' + i + ':\n' + k + '\n' + ': ' + lib[j][k] + '\n' + character[i][j][k]);
									}
								}
							}
						}
					}
					for (i in card) {
						lib.cardPack[i] = [];
						if (card[i].card) {
							for (var j in card[i].card) {
								if (!card[i].card[j].hidden && card[i].translate[j + '_info']) {
									lib.cardPack[i].push(j);
								}
							}
						}
						for (j in card[i]) {
							if (j == 'mode' || j == 'forbid') continue;
							if (j == 'list') continue;
							for (k in card[i][j]) {
								if (j == 'skill' && k[0] == '_' && !lib.config.cards.contains(i)) {
									continue;
								}
								if (j == 'translate' && k == i) {
									lib[j][k + '_card_config'] = card[i][j][k];
								}
								else {
									if (lib[j][k] == undefined) lib[j][k] = card[i][j][k];
									else console.log('dublicate ' + j + ' in card ' + i + ':\n' + k + '\n' + lib[j][k] + '\n' + card[i][j][k]);
								}
							}
						}
					}
					event.goto(0);
				},
				loadMode: function () {
					'step 0'
					window.game = game;
					lib.init.js(lib.assetURL + 'mode', event.mode, game.resume);
					game.pause();
					'step 1'
					if (!lib.config.dev) delete window.game;
					event.result = lib.imported.mode[event.mode];
					delete lib.imported.mode[event.mode];
				},
				forceOver: function () {
					'step 0'
					while (ui.controls.length) {
						ui.controls[0].close();
					}
					while (ui.dialogs.length) {
						ui.dialogs[0].close();
					}
					'step 1'
					if (event.bool != 'noover') {
						game.over(event.bool);
					}
					if (event.callback) {
						event.callback();
					}
				},
				arrangeTrigger: function () {
					'step 0'
					event.filter1 = function (info) {
						if (info[1].isDead() && !lib.skill[info[0]].forceDie) return false;
						return lib.filter.filterTrigger(trigger, info[1], event.triggername, info[0]);
					}
					event.filter2 = function (info2) {
						var info = lib.skill[info2[0]];
						if (!lib.translate[info2[0]] || info.popup === false || info.silent) return false;
						return true;
					}
					event.filter3 = function (info, info2) {
						return event.filter2(info2) && event.filter1(info2) && info2[1] == info[1] && info[2] == info2[2] && (lib.skill.global.contains(info2[0]) || info[1].hasSkill(info2[0], true));
					}
					'step 1'
					if (trigger.filterStop && trigger.filterStop()) {
						event.finish();
					}
					else if (event.list.length) {
						var info = event.list.shift();
						game.createTrigger(event.triggername, info[0], info[1], trigger);
						event.redo();
					}
					'step 2'
					if (!event.map.length) {
						if (event.list2.length) {
							var info = event.list2.shift();
							game.createTrigger(event.triggername, info[0], info[1], trigger);
							event.redo();
						}
						else {
							if (trigger._triggering == this) {
								delete trigger._triggering;
							}
							event.finish();
							return;
						}
					};
					event.doing = event.map.shift();
					'step 3'
					event.num = 0;
					var bool = false;
					var list = event.doing.list;
					for (var i = 0; i < list.length; i++) {
						if (event.filter1(list[i])) {
							event.num = i;
							bool = true;
							break;
						}
					}
					if (!bool) { event.goto(2); return; }
					var priority = list[event.num][2];
					for (var i = 0; i < event.num; i++) {
						if (event.doing.list[i][2] > priority) {
							event.doing.list.splice(i--, 1);
							event.num--;
						}
					}
					event.choice = [];
					if (event.num < event.doing.list.length - 1 && event.filter2(event.doing.list[event.num])) {
						var current = event.doing.list[event.num];
						event.choice.push(current);
						for (var i = event.num + 1; i < event.doing.list.length; i++) {
							if (event.filter3(current, event.doing.list[i])) event.choice.push(event.doing.list[i]);
						}
					}
					if (event.choice.length < 2) event.goto(6);
					'step 4'
					var controls = [];
					event.current = event.choice[0][1]
					for (var i = 0; i < event.choice.length; i++) {
						controls.push(event.choice[i][0]);
					}
					event.current.chooseControl(controls).set('prompt', '选择下一个触发的技能').set('forceDie', true);
					'step 5'
					if (result.control) {
						for (var i = 0; i < event.doing.list.length; i++) {
							if (event.doing.list[i][0] == result.control && event.doing.list[i][1] == event.current) {
								event.num = i; break;
							}
						}
					}
					'step 6'
					var info = event.doing.list[event.num];
					if (info) {
						event.doing.list2.push(info);
						event.doing.list.splice(event.num, 1);
						game.createTrigger(event.triggername, info[0], info[1], trigger);
					}
					'step 7'
					if (trigger.filterStop && trigger.filterStop()) {
						event.finish();
					}
					else event.goto(event.doing.list.length ? 3 : 2);
				},
				createTrigger: function () {
					"step 0"
					if (lib.filter.filterTrigger(trigger, player, event.triggername, event.skill)) {
						var fullskills = game.expandSkills(player.getSkills().concat(lib.skill.global));
						if (!fullskills.contains(event.skill)) {
							var info = get.info(event.skill);
							var hidden = player.hiddenSkills.slice(0);
							game.expandSkills(hidden);
							if (hidden.contains(event.skill)) {
								if (!info.silent && player.hasSkillTag('nomingzhi', false, null, true)) {
									event.finish();
								}
								else if (!info.direct) {
									event.trigger('triggerHidden');
								}
								else {
									event.skillHidden = true;
								}
							}
							else {
								var keep = false;
								for (var i in player.additionalSkills) {
									if (i.indexOf('hidden:') == 0 && game.expandSkills(player.additionalSkills[i]).contains(event.skill)) {
										keep = true; break;
									}
								}
								if (!keep) {
									event.finish();
								}
							}
						}
					}
					else {
						event.finish();
					}
					"step 1"
					if (event.cancelled) {
						event.finish();
						return;
					}
					var info = get.info(event.skill);
					if (!event.revealed && !info.forced) {
						var checkFrequent = function (info) {
							if (player.hasSkillTag('nofrequent', false, event.skill)) return false;
							if (typeof info.frequent == 'boolean') return info.frequent;
							if (typeof info.frequent == 'function') return info.frequent(trigger, player);
							if (info.frequent == 'check' && typeof info.check == 'function') return info.check(trigger, player);
							return false;
						}
						if (info.direct && player.isUnderControl()) {
							game.swapPlayerAuto(player);
							event._result = { bool: true };
							event._direct = true;
						}
						else if (info.direct) {
							event._result = { bool: true };
							event._direct = true;
						}
						else if (info.direct && player.isOnline()) {
							event._result = { bool: true };
							event._direct = true;
						}
						else {
							if (checkFrequent(info)) {
								event.frequentSkill = true;
							}
							var str;
							var check = info.check;
							if (info.prompt) str = info.prompt;
							else {
								if (typeof info.logTarget == 'string') {
									str = get.prompt(event.skill, trigger[info.logTarget], player);
								}
								else if (typeof info.logTarget == 'function') {
									str = get.prompt(event.skill, info.logTarget(trigger, player), player);
								}
								else {
									str = get.prompt(event.skill, null, player);
								}
							}
							if (typeof str == 'function') { str = str(trigger, player) }
							var next = player.chooseBool(str);
							if (event.frequentSkill) next.set('frequentSkill', event.skill);
							next.set('forceDie', true);
							next.ai = function () {
								return !check || check(trigger, player);
							};
							if (typeof info.prompt2 == 'function') {
								next.set('prompt2', info.prompt2(trigger, player));
							}
							else if (typeof info.prompt2 == 'string') {
								next.set('prompt2', info.prompt2);
							}
							else if (info.prompt2 != false) {
								if (lib.dynamicTranslate[event.skill]) next.set('prompt2', lib.dynamicTranslate[event.skill](player, event.skill));
								else if (lib.translate[event.skill + '_info']) next.set('prompt2', lib.translate[event.skill + '_info']);
							}
							if (trigger.skillwarn) {
								if (next.prompt2) {
									next.set('prompt2', '<span class="thundertext">' + trigger.skillwarn + '。</span>' + next.prompt2);
								}
								else {
									next.set('prompt2', trigger.skillwarn);
								}
							}
						}
					}
					"step 2"
					var info = get.info(event.skill);
					if (result && result.bool != false) {
						var autodelay = info.autodelay;
						if (typeof autodelay == 'function') {
							autodelay = autodelay(trigger, player);
						}
						if (autodelay && (info.forced || !event.isMine())) {
							if (typeof autodelay == 'number') {
								game.delayx(autodelay);
							}
							else {
								game.delayx();
							}
						}
					}
					"step 3"
					var info = get.info(event.skill);
					if (result && result.bool == false) {
						if (info.oncancel) info.oncancel(trigger, player);
						event.finish();
						return;
					}
					var next = game.createEvent(event.skill);
					if (typeof info.usable == 'number') {
						player.addSkill('counttrigger');
						if (!player.storage.counttrigger) {
							player.storage.counttrigger = {};
						}
						if (!player.storage.counttrigger[event.skill]) {
							player.storage.counttrigger[event.skill] = 1;
						}
						else {
							player.storage.counttrigger[event.skill]++;
						}
					}
					next.player = player;
					next._trigger = trigger;
					next.triggername = event.triggername;
					next.setContent(info.content);
					next.skillHidden = event.skillHidden;
					if (info.forceDie) next.forceDie = true;
					if (info.popup != false && !info.direct) {
						if (info.popup) {
							player.popup(info.popup);
							game.log(player, '发动了', '【' + get.skillTranslation(event.skill, player) + '】');
						}
						else {
							if (info.logTarget && info.logLine !== false) {
								if (typeof info.logTarget == 'string') {
									player.logSkill(event.skill, trigger[info.logTarget], info.line);
								}
								else if (typeof info.logTarget == 'function') {
									player.logSkill(event.skill, info.logTarget(trigger, player), info.line);
								}
							}
							else {
								player.logSkill(event.skill, false, info.line);
							}
						}
					}
					"step 4"
					if (player._hookTrigger) {
						for (var i = 0; i < player._hookTrigger.length; i++) {
							var info = lib.skill[player._hookTrigger[i]].hookTrigger;
							if (info) {
								if (info.after && info.after(event, player, event.triggername)) {
									event.trigger('triggerAfter');
									break;
								}
							}
						}
					}
				},
				playVideoContent: function () {
					'step 0'
					game.delay(0, 500);
					'step 1'
					if (!game.chess) {
						ui.control.innerHTML = '';
						var nodes = [];
						for (var i = 0; i < ui.arena.childNodes.length; i++) {
							nodes.push(ui.arena.childNodes[i]);
						}
						for (var i = 0; i < nodes.length; i++) {
							if (nodes[i] == ui.canvas) continue;
							if (nodes[i] == ui.control) continue;
							if (nodes[i] == ui.mebg) continue;
							if (nodes[i] == ui.me) continue;
							if (nodes[i] == ui.roundmenu) continue;
							nodes[i].remove();
						}
						ui.sidebar.innerHTML = '';
						ui.cardPile.innerHTML = '';
						ui.discardPile.innerHTML = '';
						ui.special.innerHTML = '';
						ui.ordering.innerHTML = '';
					}
					ui.system.firstChild.innerHTML = '';
					ui.system.lastChild.innerHTML = '';
					ui.system.firstChild.appendChild(ui.config2);
					if (ui.updateVideoMenu) {
						ui.updateVideoMenu();
					}
					_status.videoDuration = 1;
					ui.create.system('返回', function () {
						var mode = localStorage.getItem(lib.configprefix + 'playbackmode');
						if (mode) {
							game.saveConfig('mode', mode);
						}
						game.reload();
					});
					ui.create.system('重播', function () {
						_status.replayvideo = true;
						game.playVideo(_status.playback, lib.config.mode);
					});
					ui.create.system('暂停', ui.click.pause, true).id = 'pausebutton';
					var slow = ui.create.system('减速', function () {
						_status.videoDuration *= 1.5;
						updateDuration();
					}, true);
					var fast = ui.create.system('加速', function () {
						_status.videoDuration /= 1.5;
						updateDuration();
					}, true);
					var updateDuration = function () {
						if (_status.videoDuration > 1) {
							slow.classList.add('glow');
						}
						else {
							slow.classList.remove('glow');
						}
						if (_status.videoDuration < 1) {
							fast.classList.add('glow');
						}
						else {
							fast.classList.remove('glow');
						}
					}
					ui.system.style.display = '';
					ui.refresh(ui.system);
					ui.system.show();
					ui.window.show();
					if (lib.config.mode != 'versus' && lib.config.mode != 'boss') {
						ui.arena.style.display = '';
						ui.refresh(ui.arena);
						ui.arena.show();
					}
					if (!game.chess) {
						game.playerMap = {};
					}
					game.finishCards();
					'step 2'
					if (event.video.length) {
						var content = event.video.shift();
						// console.log(content);
						if (content.type == 'delay') {
							game.delay(content.content);
						}
						else if (content.type == 'play') {
							window.play = {};
							if (!event.playtoload) {
								event.playtoload = 1;
							}
							else {
								event.playtoload++;
							}
							var script = lib.init.js(lib.assetURL + 'play', content.name);
							script.addEventListener('load', function () {
								var play = window.play[content.name]
								if (play && play.video) {
									play.video(content.init);
								}
								event.playtoload--;
								if (event.playtoload == 0) {
									delete window.play;
								}
							});
						}
						else if (typeof content.player == 'string' && game.playerMap[content.player] &&
							game.playerMap[content.player].classList &&
							!game.playerMap[content.player].classList.contains('obstacle')) {
							game.videoContent[content.type](game.playerMap[content.player], content.content);
						}
						else {
							game.videoContent[content.type](content.content);
						}
						if (event.video.length) {
							game.delay(0, _status.videoDuration * Math.min(2000, event.video[0].delay));
						}
						event.redo();
					}
					else {
						_status.over = true;
						ui.system.lastChild.hide();
						setTimeout(function () {
							ui.system.lastChild.innerHTML = '';
						}, 500);
					}
				},
				waitForPlayer: function () {
					'step 0'
					ui.auto.hide();
					ui.pause.hide();

					game.createServer();
					if (!lib.translate.zhu) {
						lib.translate.zhu = '主';
					}
					if (event.func) {
						event.func();
					}
					if (!lib.configOL.number) {
						lib.configOL.number = parseInt(lib.configOL.player_number);
					}
					if (game.onlineroom) {
						game.send('server', 'config', lib.configOL);
					}

					ui.create.connectPlayers(game.ip);
					if (!window.isNonameServer) {
						var me = game.connectPlayers[0];
						me.setIdentity('zhu');
						me.initOL(lib.config.connect_nickname, lib.config.connect_avatar);
						me.playerid = '1';
						game.onlinezhu = '1';
					}
					_status.waitingForPlayer = true;
					if (window.isNonameServer) {
						document.querySelector('#server_status').innerHTML = '等待中';
					}
					game.pause();
					'step 1'
					_status.waitingForPlayer = false;
					lib.configOL.gameStarted = true;
					if (window.isNonameServer) {
						document.querySelector('#server_status').innerHTML = '游戏中';
					}
					if (game.onlineroom) {
						game.send('server', 'config', lib.configOL);
					}
					for (var i = 0; i < game.connectPlayers.length; i++) {
						game.connectPlayers[i].delete();
					}
					delete game.connectPlayers;
					if (ui.roomInfo) {
						ui.roomInfo.remove();
						delete ui.roomInfo;
					}
					if (ui.exitroom) {
						ui.exitroom.remove();
						delete ui.exitroom;
					}
					game.broadcast('gameStart');
					game.delay(2);
					ui.auto.show();
					ui.pause.show();
					if (lib.config.show_cardpile) {
						ui.cardPileButton.style.display = '';
					}
				},
				replaceHandcards: function () {
					'step 0'
					if (event.players.contains(game.me)) {
						game.me.chooseBool('是否置换手牌？');
					}
					else {
						event.finish();
					}
					'step 1'
					if (result && result.bool) {
						var hs = game.me.getCards('h')
						for (var i = 0; i < hs.length; i++) {
							hs[i].discard(false);
						}
						game.me.directgain(get.cards(hs.length));
					}
				},
				replaceHandcardsOL: function () {
					'step 0'
					var send = function () {
						game.me.chooseBool('是否置换手牌？');
						game.resume();
					};
					var sendback = function (result, player) {
						if (result && result.bool) {
							var hs = player.getCards('h')
							game.broadcastAll(function (player, hs) {
								game.addVideo('lose', player, [get.cardsInfo(hs), [], []]);
								for (var i = 0; i < hs.length; i++) {
									hs[i].discard(false);
								}
							}, player, hs);
							player.directgain(get.cards(hs.length));
						}
					};
					for (var i = 0; i < event.players.length; i++) {
						if (event.players[i].isOnline()) {
							event.withol = true;
							event.players[i].send(send);
							event.players[i].wait(sendback);
						}
						else if (event.players[i] == game.me) {
							event.withme = true;
							game.me.chooseBool('是否置换手牌？');
							game.me.wait(sendback);
						}
					}
					'step 1'
					if (event.withme) {
						game.me.unwait(result);
					}
					'step 2'
					if (event.withol && !event.resultOL) {
						game.pause();
					}
				},
				phase: function () {
					"step 0"
					player.phaseZhunbei();
					"step 1"
					player.phaseJudge();
					"step 2"
					player.phaseDraw();
					if (!player.noPhaseDelay) {
						if (player == game.me) {
							game.delay();
						}
						else {
							game.delayx();
						}
					}
					"step 3"
					player.phaseUse();
					"step 4"
					game.broadcastAll(function () {
						if (ui.tempnowuxie) {
							ui.tempnowuxie.close();
							delete ui.tempnowuxie;
						}
					});
					player.phaseDiscard()
					if (!player.noPhaseDelay) game.delayx();
					//delete player.using;
					delete player._noSkill;
					"step 5"
					player.phaseJieshu();
				},
				phaseJudge: function () {
					"step 0"
					event.cards = player.getCards('j');
					if (!event.cards.length) event.finish();
					"step 1"
					if (cards.length && player.getCards('j').contains(cards[0])) {
						event.card = cards.shift();
						if (event.card.classList.contains('removing')) {
							event.card.remove();
							delete event.card;
							event.redo();
						}
						else if (event.card.classList.contains('feichu')) {
							event.finish();
							return;
						}
						else {
							player.lose(event.card, 'visible', ui.ordering);
							player.$phaseJudge(event.card);
							event.cancelled = false;
							event.trigger('phaseJudge');
							var name = event.card.viewAs || event.card.name;
							player.popup(name, 'thunder');
							if (!lib.card[name].effect) {
								game.delay();
								event.redo();
							}
							else if (!lib.card[name].judge) {
								game.delay();
								event.nojudge = true;
							}
						}
					}
					else event.finish();
					"step 2"
					if (!event.cancelled && !event.nojudge) player.judge(event.card).set('type', 'phase');
					"step 3"
					var name = event.card.viewAs || event.card.name;
					if (event.cancelled && !event.direct) {
						if (lib.card[name].cancel) {
							var next = game.createEvent(name + 'Cancel');
							next.setContent(lib.card[name].cancel);
							next.card = event.card;
							next.cards = [event.card];
							next.player = player;
						}
					}
					else {
						var next = game.createEvent(name);
						next.setContent(lib.card[name].effect);
						next._result = result;
						next.card = event.card;
						next.cards = [event.card];
						next.player = player;
					}
					ui.clear();
					event.goto(1);
				},
				phaseDraw: function () {
					"step 0"
					event.trigger("phaseDrawBegin1");
					"step 1"
					event.trigger("phaseDrawBegin2");
					"step 2"
					if (game.modPhaseDraw) {
						game.modPhaseDraw(player, event.num);
					}
					else {
						if (event.num > 0) {
							var num = event.num;
							if (event.attachDraw) {
								for (var i = 0; i < event.attachDraw.length; i++) {
									ui.cardPile.insertBefore(event.attachDraw[i], ui.cardPile.firstChild);
								}
								num += event.attachDraw.length;
							}
							var next = player.draw(num);
							if (event.attachDraw) {
								next.minnum = event.attachDraw.length;
							}
						}
					}
					"step 3"
					if (Array.isArray(result)) {
						event.cards = result;
					}
				},
				phaseUse: function () {
					"step 0";
					var next = player.chooseToUse();
					if (!lib.config.show_phaseuse_prompt) {
						next.set('prompt', false);
					}
					next.set('type', 'phase');
					"step 1"
					if (result.bool && !event.skipped) {
						event.goto(0);
					}
					game.broadcastAll(function () {
						if (ui.tempnowuxie) {
							ui.tempnowuxie.close();
							delete ui.tempnowuxie;
						}
					});
					"step 2"
					var stat = player.getStat();
					for (var i in stat.skill) {
						var bool = false;
						var info = lib.skill[i];
						if (!info) continue;
						if (info.enable != undefined) {
							if (typeof info.enable == 'string' && info.enable == 'phaseUse') bool = true;
							else if (typeof info.enable == 'object' && info.enable.contains('phaseUse')) bool = true;
						}
						if (bool) stat.skill[i] = 0;
					}
					for (var i in stat.card) {
						var bool = false;
						var info = lib.card[i];
						if (!info) continue;
						if (info.updateUsable == 'phaseUse') stat.card[i] = 0;
					}
				},
				phaseDiscard: function () {
					"step 0"
					event.num = player.needsToDiscard();
					if (event.num <= 0) event.finish();
					else {
						if (lib.config.show_phase_prompt) {
							player.popup('弃牌阶段');
						}
					}
					event.trigger('phaseDiscard');
					"step 1"
					player.chooseToDiscard(num, true);
					"step 2"
					event.cards = result.cards;
				},
				chooseToUse: function () {
					"step 0"
					if (event.responded) return;
					if (game.modeSwapPlayer && !_status.auto && player.isUnderControl() && !lib.filter.wuxieSwap(event)) {
						game.modeSwapPlayer(player);
					}
					var skills = player.getSkills(true);
					game.expandSkills(skills);
					for (var i = 0; i < skills.length; i++) {
						var info = lib.skill[skills[i]];
						if (info && info.onChooseToUse) {
							info.onChooseToUse(event);
						}
					}
					_status.noclearcountdown = true;
					if (event.type == 'phase') {
						if (event.isMine()) {
							event.endButton = ui.create.control('结束回合', 'stayleft', function () {
								if (_status.event.skill) {
									ui.click.cancel();
								}
								ui.click.cancel();
							});
							event.fakeforce = true;
						}
						else {
							if (event.endButton) {
								event.endButton.close();
								delete event.endButton;
							}
							event.fakeforce = false;
						}
					}
					if (event.player.isUnderControl() && !_status.auto) {
						event.result = {
							bool: false
						}
						return;
					}
					else if (event.isMine()) {
						if (event.type == 'wuxie') {
							if (ui.tempnowuxie) {
								var triggerevent = event.getTrigger();
								if (triggerevent && triggerevent.targets && triggerevent.num == triggerevent.targets.length - 1) {
									ui.tempnowuxie.close();
								}
							}
							if (lib.filter.wuxieSwap(event)) {
								event.result = {
									bool: false
								}
								return;
							}
						}
						var ok = game.check();
						if (!ok || !lib.config.auto_confirm) {
							game.pause();
							if (lib.config.enable_vibrate && player._noVibrate) {
								delete player._noVibrate;
								game.vibrate();
							}
						}
						if (!ok) {
							if (typeof event.prompt == 'string') {
								if (event.openskilldialog) {
									event.skillDialog = ui.create.dialog(event.openskilldialog);
									delete event.openskilldialog;
									event.dialog = event.prompt;
								}
								else {
									event.dialog = ui.create.dialog(event.prompt);
									if (event.prompt2) {
										event.dialog.addText(event.prompt2);
									}
								}
							}
							else if (event.prompt == 'function') {
								event.dialog = ui.create.dialog(event.prompt(event));
							}
							else if (event.prompt == undefined) {
								var str;
								if (typeof event.filterCard == 'object') {
									var filter = event.filterCard;
									str = '请使用' + get.cnNumber(event.selectCard[0]) + '张'
									if (filter.name) {
										str += get.translation(filter.name);
									}
									else {
										str += '牌';
									}
								}
								else {
									str = '请选择要使用的牌';
								}
								if (event.openskilldialog) {
									event.skillDialog = ui.create.dialog(event.openskilldialog);
									delete event.openskilldialog;
									event.dialog = str;
								}
								else if (typeof event.skillDialog != 'string') {
									event.dialog = ui.create.dialog(str);
								}
								else {
									event.dialog = str;
								}
							}
						}
					}
					else if (event.isOnline()) {
						event.send();
					}
					else {
						event.result = 'ai';
					}
					"step 1"
					if (event.result == 'ai') {
						var ok = game.check();
						if (ok) {
							ui.click.ok();
						}
						else if (ai.basic.chooseCard(event.ai1)) {
							if (ai.basic.chooseTarget(event.ai2)) {
								ui.click.ok();
								event._aiexcludeclear = true;
							}
							else {
								if (!event.norestore) {
									if (event.skill) {
										var skill = event.skill;
										ui.click.cancel();
										event._aiexclude.add(skill);
										var info = get.info(skill);
										if (info.sourceSkill) {
											event._aiexclude.add(info.sourceSkill);
										}
									}
									else {
										get.card(true).aiexclude();
										game.uncheck();
									}
									event.redo();
									game.resume();
								}
								else {
									ui.click.cancel();
								}
							}
						}
						else if (event.skill && !event.norestore) {
							var skill = event.skill;
							ui.click.cancel();
							event._aiexclude.add(skill);
							var info = get.info(skill);
							if (info.sourceSkill) {
								event._aiexclude.add(info.sourceSkill);
							}
							event.redo();
							game.resume();
						}
						else {
							ui.click.cancel();
						}
						if (event.aidelay && event.result && event.result.bool) {
							game.delayx();
						}
					}
					"step 2"
					if (event.endButton) {
						event.endButton.close();
						delete event.endButton;
					}
					event.resume();
					if (event.result) {
						if (event.result.skill) {
							var info = get.info(event.result.skill);
							if (info && info.chooseButton) {
								if (event.dialog && typeof event.dialog == 'object') event.dialog.close();
								var dialog = info.chooseButton.dialog(event, player);
								if (info.chooseButton.chooseControl) {
									var next = player.chooseControl(info.chooseButton.chooseControl(event, player));
									next.dialog = dialog;
									next.set('ai', info.chooseButton.check || function () { return 0; });
								}
								else {
									var next = player.chooseButton(dialog);
									next.set('ai', info.chooseButton.check || function () { return 1; });
									next.set('filterButton', info.chooseButton.filter || function () { return true; });
									next.set('selectButton', info.chooseButton.select || 1);
								}
								event.buttoned = event.result.skill;
							}
							else if (info && info.precontent && !game.online) {
								var next = game.createEvent('pre_' + event.result.skill);
								next.setContent(info.precontent);
								next.set('result', event.result);
								next.set('player', player);
							}
						}
					}
					"step 3"
					if (event.buttoned) {
						if (result.bool || result.control && result.control != 'cancel2') {
							var info = get.info(event.buttoned).chooseButton;
							lib.skill[event.buttoned + '_backup'] = info.backup(info.chooseControl ? result : result.links, player);
							lib.skill[event.buttoned + '_backup'].sourceSkill = event.buttoned;
							if (game.online) {
								event._sendskill = [event.buttoned + '_backup', lib.skill[event.buttoned + '_backup']];
							}
							event.backup(event.buttoned + '_backup');
							if (info.prompt) {
								event.openskilldialog = info.prompt(result.links, player);
							}
						}
						else {
							ui.control.animate('nozoom', 100);
							event._aiexclude.add(event.buttoned);
						}
						event.goto(0);
						delete event.buttoned;
					}
					"step 4"
					if (event._aiexcludeclear) {
						delete event._aiexcludeclear;
						event._aiexclude.length = 0;
					}
					delete _status.noclearcountdown;
					if (event.skillDialog && get.objtype(event.skillDialog) == 'div') {
						event.skillDialog.close();
					}
					if (event.result && event.result.bool && !game.online && !event.nouse) {
						player.useResult(event.result, event);
					}
					else if (event._sendskill) {
						event.result._sendskill = event._sendskill;
					}
					if (event.dialog && typeof event.dialog == 'object') event.dialog.close();
					if (!_status.noclearcountdown) {
						game.stopCountChoose();
					}
					"step 5"
					if (event._result && event.result) {
						event.result.result = event._result;
					}
				},
				chooseToRespond: function () {
					"step 0"
					if (event.responded) {
						delete event.dialog;
						return;
					}
					if (!_status.connectMode && lib.config.skip_shan && event.autochoose && event.autochoose()) {
						event.result = { bool: false };
					}
					else {
						// &&!lib.filter.wuxieSwap(trigger)
						if (game.modeSwapPlayer && !_status.auto && player.isUnderControl()) {
							game.modeSwapPlayer(player);
						}
						game.check();
						if (event.isMine()) {
							game.pause();
							if (event.dialog) event.dialog = ui.create.dialog(event.dialog);
							if (event.prompt2) event.dialog.addText(event.prompt2);
						}
						else if (event.isOnline()) {
							event.send();
						}
						else {
							event.result = 'ai';
						}
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseCard(event.ai) || forced) {
							ui.click.ok();
						}
						else if (event.skill) {
							var skill = event.skill;
							ui.click.cancel();
							event._aiexclude.add(skill);
							event.redo();
							game.resume();
						}
						else {
							ui.click.cancel();
						}
					}
					"step 2"
					event.resume();
					if (event.result.bool && !game.online) {
						var info = get.info(event.result.skill);
						if (info && info.prerespond) {
							info.prerespond(event.result, player);
						}
						var next = player.respond(event.result.cards, event.result.card, event.animate, event.result.skill, event.source);
						if (event.result.noanimate) next.animate = false;
						if (event.parent.card && event.parent.type == 'card') {
							next.set('respondTo', [event.parent.player, event.parent.card]);
						}
						if (event.noOrdering) next.noOrdering = true;
					}
					if (event.dialog && event.dialog.close) event.dialog.close();
				},
				chooseToDiscard: function () {
					"step 0"
					if (event.autochoose()) {
						event.result = {
							bool: true,
							autochoose: true,
							cards: player.getCards(event.position),
							rawcards: player.getCards(event.position),
						}
						for (var i = 0; i < event.result.cards.length; i++) {
							if (!lib.filter.cardDiscardable(event.result.cards[i], player, event)) {
								event.result.cards.splice(i--, 1);
							}
						}
					}
					else {
						// &&!lib.filter.wuxieSwap(trigger)
						if (game.modeSwapPlayer && !_status.auto && player.isUnderControl()) {
							game.modeSwapPlayer(player);
						}
						event.rangecards = player.getCards(event.position);
						for (var i = 0; i < event.rangecards.length; i++) {
							if (lib.filter.cardDiscardable(event.rangecards[i], player, event)) {
								event.rangecards.splice(i--, 1);
							}
							else {
								event.rangecards[i].uncheck('chooseToDiscard');
							}
						}
						var range = get.select(event.selectCard);
						game.check();
						if (event.isMine()) {
							game.pause();
							if (range[1] > 1 && typeof event.selectCard != 'function') {
								event.promptdiscard = ui.create.control('提示', function () {
									ai.basic.chooseCard(event.ai);
									if (_status.event.custom.add.card) {
										_status.event.custom.add.card();
									}
									for (var i = 0; i < ui.selected.cards.length; i++) {
										ui.selected.cards[i].updateTransform(true);
									}
								});
							}
							if (Array.isArray(event.dialog)) {
								event.dialog = ui.create.dialog.apply(this, event.dialog);
								event.dialog.open();
								event.dialog.classList.add('noselect');
							}
							else if (event.prompt != false) {
								var str;
								if (typeof (event.prompt) == 'string') str = event.prompt;
								else {
									str = '请弃置';
									if (range[0] == range[1]) str += get.cnNumber(range[0]);
									else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
									else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
									str += '张';
									if (event.position == 'h' || event.position == undefined) str += '手';
									if (event.position == 'e') str += '装备';
									str += '牌';
								}
								event.dialog = ui.create.dialog(str);
								if (event.prompt2) {
									event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
								}
								if (Array.isArray(event.selectCard)) {
									event.promptbar = event.dialog.add('0/' + get.numStr(event.selectCard[1], 'card'));
									event.custom.add.card = function () {
										_status.event.promptbar.innerHTML =
											ui.selected.cards.length + '/' + get.numStr(_status.event.selectCard[1], 'card');
									}
								}
							}
							else if (get.itemtype(event.dialog) == 'dialog') {
								event.dialog.style.display = '';
								event.dialog.open();
							}
						}
						else if (event.isOnline()) {
							event.send();
						}
						else {
							event.result = 'ai';
						}
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseCard(event.ai) || forced) {
							ui.click.ok();
						}
						else if (event.skill) {
							var skill = event.skill;
							ui.click.cancel();
							event._aiexclude.add(skill);
							event.redo();
							game.resume();
						}
						else {
							ui.click.cancel();
						}
					}
					if (event.rangecards) {
						for (var i = 0; i < event.rangecards.length; i++) {
							event.rangecards[i].recheck('chooseToDiscard');
						}
					}
					"step 2"
					event.resume();
					if (event.promptdiscard) {
						event.promptdiscard.close();
					}
					"step 3"
					if (event.result.bool && event.result.cards && event.result.cards.length &&
						!game.online && event.autodelay && !event.isMine()) {
						if (typeof event.autodelay == 'number') {
							game.delayx(event.autodelay);
						}
						else {
							game.delayx();
						}
					}
					"step 4"
					if (event.logSkill && event.result.bool && !game.online) {
						if (typeof event.logSkill == 'string') {
							player.logSkill(event.logSkill);
						}
						else if (Array.isArray(event.logSkill)) {
							player.logSkill.apply(player, event.logSkill);
						}
					}
					if (!game.online) {
						if (typeof event.delay == 'boolean') {
							event.done = player.discard(event.result.cards).set('delay', event.delay);
						}
						else {
							event.done = player.discard(event.result.cards);
						}
					}
					if (event.dialog && event.dialog.close) event.dialog.close();
				},
				chooseToCompareMultiple: function () {
					"step 0"
					if (player.countCards('h') == 0) {
						event.result = { cancelled: true, bool: false }
						event.finish();
						return;
					}
					for (var i = 0; i < targets.length; i++) {
						if (targets[i].countCards('h') == 0) {
							event.result = { cancelled: true, bool: false }
							event.finish();
							return;
						}
					}
					if (!event.multitarget) {
						targets.sort(lib.sort.seat);
					}
					game.log(player, '对', targets, '发起拼点');
					"step 1"
					event._result = [];
					event.list = targets.filter(function (current) {
						return !event.fixedResult || !event.fixedResult[current.playerid];
					});
					if (event.list.length || !event.fixedResult || !event.fixedResult[player.playerid]) {
						if (!event.fixedResult || !event.fixedResult[player.playerid]) event.list.unshift(player);
						player.chooseCardOL(event.list, '请选择拼点牌', true).set('type', 'compare').set('ai', event.ai).set('source', player).aiCard = function (target) {
							var hs = target.getCards('h');
							var event = _status.event;
							event.player = target;
							hs.sort(function (a, b) {
								return event.ai(b) - event.ai(a);
							});
							delete event.player;
							return { bool: true, cards: [hs[0]] };
						};
					}
					"step 2"
					var cards = [];
					if (event.fixedResult && event.fixedResult[player.playerid]) {
						event.list.unshift(player);
						result.unshift({ bool: true, cards: [event.fixedResult[player.playerid]] });
					}
					else {
						if (result[0].skill && lib.skill[result[0].skill] && lib.skill[result[0].skill].onCompare) {
							player.logSkill(result[0].skill);
							result[0].cards = lib.skill[result[0].skill].onCompare(player)
						}
					};
					player.lose(result[0].cards, ui.ordering);
					for (var j = 0; j < targets.length; j++) {
						if (event.list.contains(targets[j])) {
							var i = event.list.indexOf(targets[j]);
							if (result[i].skill && lib.skill[result[i].skill] && lib.skill[result[i].skill].onCompare) {
								event.list[i].logSkill(result[i].skill);
								result[i].cards = lib.skill[result[i].skill].onCompare(event.list[i]);
							}
							event.list[i].lose(result[i].cards, ui.ordering);
							cards.push(result[i].cards[0]);
						}
						else if (event.fixedResult && event.fixedResult[targets[j].playerid]) {
							targets[j].lose(event.fixedResult[targets[j].playerid], ui.ordering);
							cards.push(event.fixedResult[targets[j].playerid]);
						}
					}
					event.cardlist = cards;
					event.cards = cards;
					event.card1 = result[0].cards[0];
					event.num1 = event.card1.number;
					event.iwhile = 0;
					event.result = {
						player: event.card1,
						targets: event.cardlist.slice(0),
						num1: [],
						num2: [],
					};
					game.log(player, '的拼点牌为', event.card1);
					"step 3"
					if (event.iwhile < targets.length) {
						event.target = targets[event.iwhile];
						event.target.animate('target');
						player.animate('target');
						event.card2 = event.cardlist[event.iwhile];
						event.num2 = event.card2.number;
						game.log(event.target, '的拼点牌为', event.card2);
						player.line(event.target);
						player.$compare(event.card1, event.target, event.card2);
						event.trigger('compare');
						game.delay(0, 1500);
					}
					else {
						event.goto(7);
					}
					"step 4"
					event.result.num1[event.iwhile] = event.num1;
					event.result.num2[event.iwhile] = event.num2;
					var str;
					if (event.num1 > event.num2) {
						str = get.translation(player) + '拼点成功';
						player.popup('胜');
						target.popup('负');
					}
					else {
						str = get.translation(player) + '拼点失败';
						if (event.num1 == event.num2) {
							player.popup('平');
							target.popup('平');
						}
						else {
							player.popup('负');
							target.popup('胜');
						}
					}
					game.broadcastAll(function (str) {
						var dialog = ui.create.dialog(str);
						dialog.classList.add('center');
						setTimeout(function () {
							dialog.close();
						}, 1000);
					}, str);
					game.delay(2);
					"step 5"
					if (event.callback) {
						game.broadcastAll(function (card1, card2) {
							if (card1.clone) card1.clone.style.opacity = 0.5;
							if (card2.clone) card2.clone.style.opacity = 0.5;
						}, event.card1, event.card2);
						var next = game.createEvent('compareMultiple');
						next.player = player;
						next.target = event.target;
						next.card1 = event.card1;
						next.card2 = event.card2;
						next.num1 = event.num1;
						next.num2 = event.num2;
						next.setContent(event.callback);
					}
					"step 6"
					game.broadcastAll(ui.clear);
					event.iwhile++;
					event.goto(3);
					"step 7"
					event.cards.add(event.card1);
				},
				chooseToCompare: function () {
					"step 0"
					if (player.countCards('h') == 0 || target.countCards('h') == 0) {
						event.result = { cancelled: true, bool: false }
						event.finish();
						return;
					}
					game.log(player, '对', target, '发起拼点');
					"step 1"
					var sendback = function () {
						if (_status.event != event) {
							return function () {
								event.resultOL = _status.event.resultOL;
							};
						}
					};
					if (event.fixedResult && event.fixedResult[player.playerid]) event.card1 = event.fixedResult[player.playerid];
					else if (player.isOnline()) {
						player.wait(sendback);
						event.ol = true;
						player.send(function (ai) {
							game.me.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = ai;
							game.resume();
						}, event.ai);
					}
					else {
						event.localPlayer = true;
						player.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = event.ai;
					}
					if (event.fixedResult && event.fixedResult[target.playerid]) event.card2 = event.fixedResult[target.playerid];
					else if (target.isOnline()) {
						target.wait(sendback);
						event.ol = true;
						target.send(function (ai) {
							game.me.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = ai;
							game.resume();
						}, event.ai);
					}
					else {
						event.localTarget = true;
					}
					"step 2"
					if (event.localPlayer) {
						if (result.skill && lib.skill[result.skill] && lib.skill[result.skill].onCompare) {
							result.cards = lib.skill[result.skill].onCompare(player);
							player.logSkill(result.skill);
						}
						event.card1 = result.cards[0];
					}
					if (event.localTarget) {
						target.chooseCard('请选择拼点牌', true).set('type', 'compare').set('glow_result', true).ai = event.ai;
					}
					"step 3"
					if (event.localTarget) {
						if (result.skill && lib.skill[result.skill] && lib.skill[result.skill].onCompare) {
							target.logSkill(result.skill);
							result.cards = lib.skill[result.skill].onCompare(target);
						}
						event.card2 = result.cards[0];
					}
					if (!event.resultOL && event.ol) {
						game.pause();
					}
					"step 4"
					try {
						if (!event.card1) {
							if (event.resultOL[player.playerid].skill && lib.skill[event.resultOL[player.playerid].skill] && lib.skill[event.resultOL[player.playerid].skill].onCompare) {
								player.logSkill(event.resultOL[player.playerid].skill);
								event.resultOL[player.playerid].cards = lib.skill[event.resultOL[player.playerid].skill].onCompare(player);
							}
							event.card1 = event.resultOL[player.playerid].cards[0]
						};
						if (!event.card2) {
							if (event.resultOL[target.playerid].skill && lib.skill[event.resultOL[target.playerid].skill] && lib.skill[event.resultOL[target.playerid].skill].onCompare) {
								target.logSkill(event.resultOL[target.playerid].skill);
								event.resultOL[target.playerid].cards = lib.skill[event.resultOL[target.playerid].skill].onCompare(player);
							}
							event.card2 = event.resultOL[target.playerid].cards[0];
						}
						if (!event.card1 || !event.card2) {
							throw ('err');
						}
					}
					catch (e) {
						console.log(e);
						game.print(e);
						event.finish();
						return;
					}
					if (event.card2.number >= 10 || event.card2.number <= 4) {
						if (target.countCards('h') > 2) {
							event.addToAI = true;
						}
					}
					player.lose(event.card1, ui.ordering);
					target.lose(event.card2, ui.ordering);
					"step 5"
					game.broadcast(function () {
						ui.arena.classList.add('thrownhighlight');
					});
					ui.arena.classList.add('thrownhighlight');
					game.addVideo('thrownhighlight1');
					player.$compare(event.card1, target, event.card2);
					game.log(player, '的拼点牌为', event.card1);
					game.log(target, '的拼点牌为', event.card2);
					event.num1 = event.card1.number;
					event.num2 = event.card2.number;
					event.trigger('compare');
					game.delay(0, 1500);
					"step 6"
					event.result = {
						player: event.card1,
						target: event.card2,
						num1: event.num1,
						num2: event.num2
					}
					var str;
					if (event.num1 > event.num2) {
						event.result.bool = true;
						event.result.winner = player;
						str = get.translation(player) + '拼点成功';
						player.popup('胜');
						target.popup('负');
					}
					else {
						event.result.bool = false;
						str = get.translation(player) + '拼点失败';
						if (event.num1 == event.num2) {
							event.result.tie = true;
							player.popup('平');
							target.popup('平');
						}
						else {
							event.result.winner = target;
							player.popup('负');
							target.popup('胜');
						}
					}
					game.broadcastAll(function (str) {
						var dialog = ui.create.dialog(str);
						dialog.classList.add('center');
						setTimeout(function () {
							dialog.close();
						}, 1000);
					}, str);
					game.delay(2);
					"step 7"
					if (typeof event.target.ai.shown == 'number' && event.target.ai.shown <= 0.85 && event.addToAI) {
						event.target.ai.shown += 0.1;
					}
					game.broadcastAll(function () {
						ui.arena.classList.remove('thrownhighlight');
					});
					game.addVideo('thrownhighlight2');
					if (event.clear !== false) {
						game.broadcastAll(ui.clear);
					}
					if (typeof event.preserve == 'function') {
						event.preserve = event.preserve(event.result);
					}
					else if (event.preserve == 'win') {
						event.preserve = event.result.bool;
					}
					else if (event.preserve == 'lose') {
						event.preserve = !event.result.bool;
					}
				},
				chooseSkill: function () {
					'step 0'
					var list;
					if (typeof event.target == 'string') {
						list = get.gainableSkillsName(event.target, event.func);
					}
					else {
						list = event.target.getGainableSkills(event.func);
					}
					if (!list.length) {
						event.finish();
						event.result = { bool: false };
						return;
					}
					event.skillai = function (list) {
						return get.max(list, get.skillRank, 'item');
					};
					if (event.isMine()) {
						var dialog = ui.create.dialog('forcebutton');
						dialog.add(event.prompt || '选择获得一项技能');
						_status.event.list = list;
						var clickItem = function () {
							_status.event._result = this.link;
							game.resume();
						};
						for (i = 0; i < list.length; i++) {
							if (lib.translate[list[i] + '_info']) {
								var translation = get.translation(list[i]);
								if (translation[0] == '新' && translation.length == 3) {
									translation = translation.slice(1, 3);
								}
								else {
									translation = translation.slice(0, 2);
								}
								var item = dialog.add('<div class="popup pointerdiv" style="width:80%;display:inline-block"><div class="skill">【' +
									translation + '】</div><div>' + lib.translate[list[i] + '_info'] + '</div></div>');
								item.firstChild.addEventListener('click', clickItem);
								item.firstChild.link = list[i];
							}
						}
						dialog.add(ui.create.div('.placeholder'));
						event.dialog = dialog;
						event.switchToAuto = function () {
							event._result = event.skillai(event.list);
							game.resume();
						};
						_status.imchoosing = true;
						game.pause();
					}
					else {
						event._result = event.skillai(list);
					}
					'step 1'
					_status.imchoosing = false;
					if (event.dialog) {
						event.dialog.close();
					}
					event.result = { bool: true, skill: result };
				},
				discoverCard: function () {
					'step 0'
					var num = event.num || 3;
					var choice;
					if (typeof event.list == 'string' || typeof event.list == 'function') {
						choice = get.inpile(event.list).randomGets(num);
					}
					else if (Array.isArray(event.list)) {
						choice = event.list.randomGets(num);
					}
					else {
						choice = Array.from(event.list).randomGets(num);
					}
					if (choice.length) {
						var prompt = event.prompt;
						if (!prompt) {
							prompt = '选择一张牌';
							if (event.use) {
								prompt += '使用之';
							}
							else if (!event.nogain) {
								prompt += '获得之';
							}
						}
						if (typeof choice[0] === 'string') {
							var next = player.chooseVCardButton(choice, prompt, event.forced);
							if (event.ai) {
								next.set('ai', event.ai);
							}
						}
						else if (get.itemtype(choice[0]) == 'card') {
							var next = player.chooseCardButton(choice, prompt, event.forced);
							if (event.ai) {
								next.set('ai', event.ai);
							}
						}
						else {
							event.finish();
						}
					}
					else {
						event.finish();
					}
					'step 1'
					event.result = {
						bool: result.bool,
						card: null,
						choice: null
					};
					if (result.bool && result.links.length) {
						var link = result.links[0];
						var togain = null;
						if (get.itemtype(link) == 'card') {
							event.result.card = link;
							togain = link;
						}
						else if (Array.isArray(link)) {
							event.result.choice = link[2];
							togain = game.createCard(link[2]);
						}
						if (togain) {
							if (event.use) {
								player.chooseUseTarget(togain);
							}
							else if (!event.nogain) {
								player.gain(togain, 'draw');
								game.log(player, '获得了一张牌');
							}
						}
					}
				},
				chooseButton: function () {
					"step 0"
					if (typeof event.dialog == 'number') {
						event.dialog = get.idDialog(event.dialog);
					}
					if (event.createDialog && !event.dialog) {
						if (Array.isArray(event.createDialog)) {
							event.createDialog.add('hidden');
							event.dialog = ui.create.dialog.apply(this, event.createDialog);
						}
						event.closeDialog = true;
					}
					if (event.dialog == undefined) event.dialog = ui.dialog;
					if (event.isMine() || event.dialogdisplay) {
						event.dialog.style.display = '';
						event.dialog.open();
					}
					game.check();
					if (event.isMine()) {
						game.pause();
					}
					else if (event.isOnline()) {
						event.send();
						delete event.callback;
					}
					else {
						event.result = 'ai';
					}
					if (event.onfree) {
						lib.init.onfree();
					}
					"step 1"
					if (event.result == 'ai') {
						if (event.processAI) {
							event.result = event.processAI();
						}
						else {
							game.check();
							if (ai.basic.chooseButton(event.ai) || forced) ui.click.ok();
							else ui.click.cancel();
						}
					}
					if (event.closeDialog) {
						event.dialog.close();
					}
					if (event.callback) {
						event.callback(event.player, event.result);
					}
					event.resume();
				},
				chooseCardOL: function () {
					'step 0'
					event.targets = event.list.slice(0);
					if (!_status.connectMode) {
						event.result = [];
						event.goto(7);
					}
					else {
						for (var i = 0; i < event.list.length; i++) {
							var target = event.list[i];
							target.wait();
							if (target.isOnline()) {
								target.send(function (args, set) {
									game.me.chooseCard.apply(game.me, args).set(set);
									game.resume();
								}, event._args, event._set);
								event.list.splice(i--, 1);
							}
							else if (target == game.me) {
								event.withme = true;
								event.list.splice(i--, 1);
							}
						}
					}
					'step 1'
					if (event.list.length) {
						event.target = event.list.shift();
						event.target.chooseCard.apply(event.target, event._args).set(event._set);
					}
					else {
						event.goto(3);
					}
					'step 2'
					event.target.unwait(result);
					event.goto(1);
					'step 3'
					if (event.withme) {
						game.me.chooseCard.apply(game.me, event._args).set(event._set);
					}
					else {
						event.goto(5);
					}
					'step 4'
					game.me.unwait(result);
					'step 5'
					if (!event.resultOL) {
						game.pause();
					}
					'step 6'
					event.result = [];
					for (var i = 0; i < event.targets.length; i++) {
						event.result[i] = event.resultOL[event.targets[i].playerid] || {};
						if (event.result[i] == 'ai' && event.aiCard) {
							event.result[i] = event.aiCard(event.targets[i]);
						}
					}
					event.finish();
					'step 7'
					if (event.list.length) {
						event.target = event.list.shift();
						event.target.chooseCard.apply(event.target, event._args).set(event._set);
					}
					else {
						for (var i = 0; i < event.targets.length; i++) {
							if (!event.result[i]) {
								event.result[i] = {};
							}
						}
						event.finish();
					}
					'step 8'
					event.result[event.targets.indexOf(event.target)] = result;
					event.goto(7);
				},
				chooseButtonOL: function () {
					'step 0'
					ui.arena.classList.add('markhidden');
					for (var i = 0; i < event.list.length; i++) {
						var current = event.list[i];
						current[0].wait();
						if (current[0].isOnline()) {
							var target = current.shift();
							target.send(function (args, callback, switchToAuto, processAI) {
								ui.arena.classList.add('markhidden');
								var next = game.me.chooseButton.apply(game.me, args);
								next.callback = callback;
								next.switchToAuto = switchToAuto;
								next.processAI = processAI;
								next.complexSelect = true;
								game.resume();
							}, current, event.callback, event.switchToAuto, event.processAI);
							target._choose_button_ol = current;
							event.list.splice(i--, 1);
						}
						else if (current[0] == game.me) {
							event.last = current;
							event.last.shift();
							event.list.splice(i--, 1);
						}
					}
					'step 1'
					if (event.list.length) {
						var current = event.list.shift();
						event.target = current.shift();
						var next = event.target.chooseButton.apply(event.target, current);
						next.callback = event.callback;
						next.switchToAuto = event.switchToAuto;
						next.processAI = event.processAI;
					}
					else {
						event.goto(3);
					}
					'step 2'
					event.target.unwait(result);
					event.goto(1);
					'step 3'
					if (event.last) {
						var next = game.me.chooseButton.apply(game.me, event.last);
						next.callback = event.callback;
						next.switchToAuto = event.switchToAuto;
						next.processAI = event.processAI;
					}
					else {
						event.goto(5);
					}
					'step 4'
					game.me.unwait(result);
					'step 5'
					if (!event.resultOL) {
						game.pause();
					}
					'step 6'
					game.broadcastAll(function () {
						ui.arena.classList.remove('markhidden');
					});
					event.result = event.resultOL;
				},
				chooseCard: function () {
					"step 0"
					if (event.directresult) {
						event.result = {
							buttons: [],
							cards: event.directresult.slice(0),
							targets: [],
							confirm: 'ok',
							bool: true,
							links: []
						};
					}
					else {
						game.check();
						if (event.isMine()) {
							game.pause();
							if (event.prompt != false) {
								var str;
								if (typeof event.prompt == 'string') str = event.prompt;
								else {
									str = '请选择'
									var range = get.select(event.selectCard);
									if (range[0] == range[1]) str += get.cnNumber(range[0]);
									else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
									else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
									str += '张';
									if (event.position == 'h' || event.position == undefined) str += '手';
									if (event.position == 'e') str += '装备';
									str += '牌';
								}
								event.dialog = ui.create.dialog(str);
								if (event.prompt2) {
									event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
								}
								if (Array.isArray(event.promptx)) {
									for (var i = 0; i < event.promptx.length; i++) {
										event.dialog.add(event.promptx[i]);
									}
								}
								event.promptbar = event.dialog.add('0/' + get.numStr(event.selectCard[1], 'card'));
								event.custom.add.card = function () {
									_status.event.promptbar.innerHTML =
										ui.selected.cards.length + '/' + get.numStr(_status.event.selectCard[1], 'card');
								}
							}
						}
						else if (event.isOnline()) {
							event.send();
						}
						else {
							event.result = 'ai';
						}
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseCard(event.ai) || forced) {
							ui.click.ok();
						}
						else if (event.skill) {
							var skill = event.skill;
							ui.click.cancel();
							event._aiexclude.add(skill);
							event.redo();
							game.resume();
						}
						else {
							ui.click.cancel();
						}
					}
					"step 2"
					event.resume();
					if (event.glow_result && event.result.cards && !event.directresult) {
						for (var i = 0; i < event.result.cards.length; i++) {
							event.result.cards[i].classList.add('glow');
						}
					}
					if (event.dialog) event.dialog.close();
				},
				chooseTarget: function () {
					"step 0"
					if (event.isMine()) {
						game.check();
						game.pause();
						if (event.createDialog && !event.dialog && Array.isArray(event.createDialog)) {
							event.dialog = ui.create.dialog.apply(this, event.createDialog);
						}
						else if (event.prompt != false) {
							var str;
							if (typeof event.prompt == 'string') str = event.prompt;
							else {
								str = '请选择'
								var range = get.select(event.selectTarget);
								if (range[0] == range[1]) str += get.cnNumber(range[0]);
								else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
								else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
								str += '个目标';
							}
							event.dialog = ui.create.dialog(str);
							if (event.prompt2) {
								event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
							}
							if (event.promptbar != 'none') {
								event.promptbar = event.dialog.add('0/' + get.numStr(get.select(event.selectTarget)[1], 'target'));
								event.custom.add.target = function () {
									_status.event.promptbar.innerHTML =
										ui.selected.targets.length + '/' + get.numStr(get.select(event.selectTarget)[1], 'target');
								}
							}
						}
						else if (get.itemtype(event.dialog) == 'dialog') {
							event.dialog.open();
						}
					}
					else if (event.isOnline()) {
						event.send();
					}
					else {
						event.result = 'ai';
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseTarget(event.ai) || forced) {
							ui.click.ok();
						}
						else {
							ui.click.cancel();
						}
					}
					if (event.result.bool) {
						for (var i = 0; i < event.result.targets.length; i++) {
							event.result.targets[i].animate('target');
						}
					}
					if (event.dialog) event.dialog.close();
					event.resume();
					"step 2"
					if (event.onresult) {
						event.onresult(event.result);
					}
					if (event.result.bool && event.autodelay && !event.isMine()) {
						if (typeof event.autodelay == 'number') {
							game.delayx(event.autodelay);
						}
						else {
							game.delayx();
						}
					}
				},
				chooseCardTarget: function () {
					"step 0"
					if (event.isMine()) {
						game.check();
						game.pause();
						if (event.prompt != false) {
							event.dialog = ui.create.dialog(event.prompt || '请选择卡牌和目标');
							if (event.prompt2) {
								event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
							}
						}
					}
					else if (event.isOnline()) {
						event.send();
					}
					else {
						event.result = 'ai';
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseCard(event.ai1)) {
							if (ai.basic.chooseTarget(event.ai2)) {
								ui.click.ok();
								_status.event._aiexclude.length = 0;
							}
							else {
								get.card(true).aiexclude();
								game.uncheck();
								event.redo();
								game.resume();
							}
						}
						else {
							ui.click.cancel();
						}
					}
					"step 2"
					event.resume();
					if (event.result.bool) {
						for (var i = 0; i < event.result.targets.length; i++) {
							event.result.targets[i].animate('target');
						}
					}
					if (event.dialog) event.dialog.close();
				},
				chooseControl: function () {
					"step 0"
					if (event.controls.length == 0) {
						if (event.sortcard) {
							var sortnum = 2;
							if (event.sorttop) {
								sortnum = 1;
							}
							for (var i = 0; i < event.sortcard.length + sortnum; i++) {
								event.controls.push(get.cnNumber(i, true));
							}
						}
						else if (event.choiceList) {
							for (var i = 0; i < event.choiceList.length; i++) {
								event.controls.push('选项' + get.cnNumber(i + 1, true));
							}
						}
						else {
							event.finish();
							return;
						}
					}
					else if (event.choiceList && event.controls.length == 1 && event.controls[0] == 'cancel2') {
						event.controls.shift();
						for (var i = 0; i < event.choiceList.length; i++) {
							event.controls.push('选项' + get.cnNumber(i + 1, true));
						}
						event.controls.push('cancel2');
					}
					if (event.isMine()) {
						if (event.sortcard) {
							var prompt = event.prompt || '选择一个位置';
							if (event.tosort) {
								prompt += '放置' + get.translation(event.tosort);
							}
							event.dialog = ui.create.dialog(prompt, 'hidden');
							if (event.sortcard && event.sortcard.length) {
								event.dialog.addSmall(event.sortcard);
							}
							else {
								event.dialog.buttons = [];
								event.dialog.add(ui.create.div('.buttons'));
							}
							var buttons = event.dialog.content.lastChild;
							var sortnum = 2;
							if (event.sorttop) {
								sortnum = 1;
							}
							for (var i = 0; i < event.dialog.buttons.length + sortnum; i++) {
								var item = ui.create.div('.button.card.pointerdiv.mebg');
								item.style.width = '50px';
								buttons.insertBefore(item, event.dialog.buttons[i]);
								item.innerHTML = '<div style="font-family: xinwei;font-size: 25px;height: 75px;line-height: 25px;top: 8px;left: 10px;width: 30px;">第' + get.cnNumber(i + 1, true) + '张</div>';
								if (i == event.dialog.buttons.length + 1) {
									item.firstChild.innerHTML = '牌堆底';
								}
								item.link = get.cnNumber(i, true);
								item.listen(ui.click.dialogcontrol);
							}

							event.dialog.forcebutton = true;
							event.dialog.classList.add('forcebutton');
							event.dialog.open();
						}
						else if (event.dialogcontrol) {
							event.dialog = ui.create.dialog(event.prompt || '选择一项', 'hidden');
							for (var i = 0; i < event.controls.length; i++) {
								var item = event.dialog.add('<div class="popup text pointerdiv" style="width:calc(100% - 10px);display:inline-block">' + event.controls[i] + '</div>');
								item.firstChild.listen(ui.click.dialogcontrol);
								item.firstChild.link = event.controls[i];
							}
							event.dialog.forcebutton = true;
							event.dialog.classList.add('forcebutton');
							if (event.addDialog) {
								for (var i = 0; i < event.addDialog.length; i++) {
									if (get.itemtype(event.addDialog[i]) == 'cards') {
										event.dialog.addSmall(event.addDialog[i]);
									}
									else {
										event.dialog.add(event.addDialog[i]);
									}
								}
								event.dialog.add(ui.create.div('.placeholder.slim'));
							}
							event.dialog.open();
						}
						else {
							if (event.seperate || lib.config.seperate_control) {
								event.controlbars = [];
								for (var i = 0; i < event.controls.length; i++) {
									event.controlbars.push(ui.create.control([event.controls[i]]));
								}
							}
							else {
								event.controlbar = ui.create.control(event.controls);
							}
							if (event.dialog) {
								if (Array.isArray(event.dialog)) {
									event.dialog = ui.create.dialog.apply(this, event.dialog);
								}
								event.dialog.open();
							}
							else if (event.choiceList) {
								event.dialog = ui.create.dialog(event.prompt || '选择一项', 'hidden');
								event.dialog.forcebutton = true;
								event.dialog.open();
								for (var i = 0; i < event.choiceList.length; i++) {
									event.dialog.add('<div class="popup text" style="width:calc(100% - 10px);display:inline-block">选项' +
										get.cnNumber(i + 1, true) + '：' + event.choiceList[i] + '</div>');
								}
							}
							else if (event.prompt) {
								event.dialog = ui.create.dialog(event.prompt);
								if (event.prompt2) {
									event.dialog.addText(event.prompt2, event.prompt2.length <= 20 || event.centerprompt2);
								}
							}
						}
						game.pause();
						game.countChoose();
						event.choosing = true;
					}
					else if (event.isOnline()) {
						event.send();
					}
					else {
						event.result = 'ai';
					}
					"step 1"
					if (event.result == 'ai') {
						event.result = {};
						if (event.ai) {
							var result = event.ai(event.getParent(), player);
							if (typeof result == 'number') event.result.control = event.controls[result];
							else event.result.control = result;
						}
						else event.result.control = event.controls[event.choice];
					}
					event.result.index = event.controls.indexOf(event.result.control);
					event.choosing = false;
					_status.imchoosing = false;
					if (event.dialog && event.dialog.close) event.dialog.close();
					if (event.controlbar) event.controlbar.close();
					if (event.controlbars) {
						for (var i = 0; i < event.controlbars.length; i++) {
							event.controlbars[i].close();
						}
					}
					event.resume();
				},
				chooseBool: function () {
					"step 0"
					if (event.isMine()) {
						if (event.frequentSkill && !lib.config.autoskilllist.contains(event.frequentSkill)) {
							ui.click.ok();
							return;
						}
						ui.create.confirm('oc');
						if (event.createDialog && !event.dialog) {
							if (Array.isArray(event.createDialog)) {
								event.dialog = ui.create.dialog.apply(this, event.createDialog);
								if (event.dialogselectx) {
									for (var i = 0; i < event.dialog.buttons.length; i++) {
										event.dialog.buttons[i].classList.add('selectedx');
									}
								}
							}
						}
						if (event.dialog) {
							event.dialog.open();
						}
						else if (event.prompt) {
							event.dialog = ui.create.dialog(event.prompt);
							if (event.prompt2) {
								event.dialog.addText(event.prompt2, event.prompt2.length <= 20);
							}
						}
						game.pause();
						game.countChoose();
						event.choosing = true;
					}
					else if (event.isOnline()) {
						event.send();
					}
					else {
						event.result = 'ai';
					}
					"step 1"
					if (event.result == 'ai') {
						if (event.ai) {
							event.choice = event.ai(event.getParent(), player);
						}
						event.result = { bool: event.choice };
					}
					_status.imchoosing = false;
					event.choosing = false;
					if (event.dialog) event.dialog.close();
					event.resume();
				},
				chooseDrawRecover: function () {
					'step 0'
					if (player.isHealthy() && event.forced) {
						player.draw(event.num1);
						event.finish();
						return;
					}
					var controls = ['draw_card'];
					if (player.isDamaged()) {
						event.num2 = Math.min(event.num2, player.maxHp - player.hp);
						controls.push('recover_hp');
					}
					if (!event.forced) {
						controls.push('cancel2');
					}
					var prompt = event.prompt;
					if (!prompt) {
						if (player.isHealthy()) {
							prompt = '是否摸' + get.cnNumber(event.num1) + '张牌？';
						}
						else {
							prompt = '摸' + get.cnNumber(event.num1) + '张牌或回复' + get.cnNumber(event.num2) + '点体力';
						}
					}
					var next = player.chooseControl(controls);
					next.set('prompt', prompt);
					if (event.ai) {
						next.set('ai', event.ai);
					}
					else {
						var choice;
						if (player.isDamaged() && get.recoverEffect(player) > 0 && (
							player.hp == 1 || player.needsToDiscard() ||
							player.hasSkillTag('maixie_hp') || event.num2 > event.num1 ||
							(event.num2 == event.num1 && player.needsToDiscard(1))
						)) {
							choice = 'recover_hp';
						}
						else {
							choice = 'draw_card';
						}
						next.set('ai', function () {
							return _status.event.choice;
						});
						next.set('choice', choice);
					}
					'step 1'
					if (result.control != 'cancel2') {
						if (event.logSkill) {
							if (typeof event.logSkill == 'string') {
								player.logSkill(event.logSkill);
							}
							else if (Array.isArray(event.logSkill)) {
								player.logSkill.apply(player, event.logSkill);
							}
						}
						if (result.control == 'draw_card') {
							player.draw(event.num1);
						}
						else {
							player.recover(event.num2);
						}
					}
					event.result = result;
				},
				choosePlayerCard: function () {
					"step 0"
					if (!event.dialog) event.dialog = ui.create.dialog('hidden');
					else if (!event.isMine) {
						event.dialog.style.display = 'none';
					}
					if (event.prompt) {
						event.dialog.add(event.prompt);
					}
					else {
						event.dialog.add('选择' + get.translation(target) + '的一张牌');
					}
					if (event.prompt2) {
						event.dialog.addText(event.prompt2);
					}
					var directh = !lib.config.unauto_choose;
					for (var i = 0; i < event.position.length; i++) {
						if (event.position[i] == 'h') {
							var hs = target.getCards('h');
							if (hs.length) {
								event.dialog.addText('手牌区');
								hs.randomSort();
								if (event.visible || target.isUnderControl(true) || player.hasSkillTag('viewHandcard', null, target, true)) {
									event.dialog.add(hs);
									directh = false;
								}
								else {
									event.dialog.add([hs, 'blank']);
								}
							}
						}
						else if (event.position[i] == 'e') {
							var es = target.getCards('e');
							if (es.length) {
								event.dialog.addText('装备区');
								event.dialog.add(es);
								directh = false;
							}
						}
						else if (event.position[i] == 'j') {
							var js = target.getCards('j');
							if (js.length) {
								event.dialog.addText('判定区');
								event.dialog.add(js);
								directh = false;
							}
						}
					}
					if (event.dialog.buttons.length == 0) {
						event.finish();
						return;
					}
					var cs = target.getCards(event.position);
					var select = get.select(event.selectButton);
					if (event.forced && select[0] >= cs.length) {
						event.result = {
							bool: true,
							buttons: event.dialog.buttons,
							links: cs
						}
					}
					else if (event.forced && directh && !event.isOnline() && select[0] == select[1]) {
						event.result = {
							bool: true,
							buttons: event.dialog.buttons.randomGets(select[0]),
							links: []
						}
						for (var i = 0; i < event.result.buttons.length; i++) {
							event.result.links[i] = event.result.buttons[i].link;
						}
					}
					else {
						if (event.isMine()) {
							event.dialog.open();
							game.check();
							game.pause();
						}
						else if (event.isOnline()) {
							event.send();
						}
						else {
							event.result = 'ai';
						}
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseButton(event.ai) || forced) ui.click.ok();
						else ui.click.cancel();
					}
					event.dialog.close();
					if (event.result.links) {
						event.result.cards = event.result.links.slice(0);
					}
					event.resume();
				},
				discardPlayerCard: function () {
					"step 0"
					if (event.directresult) {
						event.result = {
							buttons: [],
							cards: event.directresult.slice(0),
							links: event.directresult.slice(0),
							targets: [],
							confirm: 'ok',
							bool: true
						};
						event.cards = event.directresult.slice(0);
						event.goto(2);
						return;
					}
					if (!event.dialog) event.dialog = ui.create.dialog('hidden');
					else if (!event.isMine) {
						event.dialog.style.display = 'none';
					}
					if (event.prompt == undefined) {
						var str = '弃置' + get.translation(target);
						var range = get.select(event.selectButton);
						if (range[0] == range[1]) str += get.cnNumber(range[0]);
						else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
						else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
						str += '张';
						if (event.position == 'h' || event.position == undefined) str += '手';
						if (event.position == 'e') str += '装备';
						str += '牌';
						event.prompt = str;
					}
					if (event.prompt) {
						event.dialog.add(event.prompt);
					}
					if (event.prompt2) {
						event.dialog.addText(event.prompt2);
					}
					var directh = !lib.config.unauto_choose;
					for (var i = 0; i < event.position.length; i++) {
						if (event.position[i] == 'h') {
							var hs = target.getDiscardableCards(player, 'h');
							if (hs.length) {
								event.dialog.addText('手牌区');
								hs.randomSort();
								if (event.visible || target.isUnderControl(true) || player.hasSkillTag('viewHandcard', null, target, true)) {
									event.dialog.add(hs);
									directh = false;
								}
								else {
									event.dialog.add([hs, 'blank']);
								}
							}
						}
						else if (event.position[i] == 'e') {
							var es = target.getDiscardableCards(player, 'e');
							if (es.length) {
								event.dialog.addText('装备区');
								event.dialog.add(es);
								directh = false;
							}
						}
						else if (event.position[i] == 'j') {
							var js = target.getDiscardableCards(player, 'j');
							if (js.length) {
								event.dialog.addText('判定区');
								event.dialog.add(js);
								directh = false;
							}
						}
					}
					if (event.dialog.buttons.length == 0) {
						event.finish();
						return;
					}
					var cs = target.getCards(event.position);
					var select = get.select(event.selectButton);
					if (event.forced && select[0] >= cs.length) {
						event.result = {
							bool: true,
							buttons: event.dialog.buttons,
							links: cs
						}
					}
					else if (event.forced && directh && !event.isOnline() && select[0] == select[1]) {
						event.result = {
							bool: true,
							buttons: event.dialog.buttons.randomGets(select[0]),
							links: []
						}
						for (var i = 0; i < event.result.buttons.length; i++) {
							event.result.links[i] = event.result.buttons[i].link;
						}
					}
					else {
						if (event.isMine()) {
							event.dialog.open();
							game.check();
							game.pause();
						}
						else if (event.isOnline()) {
							event.send();
						}
						else {
							event.result = 'ai';
						}
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseButton(event.ai) || forced) ui.click.ok();
						else ui.click.cancel();
					}
					event.dialog.close();
					"step 2"
					event.resume();
					if (event.result.bool && event.result.links && !game.online) {
						if (event.logSkill) {
							if (typeof event.logSkill == 'string') {
								player.logSkill(event.logSkill);
							}
							else if (Array.isArray(event.logSkill)) {
								player.logSkill.apply(player, event.logSkill);
							}
						}
						var cards = [];
						for (var i = 0; i < event.result.links.length; i++) {
							cards.push(event.result.links[i]);
						}
						event.result.cards = event.result.links.slice(0);
						event.cards = cards;
						event.trigger("rewriteDiscardResult");
					}
					"step 3"
					if (event.boolline) {
						player.line(target, 'green');
					}
					if (!event.chooseonly) {
						var next = target.discard(event.cards);
						if (player != target) next.notBySelf = true;
						event.done = next;
						if (event.delay === false) {
							next.set('delay', false);
						}
					}
				},
				gainPlayerCard: function () {
					"step 0"
					if (event.directresult) {
						event.result = {
							buttons: [],
							cards: event.directresult.slice(0),
							links: event.directresult.slice(0),
							targets: [],
							confirm: 'ok',
							bool: true
						};
						event.cards = event.directresult.slice(0);
						event.goto(2);
						return;
					}
					if (!event.dialog) event.dialog = ui.create.dialog('hidden');
					else if (!event.isMine) {
						event.dialog.style.display = 'none';
					}
					if (event.prompt == undefined) {
						var str = '获得' + get.translation(target);
						var range = get.select(event.selectButton);
						if (range[0] == range[1]) str += get.cnNumber(range[0]);
						else if (range[1] == Infinity) str += '至少' + get.cnNumber(range[0]);
						else str += get.cnNumber(range[0]) + '至' + get.cnNumber(range[1]);
						str += '张';
						if (event.position == 'h' || event.position == undefined) str += '手';
						if (event.position == 'e') str += '装备';
						str += '牌';
						event.prompt = str;
					}
					if (event.prompt) {
						event.dialog.add(event.prompt);
					}
					if (event.prompt2) {
						event.dialog.addText(event.prompt2);
					}
					var directh = !lib.config.unauto_choose;
					for (var i = 0; i < event.position.length; i++) {
						if (event.position[i] == 'h') {
							var hs = target.getGainableCards(player, 'h');
							if (hs.length) {
								event.dialog.addText('手牌区');
								hs.randomSort();
								if (event.visible || target.isUnderControl(true) || player.hasSkillTag('viewHandcard', null, target, true)) {
									event.dialog.add(hs);
									directh = false;
								}
								else {
									event.dialog.add([hs, 'blank']);
								}
							}
						}
						else if (event.position[i] == 'e') {
							var es = target.getGainableCards(player, 'e');
							if (es.length) {
								event.dialog.addText('装备区');
								event.dialog.add(es);
								directh = false;
							}
						}
						else if (event.position[i] == 'j') {
							var js = target.getGainableCards(player, 'j');
							if (js.length) {
								event.dialog.addText('判定区');
								event.dialog.add(js);
								directh = false;
							}
						}
					}
					if (event.dialog.buttons.length == 0) {
						event.dialog.close();
						event.finish();
						return;
					}
					var cs = target.getCards(event.position);
					var select = get.select(event.selectButton);
					if (event.forced && select[0] >= cs.length) {
						event.result = {
							bool: true,
							buttons: event.dialog.buttons,
							links: cs
						}
					}
					else if (event.forced && directh && !event.isOnline() && select[0] == select[1]) {
						event.result = {
							bool: true,
							buttons: event.dialog.buttons.randomGets(select[0]),
							links: []
						}
						for (var i = 0; i < event.result.buttons.length; i++) {
							event.result.links[i] = event.result.buttons[i].link;
						}
					}
					else {
						if (event.isMine()) {
							event.dialog.open();
							game.check();
							game.pause();
						}
						else if (event.isOnline()) {
							event.send();
						}
						else {
							event.result = 'ai';
						}
					}
					"step 1"
					if (event.result == 'ai') {
						game.check();
						if (ai.basic.chooseButton(event.ai) || forced) ui.click.ok();
						else ui.click.cancel();
					}
					event.dialog.close();
					"step 2"
					event.resume();
					if (game.online || !event.result.bool) {
						event.finish();
					}
					"step 3"
					if (event.logSkill && event.result.bool && !game.online) {
						if (typeof event.logSkill == 'string') {
							player.logSkill(event.logSkill);
						}
						else if (Array.isArray(event.logSkill)) {
							player.logSkill.apply(player, event.logSkill);
						}
					}
					var cards = [];
					for (var i = 0; i < event.result.links.length; i++) {
						cards.push(event.result.links[i]);
					}
					event.result.cards = event.result.links.slice(0);
					event.cards = cards;
					event.trigger("rewriteGainResult");
					"step 4"
					if (event.boolline) {
						player.line(target, 'green');
					}
					if (!event.chooseonly) {
						if (event.delay !== false) {
							var next = player.gain(event.cards, target, event.visibleMove ? 'give' : 'giveAuto', 'bySelf');
							event.done = next;
						}
						else {
							var next = player.gain(event.cards, target, 'bySelf');
							event.done = next;
							target[event.visibleMove ? '$give' : '$giveAuto'](cards, player);
							if (event.visibleMove) next.visible = true;
						}
					}
					else target[event.visibleMove ? '$give' : '$giveAuto'](cards, player);
				},
				showHandcards: function () {
					"step 0"
					if (player.countCards('h') == 0) {
						event.finish();
						return;
					}
					var cards = player.getCards('h');
					var str = get.translation(player.name) + '的手牌';
					if (typeof event.prompt == 'string') {
						str = event.prompt;
					}
					event.dialog = ui.create.dialog(str, cards);
					event.dialogid = lib.status.videoId++;
					event.dialog.videoId = event.dialogid;
					game.broadcast(function (str, cards, id) {
						ui.create.dialog(str, cards).videoId = id;
					}, str, cards, event.dialogid);
					game.log(player, '展示了', cards);
					game.addVideo('showCards', player, [str, get.cardsInfo(cards)]);
					game.delayx(2);
					"step 1"
					game.broadcast('closeDialog', event.dialogid);
					event.dialog.close();
				},
				showCards: function () {
					"step 0"
					if (get.itemtype(cards) != 'cards') {
						event.finish();
						return;
					}
					if (!event.str) {
						event.str = get.translation(player.name) + '展示的牌';
					}
					event.dialog = ui.create.dialog(event.str, cards);
					event.dialogid = lib.status.videoId++;
					event.dialog.videoId = event.dialogid;

					if (event.hiddencards) {
						for (var i = 0; i < event.dialog.buttons.length; i++) {
							if (event.hiddencards.contains(event.dialog.buttons[i].link)) {
								event.dialog.buttons[i].className = 'button card';
								event.dialog.buttons[i].innerHTML = '';
							}
						}
					}
					game.broadcast(function (str, cards, cards2, id) {
						var dialog = ui.create.dialog(str, cards);
						dialog.forcebutton = true;
						dialog.videoId = id;
						if (cards2) {
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (cards2.contains(dialog.buttons[i].link)) {
									dialog.buttons[i].className = 'button card';
									dialog.buttons[i].innerHTML = '';
								}
							}
						}
					}, event.str, cards, event.hiddencards, event.dialogid);
					if (event.hiddencards) {
						var cards2 = cards.slice(0);
						for (var i = 0; i < event.hiddencards.length; i++) {
							cards2.remove(event.hiddencards[i]);
						}
						game.log(player, '展示了', cards2);
					}
					else {
						game.log(player, '展示了', cards);
					}
					game.delayx(2);
					game.addVideo('showCards', player, [event.str, get.cardsInfo(cards)]);
					"step 1"
					game.broadcast('closeDialog', event.dialogid);
					event.dialog.close();
				},
				viewCards: function () {
					"step 0"
					if (player == game.me) {
						event.dialog = ui.create.dialog(event.str, event.cards);
						if (event.isMine()) {
							game.pause();
							ui.create.confirm('o');
							game.countChoose();
							event.choosing = true;
						}
						else {
							event.finish();
							event.result = 'viewed';
							setTimeout(function () {
								event.dialog.close();
							}, 2 * lib.config.duration);
							game.delayx(2);
						}
					}
					else if (event.isOnline()) {
						event.send();
					}
					else {
						event.finish();
					}
					"step 1"
					event.result = 'viewed';
					_status.imchoosing = false;
					event.choosing = false;
					if (event.dialog) event.dialog.close();
				},
				moveCard: function () {
					'step 0'
					if (!player.canMoveCard(null, event.nojudge)) {
						event.finish();
						return;
					}
					var next = player.chooseTarget(2, function (card, player, target) {
						if (ui.selected.targets.length) {
							var from = ui.selected.targets[0];
							var js = from.getCards('j');
							for (var i = 0; i < js.length; i++) {
								if (_status.event.nojudge) break;
								if (target.canAddJudge(js[i])) return true;
							}
							if (target.isMin()) return false;
							var es = from.getCards('e');
							for (var i = 0; i < es.length; i++) {
								if (target.isEmpty(get.subtype(es[i]))) return true;
							}
							return false;
						}
						else {
							var range = 'ej';
							if (_status.event.nojudge) range = 'e';
							return target.countCards(range) > 0;
						}
					});
					next.set('nojudge', event.nojudge || false);
					next.set('ai', function (target) {
						var player = _status.event.player;
						var att = get.attitude(player, target);
						var sgnatt = get.sgn(att);
						if (ui.selected.targets.length == 0) {
							if (att > 0) {
								if (!_status.event.nojudge && target.countCards('j', function (card) {
									return game.hasPlayer(function (current) {
										return current.canAddJudge(card) && get.attitude(player, current) < 0;
									})
								})) return 14;
								if (target.countCards('e', function (card) {
									return get.value(card, target) < 0 && game.hasPlayer(function (current) {
										return current != target && get.attitude(player, current) < 0 && current.isEmpty(get.subtype(card))
									});
								}) > 0) return 9;
							}
							else if (att < 0) {
								if (game.hasPlayer(function (current) {
									if (current != target && get.attitude(player, current) > 0) {
										var es = target.getCards('e');
										for (var i = 0; i < es.length; i++) {
											if (get.value(es[i], target) > 0 && current.isEmpty(get.subtype(es[i])) && get.effect(current, es[i], player, current) > 0) return true;
										}
									}
								})) {
									return -att;
								}
							}
							return 0;
						}
						var es = ui.selected.targets[0].getCards('e');
						var i;
						var att2 = get.sgn(get.attitude(player, ui.selected.targets[0]));
						for (i = 0; i < es.length; i++) {
							if (sgnatt != 0 && att2 != 0 &&
								get.sgn(get.value(es[i], ui.selected.targets[0])) == -att2 &&
								get.sgn(get.effect(target, es[i], player, target)) == sgnatt &&
								target.isEmpty(get.subtype(es[i]))) {
								return Math.abs(att);
							}
						}
						if (i == es.length && (_status.event.nojudge || !ui.selected.targets[0].countCards('j', function (card) {
							return target.canAddJudge(card);
						}))) {
							return 0;
						}
						return -att * get.attitude(player, ui.selected.targets[0]);
					});
					next.set('multitarget', true);
					next.set('targetprompt', _status.event.targetprompt || ['被移走', '移动目标']);
					next.set('prompt', event.prompt || '移动场上的一张牌');
					if (event.prompt2) next.set('prompt2', event.prompt2);
					if (event.forced) next.set('forced', true);
					'step 1'
					event.result = result;
					if (result.bool) {
						player.line2(result.targets, 'green');
						event.targets = result.targets;
					}
					else {
						event.finish();
					}
					'step 2'
					game.delay();
					'step 3'
					if (targets.length == 2) {
						player.choosePlayerCard('ej', true, function (button) {
							var player = _status.event.player;
							var targets0 = _status.event.targets0;
							var targets1 = _status.event.targets1;
							if (get.attitude(player, targets0) > 0 && get.attitude(player, targets1) < 0) {
								if (get.position(button.link) == 'j') return 12;
								if (get.value(button.link, targets0) < 0 && get.effect(targets1, button.link, player, targets1) > 0) return 10;
								return 0;
							}
							else {
								if (get.position(button.link) == 'j') return -10;
								return get.equipValue(button.link) * get.effect(targets1, button.link, player, targets1);
							}
						}, targets[0]).set('nojudge', event.nojudge || false).set('targets0', targets[0]).set('targets1', targets[1]).set('filterButton', function (button) {
							var targets1 = _status.event.targets1;
							if (get.position(button.link) == 'j') {
								if (_status.event.nojudge) return false;
								return targets1.canAddJudge(button.link);
							}
							else {
								return targets1.isEmpty(get.subtype(button.link));
							}
						});
					}
					else {
						event.finish();
					}
					'step 4'
					if (result.bool && result.links.length) {
						var link = result.links[0];
						if (get.position(link) == 'e') {
							event.targets[1].equip(link);
						}
						else if (link.viewAs) {
							event.targets[1].addJudge({ name: link.viewAs }, [link]);
						}
						else {
							event.targets[1].addJudge(link);
						}
						event.targets[0].$give(link, event.targets[1])
						event.result.card = link;
						event.result.position = get.position(link);
						game.delay();
					}
				},
				useCard: function () {
					"step 0"
					if (!card) {
						console.log('err: no card', get.translation(event.player));
						event.finish();
						return;
					}
					if (!get.info(card, false).noForceDie) event.forceDie = true;
					var next = player.lose(cards, 'visible', ui.ordering).set('type', 'use');
					var directDiscard = [];
					for (var i = 0; i < cards.length; i++) {
						if (!next.cards.contains(cards[i])) {
							directDiscard.push(cards[i]);
						}
					}
					if (directDiscard.length) game.cardsGotoOrdering(directDiscard);
					//player.using=cards;
					var cardaudio = true;
					if (event.skill) {
						if (lib.skill[event.skill].audio) {
							cardaudio = false;
						}
						if (lib.skill[event.skill].log != false) {
							player.logSkill(event.skill);
						}
						if (get.info(event.skill).popname) {
							player.tryCardAnimate(card, event.card.name, 'metal', true);
						}
					}
					else if (!event.nopopup) {
						if (lib.translate[event.card.name + '_pop']) {
							player.tryCardAnimate(card, lib.translate[event.card.name + '_pop'], 'metal');
						}
						else {
							player.tryCardAnimate(card, event.card.name, 'metal');
						}
					}
					if (event.audio === false) {
						cardaudio = false;
					}
					if (cardaudio) {
						game.broadcastAll(function (player, card) {
							if (lib.config.background_audio) {
								if (get.type(card) == 'equip' && !lib.config.equip_audio) return;
								var sex = player.sex == 'female' ? 'female' : 'male';
								var audioinfo = lib.card[card.name].audio;
								// if(audioinfo||true){
								if (card.name == 'sha' && (card.nature == 'fire' || card.nature == 'thunder')) {
									game.playAudio('card', sex, card.name + '_' + card.nature);
								}
								else {
									if (typeof audioinfo == 'string') {
										if (audioinfo.indexOf('ext:') == 0) game.playAudio('..', 'extension', audioinfo.slice(4), card.name + '_' + sex);
										else game.playAudio('card', sex, audioinfo);
									}
									else {
										game.playAudio('card', sex, card.name);
									}
								}
								// }
								// else if(get.type(card)!='equip'){
								// 	game.playAudio('card/default');
								// }
							}
						}, player, card);
					}
					if (event.animate != false && event.line != false) {
						if ((card.name == 'wuxie' || card.name == 'youdishenru') && event.getParent().source) {
							var lining = event.getParent().sourcex || event.getParent().source2 || event.getParent().source;
							if (lining == player && event.getParent().sourcex2) {
								lining = event.getParent().sourcex2;
							}
							if (Array.isArray(lining) && event.getTrigger().name == 'jiedao') {
								player.line(lining[0], 'green');
							}
							else {
								player.line(lining, 'green');
							}
						}
						else {
							var config = {};
							if (card.nature == 'fire' ||
								(card.classList && card.classList.contains('fire'))) {
								config.color = 'fire';
							}
							else if (card.nature == 'thunder' ||
								(card.classList && card.classList.contains('thunder'))) {
								config.color = 'thunder';
							}
							if (event.addedTarget) {
								player.line2(targets.concat(event.addedTargets), config);
							}
							else if (get.info(card, false).multitarget && targets.length > 1 && !get.info(card, false).multiline) {
								player.line2(targets, config);
							}
							else {
								player.line(targets, config);
							}
						}
						if (event.throw !== false) player.$throw(cards);
						if (lib.config.sync_speed && cards[0] && cards[0].clone) {
							var waitingForTransition = get.time();
							event.waitingForTransition = waitingForTransition;
							cards[0].clone.listenTransition(function () {
								if (_status.waitingForTransition == waitingForTransition && _status.paused) {
									game.resume();
								}
								delete event.waitingForTransition;
							});
						}
					}
					event.id = get.id();
					if (event.oncard) {
						event.oncard(event.card, event.player);
					}
					event.excluded = [];
					event.directHit = [];
					event.customArgs = { default: {} };
					event.baseDamage = get.info(card, false).baseDamage || 1;
					player.actionHistory[player.actionHistory.length - 1].useCard.push(event);
					if (event.addCount !== false) {
						if (player.stat[player.stat.length - 1].card[card.name] == undefined) {
							player.stat[player.stat.length - 1].card[card.name] = 1;
						}
						else {
							player.stat[player.stat.length - 1].card[card.name]++;
						}
						if (event.skill) {
							if (player.stat[player.stat.length - 1].skill[event.skill] == undefined) {
								player.stat[player.stat.length - 1].skill[event.skill] = 1;
							}
							else {
								player.stat[player.stat.length - 1].skill[event.skill]++;
							}
							var sourceSkill = get.info(event.skill).sourceSkill;
							if (sourceSkill) {
								if (player.stat[player.stat.length - 1].skill[sourceSkill] == undefined) {
									player.stat[player.stat.length - 1].skill[sourceSkill] = 1;
								}
								else {
									player.stat[player.stat.length - 1].skill[sourceSkill]++;
								}
							}
						}
					}
					if (targets.length) {
						var str = (targets.length == 1 && targets[0] == player) ? '#b自己' : targets;
						if (cards.length && !card.isCard) {
							if (event.addedTarget) {
								game.log(player, '对', str, '使用了', card, '（', cards, '，指向', event.addedTargets, '）');
							}
							else {
								game.log(player, '对', str, '使用了', card, '（', cards, '）');
							}
						}
						else {
							if (event.addedTarget) {
								game.log(player, '对', str, '使用了', card, '（指向', event.addedTargets, '）');
							}
							else {
								game.log(player, '对', str, '使用了', card);
							}
						}
					}
					else {
						if (cards.length && !card.isCard) {
							if (event.addedTarget) {
								game.log(player, '使用了', card, '（', cards, '，指向', event.addedTargets, '）');
							}
							else {
								game.log(player, '使用了', card, '（', cards, '）');
							}
						}
						else {
							if (event.addedTarget) {
								game.log(player, '使用了', card, '（指向', event.addedTargets, '）');
							}
							else {
								game.log(player, '使用了', card);
							}
						}
					}
					if (card.name == 'wuxie') {
						game.logv(player, [card, cards], [event.getTrigger().card]);
					}
					else {
						game.logv(player, [card, cards], targets);
					}
					event.trigger('useCard1');
					"step 1"
					event.trigger('useCard2');
					"step 2"
					event.trigger('useCard');
					event._oncancel = function () {
						game.broadcastAll(function (id) {
							if (ui.tempnowuxie && ui.tempnowuxie._origin == id) {
								ui.tempnowuxie.close();
								delete ui.tempnowuxie;
							}
						}, event.id);
					};
					"step 3"
					event.sortTarget = function (animate, sort) {
						var info = get.info(card, false);
						if (num == 0 && targets.length > 1) {
							if (!info.multitarget) {
								if (!event.fixedSeat && !sort) {
									targets.sortBySeat(player);
								}
								if (animate) for (var i = 0; i < targets.length; i++) {
									targets[i].animate('target');
								}
							}
							else if (animate) {
								for (var i = 0; i < targets.length; i++) {
									targets[i].animate('target');
								}
							}
						}
					}
					event.sortTarget();
					event.getTriggerTarget = function (list1, list2) {
						var listx = list1.slice(0).sortBySeat();
						for (var i = 0; i < listx.length; i++) {
							if (list2.numOf(listx[i]) < listx.numOf(listx[i])) return listx[i];
						}
						return null;
					}
					var info = get.info(card, false);
					if (!info.nodelay && event.animate != false) {
						if (event.delayx !== false) {
							if (event.waitingForTransition) {
								_status.waitingForTransition = event.waitingForTransition;
								game.pause();
							}
							else {
								game.delayx();
							}
						}
					}
					"step 4"
					if (event.all_excluded) return;
					if (!event.triggeredTargets1) event.triggeredTargets1 = [];
					var target = event.getTriggerTarget(targets, event.triggeredTargets1);
					if (target) {
						event.triggeredTargets1.push(target);
						var next = game.createEvent('useCardToPlayer', false);
						if (event.triggeredTargets1.length == 1) next.isFirstTarget = true;
						next.setContent('emptyEvent');
						next.targets = targets;
						next.target = target;
						next.card = card;
						next.cards = cards;
						next.player = player;
						next.excluded = event.excluded;
						next.directHit = event.directHit;
						next.customArgs = event.customArgs;
						if (event.forceDie) next.forceDie = true;
						event.redo();
					}
					"step 5"
					if (event.all_excluded) return;
					if (!event.triggeredTargets2) event.triggeredTargets2 = [];
					var target = event.getTriggerTarget(targets, event.triggeredTargets2);
					if (target) {
						event.triggeredTargets2.push(target);
						var next = game.createEvent('useCardToTarget', false);
						if (event.triggeredTargets2.length == 1) next.isFirstTarget = true;
						next.setContent('emptyEvent');
						next.targets = targets;
						next.target = target;
						next.card = card;
						next.cards = cards;
						next.player = player;
						next.excluded = event.excluded;
						next.directHit = event.directHit;
						next.customArgs = event.customArgs;
						if (event.forceDie) next.forceDie = true;
						event.redo();
					}
					"step 6"
					if (event.all_excluded) return;
					if (!event.triggeredTargets3) event.triggeredTargets3 = [];
					var target = event.getTriggerTarget(targets, event.triggeredTargets3);
					if (target) {
						event.triggeredTargets3.push(target);
						var next = game.createEvent('useCardToPlayered', false);
						if (event.triggeredTargets3.length == 1) next.isFirstTarget = true;
						next.setContent('emptyEvent');
						next.targets = targets;
						next.target = target;
						next.card = card;
						next.cards = cards;
						next.player = player;
						next.excluded = event.excluded;
						next.directHit = event.directHit;
						next.customArgs = event.customArgs;
						if (event.forceDie) next.forceDie = true;
						event.redo();
					}
					"step 7"
					if (event.all_excluded) return;
					if (!event.triggeredTargets4) event.triggeredTargets4 = [];
					var target = event.getTriggerTarget(targets, event.triggeredTargets4);
					if (target) {
						event.triggeredTargets4.push(target);
						var next = game.createEvent('useCardToTargeted', false);
						if (event.triggeredTargets4.length == 1) next.isFirstTarget = true;
						next.setContent('emptyEvent');
						next.targets = targets;
						next.target = target;
						next.card = card;
						next.cards = cards;
						next.player = player;
						next.excluded = event.excluded;
						next.directHit = event.directHit;
						next.customArgs = event.customArgs;
						if (event.forceDie) next.forceDie = true;
						if (targets.length == event.triggeredTargets4.length) {
							event.sortTarget();
						}
						event.redo();
					}
					"step 8"
					var info = get.info(card, false);
					if (info.contentBefore) {
						var next = game.createEvent(card.name + 'ContentBefore');
						next.setContent(info.contentBefore);
						next.targets = targets;
						next.card = card;
						next.cards = cards;
						next.player = player;
						next.type = 'precard';
						if (event.forceDie) next.forceDie = true;
					}
					else if (info.reverseOrder && get.is.versus() && targets.length > 1) {
						var next = game.createEvent(card.name + 'ContentBefore');
						next.setContent('reverseOrder');
						next.targets = targets;
						next.card = card;
						next.cards = cards;
						next.player = player;
						next.type = 'precard';
						if (event.forceDie) next.forceDie = true;
					}
					"step 9"
					if (event.all_excluded) return;
					var info = get.info(card, false);
					if (num == 0 && targets.length > 1) {
						event.sortTarget(true, true);
					}
					if (targets[num] && targets[num].isDead()) return;
					if (targets[num] && targets[num].isOut()) return;
					if (targets[num] && targets[num].removed) return;
					if (targets[num] && info.ignoreTarget && info.ignoreTarget(card, player, targets[num])) return;
					if (targets.length == 0 && !info.notarget) return;
					if (targets[num] && event.excluded.contains(targets[num])) {
						var next = game.createEvent('useCardToExcluded', false);
						next.setContent('emptyEvent');
						next.targets = targets;
						next.target = targets[num];
						next.num = num;
						next.card = card;
						next.cards = cards;
						next.player = player;
						return;
					};
					var next = game.createEvent(card.name);
					next.setContent(info.content);
					next.targets = targets;
					next.card = card;
					next.cards = cards;
					next.player = player;
					next.num = num;
					next.type = 'card';
					next.skill = event.skill;
					next.multitarget = info.multitarget;
					next.preResult = event.preResult;
					next.baseDamage = event.baseDamage;
					if (event.forceDie) next.forceDie = true;
					if (event.addedTargets) {
						next.addedTargets = event.addedTargets;
						next.addedTarget = event.addedTarget;
						next._targets = event._targets;
					}
					if (info.targetDelay === false) {
						event.targetDelay = false;
					}
					next.target = targets[num];
					for (var i in event.customArgs.default) next[i] = event.customArgs.default[i];
					if (next.target && event.customArgs[next.target.playerid]) {
						var customArgs = event.customArgs[next.target.playerid];
						for (var i in customArgs) next[i] = customArgs[i];
					}
					if (next.target && event.directHit.contains(next.target)) next.directHit = true;
					if (next.target && !info.multitarget) {
						if (num == 0 && targets.length > 1) {
							// var ttt=next.target;
							// setTimeout(function(){ttt.animate('target');},0.5*lib.config.duration);
						}
						else {
							next.target.animate('target');
						}
					}
					if (!info.nodelay && num > 0) {
						if (event.targetDelay !== false) {
							game.delayx(0.5);
						}
					}
					"step 10"
					if (event.all_excluded) return;
					if (!get.info(event.card, false).multitarget && num < targets.length - 1 && !event.cancelled) {
						event.num++;
						event.goto(9);
					}
					"step 11"
					if (get.info(card, false).contentAfter) {
						var next = game.createEvent(card.name + 'ContentAfter');
						next.setContent(get.info(card, false).contentAfter);
						next.targets = targets;
						next.card = card;
						next.cards = cards;
						next.player = player;
						next.preResult = event.preResult;
						next.type = 'postcard';
						if (event.forceDie) next.forceDie = true;
					}
					"step 12"
					if (event.postAi) {
						event.player.logAi(event.targets, event.card);
					}
					if (event._result) {
						event.result = event._result;
					}
					//delete player.using;
					if (document.getElementsByClassName('thrown').length) {
						if (event.delayx !== false) game.delayx();
					}
					else {
						event.finish();
					}
					"step 13"
					event._oncancel();
				},
				useSkill: function () {
					"step 0"
					var info = get.info(event.skill);
					if (!info.noForceDie) event.forceDie = true;
					event._skill = event.skill;
					game.trySkillAudio(event.skill, player);
					var checkShow = player.checkShow(event.skill);
					if (info.discard != false && info.lose != false && !info.viewAs) {
						player.discard(cards).delay = false;
						if (lib.config.low_performance) {
							event.discardTransition = true;
						}
					}
					else {
						if (info.lose != false) {
							if (info.losetrigger == false) {
								var losecard = player.lose(cards, ui.special)._triggered = null;
							}
							else {
								var losecard = player.lose(cards, ui.special);
								if (info.visible) losecard.visible = true;
								if (info.loseTo) losecard.position = ui[info.loseTo];
								if (losecard.position == ui.special && info.toStorage) losecard.toStorage = true;
							}
						}
						if (!info.prepare && info.viewAs) {
							player.$throw(cards);
							if (losecard) losecard.visible = true;
							if (lib.config.sync_speed && cards[0] && cards[0].clone) {
								var waitingForTransition = get.time();
								event.waitingForTransition = waitingForTransition;
								cards[0].clone.listenTransition(function () {
									if (_status.waitingForTransition == waitingForTransition && _status.paused) {
										game.resume();
									}
									delete event.waitingForTransition;
								});
							}
						}
					}
					if (info.line != false && targets.length) {
						var config = {};
						if (get.is.object(info.line)) config = info.line;
						else if (info.line == 'fire') {
							config.color = 'fire';
						}
						else if (info.line == 'thunder') {
							config.color = 'thunder';
						}
						else if (info.line === undefined || info.line == 'green') {
							config.color = 'green';
						}
						if (info.multitarget && !info.multiline && targets.length > 1) {
							player.line2(targets, config);
						}
						else {
							player.line(targets, config);
						}
					}
					var str = '';
					if (targets && targets.length && info.log != 'notarget') {
						str += '对<span class="bluetext">' + (targets[0] == player ? '自己' : get.translation(targets[0]));
						for (var i = 1; i < targets.length; i++) {
							str += '、' + (targets[i] == player ? '自己' : get.translation(targets[i]));
						}
						str += '</span>'
					}
					str += '发动了';
					if (!info.direct) {
						game.log(player, str, '【' + get.skillTranslation(skill, player) + '】');
						if (info.logv !== false) game.logv(player, skill, targets);
						player.trySkillAnimate(skill, skill, checkShow);
					}
					if (event.addCount != false) {
						if (player.stat[player.stat.length - 1].skill[skill] == undefined) {
							player.stat[player.stat.length - 1].skill[skill] = 1;
						}
						else {
							player.stat[player.stat.length - 1].skill[skill]++;
						}
						var sourceSkill = get.info(skill).sourceSkill;
						if (sourceSkill) {
							if (player.stat[player.stat.length - 1].skill[sourceSkill] == undefined) {
								player.stat[player.stat.length - 1].skill[sourceSkill] = 1;
							}
							else {
								player.stat[player.stat.length - 1].skill[sourceSkill]++;
							}
						}
					}
					if (player.stat[player.stat.length - 1].allSkills == undefined) {
						player.stat[player.stat.length - 1].allSkills = 1;
					}
					else {
						player.stat[player.stat.length - 1].allSkills++;
					}
					if (info.prepare) {
						switch (info.prepare) {
							case 'give': if (losecard) losecard.visible = true; player.$give(cards, targets[0]); break;
							case 'give2': player.$give(cards.length, targets[0]); break;
							case 'throw': if (losecard) losecard.visible = true; player.$throw(cards); break;
							case 'throw2': player.$throw(cards.length); break;
							default: info.prepare(cards, player, targets);
						}
					}
					if (info.round) {
						var roundname = skill + '_roundcount';
						player.storage[roundname] = game.roundNumber;
						player.syncStorage(roundname);
						player.markSkill(roundname);
					}
					"step 1"
					var info = get.info(event.skill);
					if (info && info.contentBefore) {
						var next = game.createEvent(event.skill + 'ContentBefore');
						next.setContent(info.contentBefore);
						next.targets = targets;
						next.cards = cards;
						next.player = player;
						if (event.forceDie) next.forceDie = true;
					}
					"step 2"
					if (!event.skill) {
						console.log('error: no skill', get.translation(event.player), event.player.getSkills());
						if (event._skill) {
							event.skill = event._skill;
							console.log(event._skill);
						}
						else {
							event.finish();
							return;
						}
					}
					var info = get.info(event.skill);
					if (targets[num] && targets[num].isDead() ||
						targets[num] && targets[num].isOut() ||
						targets[num] && targets[num].removed) {
						if (!info.multitarget && num < targets.length - 1) {
							event.num++;
							event.redo();
						}
						return;
					}
					var next = game.createEvent(event.skill);
					next.setContent(info.content);
					next.targets = targets;
					next.cards = cards;
					next.player = player;
					next.num = num;
					next.multitarget = info.multitarget;
					if (num == 0 && next.targets.length > 1) {
						if (!info.multitarget) {
							lib.tempSortSeat = player;
							targets.sort(lib.sort.seat);
							delete lib.tempSortSeat;
						}
						for (var i = 0; i < targets.length; i++) {
							targets[i].animate('target');
						}
					}
					next.target = targets[num];
					if (event.forceDie) next.forceDie = true;
					if (next.target && !info.multitarget) {
						if (num == 0 && targets.length > 1) {
							// var ttt=next.target;
							// setTimeout(function(){ttt.animate('target');},0.5*lib.config.duration);
						}
						else {
							next.target.animate('target');
						}
					}
					if (num == 0) {
						if (typeof info.delay == 'number') game.delay(info.delay);
						else if (info.delay !== false && info.delay !== 0) {
							if (event.waitingForTransition) {
								_status.waitingForTransition = event.waitingForTransition;
								game.pause();
							}
							else {
								game.delayx()
							}
						}
					}
					else game.delayx(0.5);
					if (!info.multitarget && num < targets.length - 1) {
						event.num++;
						event.redo();
					}
					"step 3"
					var info = get.info(event.skill);
					if (info && info.contentAfter) {
						var next = game.createEvent(event.skill + 'ContentAfter');
						next.setContent(info.contentAfter);
						next.targets = targets;
						next.cards = cards;
						next.player = player;
						if (event.forceDie) next.forceDie = true;
					}
					"step 4"
					if (player.getStat().allSkills > 200) {
						player._noSkill = true;
						console.log(player.name, event.skill);
					}
					if (document.getElementsByClassName('thrown').length) {
						if (event.skill && get.info(event.skill).delay !== 0) game.delayx();
					}
					else {
						event.finish();
					}
					"step 5"
					ui.clear();
				},
				draw: function () {
					// if(lib.config.background_audio){
					// 	game.playAudio('effect','draw');
					// }
					// game.broadcast(function(){
					//     if(lib.config.background_audio){
					// 		game.playAudio('effect','draw');
					// 	}
					// });
					if (typeof event.minnum == 'number' && num < event.minnum) {
						num = event.minnum;
					}
					if (event.drawDeck) {
						if (event.drawDeck > num) {
							event.drawDeck = num;
						}
						num -= event.drawDeck;
					}
					if (event.log != false) {
						if (num > 0) {
							if (event.bottom) game.log(player, '从牌堆底摸了' + get.cnNumber(num) + '张牌');
							else game.log(player, '摸了' + get.cnNumber(num) + '张牌');
						}
						if (event.drawDeck) {
							game.log(player, '从牌库中获得了' + get.cnNumber(event.drawDeck) + '张牌');
						}
					}
					var cards;
					if (num > 0) {
						if (event.bottom) cards = get.bottomCards(num);
						else cards = get.cards(num);
					}
					else {
						cards = [];
					}
					if (event.drawDeck) {
						cards = cards.concat(player.getDeckCards(event.drawDeck));
					}
					if (event.animate != false) {
						if (event.visible) {
							player.gain(cards, 'gain2');
							if (event.bottom) game.log(player, '从牌堆底摸了' + get.cnNumber(num) + '张牌（', cards, '）');
							else game.log(player, '摸了' + get.cnNumber(num) + '张牌（', cards, '）');
						}
						else {
							player.gain(cards, 'draw');
						}
					}
					else {
						player.gain(cards);
						if (event.$draw) {
							player.$draw(cards.length);
						}
					}
					event.result = cards;
				},
				discard: function () {
					"step 0"
					game.log(player, '弃置了', cards);
					event.done = player.lose(cards, event.position, 'visible').type = 'discard';
					"step 1"
					event.trigger('discard');
				},
				respond: function () {
					'step 0'
					var cardaudio = true;
					if (event.skill) {
						if (lib.skill[event.skill].audio) {
							cardaudio = false;
						}
						player.logSkill(event.skill);
						player.checkShow(event.skill, true);
						if (lib.skill[event.skill].onrespond && !game.online) {
							lib.skill[event.skill].onrespond(event, player);
						}
					}
					else if (!event.nopopup) player.tryCardAnimate(card, card.name, 'wood');
					if (cardaudio && event.getParent(3).name == 'useCard') {
						game.broadcastAll(function (player, card) {
							if (lib.config.background_audio) {
								var sex = player.sex == 'female' ? 'female' : 'male';
								var audioinfo = lib.card[card.name].audio;
								// if(audioinfo||true){
								if (typeof audioinfo == 'string' && audioinfo.indexOf('ext:') == 0) {
									game.playAudio('..', 'extension', audioinfo.slice(4), card.name + '_' + sex);
								}
								else {
									game.playAudio('card', sex, card.name);
								}
								// }
								// else{
								// 	game.playAudio('card/default');
								// }
							}
						}, player, card);
					}
					if (cards.length && (cards.length > 1 || cards[0].name != card.name)) {
						game.log(player, '打出了', card, '（', cards, '）');
					}
					else {
						game.log(player, '打出了', card);
					}
					player.actionHistory[player.actionHistory.length - 1].respond.push(event);
					var cards2 = cards.slice(0);
					if (cards2.length) {
						var next = player.lose(cards2, ui.ordering, 'visible');
						if (event.noOrdering) next.noOrdering = true;
						cards2.removeArray(next.cards);
						if (cards2.length) {
							var next2 = game.cardsGotoOrdering(cards2);
							if (event.noOrdering) next2.noOrdering = true;
						}
					}
					for (var i = 0; i < cards.length; i++) {
						if (event.animate != false) player.$throw(cards[i]);
						if (event.highlight) {
							cards[i].clone.classList.add('thrownhighlight');
							game.addVideo('highlightnode', player, get.cardInfo(cards[i]));
						}
						var name = '';
						if (event.skill) name = get.translation(event.skill) + '：';
						if (event.card) name += get.translation(event.card.name);
					}
					if (event.highlight) {
						game.broadcast(function (cards) {
							for (var i = 0; i < cards.length; i++) {
								if (cards[i].clone) {
									cards[i].clone.classList.add('thrownhighlight');
								}
							}
						}, cards);
					}
					event.trigger('respond');
					'step 1'
					game.delayx(0.5);
				},
				swapHandcards: function () {
					'step 0'
					event.cards1 = event.cards1 || player.getCards('h');
					event.cards2 = event.cards2 || target.getCards('h');
					player.$giveAuto(event.cards1, target);
					target.$giveAuto(event.cards2, player);
					'step 1'
					event.cards = event.cards1;
					var next = player.lose(event.cards, ui.ordering);
					if (player == game.me) {
						event.delayed = true;
					}
					else {
						next.delay = false;
					}
					'step 1'
					event.cards = event.cards2;
					var next = target.lose(event.cards, ui.ordering);
					if (target == game.me) {
						event.delayed = true;
					}
					else {
						next.delay = false;
					}
					'step 2'
					if (!event.delayed) game.delay();
					'step 3'
					player.gain(event.cards2);
					target.gain(event.cards1);
				},
				gainMultiple: function () {
					'step 0'
					event.delayed = false;
					event.num = 0;
					event.cards = [];
					'step 1'
					player.gainPlayerCard(targets[num], event.position, true).set('boolline', false).set('delay', num == targets.length - 1);
					'step 2'
					if (result.bool) {
						event.cards.addArray(result.cards);
						if (num == targets.length - 1) event.delayed = true;
					}
					event.num++;
					if (event.num < targets.length) {
						event.goto(1);
					}
					'step 3'
					if (!event.delayed) game.delay();
				},
				gain: function () {
					"step 0"
					if (cards) {
						var owner = event.source || get.owner(cards[0]);
						if (owner) {
							var next = owner.lose(cards, ui.special).set('type', 'gain').set('forceDie', true).set('getlx', false);
							if (event.animate == 'give' || event.visible == true) next.visible = true;
							event.relatedLose = next;
						}
					}
					else {
						event.finish();
					}
					"step 1"
					for (var i = 0; i < cards.length; i++) {
						if (cards[i].destroyed) {
							if (player.hasSkill(cards[i].destroyed)) {
								delete cards[i].destroyed;
							}
							else {
								cards.splice(i--, 1);
							}
						}
					}
					if (cards.length == 0) {
						event.finish();
						return;
					}
					player.getHistory('gain').push(event);
					//if(event.source&&event.delay!==false) game.delayx();
					"step 2"
					if (player.getStat().gain == undefined) {
						player.getStat().gain = cards.length;
					}
					else {
						player.getStat().gain += cards.length;
					}
					"step 3"
					var sort;
					var frag1 = document.createDocumentFragment();
					var frag2 = document.createDocumentFragment();
					var hs = player.getCards('h');
					for (var i = 0; i < cards.length; i++) {
						if (hs.contains(cards[i])) {
							cards.splice(i--, 1);
						}
					}
					for (var num = 0; num < cards.length; num++) {
						sort = lib.config.sort_card(cards[num]);
						if (lib.config.reverse_sort) sort = -sort;
						cards[num].fix();
						cards[num].style.transform = '';
						if (_status.discarded) {
							_status.discarded.remove(cards[num]);
						}
						// cards[num].vanishtag.length=0;
						for (var num2 = 0; num2 < cards[num].vanishtag.length; num2++) {
							if (cards[num].vanishtag[num2][0] != '_') {
								cards[num].vanishtag.splice(num2--, 1);
							}
						}
						if (player == game.me) {
							cards[num].classList.add('drawinghidden');
						}
						if (get.is.singleHandcard() || sort > 1) frag1.appendChild(cards[num]);
						else frag2.appendChild(cards[num]);
					}
					var addv = function () {
						if (player == game.me) {
							game.addVideo('gain12', player, [get.cardsInfo(frag1.childNodes), get.cardsInfo(frag2.childNodes)]);
						}
					};
					var broadcast = function () {
						game.broadcast(function (player, cards, num) {
							player.directgain(cards);
							_status.cardPileNum = num;
						}, player, cards, ui.cardPile.childNodes.length);
					};
					if (event.animate == 'draw') {
						player.$draw(cards.length);
						game.pause();
						setTimeout(function () {
							addv();
							player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
							player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
							player.update();
							if (player == game.me) ui.updatehl();
							broadcast();
							game.resume();
						}, get.delayx(500, 500));
					}
					else if (event.animate == 'gain') {
						player.$gain(cards);
						game.pause();
						setTimeout(function () {
							addv();
							player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
							player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
							player.update();
							if (player == game.me) ui.updatehl();
							broadcast();
							game.resume();
						}, get.delayx(700, 700));
					}
					else if (event.animate == 'gain2' || event.animate == 'draw2') {
						var gain2t = 300;
						if (player.$gain2(cards) && player == game.me) {
							gain2t = 500;
						}
						game.pause();
						setTimeout(function () {
							addv();
							player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
							player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
							player.update();
							if (player == game.me) ui.updatehl();
							broadcast();
							game.resume();
						}, get.delayx(gain2t, gain2t));
					}
					else if (event.source && (event.animate == 'give' || event.animate == 'giveAuto')) {
						if (event.animate == 'give') event.source['$' + event.animate](cards, player);
						else {
							var givemap = { hs: [], ots: [] };
							for (var i = 0; i < cards.length; i++) {
								givemap[event.relatedLose && event.relatedLose.hs && event.relatedLose.hs.contains(cards[i]) ? 'hs' : 'ots'].push(cards[i]);
							}
							if (givemap.hs.length) event.source.$giveAuto(givemap.hs, player);
							if (givemap.ots.length) event.source.$give(givemap.ots, player);
						}
						game.pause();
						setTimeout(function () {
							addv();
							player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
							player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
							player.update();
							if (player == game.me) ui.updatehl();
							broadcast();
							game.resume();
						}, get.delayx(500, 500));
					}
					else {
						addv();
						player.node.handcards1.insertBefore(frag1, player.node.handcards1.firstChild);
						player.node.handcards2.insertBefore(frag2, player.node.handcards2.firstChild);
						player.update();
						if (player == game.me) ui.updatehl();
						broadcast();
						event.finish();
					}
					if (event.log) {
						game.log(player, '获得了', cards);
					}
					"step 4"
					game.delayx();
				},
				lose: function () {
					"step 0"
					var evt = event.getParent();
					if (evt.name != 'discard' && event.type != 'discard') return;
					if (evt.animate != false) {
						evt.discardid = lib.status.videoId++;
						game.broadcastAll(function (player, cards, id) {
							player.$throw(cards, null, 'nobroadcast');
							var cardnodes = [];
							cardnodes._discardtime = get.time();
							for (var i = 0; i < cards.length; i++) {
								if (cards[i].clone) {
									cardnodes.push(cards[i].clone);
								}
							}
							ui.todiscard[id] = cardnodes;
						}, player, cards, evt.discardid);
						if (lib.config.sync_speed && cards[0] && cards[0].clone) {
							if (evt.delay != false) {
								var waitingForTransition = get.time();
								evt.waitingForTransition = waitingForTransition;
								cards[0].clone.listenTransition(function () {
									if (_status.waitingForTransition == waitingForTransition && _status.paused) {
										game.resume();
									}
									delete evt.waitingForTransition;
								});
							}
							else if (evt.getParent().discardTransition) {
								delete evt.getParent().discardTransition;
								var waitingForTransition = get.time();
								evt.getParent().waitingForTransition = waitingForTransition;
								cards[0].clone.listenTransition(function () {
									if (_status.waitingForTransition == waitingForTransition && _status.paused) {
										game.resume();
									}
									delete evt.getParent().waitingForTransition;
								});
							}
						}
					}
					"step 1"
					var hs = [], es = [], js = [];
					var hej = player.getCards('hej');
					event.stockcards = cards.slice(0);
					for (var i = 0; i < cards.length; i++) {
						cards[i].style.transform += ' scale(0.2)';
						cards[i].classList.remove('glow');
						cards[i].recheck();
						var info = lib.card[cards[i].name];
						if (info.destroy || cards[i]._destroy) {
							cards[i].delete();
							cards[i].destroyed = info.destroy || cards[i]._destroy;
						}
						else if (event.position) {
							if (_status.discarded) {
								if (event.position == ui.discardPile) {
									_status.discarded.add(cards[i]);
								}
								else {
									_status.discarded.remove(cards[i]);
								}
							}
							cards[i].goto(event.position);
						}
						else {
							cards[i].delete();
						}
						if (!hej.contains(cards[i])) {
							cards.splice(i--, 1);
						}
						else if (cards[i].parentNode) {
							if (cards[i].parentNode.classList.contains('equips')) {
								cards[i].original = 'e';
								es.push(cards[i]);
							}
							else if (cards[i].parentNode.classList.contains('judges')) {
								cards[i].original = 'j';
								js.push(cards[i]);
							}
							else if (cards[i].parentNode.classList.contains('handcards')) {
								cards[i].original = 'h';
								hs.push(cards[i]);
							}
							else {
								cards[i].original = null;
							}
						}
					}
					if (player == game.me) ui.updatehl();
					ui.updatej(player);
					game.broadcast(function (player, cards, num) {
						for (var i = 0; i < cards.length; i++) {
							cards[i].classList.remove('glow');
							cards[i].delete();
						}
						if (player == game.me) {
							ui.updatehl();
						}
						ui.updatej(player);
						_status.cardPileNum = num;
					}, player, cards, ui.cardPile.childNodes.length);
					game.addVideo('lose', player, [get.cardsInfo(hs), get.cardsInfo(es), get.cardsInfo(js)]);
					event.cards2 = hs.concat(es);
					player.getHistory('lose').push(event);
					game.getGlobalHistory().cardMove.push(event);
					player.update();
					game.addVideo('loseAfter', player);
					event.num = 0;
					if (event.position == ui.ordering) {
						var evt = event.getParent();
						if (!evt.orderingCards) evt.orderingCards = [];
						if (!event.noOrdering && !event.cardsOrdered) {
							event.cardsOrdered = true;
							var next = game.createEvent('orderingDiscard', false, evt.getParent());
							next.relatedEvent = evt;
							next.setContent('orderingDiscard');
						}
						if (!event.noOrdering) evt.orderingCards.addArray(cards);
					}
					event.hs = hs;
					event.es = es;
					event.js = js;
					"step 2"
					if (num < cards.length) {
						if (event.es.contains(cards[num])) {
							event.loseEquip = true;
							player.removeEquipTrigger(cards[num]);
							var info = get.info(cards[num]);
							if (info.onLose && (!info.filterLose || info.filterLose(cards[num], player))) {
								event.goto(3);
								return;
							}
						}
						event.num++;
						event.redo();
					}
					else {
						if (event.loseEquip) {
							player.addEquipTrigger();
						}
						event.goto(4);
					}
					"step 3"
					var info = get.info(cards[num]);
					if (info.loseDelay != false && (player.isAlive() || info.forceDie)) {
						player.popup(cards[num].name);
						game.delayx();
					}
					if (Array.isArray(info.onLose)) {
						for (var i = 0; i < info.onLose.length; i++) {
							var next = game.createEvent('lose_' + cards[num].name);
							next.setContent(info.onLose[i]);
							if (info.forceDie) next.forceDie = true;
							next.player = player;
							next.card = cards[num];
						}
					}
					else {
						var next = game.createEvent('lose_' + cards[num].name);
						next.setContent(info.onLose);
						next.player = player;
						if (info.forceDie) next.forceDie = true;
						next.card = cards[num];
					}
					event.num++;
					event.goto(2);
					"step 4"
					var evt = event.getParent();
					if (evt.name != 'discard' && event.type != 'discard') return;
					if (evt.delay != false) {
						if (evt.waitingForTransition) {
							_status.waitingForTransition = evt.waitingForTransition;
							game.pause();
						}
						else {
							game.delayx();
						}
					}
				},
				damage: function () {
					"step 0"
					event.forceDie = true;
					event.trigger('damageBegin1');
					"step 1"
					event.trigger('damageBegin2');
					"step 2"
					event.trigger('damageBegin3');
					"step 3"
					event.trigger('damageBegin4');
					"step 4"
					if (num > 0 && player.hujia && !player.hasSkillTag('nohujia')) {
						if (num >= player.hujia) {
							event.hujia = player.hujia;
							num -= player.hujia;
						}
						else {
							event.hujia = num;
							num = 0;
						}
						game.log(player, '的护甲抵挡了' + get.cnNumber(event.hujia) + '点伤害');
						player.changeHujia(-event.hujia).type = 'damage';
					}
					event.num = num;
					if (num <= 0) {
						event.trigger('damageZero');
						delete event.filterStop;
						event.finish();
						event._triggered = null;
					}
					"step 5"
					if (lib.config.background_audio) {
						game.playAudio('effect', 'damage' + (num > 1 ? '2' : ''));
					}
					game.broadcast(function (num) {
						if (lib.config.background_audio) {
							game.playAudio('effect', 'damage' + (num > 1 ? '2' : ''));
						}
					}, num);
					var str = '受到了';
					if (source) str += '来自<span class="bluetext">' + (source == player ? '自己' : get.translation(source)) + '</span>的';
					str += get.cnNumber(num) + '点';
					if (event.nature) str += get.translation(event.nature) + '属性';
					str += '伤害';
					game.log(player, str);
					if (player.stat[player.stat.length - 1].damaged == undefined) {
						player.stat[player.stat.length - 1].damaged = num;
					}
					else {
						player.stat[player.stat.length - 1].damaged += num;
					}
					if (source) {
						source.getHistory('sourceDamage').push(event);
						if (source.stat[source.stat.length - 1].damage == undefined) {
							source.stat[source.stat.length - 1].damage = num;
						}
						else {
							source.stat[source.stat.length - 1].damage += num;
						}
					}
					player.getHistory('damage').push(event);
					if (event.notrigger) {
						player.changeHp(-num, false)._triggered = null;
					}
					else {
						player.changeHp(-num, false);
					}
					if (event.animate !== false) {
						player.$damage(source);
						game.broadcastAll(function (nature, player) {
							if (lib.config.animation && !lib.config.low_performance) {
								if (nature == 'fire') {
									player.$fire();
								}
								else if (nature == 'thunder') {
									player.$thunder();
								}
							}
						}, event.nature, player);
						player.$damagepop(-num, event.nature);
					}
					if (!event.notrigger) {
						if (num == 0) {
							event.trigger('damageZero');
							event._triggered = null;
						}
						else {
							event.trigger('damage');
						}
					}
					"step 6"
					if (player.hp <= 0 && player.isAlive()) {
						game.delayx();
						player.dying(event);
					}
					if (source && lib.config.border_style == 'auto') {
						var dnum = 0;
						for (var j = 0; j < source.stat.length; j++) {
							if (source.stat[j].damage != undefined) dnum += source.stat[j].damage;
						}
						if (dnum >= 2) {
							if (lib.config.autoborder_start == 'silver') {
								dnum += 4;
							}
							else if (lib.config.autoborder_start == 'gold') {
								dnum += 8;
							}
						}
						if (lib.config.autoborder_count == 'damage') {
							source.node.framebg.dataset.decoration = '';
							if (dnum >= 10) {
								source.node.framebg.dataset.auto = 'gold';
								if (dnum >= 12) source.node.framebg.dataset.decoration = 'gold';
							}
							else if (dnum >= 6) {
								source.node.framebg.dataset.auto = 'silver';
								if (dnum >= 8) source.node.framebg.dataset.decoration = 'silver';
							}
							else if (dnum >= 2) {
								source.node.framebg.dataset.auto = 'bronze';
								if (dnum >= 4) source.node.framebg.dataset.decoration = 'bronze';
							}
							if (dnum >= 2) {
								source.classList.add('topcount');
							}
						}
						else if (lib.config.autoborder_count == 'mix') {
							source.node.framebg.dataset.decoration = '';
							switch (source.node.framebg.dataset.auto) {
								case 'bronze': if (dnum >= 4) source.node.framebg.dataset.decoration = 'bronze'; break;
								case 'silver': if (dnum >= 8) source.node.framebg.dataset.decoration = 'silver'; break;
								case 'gold': if (dnum >= 12) source.node.framebg.dataset.decoration = 'gold'; break;
							}
						}
					}
					"step 7"
					if (!event.notrigger) event.trigger('damageSource');
				},
				recover: function () {
					if (lib.config.background_audio) {
						game.playAudio('effect', 'recover');
					}
					game.broadcast(function () {
						if (lib.config.background_audio) {
							game.playAudio('effect', 'recover');
						}
					});
					if (num > player.maxHp - player.hp) num = player.maxHp - player.hp;
					if (num > 0) {
						player.changeHp(num, false);
						game.broadcastAll(function (player) {
							if (lib.config.animation && !lib.config.low_performance) {
								player.$recover();
							}
						}, player);
						player.$damagepop(num, 'wood');
						game.log(player, '回复了' + get.cnNumber(num) + '点体力')
					}
				},
				loseHp: function () {
					"step 0"
					if (lib.config.background_audio) {
						game.playAudio('effect', 'loseHp');
					}
					game.broadcast(function () {
						if (lib.config.background_audio) {
							game.playAudio('effect', 'loseHp');
						}
					});
					game.log(player, '失去了' + get.cnNumber(num) + '点体力')
					player.changeHp(-num);
					"step 1"
					if (player.hp <= 0) {
						game.delayx();
						player.dying(event);
					}
				},
				doubleDraw: function () {
					"step 0"
					player.chooseBool('你的主副将体力上限之和是奇数，是否摸一张牌？');
					"step 1"
					if (result.bool) {
						player.draw();
					}
				},
				loseMaxHp: function () {
					"step 0"
					game.log(player, '减少了' + get.cnNumber(num) + '点体力上限');
					player.maxHp -= num;
					player.update();
					"step 1"
					if (player.maxHp <= 0) {
						player.die(event);
					}
				},
				gainMaxHp: function () {
					"step 0"
					game.log(player, '增加了' + get.cnNumber(num) + '点体力上限');
					player.maxHp += num;
					player.update();
				},
				changeHp: function () {
					player.hp += num;
					if (isNaN(player.hp)) player.hp = 0;
					if (player.hp > player.maxHp) player.hp = player.maxHp;
					player.update();
					if (event.popup !== false) {
						player.$damagepop(num, 'water');
					}
					event.trigger('changeHp');
				},
				changeHujia: function () {
					player.hujia += num;
					if (num > 0) {
						game.log(player, '获得了' + get.cnNumber(num) + '点护甲');
					}
					if (player.hujia < 0) {
						player.hujia = 0;
					}
					player.update();
				},
				dying: function () {
					"step 0"
					event.forceDie = true;
					if (player.isDying() || player.hp > 0) {
						event.finish();
						return;
					}
					_status.dying.unshift(player);
					game.broadcast(function (list) {
						_status.dying = list;
					}, _status.dying);
					event.trigger('dying');
					game.log(player, '濒死');
					"step 1"
					delete event.filterStop;
					if (player.hp > 0) {
						_status.dying.remove(player);
						game.broadcast(function (list) {
							_status.dying = list;
						}, _status.dying);
						event.finish();
					}
					else if (!event.skipTao) {
						var next = game.createEvent('_save');
						var start = false;
						var starts = [_status.currentPhase, event.source, event.player, game.me, game.players[0]];
						for (var i = 0; i < starts.length; i++) {
							if (get.itemtype(starts[i]) == 'player') {
								start = starts[i]; break;
							}
						}
						next.player = start;
						next._trigger = event;
						next.triggername = '_save';
						next.forceDie = true;
						next.setContent(lib.skill._save.content);
					}
					"step 2"
					_status.dying.remove(player);
					game.broadcast(function (list) {
						_status.dying = list;
					}, _status.dying);
					if (player.hp <= 0 && !player.nodying) player.die(event.reason);
				},
				die: function () {
					"step 0"
					event.forceDie = true;
					if (_status.roundStart == player) {
						_status.roundStart = player.next || player.getNext() || game.players[0];
					}
					if (ui.land && ui.land.player == player) {
						game.addVideo('destroyLand');
						ui.land.destroy();
					}
					var unseen = false;
					if (player.classList.contains('unseen')) {
						player.classList.remove('unseen');
						unseen = true;
					}
					var logvid = game.logv(player, 'die', source);
					event.logvid = logvid;
					if (unseen) {
						player.classList.add('unseen');
					}
					if (source && source != player) {
						game.log(player, '被', source, '杀害');
						if (source.stat[source.stat.length - 1].kill == undefined) {
							source.stat[source.stat.length - 1].kill = 1;
						}
						else {
							source.stat[source.stat.length - 1].kill++;
						}
					}
					else {
						game.log(player, '阵亡')
					}


					// player.removeEquipTrigger();

					// for(var i in lib.skill.globalmap){
					//     if(lib.skill.globalmap[i].contains(player)){
					//      			lib.skill.globalmap[i].remove(player);
					//      			if(lib.skill.globalmap[i].length==0&&!lib.skill[i].globalFixed){
					//      						 game.removeGlobalSkill(i);
					//      			}
					//     }
					// }

					game.broadcastAll(function (player) {
						player.classList.add('dead');
						player.removeLink();
						player.classList.remove('turnedover');
						player.classList.remove('out');
						player.node.count.innerHTML = '0';
						player.node.hp.hide();
						player.node.equips.hide();
						player.node.count.hide();
						player.previous.next = player.next;
						player.next.previous = player.previous;
						game.players.remove(player);
						game.dead.push(player);
						_status.dying.remove(player);

						if (lib.config.background_speak) {
							if (lib.character[player.name] && lib.character[player.name][4].contains('die_audio')) {
								game.playAudio('die', player.name);
							}
							// else if(true){
							else {
								game.playAudio('die', player.name, function () {
									game.playAudio('die', player.name.slice(player.name.indexOf('_') + 1));
								});
							}
						}
					}, player);

					game.addVideo('diex', player);
					if (event.animate !== false) {
						player.$die(source);
					}
					if (player.hp != 0) {
						player.changeHp(0 - player.hp, false).forceDie = true;
					}
					"step 1"
					if (player.dieAfter) player.dieAfter(source);
					"step 2"
					event.trigger('die');
					"step 3"
					if (player.isDead()) {
						if (!game.reserveDead) {
							for (var mark in player.marks) {
								player.unmarkSkill(mark);
							}
							while (player.node.marks.childNodes.length > 1) {
								player.node.marks.lastChild.remove();
							}
							game.broadcast(function (player) {
								while (player.node.marks.childNodes.length > 1) {
									player.node.marks.lastChild.remove();
								}
							}, player);
						}
						for (var i in player.tempSkills) {
							player.removeSkill(i);
						}
						var skills = player.getSkills();
						for (var i = 0; i < skills.length; i++) {
							if (lib.skill[skills[i]].temp) {
								player.removeSkill(skills[i]);
							}
						}
						if (_status.characterlist) {
							if (lib.character[player.name]) _status.characterlist.add(player.name);
							if (lib.character[player.name1]) _status.characterlist.add(player.name1);
							if (lib.character[player.name2]) _status.characterlist.add(player.name2);
						}
						event.cards = player.getCards('hej');
						if (event.cards.length) {
							player.discard(event.cards).forceDie = true;
							//player.$throw(event.cards,1000);
						}
					}
					"step 4"
					if (player.dieAfter2) player.dieAfter2(source);
					"step 5"
					game.broadcastAll(function (player) {
						if (game.online && player == game.me && !_status.over && !game.controlOver && !ui.exit) {
							if (lib.mode[lib.configOL.mode].config.dierestart) {
								ui.create.exit();
							}
						}
					}, player);
					if (!_status.connectMode && player == game.me && !_status.over && !game.controlOver) {
						ui.control.show();
						if (get.config('revive') && lib.mode[lib.config.mode].config.revive && !ui.revive) {
							ui.revive = ui.create.control('revive', ui.click.dierevive);
						}
						if (get.config('continue_game') && !ui.continue_game && lib.mode[lib.config.mode].config.continue_game && !_status.brawl) {
							ui.continue_game = ui.create.control('再战', game.reloadCurrent);
						}
						if (get.config('dierestart') && lib.mode[lib.config.mode].config.dierestart && !ui.restart) {
							ui.restart = ui.create.control('restart', game.reload);
						}
					}

					if (!_status.connectMode && player == game.me && !game.modeSwapPlayer) {
						// _status.auto=false;
						if (ui.auto) {
							// ui.auto.classList.remove('glow');
							ui.auto.hide();
						}
						if (ui.wuxie) ui.wuxie.hide();
					}

					if (typeof _status.coin == 'number' && source && !_status.auto) {
						if (source == game.me || source.isUnderControl()) {
							_status.coin += 10;
						}
					}
					if (source && lib.config.border_style == 'auto' && (lib.config.autoborder_count == 'kill' || lib.config.autoborder_count == 'mix')) {
						switch (source.node.framebg.dataset.auto) {
							case 'gold': case 'silver': source.node.framebg.dataset.auto = 'gold'; break;
							case 'bronze': source.node.framebg.dataset.auto = 'silver'; break;
							default: source.node.framebg.dataset.auto = lib.config.autoborder_start || 'bronze';
						}
						if (lib.config.autoborder_count == 'kill') {
							source.node.framebg.dataset.decoration = source.node.framebg.dataset.auto;
						}
						else {
							var dnum = 0;
							for (var j = 0; j < source.stat.length; j++) {
								if (source.stat[j].damage != undefined) dnum += source.stat[j].damage;
							}
							source.node.framebg.dataset.decoration = '';
							switch (source.node.framebg.dataset.auto) {
								case 'bronze': if (dnum >= 4) source.node.framebg.dataset.decoration = 'bronze'; break;
								case 'silver': if (dnum >= 8) source.node.framebg.dataset.decoration = 'silver'; break;
								case 'gold': if (dnum >= 12) source.node.framebg.dataset.decoration = 'gold'; break;
							}
						}
						source.classList.add('topcount');
					}
				},
				equip: function () {
					"step 0"
					var owner = get.owner(card)
					if (owner) owner.lose(card, ui.special, 'visible').set('type', 'equip').set('getlx', false);
					"step 1"
					if (event.cancelled) {
						event.finish();
						return;
					}
					if (card.destroyed) {
						if (player.hasSkill(card.destroyed)) {
							delete card.destroyed;
						}
						else {
							event.finish();
							return;
						}
					}
					if (event.draw) {
						game.delay(0, 300);
						player.$draw(card);
					}
					"step 2"
					if (card.clone) {
						game.broadcast(function (card, player) {
							if (card.clone) {
								card.clone.moveDelete(player);
							}
						}, card, player);
						card.clone.moveDelete(player);
						game.addVideo('gain2', player, get.cardsInfo([card.clone]));
					}
					player.equiping = true;
					"step 3"
					var info = get.info(card, false);
					var current = player.getCards('e', function (card) {
						if (info.customSwap) return info.customSwap(card);
						return get.subtype(card, false) == info.subtype;
					});
					if (current.length) {
						player.lose(current, false, 'visible').set('type', 'equip').set('getlx', false);
						if (info.loseThrow) {
							player.$throw(current);
						}
						event.swapped = true;
						event.redo();
					}
					"step 4"
					if (player.isMin() || player.countCards('e', { subtype: get.subtype(card) })) {
						event.finish();
						game.cardsDiscard(card);
						delete player.equiping;
						return;
					}
					if (lib.config.background_audio) {
						game.playAudio('effect', get.subtype(card));
					}
					game.broadcast(function (type) {
						if (lib.config.background_audio) {
							game.playAudio('effect', type);
						}
					}, get.subtype(card));
					player.$equip(card);
					game.addVideo('equip', player, get.cardInfo(card));
					game.log(player, '装备了', card);
					"step 5"
					var info = get.info(card, false);
					if (info.onEquip && (!info.filterEquip || info.filterEquip(card, player))) {
						if (Array.isArray(info.onEquip)) {
							for (var i = 0; i < info.onEquip.length; i++) {
								var next = game.createEvent('equip_' + card.name);
								next.setContent(info.onEquip[i]);
								next.player = player;
								next.card = card;
							}
						}
						else {
							var next = game.createEvent('equip_' + card.name);
							next.setContent(info.onEquip);
							next.player = player;
							next.card = card;
						}
						if (info.equipDelay != 'false') game.delayx();
					}
					delete player.equiping;
					if (event.delay) {
						game.delayx();
					}
				},
				addJudge: function () {
					"step 0"
					if (cards) {
						var owner = get.owner(cards[0]);
						if (owner) {
							event.relatedLose = owner.lose(cards, 'visible').set('getlx', false);
						}
					}
					"step 1"
					if (cards[0].destroyed) {
						if (player.hasSkill(cards[0].destroyed)) {
							delete cards[0].destroyed;
						}
						else {
							event.finish();
							return;
						}
					}
					cards[0].fix();
					cards[0].style.transform = '';
					cards[0].classList.remove('drawinghidden');
					delete cards[0]._transform;
					var viewAs = typeof card == 'string' ? card : card.name;
					if (!lib.card[viewAs] || !lib.card[viewAs].effect) {
						game.cardsDiscard(cards[0]);
					}
					else {
						cards[0].style.transform = '';
						cards[0].classList.add('drawinghidden');
						player.node.judges.insertBefore(cards[0], player.node.judges.firstChild);
						if (_status.discarded) {
							_status.discarded.remove(cards[0]);
						}
						ui.updatej(player);
						game.broadcast(function (player, card, viewAs) {
							card.fix();
							card.style.transform = '';
							card.classList.add('drawinghidden');
							card.viewAs = viewAs;
							if (viewAs && viewAs != card.name && (card.classList.contains('fullskin') || card.classList.contains('fullborder'))) {
								card.classList.add('fakejudge');
								card.node.background.innerHTML = lib.translate[viewAs + '_bg'] || get.translation(viewAs)[0]
							}
							else {
								card.classList.remove('fakejudge');
							}
							player.node.judges.insertBefore(card, player.node.judges.firstChild);
							ui.updatej(player);
							if (card.clone && (card.clone.parentNode == player.parentNode || card.clone.parentNode == ui.arena)) {
								card.clone.moveDelete(player);
								game.addVideo('gain2', player, get.cardsInfo([card]));
							}
						}, player, cards[0], viewAs);
						if (cards[0].clone && (cards[0].clone.parentNode == player.parentNode || cards[0].clone.parentNode == ui.arena)) {
							cards[0].clone.moveDelete(player);
							game.addVideo('gain2', player, get.cardsInfo(cards));
						}
						// player.$gain2(cards);
						if (get.itemtype(card) != 'card') {
							if (typeof card == 'string') cards[0].viewAs = card;
							else cards[0].viewAs = card.name;
						}
						else {
							delete cards[0].viewAs;
						}
						if (cards[0].viewAs && cards[0].viewAs != cards[0].name) {
							if (cards[0].classList.contains('fullskin') || cards[0].classList.contains('fullborder')) {
								cards[0].classList.add('fakejudge');
								cards[0].node.background.innerHTML = lib.translate[cards[0].viewAs + '_bg'] || get.translation(cards[0].viewAs)[0];
							}
							game.log(player, '被贴上了<span class="yellowtext">' + get.translation(cards[0].viewAs) + '</span>（', cards, '）');
						}
						else {
							cards[0].classList.remove('fakejudge');
							game.log(player, '被贴上了', cards);
						}
						game.addVideo('addJudge', player, [get.cardInfo(cards[0]), cards[0].viewAs]);
					}
				},
				judge: function () {
					"step 0"
					var judgestr = get.translation(player) + '的' + event.judgestr + '判定';
					event.videoId = lib.status.videoId++;
					var cardj = event.directresult || get.cards()[0];
					var nextj = game.cardsGotoOrdering(cardj);
					if (event.position != ui.discardPile) nextj.noOrdering = true;
					player.judging.unshift(cardj);
					game.addVideo('judge1', player, [get.cardInfo(player.judging[0]), judgestr, event.videoId]);
					game.broadcastAll(function (player, card, str, id, cardid) {
						var event;
						if (game.online) {
							event = {};
						}
						else {
							event = _status.event;
						}
						if (game.chess) {
							event.node = card.copy('thrown', 'center', ui.arena).animate('start');
						}
						else {
							event.node = player.$throwordered(card.copy(), true);
						}
						if (lib.cardOL) lib.cardOL[cardid] = event.node;
						event.node.cardid = cardid;
						event.node.classList.add('thrownhighlight');
						ui.arena.classList.add('thrownhighlight');
						event.dialog = ui.create.dialog(str);
						event.dialog.classList.add('center');
						event.dialog.videoId = id;
					}, player, player.judging[0], judgestr, event.videoId, get.id());

					game.log(player, '进行' + event.judgestr + '判定，亮出的判定牌为', player.judging[0]);
					game.delay(2);
					if (!event.noJudgeTrigger) event.trigger('judge');
					"step 1"
					event.result = {
						card: player.judging[0],
						name: player.judging[0].name,
						number: get.number(player.judging[0]),
						suit: get.suit(player.judging[0]),
						color: get.color(player.judging[0]),
						node: event.node,
					};
					if (event.fixedResult) {
						for (var i in event.fixedResult) {
							event.result[i] = event.fixedResult[i];
						}
					}
					event.result.judge = event.judge(event.result);
					if (event.result.judge > 0) event.result.bool = true;
					else if (event.result.judge < 0) event.result.bool = false;
					else event.result.bool = null;
					player.judging.shift();
					game.checkMod(player, event.result, 'judge', player);
					if (event.result.bool == true) {
						player.popup('洗具');
					}
					else if (event.result.bool == false) {
						player.popup('杯具');
					}
					if (event.clearArena != false) {
						game.broadcastAll(ui.clear);
					}
					game.broadcast(function (id) {
						var dialog = get.idDialog(id);
						if (dialog) {
							dialog.close();
						}
						ui.arena.classList.remove('thrownhighlight');
					}, event.videoId);
					event.dialog.close();
					game.addVideo('judge2', null, event.videoId);
					ui.arena.classList.remove('thrownhighlight');
					game.log(player, '的判定结果为', event.result.card);
					if (event.callback) {
						var next = game.createEvent('judgeCallback', false);
						next.player = player;
						next.card = event.result.card;
						next.judgeResult = get.copy(event.result);
						next.setContent(event.callback);
					}
					else {
						if (!get.owner(event.result.card)) {
							if (event.position != ui.discardPile) event.position.appendChild(event.result.card);
						}
					}
				},
				turnOver: function () {
					game.log(player, '翻面');
					player.classList.toggle('turnedover');
					game.broadcast(function (player) {
						player.classList.toggle('turnedover');
					}, player);
					game.addVideo('turnOver', player, player.classList.contains('turnedover'));
				},
				link: function () {
					if (player.isLinked()) {
						game.log(player, '解除连环');
					}
					else {
						game.log(player, '被连环');
					}
					if (lib.config.background_audio) {
						game.playAudio('effect', 'link');
					}
					game.broadcast(function () {
						if (lib.config.background_audio) {
							game.playAudio('effect', 'link');
						}
					});
					player.classList.remove('target');
					if (get.is.linked2(player)) {
						player.classList.toggle('linked2');
					}
					else {
						player.classList.toggle('linked');
					}
					ui.updatej(player);
					ui.updatem(player);
					game.broadcast(function (player, linked) {
						player.classList.remove('target');
						if (get.is.linked2(player)) {
							if (linked) {
								player.classList.add('linked2');
							}
							else {
								player.classList.remove('linked2');
							}
						}
						else {
							if (linked) {
								player.classList.add('linked');
							}
							else {
								player.classList.remove('linked');
							}
						}
						ui.updatej(player);
						ui.updatem(player);
					}, player, player.isLinked());
					game.addVideo('link', player, player.isLinked());
				},
			},
			player: {
				//新函数
				trySkillAnimate: function (name, popname, checkShow) {
					if (!game.online && lib.config.skill_animation_type != 'off' && lib.skill[name] && lib.skill[name].skillAnimation) {
						if (lib.config.skill_animation_type == 'default') {
							checkShow = checkShow || 'main';
						}
						else {
							checkShow = false;
						}
						if (lib.skill[name].textAnimation) {
							checkShow = false;
						}
						this.$skill(lib.skill[name].animationStr || lib.translate[name], lib.skill[name].skillAnimation, lib.skill[name].animationColor, checkShow);
						return;
					}
					var player = this;
					game.broadcast(function (player, name, popname) {
						player.trySkillAnimate(name, popname);
					}, player, name, popname);
					if (lib.animate.skill[name]) lib.animate.skill[name].apply(this, arguments);
					else {
						if (popname != name) this.popup(popname, 'water', false);
						else this.popup(get.skillTranslation(name, this), 'water', false);
					}
				},
				tryCardAnimate: function (card, name, nature, popname) {
					var player = this;
					game.broadcast(function (player, card, name, nature, popname) {
						player.tryCardAnimate(card, name, nature, popname);
					}, player, card, name, nature, popname);
					if (lib.animate.card[card.name]) lib.animate.card[card.name].apply(this, arguments);
					else {
						if (!lib.config.show_card_prompt) return;
						if (get.type(card) == 'equip' && lib.config.hide_card_prompt_equip) return;
						if (get.type(card) == 'basic' && lib.config.hide_card_prompt_basic) return;
						if (popname) player.popup({ name: card.name, nature: card.nature }, nature, false);
						else player.popup(name, nature, false);
					}
				},
				hasUsableCard: function (name) {
					var player = this;
					if (player.countCards('h', name)) return true;
					var skills = player.getSkills(true).concat(lib.skill.global);
					game.expandSkills(skills);
					for (var i = 0; i < skills.length; i++) {
						var ifo = get.info(skills[i]);
						if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.name == name) {
							if (!ifo.viewAsFilter || ifo.viewAsFilter(player)) {
								return true;
							}
						}
						else {
							var hiddenCard = get.info(skills[i]).hiddenCard;
							if (typeof hiddenCard == 'function' && hiddenCard(player, name)) {
								return true;
							}
						}
					}
				},
				inRange: function (to) {
					var from = this;
					if (from == to || from.hasSkill('undist') || to.hasSkill('undist')) return false;
					if (!game.players.contains(from) && !game.dead.contains(from)) return false;
					if (!game.players.contains(to) && !game.dead.contains(to)) return false;
					var mod1 = game.checkMod(from, to, 'unchanged', 'inRange', from);
					if (mod1 != 'unchanged') return mod1;
					var mod2 = game.checkMod(from, to, 'unchanged', 'inRangeOf', to);
					if (mod2 != 'unchanged') return mod2;
					if (from.getAttackRange() < 1) return false;
					var player = from, m, n = 1, i;
					var fxy, txy;
					if (game.chess) {
						fxy = from.getXY();
						txy = to.getXY();
						n = Math.abs(fxy[0] - txy[0]) + Math.abs(fxy[1] - txy[1]);
					}
					else if (to.isMin(true) || from.isMin(true)) { }
					else {
						var length = game.players.length;
						var totalPopulation = game.players.length + game.dead.length + 1;
						for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
							if (player.nextSeat != to) {
								player = player.nextSeat;
								if (player.isAlive() && !player.isOut() && !player.hasSkill('undist') && !player.isMin(true)) n++;
							}
							else {
								break;
							}
						}
						for (i = 0; i < game.players.length; i++) {
							if (game.players[i].isOut() || game.players[i].hasSkill('undist') || game.players[i].isMin(true)) length--;
						}
						if (from.isDead()) length++;
						if (to.isDead()) length++;
						var left = from.hasSkillTag('left_hand');
						var right = from.hasSkillTag('right_hand');
						if (left === right) n = Math.min(n, length - n);
						else if (left == true) n = length - n;
					}
					n = game.checkMod(from, to, n, 'globalFrom', from);
					n = game.checkMod(from, to, n, 'globalTo', to);
					m = n;
					m = game.checkMod(from, to, m, 'attackFrom', from);
					m = game.checkMod(from, to, m, 'attackTo', to);
					var equips1 = from.getCards('e', function (card) {
						return !ui.selected.cards || !ui.selected.cards.contains(card);
					}), equips2 = to.getCards('e', function (card) {
						return !ui.selected.cards || !ui.selected.cards.contains(card);
					});
					for (i = 0; i < equips1.length; i++) {
						var info = get.info(equips1[i]).distance;
						if (!info) continue;
						if (info.globalFrom) {
							m += info.globalFrom;
							n += info.globalFrom;
						}
						if (info.attackFrom) {
							m += info.attackFrom;
						}
					}
					for (i = 0; i < equips2.length; i++) {
						var info = get.info(equips2[i]).distance;
						if (!info) continue;
						if (info.globalTo) {
							m += info.globalTo;
							n += info.globalTo;
						}
						if (info.attaclTo) {
							m += info.attaclTo;
						}
					}
					return m <= 1;
				},
				inRangeOf: function (source) {
					return source.inRange(this);
				},
				getDamagedHp: function () {
					return this.maxHp - Math.max(0, this.hp);
				},
				changeGroup: function (group, log, broadcast) {
					var player = this;
					if (broadcast !== false) {
						game.broadcast(function (player, group) {
							player.group = group;
							player.node.name.dataset.nature = get.groupnature(group);
						}, player, group);
					}
					player.group = group;
					player.node.name.dataset.nature = get.groupnature(group);
					if (log !== false) game.log(this, '将势力变为了', '#y' + get.translation(group + 2));
				},
				chooseToDuiben: function (target) {
					var next = game.createEvent('chooseToDuiben');
					next.player = this;
					next.target = target;
					next.setContent('chooseToDuiben');
					return next;
				},
				chooseToPSS: function (target) {
					var next = game.createEvent('chooseToPSS');
					next.player = this;
					next.target = target;
					next.setContent('chooseToPSS');
					return next;
				},
				chooseToEnable: function () {
					var next = game.createEvent('chooseToEnable');
					next.player = this;
					next.setContent('chooseToEnable');
					return next;
				},
				chooseToDisable: function (horse) {
					var next = game.createEvent('chooseToDisable');
					next.player = this;
					if (horse) next.horse = true;
					next.setContent('chooseToDisable');
					return next;
				},
				countDisabled: function () {
					if (!this.storage.disableEquip) return 0;
					return this.storage.disableEquip.length;
				},
				isPhaseUsing: function (notmeisok) {
					if (!notmeisok && _status.currentPhase != this) return false;
					return _status.event.name == 'phaseUse' || _status.event.getParent('phaseUse').name == 'phaseUse';
				},
				swapEquip: function (target) {
					var next = game.createEvent('swapEquip');
					next.player = this;
					next.target = target;
					next.setContent('swapEquip');
					return next;
				},
				canCompare: function (target) {
					if (this == target) return false;
					if (!this.countCards('h') || !target.countCards('h')) return false;
					if (this.hasSkillTag('noCompareSource') || target.hasSkillTag('noCompareTarget')) return false;
					return true;
				},
				disableEquip: function (pos) {
					if (typeof pos == 'number') pos = 'equip' + pos;
					var next = game.createEvent('disableEquip');
					next.player = this;
					next.pos = pos;
					next.source = _status.event.player;
					next.setContent('disableEquip');
					return next;
				},
				$disableEquip: function (skill) {
					game.broadcast(function (player, skill) {
						player.$disableEquip(skill);
					}, this, skill);
					var player = this;
					if (!player.storage.disableEquip) player.storage.disableEquip = [];
					player.storage.disableEquip.add(skill);
					player.storage.disableEquip.sort();
					var pos = { equip1: '武器栏', equip2: '防具栏', equip3: '+1马栏', equip4: '-1马栏', equip5: '宝物栏' }[skill];
					if (!pos) return;
					var card = game.createCard('feichu_' + skill, pos, '');
					card.fix();
					card.style.transform = '';
					card.classList.remove('drawinghidden');
					card.classList.add('feichu');
					delete card._transform;
					var equipNum = get.equipNum(card);
					var equipped = false;
					for (var i = 0; i < player.node.equips.childNodes.length; i++) {
						if (get.equipNum(player.node.equips.childNodes[i]) >= equipNum) {
							player.node.equips.insertBefore(card, player.node.equips.childNodes[i]);
							equipped = true;
							break;
						}
					}
					if (!equipped) {
						player.node.equips.appendChild(card);
						if (_status.discarded) {
							_status.discarded.remove(card);
						}
					}
					return player;
				},
				enableEquip: function (pos) {
					if (typeof pos == 'number') pos = 'equip' + pos;
					var next = game.createEvent('enableEquip');
					next.player = this;
					next.pos = pos;
					next.source = _status.event.player;
					next.setContent('enableEquip');
					return next;
				},
				$enableEquip: function (skill) {
					game.broadcast(function (player, skill) {
						player.$enableEquip(skill);
					}, this, skill);
					var player = this;
					if (player.storage.disableEquip) player.storage.disableEquip.remove(skill);
					for (var i = 0; i < player.node.equips.childNodes.length; i++) {
						if (player.node.equips.childNodes[i].name == 'feichu_' + skill) {
							player.node.equips.removeChild(player.node.equips.childNodes[i]);
							break;
						}
					}
					return player;
				},
				isDisabled: function (arg) {
					if (typeof arg == 'number') arg = 'equip' + arg;
					if (arg == 'equip6' && this.storage.disableEquip && (this.storage.disableEquip.contains('equip3') || this.storage.disableEquip.contains('equip4'))) return true;
					if (this.storage.disableEquip && this.storage.disableEquip.contains(arg)) return true;
					return false;
				},
				isEmpty: function (num) {
					if (num == 6 || num == 'equip6') {
						if (!this.isEmpty(3) || !this.isEmpty(4)) return false;
					}
					else if ([3, 4, 'equip3', 'equip4'].contains(num)) {
						if (this.getEquip(6)) return false;
					}
					return !this.isDisabled(num) && !this.getEquip(num);
				},
				$disableJudge: function () {
					var player = this;
					var card = game.createCard('disable_judge', '', '');
					player.storage._disableJudge = true;
					card.fix();
					card.classList.add('feichu');
					card.style.transform = '';
					card.classList.add('drawinghidden');
					player.node.judges.insertBefore(card, player.node.judges.firstChild);
					ui.updatej(player);
				},
				$enableJudge: function () {
					var player = this;
					player.storage._disableJudge = false;
					for (var i = 0; i < player.node.judges.childNodes.length; i++) {
						if (player.node.judges.childNodes[i].name == 'disable_judge') {
							player.node.judges.removeChild(player.node.judges.childNodes[i]);
							break;
						}
					}
				},
				disableJudge: function () {
					var next = game.createEvent('disableJudge');
					next.player = this;
					next.source = _status.event.player;
					next.setContent('disableJudge');
					return next;
				},
				enableJudge: function () {
					var next = game.createEvent('enableJudge');
					next.player = this;
					next.source = _status.event.player;
					next.setContent('enableJudge');
					return next;
				},
				//原有函数
				init: function (character, character2, skill) {
					if (typeof character == 'string' && !lib.character[character]) {
						lib.character[character] = get.character(character);
					}
					if (typeof character2 == 'string' && !lib.character[character2]) {
						lib.character[character2] = get.character(character2);
					}
					if (!lib.character[character]) return;
					if (get.is.jun(character2)) {
						var tmp = character;
						character = character2;
						character2 = tmp;
					}
					if (character2 == false) {
						skill = false;
						character2 = null;
					}
					var info = lib.character[character];
					if (!info) {
						info = ['', '', 1, [], []];
					}
					if (!info[4]) {
						info[4] = [];
					}
					var skills = info[3];
					this.clearSkills(true);
					this.classList.add('fullskin');
					if (!game.minskin && get.is.newLayout() && !info[4].contains('minskin')) {
						this.classList.remove('minskin');
						this.node.avatar.setBackground(character, 'character');
					}
					else {
						this.node.avatar.setBackground(character, 'character');
						if (info[4].contains('minskin')) {
							this.classList.add('minskin');
						}
						else if (game.minskin) {
							this.classList.add('minskin');
						}
						else {
							this.classList.remove('minskin');
						}
					}

					var hp1 = get.infoHp(info[2]);
					var maxHp1 = get.infoMaxHp(info[2]);

					this.node.avatar.show();
					this.node.count.show();
					this.node.equips.show();
					this.name = character;
					this.sex = info[0];
					this.group = info[1];
					this.hp = hp1;
					this.maxHp = maxHp1;
					this.hujia = 0;
					this.node.intro.innerHTML = lib.config.intro;
					this.node.name.dataset.nature = get.groupnature(this.group);
					lib.setIntro(this);
					// var name=get.translation(character);
					this.node.name.innerHTML = get.slimName(character);
					if (this.classList.contains('minskin') && this.node.name.querySelectorAll('br').length >= 4) {
						this.node.name.classList.add('long');
					}
					// if(!lib.config.show_name){
					// 	this.node.name.style.display='none';
					// }
					// for(var i=0;i<name.length;i++){
					// 	if(name[i]!='s'&&name[i]!='p')
					// 	this.node.name.innerHTML+=name[i]+'<br/>';
					// }
					if (character2 && lib.character[character2]) {
						var info2 = lib.character[character2];
						if (!info2) {
							info2 = ['', '', 1, [], []];
						}
						if (!info2[4]) {
							info2[4] = [];
						}
						this.classList.add('fullskin2');
						this.node.avatar2.setBackground(character2, 'character');

						this.node.avatar2.show();
						this.name2 = character2;
						var hp2 = get.infoHp(info2[2]);
						var maxHp2 = get.infoMaxHp(info2[2]);
						var double_hp;
						if (_status.connectMode || get.mode() == 'single') {
							double_hp = 'pingjun';
						}
						else {
							double_hp = get.config('double_hp');
						}
						switch (double_hp) {
							case 'pingjun': {
								this.maxHp = Math.floor((maxHp1 + maxHp2) / 2);
								this.hp = Math.floor((hp1 + hp2) / 2);
								this.singleHp = ((maxHp1 + maxHp2) % 2 === 1);
								break;
							}
							case 'zuidazhi': {
								this.maxHp = Math.max(maxHp1, maxHp2);
								this.hp = Math.max(hp1, hp2);
								break;
							}
							case 'zuixiaozhi': {
								this.maxHp = Math.min(maxHp1, maxHp2);
								this.hp = Math.min(hp1, hp2);
								break;
							}
							case 'zonghe': {
								this.maxHp = maxHp1 + maxHp2;
								this.hp = hp1 + hp2;
								break;
							}
							default: {
								this.maxHp = maxHp1 + maxHp2 - 3;
								this.hp = hp1 + hp2 - 3;
							};
						}
						this.node.count.classList.add('p2');
						skills = skills.concat(info2[3]);

						// var name=get.translation(character2);
						this.node.name2.innerHTML = get.slimName(character2);
						// this.node.name2.dataset.nature=get.groupnature(info2[1]);
						// if(!lib.config.show_name){
						// 	this.node.name2.style.display='none';
						// }
						// for(var i=0;i<name.length;i++){
						// 	this.node.name2.innerHTML+=name[i]+'<br/>';
						// }
					}
					if (skill != false) {
						for (var i = 0; i < skills.length; i++) {
							this.addSkill(skills[i]);
						}
						this.checkConflict();
					}
					lib.group.add(this.group);
					if (this.inits) {
						for (var i = 0; i < lib.element.player.inits.length; i++) {
							lib.element.player.inits[i](this);
						}
					}
					if (this._inits) {
						for (var i = 0; i < this._inits.length; i++) {
							this._inits[i](this);
						}
					}
					this.update();
					return this;
				},
				initOL: function (name, character) {
					this.node.avatar.setBackground(character, 'character');
					this.node.avatar.show();
					this.node.name.innerHTML = get.verticalStr(name);
					this.nickname = name;
					this.avatar = character;
					this.node.nameol.innerHTML = '';
				},
				uninitOL: function () {
					this.node.avatar.hide();
					this.node.name.innerHTML = '';
					this.node.identity.firstChild.innerHTML = '';
					delete this.nickname;
					delete this.avatar;
				},
				initRoom: function (info, info2) {
					if (!this.node.gaming) {
						this.node.gaming = ui.create.div('.gaming', '游戏中', this);
						this.node.gaming.dataset.nature = 'fire';
					}
					if (!this.node.serving) {
						this.node.serving = ui.create.div('.gaming', '服务器', this);
						this.node.serving.dataset.nature = 'wood';
					}
					if (!this.node.waiting) {
						this.node.waiting = ui.create.div('.gaming', '等待中', this);
						this.node.waiting.dataset.nature = 'water';
					}
					this.serving = false;
					if (!info || info == 'server') {
						this.roomempty = true;
						this.initOL('空房间', info2 || 'room');
						this.node.hp.innerHTML = '';
						this.roomfull = false;
						this.roomgaming = false;
						this.version = null;
						if (info == 'server') {
							this.serving = true;
							this.node.serving.show();
						}
						else {
							this.node.serving.hide();
						}
						this.node.gaming.hide();
						this.node.waiting.hide();
						this.dataset.cursor_style = 'menu';
					}
					else {
						this.roomempty = false;
						var config = info[2];
						this.initOL(get.modetrans(config), info[1]);
						this.version = config.version;
						if (config.gameStarted) {
							this.node.gaming.show();
							this.node.waiting.hide();
							if (config.observe && config.observeReady && this.version == lib.versionOL) {
								this.dataset.cursor_style = 'zoom';
							}
							else {
								this.dataset.cursor_style = 'forbidden';
							}
						}
						else {
							this.node.gaming.hide();
							this.node.waiting.show();
							if (this.version != lib.versionOL) {
								this.dataset.cursor_style = 'forbidden';
							}
							else {
								this.dataset.cursor_style = 'pointer';
							}
						}
						this.node.serving.hide();
						this.setNickname(info[0]);
						this.maxHp = parseInt(config.number);
						this.hp = info[3];
						this.update();
						this.config = config;
						if (this.hp == this.maxHp && !config.gameStarted) {
							this.roomfull = true;
						}
						else {
							this.roomfull = false;
						}
						if (config.gameStarted && (!config.observe || !config.observeReady)) {
							this.roomgaming = true;
						}
						else {
							this.roomgaming = false;
						}
					}
					return this;
				},
				reinit: function (from, to, maxHp, online) {
					var info1 = lib.character[from];
					var info2 = lib.character[to];
					var smooth = true;
					if (maxHp == 'nosmooth') {
						smooth = false;
						maxHp = null;
					}
					if (this.name2 == from) {
						this.name2 = to;
						if (this.isUnseen(0) && !this.isUnseen(1)) {
							this.sex = info2[0];
							this.name = to;
						}
						if (smooth) this.smoothAvatar(true);
						this.node.avatar2.setBackground(to, 'character');
						this.node.name2.innerHTML = get.slimName(to);
					}
					else if (this.name == from || this.name1 == from) {
						if (this.name1 == from) {
							this.name1 = to;
						}
						if (!this.classList.contains('unseen2')) {
							this.name = to;
							this.sex = info2[0];
						}
						if (smooth) this.smoothAvatar(false);
						this.node.avatar.setBackground(to, 'character');
						this.node.name.innerHTML = get.slimName(to);

						if (this == game.me && ui.fakeme) {
							ui.fakeme.style.backgroundImage = this.node.avatar.style.backgroundImage;
						}
					}
					else {
						return this;
					}
					if (online) {
						return;
					}
					for (var i = 0; i < info1[3].length; i++) {
						this.removeSkill(info1[3][i]);
					}
					for (var i = 0; i < info2[3].length; i++) {
						this.addSkill(info2[3][i]);
					}
					if (Array.isArray(maxHp)) {
						this.maxHp = maxHp[1];
						this.hp = maxHp[0];
					}
					else {
						var num;
						if (maxHp === false) {
							num = 0;
						}
						else {
							if (typeof maxHp != 'number') {
								maxHp = get.infoMaxHp(info2[2]);
							}
							num = maxHp - get.infoMaxHp(info1[2]);
						}
						if (typeof this.singleHp == 'boolean') {
							if (num % 2 != 0) {
								if (this.singleHp) {
									this.maxHp += (num + 1) / 2;
									this.singleHp = false;
								}
								else {
									this.maxHp += (num - 1) / 2;
									this.singleHp = true;
									if (!game.online) {
										this.doubleDraw();
									}
								}
							}
							else {
								this.maxHp += num / 2;
							}
						}
						else {
							this.maxHp += num;
						}
					}
					game.broadcast(function (player, from, to, skills) {
						player.reinit(from, to, null, true);
						player.applySkills(skills);
					}, this, from, to, get.skillState(this));
					game.addVideo('reinit3', this, {
						from: from,
						to: to,
						hp: this.maxHp,
						avatar2: this.name2 == to
					});
					this.update();
				},
				uninit: function () {
					for (var i = 1; i < 6; i++) {
						if (this.isDisabled(i)) this.$enableEquip('equip' + i);
					}
					if (this.storage._disableJudge) {
						game.broadcastAll(function (player) {
							player.storage._disableJudge = false;
							for (var i = 0; i < player.node.judges.childNodes.length; i++) {
								if (player.node.judges.childNodes[i].name == 'disable_judge') {
									player.node.judges.removeChild(player.node.judges.childNodes[i]);
									break;
								}
							}
						}, this);
					}
					this.node.avatar.hide();
					this.node.count.hide();
					if (this.node.wuxing) {
						this.node.wuxing.hide();
					}
					delete this.name;
					delete this.sex;
					delete this.group;
					delete this.hp;
					delete this.maxHp;
					delete this.hujia;
					this.clearSkills(true);
					this.node.identity.style.backgroundColor = '';
					this.node.intro.innerHTML = '';
					this.node.name.innerHTML = '';
					this.node.hp.innerHTML = '';
					this.node.count.innerHTML = '0';
					if (this.name2) {
						delete this.singleHp;
						this.node.avatar2.hide();
						this.node.name2.innerHTML = '';
						this.classList.remove('fullskin2')
						delete this.name2;
						this.node.count.classList.remove('p2');
					}
					for (var mark in this.marks) {
						this.marks[mark].remove();
					}
					ui.updatem(this);

					this.skipList = [];
					this.skills = this.skills.contains('cangji_yozuru') ? ['cangji_yozuru'] : [];
					this.initedSkills = [];
					this.additionalSkills = {};
					this.disabledSkills = {};
					this.hiddenSkills = [];
					this.awakenedSkills = [];
					this.forbiddenSkills = {};
					this.phaseNumber = 0;
					this.stat = [{ card: {}, skill: {} }];
					this.tempSkills = {};
					this.storage = {};
					this.marks = {};
					this.ai = { friend: [], enemy: [], neutral: [] };

					return this;
				},
				getLeft: function () {
					return this.offsetLeft;
				},
				getTop: function () {
					return this.offsetTop;
				},
				smoothAvatar: function (vice, video) {
					var div = ui.create.div('.fullsize');
					if (vice) {
						div.style.background = getComputedStyle(this.node.avatar2).background;
						this.node.avatar2.appendChild(div);
					}
					else {
						div.style.background = getComputedStyle(this.node.avatar).background;
						this.node.avatar.appendChild(div);
					}
					ui.refresh(div);
					div.style.transition = 'all 1s';
					setTimeout(function () {
						div.classList.add('removing');
						setTimeout(function () {
							div.remove();
						}, 2000);
					}, 100);
					if (video != false) {
						game.addVideo('smoothAvatar', this, vice);
					}
				},
				changeSeat: function (position, video) {
					var player = this;
					if (video !== false) game.addVideo('changeSeat', player, position);
					var rect1 = player.getBoundingClientRect();
					player.style.transition = 'all 0s';
					ui.refresh(player);
					player.dataset.position = position;
					var rect2 = player.getBoundingClientRect();
					var dx = rect1.left - rect2.left;
					var dy = rect1.top - rect2.top;
					if ((game.chess || (player.dataset.position != 0 && position != 0)) && player.classList.contains('linked')) {
						player.style.transform = 'rotate(-90deg) translate(' + (-dy) + 'px,' + (dx) + 'px)';
					}
					else {
						player.style.transform = 'translate(' + (dx) + 'px,' + (dy) + 'px)';
					}
					setTimeout(function () {
						player.style.transition = '';
						ui.refresh(player);
						player.style.transform = '';
					}, 100);
				},
				send: function () {
					if (!this.ws || this.ws.closed) return this;
					this.ws.send.apply(this.ws, arguments);
					return this;
				},
				getId: function () {
					if (_status.video || _status.connectMode) return this;
					if (this.playerid) {
						delete game.playerMap[this.playerid];
					}
					this.playerid = get.id();
					game.playerMap[this.playerid] = this;
					return this;
				},
				emotion: function (pack, id) {
					var str = '<img src="##assetURL##image/emotion/' + pack + '/' + id + '.gif" width="50" height="50">';
					lib.element.player.say.call(this, str);
					game.broadcast(function (id, str) {
						if (lib.playerOL[id]) {
							lib.playerOL[id].say(str);
						}
						else if (game.connectPlayers) {
							for (var i = 0; i < game.connectPlayers.length; i++) {
								if (game.connectPlayers[i].playerid == id) {
									lib.element.player.say.call(game.connectPlayers[i], str);
									return;
								}
							}
						}
					}, this.playerid, str);
				},
				chat: function (str) {
					if (get.is.banWords(str)) return;
					lib.element.player.say.call(this, str);
					game.broadcast(function (id, str) {
						if (lib.playerOL[id]) {
							lib.playerOL[id].say(str);
						}
						else if (game.connectPlayers) {
							for (var i = 0; i < game.connectPlayers.length; i++) {
								if (game.connectPlayers[i].playerid == id) {
									lib.element.player.say.call(game.connectPlayers[i], str);
									return;
								}
							}
						}
					}, this.playerid, str);
				},
				say: function (str) {
					str = str.replace(/##assetURL##/g, lib.assetURL);
					var dialog = ui.create.dialog('hidden');
					dialog.classList.add('static');
					dialog.add('<div class="text" style="word-break:break-all;display:inline">' + str + '</div>');
					dialog.classList.add('popped');
					ui.window.appendChild(dialog);
					var width = dialog.content.firstChild.firstChild.offsetWidth;
					if (width < 190) {
						dialog._mod_height = -16;
					}
					else {
						dialog.content.firstChild.style.textAlign = 'left';
					}
					dialog.style.width = (width + 16) + 'px';
					var refnode;
					if (this.node && this.node.avatar && this.parentNode == ui.arena) {
						refnode = this.node.avatar;
					}
					if (refnode) {
						lib.placePoppedDialog(dialog, {
							clientX: (ui.arena.offsetLeft + this.getLeft() + refnode.offsetLeft + refnode.offsetWidth / 2) * game.documentZoom,
							clientY: (ui.arena.offsetTop + this.getTop() + refnode.offsetTop + refnode.offsetHeight / 4) * game.documentZoom
						});
					}
					else {
						lib.placePoppedDialog(dialog, {
							clientX: (this.getLeft() + this.offsetWidth / 2) * game.documentZoom,
							clientY: (this.getTop() + this.offsetHeight / 4) * game.documentZoom
						});
					}
					if (dialog._mod_height) {
						dialog.content.firstChild.style.padding = 0;
					}
					setTimeout(function () {
						dialog.delete();
					}, 2000);
					var name = get.translation(this.name);
					var info = [name ? (name + '[' + this.nickname + ']') : this.nickname, str];
					lib.chatHistory.push(info);
					if (_status.addChatEntry) {
						if (_status.addChatEntry._origin.parentNode) {
							_status.addChatEntry(info, false);
						}
						else {
							delete _status.addChatEntry;
						}
					}
				},
				showGiveup: function () {
					if (this == game.me) {
						ui.create.giveup();
					}
					else if (this.isOnline2()) {
						this.send(ui.create.giveup);
					}
				},
				applySkills: function (skills) {
					for (var i in skills) {
						if (i == 'global') {
							lib.skill.global = skills[i];
						}
						else if (i == 'skillinfo') {
							for (var j in skills[i]) {
								if (!lib.skill[j]) {
									lib.skill[j] = {};
								}
								lib.skill[j].chooseButton = skills[i][j];
							}
						}
						else if (i == 'stat') {
							this.stat = [skills.stat];
						}
						else if (lib.playerOL[i]) {
							for (var j in skills[i]) {
								lib.playerOL[i][j] = skills[i][j];
							}
						}
					}
				},
				getState: function () {
					var state = {
						hp: this.hp,
						maxHp: this.maxHp,
						nickname: this.nickname,
						sex: this.sex,
						group: this.group,
						name: this.name,
						name1: this.name1,
						name2: this.name2,
						handcards: this.getCards('h'),
						equips: this.getCards('e'),
						judges: this.getCards('j'),
						disableJudge: this.storage._disableJudge,
						disableEquip: this.storage.disableEquip,
						views: [],
						position: parseInt(this.dataset.position),
						hujia: this.hujia,
						side: this.side,
						identityShown: this.identityShown,
						identityNode: [this.node.identity.innerHTML, this.node.identity.dataset.color],
						identity: this.identity,
						dead: this.isDead(),
						linked: this.isLinked(),
						turnedover: this.isTurnedOver(),
						phaseNumber: this.phaseNumber,
					}
					for (var i = 0; i < state.judges.length; i++) {
						state.views[i] = state.judges[i].viewAs;
					}
					if (this.getModeState) {
						state.mode = this.getModeState();
					}
					return state;
				},
				setNickname: function (str) {
					this.node.nameol.innerHTML = str || this.nickname || '';
					return this;
				},
				setAvatar: function (name, name2, video, fakeme) {
					var node;
					if (this.name2 == name) {
						node = this.node.avatar2;
						this.smoothAvatar(true, video);
					}
					else if (this.name == name) {
						node = this.node.avatar;
						this.smoothAvatar(false, video);
					}
					if (node) {
						node.setBackground(name2, 'character');
						if (this == game.me && ui.fakeme && fakeme !== false) {
							ui.fakeme.style.backgroundImage = node.style.backgroundImage;
						}
						if (video != false) {
							game.addVideo('setAvatar', this, [name, name2]);
						}
					}
					game.broadcast(function (player, name, name2) {
						player.setAvatar(name, name2, false);
					}, this, name, name2);
				},
				setAvatarQueue: function (name, list) {
					var node;
					var player = this;
					if (player.name2 == name) {
						node = player.node.avatar2;
					}
					else {
						node = player.node.avatar;
					}
					if (node._avatarqueue) {
						for (var i = 0; i < list.length; i++) {
							node._avatarqueue.push(list[i]);
						}
					}
					else {
						var func = function () {
							if (node._avatarqueue.length) {
								player.setAvatar(name, node._avatarqueue.shift(), false, false);
							}
							else {
								clearInterval(node._avatarqueueinterval);
								delete node._avatarqueue;
								delete node._avatarqueueinterval;
								player.setAvatar(name, name, false, false);
							}
						};
						node._avatarqueue = list.slice(0);
						node._avatarqueueinterval = setInterval(func, 1000);
						func();
					}
					game.addVideo('setAvatarQueue', this, [name, list]);
				},
				flashAvatar: function (skill, name) {
					if (lib.skill[name] && !lib.character[name]) {
						var stop = false;
						var list = lib.config.all.characters.slice(0);
						for (var i in lib.characterPack) {
							list.add(i);
						}
						for (var i = 0; i < list.length; i++) {
							for (var j in lib.characterPack[list[i]]) {
								if (lib.characterPack[list[i]][j][3].contains(name)) {
									name = j;
									stop = true;
									break;
								}
							}
							if (stop) {
								break;
							}
						}
					}
					if (lib.character[this.name2] && lib.character[this.name2][3].contains(skill)) {
						this.setAvatarQueue(this.name2, [name]);
					}
					else {
						this.setAvatarQueue(this.name, [name]);
					}
				},
				update: function () {
					if (_status.video && arguments.length == 0) return;
					if (this.hp >= this.maxHp) this.hp = this.maxHp;
					var hp = this.node.hp;
					hp.style.transition = 'none';
					game.broadcast(function (player, hp, maxHp, hujia) {
						player.hp = hp;
						player.maxHp = maxHp;
						player.hujia = hujia;
						player.update();
					}, this, this.hp, this.maxHp, this.hujia);
					if (!_status.video) {
						if (this.hujia) {
							this.markSkill('ghujia');
						}
						else {
							this.unmarkSkill('ghujia');
						}
					}
					if (this.maxHp == Infinity) {
						hp.innerHTML = '∞';
					}
					else if (game.layout == 'default' && this.maxHp > 14) {
						hp.innerHTML = this.hp + '/' + this.maxHp;
						hp.classList.add('text');
					}
					else if (get.is.newLayout() &&
						(
							this.maxHp > 9 ||
							(this.maxHp > 5 && this.classList.contains('minskin')) ||
							((game.layout == 'mobile' || game.layout == 'long') && this.dataset.position == 0 && this.maxHp > 7)
						)) {
						hp.innerHTML = this.hp + '<br>/<br>' + this.maxHp + '<div></div>';
						if (this.hp == 0) {
							hp.lastChild.classList.add('lost');
						}
						hp.classList.add('textstyle');
						// hp.classList.remove('long');
					}
					else {
						hp.innerHTML = '';
						hp.classList.remove('text');
						hp.classList.remove('textstyle');
						while (this.maxHp > hp.childNodes.length) {
							ui.create.div(hp);
						}
						while (Math.max(0, this.maxHp) < hp.childNodes.length) {
							hp.removeChild(hp.lastChild);
						}
						for (var i = 0; i < this.maxHp; i++) {
							var index = i;
							if (get.is.newLayout()) {
								index = this.maxHp - i - 1;
							}
							if (i < this.hp) {
								hp.childNodes[index].classList.remove('lost');
							}
							else {
								hp.childNodes[index].classList.add('lost');
							}
						}
						// if(this.maxHp==9){
						// 	hp.classList.add('long');
						// }
						// else{
						// 	hp.classList.remove('long');
						// }
					}
					if (hp.classList.contains('room')) {
						hp.dataset.condition = 'high';
					}
					else if (this.hp == 0) {
						hp.dataset.condition = '';
					}
					else if (this.hp > Math.round(this.maxHp / 2) || this.hp === this.maxHp) {
						hp.dataset.condition = 'high';
					}
					else if (this.hp > Math.floor(this.maxHp / 3)) {
						hp.dataset.condition = 'mid';
					}
					else {
						hp.dataset.condition = 'low';
					}

					setTimeout(function () {
						hp.style.transition = '';
					});
					var numh = this.countCards('h');
					if (_status.video) {
						numh = arguments[0];
					}
					if (numh >= 10) {
						numh = numh.toString();
						this.node.count.dataset.condition = 'low';
						this.node.count.innerHTML = numh[0] + '<br>' + numh[1];
					}
					else {
						if (numh > 5) {
							this.node.count.dataset.condition = 'higher';
						}
						else if (numh > 2) {
							this.node.count.dataset.condition = 'high';
						}
						else if (numh > 0) {
							this.node.count.dataset.condition = 'mid';
						}
						else {
							this.node.count.dataset.condition = 'none';
						}
						this.node.count.innerHTML = numh;
					}
					if (this.updates) {
						for (var i = 0; i < lib.element.player.updates.length; i++) {
							lib.element.player.updates[i](this);
						}
					}
					if (!_status.video) {
						game.addVideo('update', this, [this.countCards('h'), this.hp, this.maxHp, this.hujia]);
					}
					this.updateMarks();
					return this;
				},
				removeMark: function (i, num, log) {
					if (typeof num != 'number' || !num) num = 1;
					if (typeof this.storage[i] != 'number' || !this.storage[i]) return;
					if (num > this.storage[i]) num = this.storage[i];
					this.storage[i] -= num;
					if (log !== false) {
						var str = false;
						var info = get.info(i);
						if (info && info.intro && (info.intro.name || info.intro.name2)) str = info.intro.name2 || info.intro.name;
						else str = lib.translate[i];
						if (str) game.log(this, '移去了', get.cnNumber(num), '个', '#g【' + str + '】');
					}
					this.syncStorage(i);
					this[this.storage[i] ? 'markSkill' : 'unmarkSkill'](i);
				},
				addMark: function (i, num, log) {
					if (typeof num != 'number' || !num) num = 1;
					if (typeof this.storage[i] != 'number') this.storage[i] = 0;
					this.storage[i] += num;
					if (log !== false) {
						var str = false;
						var info = get.info(i);
						if (info && info.intro && (info.intro.name || info.intro.name2)) str = info.intro.name2 || info.intro.name;
						else str = lib.translate[i];
						if (str) game.log(this, '获得了', get.cnNumber(num), '个', '#g【' + str + '】');
					}
					this.syncStorage(i);
					this.markSkill(i);
				},
				countMark: function (i) {
					if (this.storage[i] == undefined) return 0;
					if (typeof this.storage[i] == 'number') return this.storage[i];
					if (Array.isArray(this.storage[i])) return this.storage[i].length;
					return 0;
				},
				hasMark: function (i) {
					return this.countMark(i) > 0;
				},
				updateMark: function (i, storage) {
					if (!this.marks[i]) {
						if (lib.skill[i] && lib.skill[i].intro && (this.storage[i] || lib.skill[i].intro.markcount)) {
							this.markSkill(i);
							if (!this.marks[i]) return this;
						}
						else {
							return this;
						}
					}
					if (storage && this.storage[i]) {
						this.syncStorage(i);
					}
					if (i == 'ghujia' || ((!this.marks[i].querySelector('.image') || this.storage[i + '_markcount']) &&
						lib.skill[i] && lib.skill[i].intro && !lib.skill[i].intro.nocount &&
						(this.storage[i] || lib.skill[i].intro.markcount))) {
						this.marks[i].classList.add('overflowmark')
						var num = 0;
						if (typeof lib.skill[i].intro.markcount == 'function') {
							num = lib.skill[i].intro.markcount(this.storage[i], this);
						}
						else if (typeof this.storage[i + '_markcount'] == 'number') {
							num = this.storage[i + '_markcount'];
						}
						else if (i == 'ghujia') {
							num = this.hujia;
						}
						else if (typeof this.storage[i] == 'number') {
							num = this.storage[i];
						}
						else if (Array.isArray(this.storage[i])) {
							num = this.storage[i].length;
						}
						if (num) {
							if (!this.marks[i].markcount) {
								this.marks[i].markcount = ui.create.div('.markcount.menubutton', this.marks[i]);
							}
							this.marks[i].markcount.innerHTML = num;
						}
						else if (this.marks[i].markcount) {
							this.marks[i].markcount.delete();
							delete this.marks[i].markcount;
						}
					}
					else {
						if (this.marks[i].markcount) {
							this.marks[i].markcount.delete();
							delete this.marks[i].markcount;
						}
						if (lib.skill[i].mark == 'auto') {
							this.unmarkSkill(i);
						}
					}
					return this;
				},
				updateMarks: function (connect) {
					if (typeof connect == 'string' && _status.connectMode && !game.online) {
						game.broadcast(function (player, storage, skill) {
							player.storage[skill] = storage;
							player.updateMarks();
						}, this, this.storage[connect], connect);
					}
					for (var i in this.marks) {
						this.updateMark(i);
					}
				},
				num: function (arg1, arg2, arg3) {
					if (get.itemtype(arg1) == 'position') {
						return this.get(arg1, arg2, arg3).length;
					}
					else if (arg1 == 's') {
						if (typeof arg2 == 'boolean') {
							return game.expandSkills(this.getSkills(arg2).concat(lib.skill.global)).contains(arg3);
						}
						else {
							return game.expandSkills(this.getSkills().concat(lib.skill.global)).contains(arg2);
						}
					}
				},
				line: function (target, config) {
					if (get.itemtype(target) == 'players') {
						for (var i = 0; i < target.length; i++) {
							this.line(target[i], config);
						}
					}
					else if (get.itemtype(target) == 'player') {
						if (target == this) return;
						game.broadcast(function (player, target, config) {
							player.line(target, config);
						}, this, target, config);
						game.addVideo('line', this, [target.dataset.position, config]);
						game.linexy([
							this.getLeft() + this.offsetWidth / 2,
							this.getTop() + this.offsetHeight / 2,
							target.getLeft() + target.offsetWidth / 2,
							target.getTop() + target.offsetHeight / 2
						], config, true);
					}
				},
				line2: function (targets, config) {
					this.line(targets[0], config);
					targets = targets.slice(0);
					for (var i = 1; i < targets.length; i++) {
						(function (j) {
							setTimeout(function () {
								targets[j - 1].line(targets[j], config);
							}, lib.config.duration * i);
						}(i));
					}
				},
				getNext: function () {
					if (this.hasSkill('undist')) return null;
					var target = this;
					for (var i = 0; i < game.players.length - 1; i++) {
						target = target.next;
						if (!target.hasSkill('undist')) {
							return target;
						}
					}
					return null;
				},
				getPrevious: function () {
					if (this.hasSkill('undist')) return null;
					var target = this;
					for (var i = 0; i < game.players.length - 1; i++) {
						target = target.previous;
						if (!target.hasSkill('undist')) {
							return target;
						}
					}
					return null;
				},
				countUsed: function (card, type) {
					if (type === true) {
						var num = 0;
						var history = this.getHistory('useCard');
						for (var i = 0; i < history.length; i++) {
							if (!card) num++;
							else if (typeof card == 'string' && history[i].card && card == history[i].card.name) num++;
							else if (typeof card == 'object' && history[i].card && card.name == history[i].card.name) num++;
						}
						return num;
					}
					var num;
					var stat = this.getStat('card');
					if (!card) {
						num = 0;
						for (var i in stat) {
							if (typeof stat[i] == 'number') num += stat[i];
						}
						return num;
					}
					if (typeof card == 'object') {
						card = card.name;
					}
					num = stat[card];
					if (typeof num != 'number') return 0;
					return num;
				},
				countSkill: function (skill) {
					var num = this.getStat('skill')[skill];
					if (num == undefined) return 0;
					return num;
				},
				getStockSkills: function (unowned, unique, hidden) {
					var list = [];
					if (lib.character[this.name] && (hidden || !this.isUnseen(0))) {
						list.addArray(lib.character[this.name][3]);
					}
					if (lib.character[this.name1] && (hidden || !this.isUnseen(0))) {
						list.addArray(lib.character[this.name1][3]);
					}
					if (lib.character[this.name2] && (hidden || !this.isUnseen(1))) {
						list.addArray(lib.character[this.name2][3]);
					}
					if (!unowned) {
						for (var i = 0; i < list.length; i++) {
							if (!this.hasSkill(list[i])) {
								list.splice(i--, 1);
							}
						}
					}
					if (!unique) {
						for (var i = 0; i < list.length; i++) {
							var info = lib.skill[list[i]];
							if (!info || info.unique || info.temp || info.sub || info.charlotte) {
								list.splice(i--, 1);
							}
						}
					}
					return list;
				},
				getCards: function (arg1, arg2) {
					if (typeof arg1 != 'string') {
						arg1 = 'h';
					}
					var cards = [], cards1 = [];
					var i, j;
					for (i = 0; i < arg1.length; i++) {
						if (arg1[i] == 'h') {
							for (j = 0; j < this.node.handcards1.childElementCount; j++) {
								if (!this.node.handcards1.childNodes[j].classList.contains('removing')) {
									cards.push(this.node.handcards1.childNodes[j]);
								}
							}
							for (j = 0; j < this.node.handcards2.childElementCount; j++) {
								if (!this.node.handcards2.childNodes[j].classList.contains('removing')) {
									cards.push(this.node.handcards2.childNodes[j]);
								}
							}
						}
						else if (arg1[i] == 'e') {
							for (j = 0; j < this.node.equips.childElementCount; j++) {
								if (!this.node.equips.childNodes[j].classList.contains('removing') && !this.node.equips.childNodes[j].classList.contains('feichu')) {
									cards.push(this.node.equips.childNodes[j]);
								}
							}
						}
						else if (arg1[i] == 'j') {
							for (j = 0; j < this.node.judges.childElementCount; j++) {
								if (!this.node.judges.childNodes[j].classList.contains('removing') && !this.node.judges.childNodes[j].classList.contains('feichu')) {
									cards.push(this.node.judges.childNodes[j]);
									if (this.node.judges.childNodes[j].viewAs && arguments.length > 1) {
										this.node.judges.childNodes[j].tempJudge = this.node.judges.childNodes[j].name;
										this.node.judges.childNodes[j].name = this.node.judges.childNodes[j].viewAs;
										cards1.push(this.node.judges.childNodes[j]);
									}
								}
							}
						}
					}
					if (arguments.length == 1) {
						return cards;
					}
					if (arg2) {
						if (typeof arg2 == 'string') {
							for (i = 0; i < cards.length; i++) {
								if (get.name(cards[i]) != arg2) {
									cards.splice(i, 1); i--;
								}
							}
						}
						else if (typeof arg2 == 'object') {
							for (i = 0; i < cards.length; i++) {
								for (j in arg2) {
									var value;
									if (j == 'type' || j == 'subtype' || j == 'color' || j == 'suit' || j == 'number') {
										value = get[j](cards[i]);
									}
									else {
										value = cards[i][j];
									}
									if ((typeof arg2[j] == 'string' && value != arg2[j]) ||
										(Array.isArray(arg2[j]) && !arg2[j].contains(value))) {
										cards.splice(i--, 1); break;
									}
								}
							}
						}
						else if (typeof arg2 == 'function') {
							for (i = 0; i < cards.length; i++) {
								if (!arg2(cards[i])) {
									cards.splice(i--, 1);
								}
							}
						}
					}
					for (i = 0; i < cards1.length; i++) {
						if (cards1[i].tempJudge) {
							cards1[i].name = cards1[i].tempJudge;
							delete cards1[i].tempJudge;
						}
					}
					return cards;
				},
				getDiscardableCards: function (player, arg1, arg2) {
					var cards = this.getCards(arg1, arg2);
					for (var i = 0; i < cards.length; i++) {
						if (!lib.filter.canBeDiscarded(cards[i], player, this)) {
							cards.splice(i--, 1);
						}
					}
					return cards;
				},
				getGainableCards: function (player, arg1, arg2) {
					var cards = this.getCards(arg1, arg2);
					for (var i = 0; i < cards.length; i++) {
						if (!lib.filter.canBeGained(cards[i], player, this)) {
							cards.splice(i--, 1);
						}
					}
					return cards;
				},
				getGainableSkills: function (func) {
					var list = [];
					var names = [this.name, this.name1, this.name2];
					for (var i = 0; i < names.length; i++) {
						list.addArray(get.gainableSkillsName(names[i], func));
					}
					return list;
				},
				countCards: function (arg1, arg2) {
					return this.getCards(arg1, arg2).length;
				},
				countDiscardableCards: function (player, arg1, arg2) {
					return this.getDiscardableCards(player, arg1, arg2).length;
				},
				countGainableCards: function (player, arg1, arg2) {
					return this.getGainableCards(player, arg1, arg2).length;
				},
				getOriginalSkills: function () {
					var skills = [];
					if (lib.character[this.name] && !this.isUnseen(0)) {
						skills.addArray(lib.character[this.name][3]);
					}
					if (this.name2 && lib.character[this.name2] && !this.isUnseen(1)) {
						skills.addArray(lib.character[this.name2][3]);
					}
					return skills;
				},
				getSkills: function (arg2, arg3, arg4) {
					var skills = this.skills.slice(0);
					var es = [];
					var i, j;
					if (arg3 !== false) {
						for (i = 0; i < this.node.equips.childElementCount; i++) {
							if (!this.node.equips.childNodes[i].classList.contains('removing')) {
								var equipskills = get.info(this.node.equips.childNodes[i], false).skills;
								if (equipskills) {
									es.addArray(equipskills);
								}
							}
						}
						if (arg2 == 'e') {
							return es;
						}
					}
					for (var i in this.additionalSkills) {
						if (Array.isArray(this.additionalSkills[i]) && (arg2 || i.indexOf('hidden:') !== 0)) {
							for (j = 0; j < this.additionalSkills[i].length; j++) {
								if (this.additionalSkills[i][j]) {
									skills.add(this.additionalSkills[i][j]);
								}
							}
						}
						else if (this.additionalSkills[i] && typeof this.additionalSkills[i] == 'string') {
							skills.add(this.additionalSkills[i]);
						}
					}
					for (var i in this.tempSkills) {
						skills.add(i);
					}
					if (arg2) skills.addArray(this.hiddenSkills);
					if (arg3 !== false) skills.addArray(es);
					for (var i in this.forbiddenSkills) {
						skills.remove(i);
					}
					if (arg4 !== false) {
						skills = game.filterSkills(skills, this);
					}
					return skills;
				},
				get: function (arg1, arg2, arg3, arg4) {
					var i, j;
					if (arg1 == 's') {
						var skills = this.skills.slice(0);
						var es = [];
						if (arg3 !== false) {
							for (i = 0; i < this.node.equips.childElementCount; i++) {
								if (!this.node.equips.childNodes[i].classList.contains('removing') && !this.node.equips.childNodes[i].classList.contains('feichu')) {
									var equipskills = get.info(this.node.equips.childNodes[i]).skills;
									if (equipskills) {
										es.addArray(equipskills);
									}
								}
							}
							if (arg2 == 'e') {
								return es;
							}
						}
						for (var i in this.additionalSkills) {
							if (Array.isArray(this.additionalSkills[i])) {
								for (j = 0; j < this.additionalSkills[i].length; j++) {
									if (this.additionalSkills[i][j]) {
										skills.add(this.additionalSkills[i][j]);
									}
								}
							}
							else if (this.additionalSkills[i] && typeof this.additionalSkills[i] == 'string') {
								skills.add(this.additionalSkills[i]);
							}
						}
						for (var i in this.tempSkills) {
							skills.add(i);
						}
						if (arg2) skills.addArray(this.hiddenSkills);
						if (arg3 !== false) skills.addArray(es);
						for (var i in this.forbiddenSkills) {
							skills.remove(i);
						}
						if (arg4 !== false) {
							skills = game.filterSkills(skills, this);
						}
						return skills;
					}
					else if (get.is.pos(arg1)) {
						var cards = [], cards1 = [];
						for (i = 0; i < arg1.length; i++) {
							if (arg1[i] == 'h') {
								for (j = 0; j < this.node.handcards1.childElementCount; j++) {
									if (!this.node.handcards1.childNodes[j].classList.contains('removing') && !this.node.handcards1.childNodes[j].classList.contains('feichu')) {
										cards.push(this.node.handcards1.childNodes[j]);
									}
								}
								for (j = 0; j < this.node.handcards2.childElementCount; j++) {
									if (!this.node.handcards2.childNodes[j].classList.contains('removing') && !this.node.handcards2.childNodes[j].classList.contains('feichu')) {
										cards.push(this.node.handcards2.childNodes[j]);
									}
								}
							}
							else if (arg1[i] == 'e') {
								for (j = 0; j < this.node.equips.childElementCount; j++) {
									if (!this.node.equips.childNodes[j].classList.contains('removing') && !this.node.equips.childNodes[j].classList.contains('feichu')) {
										cards.push(this.node.equips.childNodes[j]);
									}
								}
								if (arguments.length == 2 && typeof arg2 == 'string' && /1|2|3|4|5/.test(arg2)) {
									for (j = 0; j < cards.length; j++) {
										if (get.subtype(cards[j]) == 'equip' + arg2) return cards[j];
									}
									return;
								}
							}
							else if (arg1[i] == 'j') {
								for (j = 0; j < this.node.judges.childElementCount; j++) {
									if (!this.node.judges.childNodes[j].classList.contains('removing') && !this.node.judges.childNodes[j].classList.contains('feichu')) {
										cards.push(this.node.judges.childNodes[j]);
										if (this.node.judges.childNodes[j].viewAs && arguments.length > 1) {
											this.node.judges.childNodes[j].tempJudge = this.node.judges.childNodes[j].name;
											this.node.judges.childNodes[j].name = this.node.judges.childNodes[j].viewAs;
											cards1.push(this.node.judges.childNodes[j]);
										}
									}
								}
							}
						}
						if (arguments.length == 1) {
							return cards;
						}
						if (arg2 != undefined) {
							if (typeof arg3 == 'function') {
								var cards2 = cards.slice(0);
								cards.sort(function (a, b) {
									return arg3(b, cards2) - arg3(a, cards2);
								});
							}
							if (typeof arg2 == 'string') {
								for (i = 0; i < cards.length; i++) {
									if (cards[i].name != arg2) {
										cards.splice(i, 1); i--;
									}
								}
							}
							else if (typeof arg2 == 'object') {
								for (i = 0; i < cards.length; i++) {
									for (j in arg2) {
										if (j == 'type') {
											if (typeof arg2[j] == 'object') {
												if (arg2[j].contains(get.type(cards[i])) == false) {
													cards.splice(i, 1); i--; break;
												}
											}
											else if (typeof arg2[j] == 'string') {
												if (get.type(cards[i]) != arg2[j]) {
													cards.splice(i, 1); i--; break;
												}
											}
										}
										else if (j == 'subtype') {
											if (typeof arg2[j] == 'object') {
												if (arg2[j].contains(get.subtype(cards[i])) == false) {
													cards.splice(i, 1); i--; break;
												}
											}
											else if (typeof arg2[j] == 'string') {
												if (get.subtype(cards[i]) != arg2[j]) {
													cards.splice(i, 1); i--; break;
												}
											}
										}
										else if (j == 'color') {
											if (typeof arg2[j] == 'object') {
												if (arg2[j].contains(get.color(cards[i])) == false) {
													cards.splice(i, 1); i--; break;
												}
											}
											else if (typeof arg2[j] == 'string') {
												if (get.color(cards[i]) != arg2[j]) {
													cards.splice(i, 1); i--; break;
												}
											}
										}
										else if (j == 'suit') {
											if (typeof arg2[j] == 'object') {
												if (arg2[j].contains(get.suit(cards[i])) == false) {
													cards.splice(i, 1); i--; break;
												}
											}
											else if (typeof arg2[j] == 'string') {
												if (get.suit(cards[i]) != arg2[j]) {
													cards.splice(i, 1); i--; break;
												}
											}
										}
										else if (j == 'number') {
											if (typeof arg2[j] == 'object') {
												if (arg2[j].contains(get.number(cards[i])) == false) {
													cards.splice(i, 1); i--; break;
												}
											}
											else if (typeof arg2[j] == 'string') {
												if (get.number(cards[i]) != arg2[j]) {
													cards.splice(i, 1); i--; break;
												}
											}
										}
										else if (typeof arg2[j] == 'object') {
											if (arg2[j].contains(cards[i][j]) == false) {
												cards.splice(i, 1); i--; break;
											}
										}
										else if (typeof arg2[j] == 'string') {
											if (cards[i][j] != arg2[j]) {
												cards.splice(i, 1); i--; break;
											}
										}
									}
								}
							}
							else if (typeof arg2 == 'number' && arg2 > 0) {
								cards.splice(arg2);
							}
							else if (typeof arg2 == 'function') {
								for (i = 0; i < cards.length; i++) {
									if (!arg2(cards[i])) {
										cards.splice(i, 1); i--;
									}
								}
							}
						}
						for (i = 0; i < cards1.length; i++) {
							if (cards1[i].tempJudge) {
								cards1[i].name = cards1[i].tempJudge;
								delete cards1[i].tempJudge;
							}
						}
						if (arg2 === 0) return cards[0];
						if (typeof arg3 == 'number') {
							if (arg3 == 0) return cards[0];
							cards.splice(arg3);
						}
						if (typeof arg4 == 'number') {
							if (arg4 == 0) return cards[0];
							cards.splice(arg4);
						}
						return cards;
					}
				},
				syncStorage: function (skill) {
					switch (get.itemtype(this.storage[skill])) {
						case 'cards': game.addVideo('storage', this, [skill, get.cardsInfo(this.storage[skill]), 'cards']); break;
						case 'card': game.addVideo('storage', this, [skill, get.cardInfo(this.storage[skill]), 'card']); break;
						default:
							try {
								game.addVideo('storage', this, [skill, JSON.parse(JSON.stringify(this.storage[skill]))]);
							}
							catch (e) {
								console.log(this.storage[skill]);
							}
					}
				},
				syncSkills: function () {
					game.broadcast(function (player, skills) {
						player.applySkills(skills);
					}, this, get.skillState(this));
				},
				playerfocus: function (time) {
					time = time || 1000;
					this.classList.add('playerfocus');
					ui.arena.classList.add('playerfocus');
					var that = this;
					setTimeout(function () {
						that.classList.remove('playerfocus');
						ui.arena.classList.remove('playerfocus');
					}, time);
					game.addVideo('playerfocus', this, time);
					game.broadcast(function (player, time) {
						player.playerfocus(time);
					}, this, time);
					return this;
				},
				setIdentity: function (identity) {
					if (!identity) identity = this.identity;
					if (get.is.jun(this)) {
						this.node.identity.firstChild.innerHTML = '君';
					}
					else {
						this.node.identity.firstChild.innerHTML = get.translation(identity);
					}
					this.node.identity.dataset.color = identity;
					return this;
				},
				insertPhase: function (skill, insert) {
					var evt = _status.event.getParent('phase');
					var next;
					if (evt && evt.parent && evt.parent.next) {
						evt = evt.parent;
						next = game.createEvent('phase', null, evt);
					}
					else if (_status.event.parent && _status.event.parent.next) {
						evt = _status.event.parent;
						next = game.createEvent('phase', null, evt);
					}
					else {
						evt = null;
						next = game.createEvent('phase');
					}
					if (evt && insert && evt.next.contains(next)) {
						evt.next.remove(next);
						evt.next.unshift(next);
					}
					next.player = this;
					next.skill = skill || _status.event.name;
					next.setContent('phase');
					return next;
				},
				insertEvent: function (name, content, arg) {
					var evt = _status.event.getParent('phase');
					var next;
					if (evt && evt.parent && evt.parent.next) {
						next = game.createEvent(name, null, evt.parent);
					}
					else {
						next = game.createEvent(name);
					}
					for (var i in arg) {
						next[i] = arg[i];
					}
					next.player = this;
					next.setContent(content);
					return next;
				},
				phase: function (skill) {
					var next = game.createEvent('phase');
					next.player = this;
					next.setContent('phase');
					if (!_status.roundStart) {
						_status.roundStart = this;
					}
					if (skill) {
						next.skill = skill;
					}
					return next;
				},
				phaseZhunbei: function () {
					var next = game.createEvent('phaseZhunbei');
					next.player = this;
					next.setContent('emptyEvent');
					return next;
				},
				phaseJudge: function () {
					var next = game.createEvent('phaseJudge');
					next.player = this;
					next.setContent('phaseJudge');
					return next;
				},
				phaseDraw: function () {
					var next = game.createEvent('phaseDraw');
					next.player = this;
					next.num = 2;
					if ((get.config('first_less') || _status.connectMode || _status.first_less_forced) && game.phaseNumber == 1 && _status.first_less) {
						next.num--;
					}
					next.setContent('phaseDraw');
					return next;
				},
				phaseUse: function () {
					var next = game.createEvent('phaseUse');
					next.player = this;
					next.setContent('phaseUse');
					return next;
				},
				phaseDiscard: function () {
					var next = game.createEvent('phaseDiscard');
					next.player = this;
					next.setContent('phaseDiscard');
					return next;
				},
				phaseJieshu: function () {
					var next = game.createEvent('phaseJieshu');
					next.player = this;
					next.setContent('emptyEvent');
					return next;
				},
				chooseToUse: function (use) {
					var next = game.createEvent('chooseToUse');
					next.player = this;
					if (arguments.length == 1 && get.objtype(arguments[0]) == 'object') {
						for (var i in use) {
							next[i] = use[i];
						}
					}
					else {
						for (var i = 0; i < arguments.length; i++) {
							if (typeof arguments[i] == 'number' || get.itemtype(arguments[i]) == 'select') {
								next.selectTarget = arguments[i];
							}
							else if ((typeof arguments[i] == 'object' && arguments[i]) || typeof arguments[i] == 'function') {
								if (get.itemtype(arguments[i]) == 'player' || next.filterCard) {
									next.filterTarget = arguments[i];
								}
								else next.filterCard = arguments[i];
							}
							else if (typeof arguments[i] == 'boolean') {
								next.forced = arguments[i];
							}
							else if (typeof arguments[i] == 'string') {
								next.prompt = arguments[i];
							}
						}
					}
					if (typeof next.filterCard == 'object') {
						next.filterCard = get.filter(next.filterCard);
					}
					if (typeof next.filterTarget == 'object') {
						next.filterTarget = get.filter(next.filterTarget, 2);
					}
					if (next.filterCard == undefined) {
						next.filterCard = lib.filter.filterCard;
					}
					if (next.selectCard == undefined) {
						next.selectCard = [1, 1];
					}
					if (next.filterTarget == undefined) {
						next.filterTarget = lib.filter.filterTarget;
					}
					if (next.selectTarget == undefined) {
						next.selectTarget = lib.filter.selectTarget;
					}
					if (next.ai1 == undefined) next.ai1 = get.order;
					if (next.ai2 == undefined) next.ai2 = get.effect_use;
					next.setContent('chooseToUse');
					next._args = Array.from(arguments);
					return next;
				},
				chooseToRespond: function () {
					var next = game.createEvent('chooseToRespond');
					next.player = this;
					var filter;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							next.selectCard = [arguments[i], arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectCard = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'position') {
							next.position = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							if (next.filterCard) next.ai = arguments[i];
							else next.filterCard = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i]) {
							next.filterCard = get.filter(arguments[i]);
							filter = arguments[i];
						}
						else if (arguments[i] == 'nosource') {
							next.nosource = true;
						}
						else if (typeof arguments[i] == 'string') {
							next.prompt = arguments[i];
						}
					}
					if (next.filterCard == undefined) next.filterCard = lib.filter.all;
					if (next.selectCard == undefined) next.selectCard = [1, 1];
					if (next.source == undefined && !next.nosource) next.source = _status.event.player;
					if (next.ai == undefined) next.ai = get.unuseful2;
					if (next.prompt != false) {
						if (typeof next.prompt == 'string') {
							next.dialog = next.prompt;
						}
						else {
							var str = '请打出' + get.cnNumber(next.selectCard[0]) + '张'
							if (filter) {
								if (filter.name) {
									str += get.translation(filter.name);
								}
								else {
									str += '牌';
								}
							}
							else {
								str += '牌';
							}
							if (_status.event.getParent().name == 'useCard') {
								var cardname = _status.event.name;
								if (lib.card[cardname] && lib.translate[cardname]) {
									str += '响应' + lib.translate[cardname];
								}
							}
							next.dialog = str;
						}
					}
					next.setContent('chooseToRespond');
					next._args = Array.from(arguments);
					return next;
				},
				chooseToDiscard: function () {
					var next = game.createEvent('chooseToDiscard');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							next.selectCard = [arguments[i], arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectCard = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'dialog') {
							next.dialog = arguments[i];
							next.prompt = false;
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'position') {
							next.position = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							if (next.filterCard) next.ai = arguments[i];
							else next.filterCard = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i]) {
							next.filterCard = get.filter(arguments[i]);
						}
						else if (typeof arguments[i] == 'string') {
							get.evtprompt(next, arguments[i]);
						}
						if (arguments[i] === null) {
							for (var i = 0; i < arguments.length; i++) {
								console.log(arguments[i]);
							}
						}
					}
					if (next.isMine() == false && next.dialog) next.dialog.style.display = 'none';
					if (next.filterCard == undefined) next.filterCard = lib.filter.all;
					if (next.selectCard == undefined) next.selectCard = [1, 1];
					if (next.ai == undefined) next.ai = get.unuseful;
					next.autochoose = function () {
						if (!this.forced) return false;
						if (typeof this.selectCard == 'function') return false;
						var cards = this.player.getCards(this.position);
						var num = cards.length;
						for (var i = 0; i < cards.length; i++) {
							if (!lib.filter.cardDiscardable(cards[i], this.player, this)) num--;
						}
						return get.select(this.selectCard)[0] >= num;
					}
					next.setContent('chooseToDiscard');
					next._args = Array.from(arguments);
					return next;
				},
				chooseToCompare: function (target, check) {
					var next = game.createEvent('chooseToCompare');
					next.player = this;
					if (Array.isArray(target)) {
						next.targets = target;
						if (check) next.ai = check;
						else next.ai = function (card) {
							if (typeof card == 'string' && lib.skill[card]) {
								var ais = lib.skill[card].check || function () { return 0 };
								return ais();
							}
							var addi = (get.value(card) >= 8 && get.type(card) != 'equip') ? -10 : 0;
							if (card.name == 'du') addi += 5;
							var source = _status.event.source;
							var player = _status.event.player;
							if (source && source != player && get.attitude(player, source) > 1) {
								return -get.number(card) - get.value(card) / 2 + addi;
							}
							return get.number(card) - get.value(card) / 2 + addi;
						}
						next.setContent('chooseToCompareMultiple');
					}
					else {
						next.target = target;
						if (check) next.ai = check;
						else next.ai = function (card) {
							if (typeof card == 'string' && lib.skill[card]) {
								var ais = lib.skill[card].check || function () { return 0 };
								return ais();
							}
							var player = get.owner(card);
							var event = _status.event.getParent();
							var to = (player == event.player ? event.target : event.player);
							var addi = (get.value(card) >= 8 && get.type(card) != 'equip') ? -10 : 0;
							if (card.name == 'du') addi += 5;
							if (player == event.player) {
								if (get.attitude(player, to) > 0 && event.small) {
									return -get.number(card) - get.value(card) / 2 + addi;
								}
								return get.number(card) - get.value(card) / 2 + addi;
							}
							else {
								if (get.attitude(player, to) > 0 && !event.small) {
									return -get.number(card) - get.value(card) / 2 + addi;
								}
								return get.number(card) - get.value(card) / 2 + addi;
							}
						}
						next.setContent('chooseToCompare');
					}
					next._args = Array.from(arguments);
					return next;
				},
				chooseSkill: function (target) {
					var next = game.createEvent('chooseSkill');
					next.player = this;
					next.setContent('chooseSkill');
					next.target = target;
					for (var i = 1; i < arguments.length; i++) {
						if (typeof arguments[i] == 'string') {
							next.prompt = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							next.func = arguments[i];
						}
					}
				},
				discoverCard: function (list) {
					var next = game.createEvent('discoverCard');
					next.player = this;
					next.setContent('discoverCard');
					next.list = list || lib.inpile.slice(0);
					next.forced = true;
					for (var i = 1; i < arguments.length; i++) {
						if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							switch (arguments[i]) {
								case 'use': next.use = true; break;
								case 'nogain': next.nogain = true; break;
								default: next.prompt = arguments[i];
							}
						}
						else if (typeof arguments[i] == 'number') {
							next.num = arguments[i];
						}
						else if (typeof arguments[i] === 'function') {
							next.ai = arguments[i];
						}
					}
					return next;
				},
				chooseCardButton: function () {
					var cards, prompt, forced, select;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'cards') cards = arguments[i];
						else if (typeof arguments[i] == 'boolean') forced = arguments[i];
						else if (typeof arguments[i] == 'string') prompt = arguments[i];
						else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number') select = arguments[i];
					}
					if (prompt == undefined) prompt = '请选择卡牌';
					return this.chooseButton(forced, select, 'hidden', [prompt, cards, 'hidden']);
				},
				chooseVCardButton: function () {
					var list, prompt, forced, select, notype = false;
					for (var i = 0; i < arguments.length; i++) {
						if (Array.isArray(arguments[i])) {
							list = arguments[i];
						}
						else if (arguments[i] == 'notype') {
							notype = true;
						}
						else if (typeof arguments[i] == 'boolean') forced = arguments[i];
						else if (typeof arguments[i] == 'string') prompt = arguments[i];
						else if (get.itemtype(arguments[i]) == 'select' || typeof arguments[i] == 'number') select = arguments[i];
					}
					for (var i = 0; i < list.length; i++) {
						list[i] = [notype ? '' : (get.subtype(list[i]) || get.type(list[i])), '', list[i]];
					}
					if (prompt == undefined) prompt = '请选择卡牌';
					return this.chooseButton(forced, select, 'hidden', [prompt, [list, 'vcard'], 'hidden']);
				},
				chooseButton: function () {
					var next = game.createEvent('chooseButton');
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'dialog') {
							next.dialog = arguments[i];
							next.closeDialog = true;
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectButton = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.selectButton = [arguments[i], arguments[i]];
						}
						else if (typeof arguments[i] == 'function') {
							if (next.ai) next.filterButton = arguments[i];
							else next.ai = arguments[i];
						}
						else if (Array.isArray(arguments[i])) {
							next.createDialog = arguments[i];
						}
					}
					next.player = this;
					if (typeof next.forced != 'boolean') next.forced = false;
					if (next.isMine() == false && next.dialog) next.dialog.style.display = 'none';
					if (next.filterButton == undefined) next.filterButton = lib.filter.filterButton;
					if (next.selectButton == undefined) next.selectButton = [1, 1];
					if (next.ai == undefined) next.ai = function () { return 1 };
					next.setContent('chooseButton');
					next._args = Array.from(arguments);
					next.forceDie = true;
					return next;
				},
				chooseButtonOL: function (list, callback, ai) {
					var next = game.createEvent('chooseButtonOL');
					next.list = list;
					next.setContent('chooseButtonOL');
					next.ai = ai;
					next.callback = callback;
					next._args = Array.from(arguments);
					return next;
				},
				chooseCardOL: function () {
					var next = game.createEvent('chooseCardOL');
					next._args = [];
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'players') {
							next.list = arguments[i].slice(0);
						}
						else {
							next._args.push(arguments[i]);
						}
					}
					next.setContent('chooseCardOL');
					next._args.add('glow_result');
					return next;
				},
				chooseCard: function () {
					var next = game.createEvent('chooseCard');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							next.selectCard = [arguments[i], arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectCard = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'position') {
							next.position = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							if (next.filterCard) next.ai = arguments[i];
							else next.filterCard = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i]) {
							next.filterCard = get.filter(arguments[i]);
						}
						else if (arguments[i] == 'glow_result') {
							next.glow_result = true;
						}
						else if (typeof arguments[i] == 'string') {
							get.evtprompt(next, arguments[i]);
						}
					}
					if (next.filterCard == undefined) next.filterCard = lib.filter.all;
					if (next.selectCard == undefined) next.selectCard = [1, 1];
					if (next.ai == undefined) next.ai = get.unuseful3;
					next.setContent('chooseCard');
					next._args = Array.from(arguments);
					return next;
				},
				chooseUseTarget: function () {
					var next = game.createEvent('chooseUseTarget');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.card = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'players') {
							next.targets = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'player') {
							next.targets = [arguments[i]];
						}
						else if (get.is.object(arguments[i]) && arguments[i].name) {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							if (arguments[i] == 'nopopup') {
								next.nopopup = true;
							}
							else if (arguments[i] == 'noanimate') {
								next.animate = false;
							}
							else if (arguments[i] == 'nothrow') {
								next.throw = false;
							}
							else if (arguments[i] == 'nodistance') {
								next.nodistance = true;
							}
							else if (arguments[i] == 'noTargetDelay') {
								next.noTargetDelay = true;
							}
							else if (arguments[i] == 'nodelayx') {
								next.nodelayx = true;
							}
							else if (lib.card[arguments[i]] && !next.card) {
								next.card = { name: arguments[i], isCard: true };
							}
							else get.evtprompt(next, arguments[i]);
						}
						else if (arguments[i] === true) {
							next.forced = true;
						}
						else if (arguments[i] === false) {
							next.addCount = false;
						}
					}
					if (!next.targets) next.targets = game.players.slice(0);
					if (next.cards == undefined) {
						if (get.itemtype(next.card) == 'card') {
							next.cards = [next.card];
						}
						else next.cards = [];
					}
					else if (next.card == undefined) {
						if (next.cards) {
							next.card = next.cards[0];
						}
					}
					next.setContent('chooseUseTarget');
					next._args = Array.from(arguments);
					return next;
					// Fully Online-Ready! Enjoy It!
				},
				chooseTarget: function () {
					var next = game.createEvent('chooseTarget');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							next.selectTarget = [arguments[i], arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectTarget = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'dialog') {
							next.dialog = arguments[i];
							next.prompt = false;
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							if (next.filterTarget) next.ai = arguments[i];
							else next.filterTarget = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							get.evtprompt(next, arguments[i]);
						}
					}
					if (next.filterTarget == undefined) next.filterTarget = lib.filter.all;
					if (next.selectTarget == undefined) next.selectTarget = [1, 1];
					if (next.ai == undefined) next.ai = get.attitude2;
					next.setContent('chooseTarget');
					next._args = Array.from(arguments);
					next.forceDie = true;
					return next;
				},
				chooseCardTarget: function (choose) {
					var next = game.createEvent('chooseCardTarget');
					next.player = this;
					if (arguments.length == 1) {
						for (var i in choose) {
							next[i] = choose[i];
						}
					}
					if (typeof next.filterCard == 'object') {
						next.filterCard = get.filter(next.filterCard);
					}
					if (typeof next.filterTarget == 'object') {
						next.filterTarget = get.filter(next.filterTarget, 2);
					}
					if (next.filterCard == undefined || next.filterCard === true) {
						next.filterCard = lib.filter.all;
					}
					if (next.selectCard == undefined) {
						next.selectCard = 1;
					}
					if (next.filterTarget == undefined || next.filterTarget === true) {
						next.filterTarget = lib.filter.all;
					}
					if (next.selectTarget == undefined) {
						next.selectTarget = 1;
					}
					if (next.ai1 == undefined) next.ai1 = get.unuseful2;
					if (next.ai2 == undefined) next.ai2 = get.attitude2;
					next.setContent('chooseCardTarget');
					next._args = Array.from(arguments);
					return next;
				},
				chooseControlList: function () {
					var list = [];
					var prompt = null;
					var forced = 'cancel2';
					var func = null;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'string') {
							if (!prompt) {
								prompt = arguments[i];
							}
							else {
								list.push(arguments[i]);
							}
						}
						else if (Array.isArray(arguments[i])) {
							list = arguments[i];
						}
						else if (arguments[i] === true) {
							forced = null;
						}
						else if (typeof arguments[i] == 'function') {
							func = arguments[i];
						}
					}
					return this.chooseControl(forced, func).set('choiceList', list).set('prompt', prompt);
				},
				chooseControl: function () {
					var next = game.createEvent('chooseControl');
					next.controls = [];
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'string') {
							if (arguments[i] == 'dialogcontrol') {
								next.dialogcontrol = true;
							}
							else if (arguments[i] == 'seperate') {
								next.seperate = true;
							}
							else {
								next.controls.push(arguments[i]);
							}
						}
						else if (Array.isArray(arguments[i])) {
							next.controls = next.controls.concat(arguments[i]);
						}
						else if (typeof arguments[i] == 'function') {
							next.ai = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.choice = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'dialog') {
							next.dialog = arguments[i];
						}
					}
					next.player = this;
					if (next.choice == undefined) next.choice = 0;
					next.setContent('chooseControl');
					next._args = Array.from(arguments);
					next.forceDie = true;
					return next;
				},
				chooseBool: function () {
					var next = game.createEvent('chooseBool');
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'boolean') {
							next.choice = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							next.ai = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							get.evtprompt(next, arguments[i]);
						}
						else if (get.itemtype(arguments[i]) == 'dialog') {
							next.dialog = arguments[i];
						}
						if (next.choice == undefined) next.choice = true;
					}
					next.player = this;
					next.setContent('chooseBool');
					next._args = Array.from(arguments);
					next.forceDie = true;
					return next;
				},
				chooseDrawRecover: function () {
					var next = game.createEvent('chooseDrawRecover', false);
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							if (typeof next.num1 == 'number') {
								next.num2 = arguments[i];
							}
							else {
								next.num1 = arguments[i];
							}
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							next.prompt = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							next.ai = arguments[i];
						}
					}
					if (typeof next.num1 != 'number') {
						next.num1 = 1;
					}
					if (typeof next.num2 != 'number') {
						next.num2 = 1;
					}
					next.setContent('chooseDrawRecover');
					return next;
				},
				choosePlayerCard: function () {
					var next = game.createEvent('choosePlayerCard');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'player') {
							next.target = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.selectButton = [arguments[i], arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectButton = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'position') {
							next.position = arguments[i];
						}
						else if (arguments[i] == 'visible') {
							next.visible = true;
						}
						else if (typeof arguments[i] == 'function') {
							if (next.ai) next.filterButton = arguments[i];
							else next.ai = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i]) {
							next.filterButton = get.filter(arguments[i]);
						}
						else if (typeof arguments[i] == 'string') {
							next.prompt = arguments[i];
						}
					}
					if (next.filterButton == undefined) next.filterButton = lib.filter.all;
					if (next.position == undefined) next.position = 'he';
					if (next.selectButton == undefined) next.selectButton = [1, 1];
					if (next.ai == undefined) next.ai = function (button) {
						var val = get.buttonValue(button);
						if (get.attitude(_status.event.player, get.owner(button.link)) > 0) return -val;
						return val;
					};
					next.setContent('choosePlayerCard');
					next._args = Array.from(arguments);
					return next;
				},
				discardPlayerCard: function () {
					var next = game.createEvent('discardPlayerCard');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'player') {
							next.target = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.selectButton = [arguments[i], arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectButton = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'position') {
							next.position = arguments[i];
						}
						else if (arguments[i] == 'visible') {
							next.visible = true;
						}
						else if (typeof arguments[i] == 'function') {
							if (next.ai) next.filterButton = arguments[i];
							else next.ai = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i]) {
							next.filterButton = get.filter(arguments[i]);
						}
						else if (typeof arguments[i] == 'string') {
							next.prompt = arguments[i];
						}
					}
					if (next.filterButton == undefined) next.filterButton = lib.filter.all;
					if (next.position == undefined) next.position = 'he';
					if (next.selectButton == undefined) next.selectButton = [1, 1];
					if (next.ai == undefined) next.ai = function (button) {
						var val = get.buttonValue(button);
						if (get.attitude(_status.event.player, get.owner(button.link)) > 0) return -val;
						return val;
					};
					next.setContent('discardPlayerCard');
					next._args = Array.from(arguments);
					return next;
				},
				gainPlayerCard: function () {
					var next = game.createEvent('gainPlayerCard');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'player') {
							next.target = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.selectButton = [arguments[i], arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							next.selectButton = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'position') {
							next.position = arguments[i];
						}
						else if (arguments[i] == 'visible') {
							next.visible = true;
						}
						else if (arguments[i] == 'visibleMove') {
							next.visibleMove = true;
						}
						else if (typeof arguments[i] == 'function') {
							if (next.ai) next.filterButton = arguments[i];
							else next.ai = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i]) {
							next.filterButton = get.filter(arguments[i]);
						}
						else if (typeof arguments[i] == 'string') {
							next.prompt = arguments[i];
						}
					}
					if (next.filterButton == undefined) next.filterButton = lib.filter.all;
					if (next.position == undefined) next.position = 'he';
					if (next.selectButton == undefined) next.selectButton = [1, 1];
					if (next.ai == undefined) next.ai = function (button) {
						var val = get.buttonValue(button);
						if (get.attitude(_status.event.player, get.owner(button.link)) > 0) return -val;
						return val;
					};
					next.setContent('gainPlayerCard');
					next._args = Array.from(arguments);
					return next;
				},
				showHandcards: function (str) {
					var next = game.createEvent('showHandcards');
					next.player = this;
					if (typeof str == 'string') {
						next.prompt = str;
					}
					next.setContent('showHandcards');
					next._args = Array.from(arguments);
					return next;
				},
				showCards: function (cards, str) {
					var next = game.createEvent('showCards');
					next.player = this;
					next.str = str;
					if (typeof cards == 'string') {
						str = cards;
						cards = next.str;
						next.str = str;
					}
					if (get.itemtype(cards) == 'card') next.cards = [cards];
					else if (get.itemtype(cards) == 'cards') next.cards = cards.slice(0);
					else _status.event.next.remove(next);
					next.setContent('showCards');
					next._args = Array.from(arguments);
					return next;
				},
				viewCards: function (str, cards) {
					var next = game.createEvent('viewCards');
					next.player = this;
					next.str = str;
					next.cards = cards.slice(0);
					next.setContent('viewCards');
					next._args = Array.from(arguments);
					return next;
				},
				viewHandcards: function (target) {
					var cards = target.getCards('h');
					if (cards.length) {
						return this.viewCards(get.translation(target) + '的手牌', cards);
					}
					else {
						return false;
					}
				},
				canMoveCard: function (withatt, nojudge) {
					var player = this;
					return game.hasPlayer(function (current) {
						var att = get.sgn(get.attitude(player, current));
						if (!withatt || att != 0) {
							var es = current.getCards('e');
							for (var i = 0; i < es.length; i++) {
								if (game.hasPlayer(function (current2) {
									if (withatt) {
										if (get.sgn(get.value(es[i], current)) != -att) return false;
										var att2 = get.sgn(get.attitude(player, current2));
										if (att2 != get.sgn(get.effect(current2, es[i], player, current2))) return false;
									}
									return current != current2 && !current2.isMin() && current2.isEmpty(get.subtype(es[i]));
								})) {
									return true;
								}
							}
						}
						if (!nojudge && (!withatt || att > 0)) {
							var js = current.getCards('j');
							for (var i = 0; i < js.length; i++) {
								if (game.hasPlayer(function (current2) {
									if (withatt) {
										var att2 = get.attitude(player, current2);
										if (att2 >= 0) return false;
									}
									return current != current2 && current2.canAddJudge(js[i]);
								})) {
									return true;
								}
							}
						}
					});
				},
				moveCard: function () {
					var next = game.createEvent('moveCard');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'boolean') {
							next.forced = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							get.evtprompt(next, arguments[i]);
						}
						else if (Array.isArray(arguments[i])) {
							for (var j = 0; j < arguments[i].length; j++) {
								if (typeof arguments[i][j] != 'string') break;
							}
							if (j == arguments[i].length) {
								next.targetprompt = arguments[i];
							}
						}
					}
					next.setContent('moveCard');
					next._args = Array.from(arguments);
					return next;
				},
				useResult: function (result, event) {
					event = event || _status.event;
					if (result._sendskill) {
						lib.skill[result._sendskill[0]] = result._sendskill[1];
					}
					if (event.onresult) {
						event.onresult(result);
					}
					if (result.skill) {
						var info = get.info(result.skill);
						if (info.onuse) {
							info.onuse(result, this);
						}
						if (info.direct && !info.clearTime) {
							_status.noclearcountdown = true;
						}
					}
					if (event.logSkill) {
						if (typeof event.logSkill == 'string') {
							this.logSkill(event.logSkill);
						}
						else if (Array.isArray(event.logSkill)) {
							this.logSkill.apply(this, event.logSkill);
						}
					}
					if (result.card || !result.skill) {
						result.used = result.card || result.cards[0];
						var next = this.useCard(result.card, result.cards, result.targets, result.skill);
						next.oncard = event.oncard;
						next.respondTo = event.respondTo;
						if (event.addCount === false) {
							next.addCount = false;
						}
						return next;
					}
					else if (result.skill) {
						result.used = result.skill;
						return this.useSkill(result.skill, result.cards, result.targets);
					}
				},
				useCard: function () {
					var next = game.createEvent('useCard');
					next.player = this;
					next.num = 0;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'players') {
							next.targets = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'player') {
							next.targets = [arguments[i]];
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							if (arguments[i] == 'noai') {
								next.noai = true;
							}
							else if (arguments[i] == 'nowuxie') {
								next.nowuxie = true;
							}
							else {
								next.skill = arguments[i];
							}
						}
						else if (typeof arguments[i] == 'boolean') {
							next.addCount = arguments[i];
						}
					}
					if (next.cards == undefined) {
						if (get.itemtype(next.card) == 'card') {
							next.cards = [next.card];
						}
						else next.cards = [];
					}
					else if (next.card == undefined) {
						if (next.cards) {
							next.card = next.cards[0];
						}
					}
					if (!next.targets) {
						next.targets = [];
					}
					if (next.card) {
						next.card = get.autoViewAs(next.card, false, next.player);
						var info = get.info(next.card);
						if (info.changeTarget) {
							info.changeTarget(next.player, next.targets);
						}
						if (info.singleCard) {
							next._targets = next.targets.slice(0);
							next.target = next.targets[0];
							next.addedTargets = next.targets.splice(1);
							if (next.addedTargets.length) {
								next.addedTarget = next.addedTargets[0];
							}
						}
						if (!next.card.isCard && next.cards.length) {
							next.card.cards = next.cards.slice(0);
						}
					}
					for (var i = 0; i < next.targets.length; i++) {
						if (get.attitude(this, next.targets[i]) >= -1 && get.attitude(this, next.targets[i]) < 0) {
							if (!this.ai.tempIgnore) this.ai.tempIgnore = [];
							this.ai.tempIgnore.add(next.targets[i]);
						}
					}
					if (typeof this.logAi == 'function' && !next.noai) {
						var postAi = get.info(next.card).postAi;
						if (postAi && postAi(next.targets)) {
							next.postAi = true;
						}
						else {
							this.logAi(next.targets, next.card);
						}
					}
					next.stocktargets = next.targets.slice(0);
					next.setContent('useCard');
					return next;
				},
				useSkill: function () {
					var next = game.createEvent('useSkill');
					next.player = this;
					next.num = 0;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'players') {
							next.targets = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							next.skill = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.addCount = arguments[i];
						}
					}
					if (next.cards == undefined) {
						next.cards = [];
					}
					if (next.skill && get.info(next.skill) && get.info(next.skill).changeTarget) {
						get.info(next.skill).changeTarget(next.player, next.targets);
					}
					if (next.targets) {
						for (var i = 0; i < next.targets.length; i++) {
							if (get.attitude(this, next.targets[i]) >= -1 && get.attitude(this, next.targets[i]) < 0) {
								if (!this.ai.tempIgnore) this.ai.tempIgnore = [];
								this.ai.tempIgnore.add(next.targets[i]);
							}
						}
						if (typeof this.logAi == 'function') {
							this.logAi(next.targets, next.skill);
						}
					}
					else {
						next.targets = [];
					}
					next.setContent('useSkill');
					return next;
				},
				drawTo: function (num, args) {
					var num2 = num - this.countCards('h');
					if (!num2) return;
					var next = this.draw(num2);
					if (Array.isArray(args)) {
						for (var i = 0; i < args.length; i++) {
							if (get.itemtype(args[i]) == 'player') {
								next.source = args[i];
							}
							else if (typeof args[i] == 'boolean') {
								next.animate = args[i];
							}
							else if (args[i] == 'nodelay') {
								next.animate = false;
								next.$draw = true;
							}
							else if (args[i] == 'visible') {
								next.visible = true;
							}
							else if (args[i] == 'bottom') {
								next.bottom = true;
							}
							else if (typeof args[i] == 'object' && args[i] && args[i].drawDeck != undefined) {
								next.drawDeck = args[i].drawDeck;
							}
						}
					}
					return next;
				},
				draw: function () {
					var next = game.createEvent('draw');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'player') {
							next.source = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.num = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.animate = arguments[i];
						}
						else if (arguments[i] == 'nodelay') {
							next.animate = false;
							next.$draw = true;
						}
						else if (arguments[i] == 'visible') {
							next.visible = true;
						}
						else if (arguments[i] == 'bottom') {
							next.bottom = true;
						}
						else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].drawDeck != undefined) {
							next.drawDeck = arguments[i].drawDeck;
						}
					}
					if (next.num == undefined) next.num = 1;
					if (next.num <= 0) _status.event.next.remove(next);
					next.setContent('draw');
					if (lib.config.mode == 'stone' && _status.mode == 'deck' &&
						next.drawDeck == undefined && !next.player.isMin() && next.num > 1) {
						next.drawDeck = 1;
					}
					return next;
				},
				randomDiscard: function () {
					var position = 'he', num = 1, delay = null;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							num = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'position') {
							position = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							delay = arguments[i];
						}
					}
					var cards = this.getCards(position).randomGets(num);
					if (cards.length) {
						var next = this.discard(cards, 'notBySelf');
						if (typeof delay == 'boolean') {
							next.delay = delay;
						}
					}
					return cards;
				},
				randomGain: function () {
					var position = 'he', num = 1, target = null, line = false;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							num = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'select') {
							position = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'player') {
							target = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							line = arguments[i];
						}
					}
					if (target) {
						var cards = target.getCards(position).randomGets(num);
						if (cards.length) {
							if (line) {
								this.line(target, 'green');
							}
							this.gain(cards, target, 'log', 'bySelf');
							target.$giveAuto(cards, this);
						}
						return cards;
					}
					return [];
				},
				discard: function () {
					var next = game.createEvent('discard');
					next.player = this;
					next.num = 0;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'player') {
							next.source = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.cards = [arguments[i]];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.animate = arguments[i];
						}
						else if (get.objtype(arguments[i]) == 'div') {
							next.position = arguments[i];
						}
						else if (arguments[i] == 'notBySelf') {
							next.notBySelf = true;
						}
					}
					if (next.cards == undefined) _status.event.next.remove(next);
					next.setContent('discard');
					return next;
				},
				respond: function () {
					var next = game.createEvent('respond');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.card = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'player') {
							next.source = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') next.animate = arguments[i];
						else if (arguments[i] == 'highlight') next.highlight = true;
						else if (arguments[i] == 'noOrdering') next.noOrdering = true;
						else if (typeof arguments[i] == 'string') next.skill = arguments[i];
					}
					if (next.cards == undefined) {
						if (get.itemtype(next.card) == 'card') {
							next.cards = [next.card];
						}
						else {
							next.cards = [];
						}
					}
					else if (next.card == undefined) {
						if (next.cards) {
							next.card = next.cards[0];
							if (!next.skill) {
								next.card = get.autoViewAs(next.card, null, next.player);
							}
						}
					}
					next.setContent('respond');
					return next;
				},
				swapHandcards: function (target, cards1, cards2) {
					var next = game.createEvent('swapHandcards', false);
					next.player = this;
					next.target = target;
					if (cards1) next.cards1 = cards1;
					if (cards2) next.cards2 = cards2;
					next.setContent('swapHandcards');
					return next;
				},
				directequip: function (cards) {
					for (var i = 0; i < cards.length; i++) {
						this.$equip(cards[i]);
					}
					if (!_status.video) {
						game.addVideo('directequip', this, get.cardsInfo(cards));
					}
				},
				directgain: function (cards, broadcast) {
					var hs = this.getCards('h');
					for (var i = 0; i < cards.length; i++) {
						if (hs.contains(cards[i])) {
							cards.splice(i--, 1);
						}
					}
					for (var i = 0; i < cards.length; i++) {
						cards[i].fix();
						var sort = lib.config.sort_card(cards[i]);
						if (this == game.me) {
							cards[i].classList.add('drawinghidden');
						}
						if (get.is.singleHandcard() || sort > 0) {
							this.node.handcards1.insertBefore(cards[i], this.node.handcards1.firstChild);
						}
						else {
							this.node.handcards2.insertBefore(cards[i], this.node.handcards2.firstChild);
						}
					}
					if (this == game.me || _status.video) ui.updatehl();
					if (!_status.video) {
						game.addVideo('directgain', this, get.cardsInfo(cards));
						this.update();
					}
					if (broadcast !== false) game.broadcast(function (player, cards) {
						player.directgain(cards);
					}, this, cards);
					return this;
				},
				gainMultiple: function (targets, position) {
					var next = game.createEvent('gainMultiple', false);
					next.setContent('gainMultiple');
					next.player = this;
					next.targets = targets;
					next.position = position || 'h';
					return next;
				},
				gain: function () {
					var next = game.createEvent('gain');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'player') {
							next.source = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.cards = [arguments[i]];
						}
						else if (arguments[i] === 'log') {
							next.log = true;
						}
						else if (arguments[i] == 'fromStorage') {
							next.fromStorage = true;
						}
						else if (arguments[i] == 'bySelf') {
							next.bySelf = true;
						}
						else if (typeof arguments[i] == 'string') {
							next.animate = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.delay = arguments[i];
						}
					}
					if (next.animate == 'gain2' || next.animate == 'draw2') {
						if (!next.hasOwnProperty('log')) {
							next.log = true;
						}
					}
					next.setContent('gain');
					next.getl = function (player) {
						var that = this;
						var map = {
							player: player,
							hs: [],
							es: [],
							js: [],
							cards: [],
							cards2: [],
						};
						player.getHistory('lose', function (evt) {
							if (evt.parent == that) {
								map.hs.addArray(evt.hs);
								map.es.addArray(evt.es);
								map.js.addArray(evt.js);
								map.cards.addArray(evt.cards);
								map.cards2.addArray(evt.cards2);
							}
						});
						if (map.cards.length > 0) return map;
					};
					return next;
				},
				give: function (cards, target, visible) {
					var next = target.gain(cards, this);
					next.animate = visible ? 'give' : 'giveAuto';
				},
				lose: function () {
					var next = game.createEvent('lose');
					next.player = this;
					next.forceDie = true;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'player') {
							next.source = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.cards = [arguments[i]];
						}
						else if (get.objtype(arguments[i]) == 'div') {
							next.position = arguments[i];
						}
						else if (arguments[i] == 'toStorage') {
							next.toStorage = true;
						}
						else if (arguments[i] == 'visible') {
							next.visible = true;
						}
					}
					if (next.cards) {
						var hej = this.getCards('hej');
						for (var i = 0; i < next.cards.length; i++) {
							if (!hej.contains(next.cards[i])) {
								next.cards.splice(i--, 1);
							}
						}
					}
					if (!next.cards || !next.cards.length) {
						_status.event.next.remove(next);
					}
					else {
						if (next.position == undefined) next.position = ui.discardPile;
						next.cards = next.cards.slice(0);
					}
					next.setContent('lose');
					next.getl = function (player) {
						if (this.getlx !== false && this.player == player) return this;
					};
					return next;
				},
				damage: function () {
					var next = game.createEvent('damage');
					//next.forceDie=true;
					next.player = this;
					var nocard, nosource;
					var event = _status.event;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.num = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'player') {
							next.source = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
							next.card = arguments[i];
						}
						else if (arguments[i] == 'nocard') {
							nocard = true;
						}
						else if (arguments[i] == 'nosource') {
							nosource = true;
						}
						else if (arguments[i] == 'notrigger') {
							next._triggered = null;
							next.notrigger = true;
						}
						else if (get.itemtype(arguments[i]) == 'nature') {
							next.nature = arguments[i];
						}
					}
					if (next.card == undefined && !nocard) next.card = event.card;
					if (next.cards == undefined && !nocard) next.cards = event.cards;
					if (next.source == undefined && !nosource) next.source = event.player;
					if (next.source && next.source.isDead()) delete next.source;
					if (next.num == undefined) next.num = 1;
					if (next.nature == 'poison') delete next._triggered;
					next.setContent('damage');
					next.filterStop = function () {
						if (this.source && this.source.isDead()) delete this.source;
						if (this.num <= 0) {
							delete this.filterStop;
							this.trigger('damageZero');
							this._triggered = null;
							return true;
						}
					};
					return next;
				},
				recover: function () {
					var next = game.createEvent('recover');
					next.player = this;
					var nocard, nosource;
					var event = _status.event;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'cards') {
							next.cards = arguments[i].slice(0);
						}
						else if (get.itemtype(arguments[i]) == 'card') {
							next.card = arguments[i];
						}
						else if (get.itemtype(arguments[i]) == 'player') {
							next.source = arguments[i];
						}
						else if (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name) {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'number') {
							next.num = arguments[i];
						}
						else if (arguments[i] == 'nocard') {
							nocard = true;
						}
						else if (arguments[i] == 'nosource') {
							nosource = true;
						}
					}
					if (next.card == undefined && !nocard) next.card = event.card;
					if (next.cards == undefined && !nocard) next.cards = event.cards;
					if (next.source == undefined && !nosource) next.source = event.player;
					if (next.num == undefined) next.num = 1;
					if (next.num <= 0) _status.event.next.remove(next);
					next.setContent('recover');
					return next;
				},
				doubleDraw: function () {
					if (get.is.changban()) return;
					var next = game.createEvent('doubleDraw');
					next.player = this;
					next.setContent('doubleDraw');
					return next;
				},
				loseHp: function (num) {
					var next = game.createEvent('loseHp');
					next.num = num;
					next.player = this;
					if (next.num == undefined) next.num = 1;
					next.setContent('loseHp');
					return next;
				},
				loseMaxHp: function () {
					var next = game.createEvent('loseMaxHp');
					next.player = this;
					next.num = 1;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] === 'number') {
							next.num = arguments[i];
						}
						else if (typeof arguments[i] === 'boolean') {
							next.forced = arguments[i];
						}
					}
					next.setContent('loseMaxHp');
					return next;
				},
				gainMaxHp: function () {
					var next = game.createEvent('gainMaxHp');
					next.player = this;
					next.num = 1;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] === 'number') {
							next.num = arguments[i];
						}
						else if (typeof arguments[i] === 'boolean') {
							next.forced = arguments[i];
						}
					}
					next.setContent('gainMaxHp');
					return next;
				},
				changeHp: function (num, popup) {
					var next = game.createEvent('changeHp', false);
					next.num = num;
					if (popup != undefined) next.popup = popup;
					next.player = this;
					next.setContent('changeHp');
					return next;
				},

				changeHujia: function (num, type) {
					var next = game.createEvent('changeHujia');
					if (typeof num != 'number') {
						num = 1;
					}
					next.num = num;
					next.player = this;
					if (type) next.type = type;
					next.setContent('changeHujia');
					return next;
				},
				getBuff: function () {
					var list = [1, 2, 3, 4, 5, 6];
					var nodelay = false;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							list.remove(arguments[i]);
						}
						else if (arguments[i] === false) {
							nodelay = true;
						}
					}
					if (this.isHealthy()) {
						list.remove(2);
					}
					if (!this.countCards('j')) {
						list.remove(5);
					}
					if (!this.isLinked() && !this.isTurnedOver()) {
						list.remove(6);
					}
					if (this.hasSkill('qianxing')) {
						list.remove(4);
					}
					switch (list.randomGet()) {
						case 1: this.draw(nodelay ? 'nodelay' : 1); break;
						case 2: this.recover(); break;
						case 3: this.changeHujia(); break;
						case 4: this.tempHide();
						case 5: this.discard(this.getCards('j')).delay = (!nodelay); break;
						case 6: {
							if (this.isLinked()) this.link();
							if (this.isTurnedOver()) this.turnOver();
							break;
						}
					}
					return this;
				},
				getDebuff: function () {
					var list = [1, 2, 3, 4, 5, 6];
					var nodelay = false;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'number') {
							list.remove(arguments[i]);
						}
						else if (arguments[i] === false) {
							nodelay = true;
						}
					}
					if (this.countCards('he') == 0) {
						list.remove(1);
					}
					if (this.isLinked()) {
						list.remove(4);
					}
					if (this.hasSkill('fengyin')) {
						list.remove(5);
					}
					if (this.hp == 1) {
						list.remove(3);
						if (list.length > 1) list.remove(2);
					}
					if (!list.length) return this;
					var num = list.randomGet();
					switch (list.randomGet()) {
						case 1: this.randomDiscard(nodelay ? false : 'he'); break;
						case 2: this.loseHp(); break;
						case 3: this.damage(); break;
						case 4: if (!this.isLinked()) this.link(); break;
						case 5: this.addTempSkill('fengyin', { player: 'phaseAfter' }); break;
						case 6: {
							var list = [];
							for (var i = 0; i < lib.inpile.length; i++) {
								var info = lib.card[lib.inpile[i]];
								if (info.type == 'delay' && !info.cancel && !this.hasJudge(lib.inpile[i])) {
									list.push(lib.inpile[i]);
								}
							}
							if (list.length) {
								var card = game.createCard(list.randomGet());
								this.addJudge(card);
								this.$draw(card);
								if (!nodelay) game.delay();
							}
							else {
								this.getDebuff(6);
							}
							break;
						}
					}
					return this;
				},
				dying: function (reason) {
					if (this.nodying || this.hp > 0 || this.isDying()) return;
					var next = game.createEvent('dying');
					next.player = this;
					next.reason = reason;
					if (reason && reason.source) next.source = reason.source;
					next.setContent('dying');
					next.filterStop = function () {
						return this.player.hp > 0;
					};
					return next;
				},
				die: function (reason) {
					var next = game.createEvent('die');
					next.player = this;
					next.reason = reason;
					if (reason) next.source = reason.source;
					next.setContent('die');
					return next;
				},
				revive: function (hp, log) {
					if (log !== false) game.log(this, '复活');
					if (this.maxHp < 1) this.maxHp = 1;
					if (hp) this.hp = hp;
					else {
						this.hp = 1;
					}
					game.addVideo('revive', this);
					this.classList.remove('dead');
					this.removeAttribute('style');
					this.node.avatar.style.transform = '';
					this.node.avatar2.style.transform = '';
					this.node.hp.show();
					this.node.equips.show();
					this.node.count.show();
					this.update();
					var player;
					player = this.previousSeat;
					while (player.isDead()) player = player.previousSeat;
					player.next = this;
					this.previous = player;
					player = this.nextSeat;
					while (player.isDead()) player = player.nextSeat;
					player.previous = this;
					this.next = player;
					game.players.add(this);
					game.dead.remove(this);
					if (this == game.me) {
						if (ui.auto) ui.auto.show();
						if (ui.wuxie) ui.wuxie.show();
						if (ui.revive) {
							ui.revive.close();
							delete ui.revive;
						}
						if (ui.exit) {
							ui.exit.close();
							delete ui.exit;
						}
						if (ui.swap) {
							ui.swap.close();
							delete ui.swap;
						}
						if (ui.restart) {
							ui.restart.close();
							delete ui.restart;
						}
						if (ui.continue_game) {
							ui.continue_game.close();
							delete ui.continue_game;
						}
					}
				},
				isMad: function () {
					return this.hasSkill('mad');
				},
				goMad: function (end) {
					if (end) {
						this.addTempSkill('mad', end);
					}
					else {
						this.addSkill('mad');
					}
					game.log(this, '进入混乱状态');
				},
				unMad: function () {
					this.removeSkill('mad');
				},
				tempHide: function () {
					this.addTempSkill('qianxing', { player: 'phaseBegin' });
				},
				addExpose: function (num) {
					if (typeof this.ai.shown == 'number' && !this.identityShown && this.ai.shown < 1) {
						this.ai.shown += num;
						if (this.ai.shown > 0.95) {
							this.ai.shown = 0.95;
						}
					}
					return this;
				},
				equip: function (card, draw) {
					var next = game.createEvent('equip');
					next.card = card;
					next.player = this;
					if (draw) {
						next.draw = true;
					}
					next.setContent(lib.element.content.equip);
					if (get.is.object(next.card) && next.card.cards) next.card = next.card.cards[0];
					next.cards = [next.card];
					next.getl = function (player) {
						var that = this;
						var map = {
							player: player,
							hs: [],
							es: [],
							js: [],
							cards: [],
							cards2: [],
						};
						player.getHistory('lose', function (evt) {
							if (evt.parent == that) {
								map.hs.addArray(evt.hs);
								map.es.addArray(evt.es);
								map.js.addArray(evt.js);
								map.cards.addArray(evt.cards);
								map.cards2.addArray(evt.cards2);
							}
						});
						if (map.cards.length > 0) return map;
					};
					return next;
				},
				addJudge: function (card, cards) {
					var next = game.createEvent('addJudge');
					next.card = card;
					next.cards = cards;
					if (next.cards == undefined) next.cards = [card];
					if (get.itemtype(next.cards) == 'card') next.cards = [next.cards];
					next.player = this;
					next.setContent('addJudge');
					next.getl = function (player) {
						var that = this;
						var map = {
							player: player,
							hs: [],
							es: [],
							js: [],
							cards: [],
							cards2: [],
						};
						player.getHistory('lose', function (evt) {
							if (evt.parent == that) {
								map.hs.addArray(evt.hs);
								map.es.addArray(evt.es);
								map.js.addArray(evt.js);
								map.cards.addArray(evt.cards);
								map.cards2.addArray(evt.cards2);
							}
						});
						if (map.cards.length > 0) return map;
					};
					return next;
				},
				canAddJudge: function (card) {
					if (this.storage._disableJudge) return false;
					var name;
					if (typeof card == 'string') {
						name = card;
					}
					else {
						name = card.viewAs || card.name;
					}
					if (!name) return false;
					if (this.hasJudge(name)) return false;
					var mod = game.checkMod(card, this, this, 'unchanged', 'targetEnabled', this);
					if (mod != 'unchanged') return mod;
					return true;
				},
				addJudgeNext: function (card) {
					if (!card.expired) {
						var target = this.next;
						var name = card.viewAs || card.name;
						var bool = false;
						for (var iwhile = 0; iwhile < 20; iwhile++) {
							if (target.canAddJudge(card)) {
								bool = true; break;
							}
							target = target.next;
						}
						if (!bool) {
							game.log(card, '进入了弃牌堆');
							game.cardsDiscard(card);
						}
						else {
							if (card.name != name) {
								target.addJudge(name, card);
							}
							else {
								target.addJudge(card);
							}
						}
					}
					else {
						card.expired = false;
					}
				},
				judge: function () {
					var next = game.createEvent('judge');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (get.itemtype(arguments[i]) == 'card') {
							next.card = arguments[i];
						}
						else if (typeof arguments[i] == 'string') {
							next.skill = arguments[i];
						}
						else if (typeof arguments[i] == 'function') {
							next.judge = arguments[i];
						}
						else if (typeof arguments[i] == 'boolean') {
							next.clearArena = arguments[i];
						}
						else if (get.objtype(arguments[i]) == 'div') {
							next.position = arguments[i];
						}
					}
					if (next.card && next.judge == undefined) {
						next.judge = get.judge(next.card);
					}
					if (next.judge == undefined) next.judge = function () { return 0 };
					if (next.position == undefined) next.position = ui.discardPile;
					if (next.card) next.cardname = next.card.viewAs || next.card.name;

					var str = '';
					if (next.card) str = get.translation(next.card.viewAs || next.card.name);
					else if (next.skill) str = get.translation(next.skill);
					else str = get.translation(_status.event.name);
					next.judgestr = str;
					next.setContent('judge');
					return next;
				},
				turnOver: function (bool) {
					if (typeof bool == 'boolean') {
						if (bool) {
							if (this.isTurnedOver()) return;
						}
						else {
							if (!this.isTurnedOver()) return;
						}
					}
					var next = game.createEvent('turnOver');
					next.player = this;
					next.setContent('turnOver');
					return next;
				},
				out: function (skill) {
					if (typeof skill == 'number') {
						this.outCount += skill;
					}
					else if (typeof skill == 'string') {
						if (!this.outSkills) {
							this.outSkills = [];
						}
						this.outSkills.add(skill);
					}
					else {
						this.outCount++;
					}
					if (!this.classList.contains('out')) {
						this.classList.add('out');
						game.log(this, '离开游戏');
					}
					if (!game.countPlayer()) {
						game.over();
					}
				},
				in: function (skill) {
					if (this.isOut()) {
						if (typeof skill == 'string') {
							if (this.outSkills) {
								this.outSkills.remove(skill);
								if (!this.outSkills.length) {
									delete this.outSkills;
								}
							}
						}
						else if (typeof skill == 'number') {
							this.outCount -= skill;
						}
						else {
							if (skill === true) {
								delete this.outSkills;
							}
							this.outCount = 0;
						}
						if (this.outCount <= 0 && !this.outSkills) {
							this.outCount = 0;
							this.classList.remove('out');
							game.log(this, '进入游戏');
						}
					}
				},
				link: function (bool) {
					if (typeof bool == 'boolean') {
						if (bool) {
							if (this.isLinked()) return;
						}
						else {
							if (!this.isLinked()) return;
						}
					}
					var next = game.createEvent('link');
					next.player = this;
					next.setContent('link');
					return next;
				},
				skip: function (name) {
					this.skipList.add(name);
				},
				wait: function (callback) {
					if (lib.node) {
						if (typeof callback == 'function') {
							callback._noname_waiting = true;
							lib.node.torespond[this.playerid] = callback;
						}
						else {
							lib.node.torespond[this.playerid] = '_noname_waiting';
						}
						clearTimeout(lib.node.torespondtimeout[this.playerid]);
						if (this.ws && !this.ws.closed) {
							var player = this;
							var time = parseInt(lib.configOL.choose_timeout) * 1000;
							if (_status.event.getParent().skillHidden) {
								for (var i = 0; i < game.players.length; i++) {
									game.players[i].showTimer(time);
								}
								player._hide_all_timer = true;
							}
							else if (!_status.event._global_waiting) {
								player.showTimer(time);
							}
							lib.node.torespondtimeout[this.playerid] = setTimeout(function () {
								player.unwait('ai');
								player.ws.ws.close();
							}, time + 5000);
						}
					}
				},
				unwait: function (result) {
					if (this._hide_all_timer) {
						delete this._hide_all_timer;
						for (var i = 0; i < game.players.length; i++) {
							game.players[i].hideTimer();
						}
					}
					else if (!_status.event._global_waiting) {
						this.hideTimer();
					}
					clearTimeout(lib.node.torespondtimeout[this.playerid]);
					delete lib.node.torespondtimeout[this.playerid];
					if (!lib.node.torespond.hasOwnProperty(this.playerid)) {
						return;
					}
					var noresume = false;
					var proceed = null;
					if (typeof lib.node.torespond[this.playerid] == 'function' && lib.node.torespond[this.playerid]._noname_waiting) {
						proceed = lib.node.torespond[this.playerid](result, this);
						if (proceed === false) {
							noresume = true;
						}
					}
					lib.node.torespond[this.playerid] = result;
					for (var i in lib.node.torespond) {
						if (lib.node.torespond[i] == '_noname_waiting') {
							return;
						}
						else if (lib.node.torespond[i] && lib.node.torespond[i]._noname_waiting) {
							return;
						}
					}
					_status.event.result = result;
					_status.event.resultOL = lib.node.torespond;
					lib.node.torespond = {};
					if (typeof proceed == 'function') proceed();
					else if (_status.paused && !noresume) game.resume();
				},
				logSkill: function (name, targets, nature, logv) {
					if (get.itemtype(targets) == 'player') targets = [targets];
					var nopop = false;
					var popname = name;
					if (Array.isArray(name)) {
						popname = name[1];
						name = name[0];
					}
					var checkShow = this.checkShow(name);
					if (lib.translate[name]) {
						this.trySkillAnimate(name, popname, checkShow);
						if (typeof targets == 'object' && targets.length) {
							var str = (targets[0] == this ? '#b自己' : targets);
							game.log(this, '对', str, '发动了', '【' + get.skillTranslation(name, this) + '】');
						}
						else {
							game.log(this, '发动了', '【' + get.skillTranslation(name, this) + '】');
						}
					}
					if (nature != false) {
						if (nature === undefined) {
							nature = 'green';
						}
						this.line(targets, nature);
					}
					var info = lib.skill[name];
					if (info && info.ai && info.ai.expose != undefined &&
						this.logAi && (!targets || targets.length != 1 || targets[0] != this)) {
						this.logAi(lib.skill[name].ai.expose);
					}
					if (info && info.round) {
						var roundname = name + '_roundcount';
						this.storage[roundname] = game.roundNumber;
						this.syncStorage(roundname);
						this.markSkill(roundname);
					}
					game.trySkillAudio(name, this, true);
					if (game.chess) {
						this.chessFocus();
					}
					if (logv === true) {
						game.logv(this, name, targets, null, true);
					}
					else if (info && info.logv !== false) {
						game.logv(this, name, targets);
					}
					if (this._hookTrigger) {
						for (var i = 0; i < this._hookTrigger.length; i++) {
							var info = lib.skill[this._hookTrigger[i]].hookTrigger;
							if (info && info.log) {
								info.log(this, name, targets);
							}
						}
					}
				},
				unprompt: function () {
					if (this.node.prompt) {
						this.node.prompt.delete();
						delete this.node.prompt;
					}
				},
				prompt: function (str, nature) {
					var node;
					if (this.node.prompt) {
						node = this.node.prompt;
						node.innerHTML = '';
						node.className = 'damage normal-font damageadded';
					}
					else {
						node = ui.create.div('.damage.normal-font', this);
						this.node.prompt = node;
						ui.refresh(node);
						node.classList.add('damageadded');
					}
					node.innerHTML = str;
					node.dataset.nature = nature || 'soil';
				},
				prompt_old: function (name2, className) {
					var node;
					if (this.node.prompt) {
						node = this.node.prompt;
						node.innerHTML = '';
						node.className = 'popup';
					}
					else {
						node = ui.create.div('.popup', this.parentNode);
						this.node.prompt = node;
					}
					node.dataset.position = this.dataset.position;
					if (this.dataset.position == 0 || parseInt(this.dataset.position) == parseInt(ui.arena.dataset.number) / 2 ||
						typeof name2 == 'number' || this.classList.contains('minskin')) {
						node.innerHTML = name2;
					}
					else {
						for (var i = 0; i < name2.length; i++) {
							node.innerHTML += name2[i] + '<br/>';
						}
					}
					if (className) {
						node.classList.add(className);
					}
				},
				popup: function (name, className, nobroadcast) {
					var name2 = get.translation(name);
					if (!name2) return;
					this.$damagepop(name2, className || 'water', true, nobroadcast);
				},
				popup_old: function (name, className) {
					var name2 = get.translation(name);
					var node = ui.create.div('.popup', this.parentNode);
					if (!name2) {
						node.remove();
						return node;
					}
					game.addVideo('popup', this, [name, className]);
					node.dataset.position = this.dataset.position;
					if (this.dataset.position == 0 || parseInt(this.dataset.position) == parseInt(ui.arena.dataset.number) / 2 ||
						typeof name2 == 'number' || this.classList.contains('minskin')) {
						node.innerHTML = name2;
					}
					else {
						for (var i = 0; i < name2.length; i++) {
							node.innerHTML += name2[i] + '<br/>';
						}
					}
					if (className) {
						node.classList.add(className);
					}
					this.popups.push(node);
					if (this.popups.length > 1) {
						node.hide();
					}
					else {
						var that = this;
						setTimeout(function () { that._popup(); }, 1000);
					}
					return node;
				},
				_popup: function () {
					if (this.popups.length) {
						this.popups.shift().delete();
						if (this.popups.length) {
							this.popups[0].show();
							var that = this;
							setTimeout(function () { that._popup(); }, 1000);
						}
					}
				},
				showTimer: function (time) {
					if (!time && lib.configOL) {
						time = parseInt(lib.configOL.choose_timeout) * 1000;
					}
					if (_status.connectMode && !game.online) {
						game.broadcast(function (player, time) {
							player.showTimer(time);
						}, this, time);
					}
					if (this == game.me) {
						return;
					}
					if (this.node.timer) {
						this.node.timer.remove();
					}
					var timer = ui.create.div('.timerbar', this);
					this.node.timer = timer;
					ui.create.div(this.node.timer);
					var bar = ui.create.div(this.node.timer);
					ui.refresh(bar);
					bar.style.transitionDuration = (time / 1000) + 's';
					bar.style.width = 0;
				},
				hideTimer: function () {
					if (_status.connectMode && !game.online && this.playerid) {
						game.broadcast(function (player) {
							player.hideTimer();
						}, this);
					}
					if (this.node.timer) {
						this.node.timer.delete();
						delete this.node.timer;
					}
				},
				markAuto: function (name, info) {
					if (Array.isArray(info)) {
						if (!Array.isArray(this.storage[name])) this.storage[name] = [];
						this.storage[name].addArray(info);
						this.markSkill(name);
					}
					else {
						var storage = this.storage[name];
						if (Array.isArray(storage)) {
							this[storage.length > 0 ? 'markSkill' : 'unmarkSkill'](name);
						}
						else if (typeof storage == 'number') {
							this[storage.length > 0 ? 'markSkill' : 'unmarkSkill'](name);
						}
					}
				},
				unmarkAuto: function (name, info) {
					var storage = this.storage[name]
					if (Array.isArray(info) && Array.isArray(storage)) {
						storage.removeArray(info.slice(0));
						this.markAuto(name);
					}
				},
				getStorage: function (name) {
					return this.storage[name] || [];
				},
				markSkill: function (name, info, card) {
					if (info === true) {
						this.syncStorage(name);
						info = null;
					}
					if (get.itemtype(card) == 'card') {
						game.addVideo('markSkill', this, [name, get.cardInfo(card)]);
					}
					else {
						game.addVideo('markSkill', this, [name]);
					}
					game.broadcastAll(function (storage, player, name, info, card) {
						if (storage != undefined) {
							player.storage[name] = storage;
						}
						if (!info) {
							if (player.marks[name]) {
								player.updateMarks();
								return;
							}
							if (lib.skill[name]) {
								info = lib.skill[name].intro;
							}
							if (!info) {
								return;
							}
						}
						if (player.marks[name]) {
							player.marks[name].info = info;
						}
						else {
							if (card) {
								player.marks[name] = player.mark(card, info, name);
							}
							else {
								player.marks[name] = player.mark(name, info);
							}
						}
						player.updateMarks();
					}, this.storage[name], this, name, info, card);
					return this;
				},
				unmarkSkill: function (name) {
					game.addVideo('unmarkSkill', this, name);
					game.broadcast(function (player, name) {
						if (player.marks[name]) {
							player.marks[name].delete();
							player.marks[name].style.transform += ' scale(0.2)';
							delete player.marks[name];
							ui.updatem(player);
						}
					}, this, name);
					if (this.marks[name]) {
						this.marks[name].delete();
						this.marks[name].style.transform += ' scale(0.2)';
						delete this.marks[name];
						ui.updatem(this);
						var info = lib.skill[name];
						if (info && info.intro && info.intro.onunmark) {
							if (info.intro.onunmark == 'throw') {
								if (get.itemtype(this.storage[name]) == 'cards') {
									this.$throw(this.storage[name], 1000);
									game.cardsDiscard(this.storage[name]);
									game.log(this.storage[name], '进入了弃牌堆');
									this.storage[name].length = 0;
								}
							}
							else if (typeof info.intro.onunmark == 'function') {
								info.intro.onunmark(this.storage[name], this);
							}
						}
					}
					return this;
				},
				markSkillCharacter: function (id, target, name, content) {
					if (typeof target == 'object') {
						target = target.name;
					}
					game.broadcastAll(function (player, target, name, content, id) {
						if (player.marks[id]) {
							player.marks[id].name = name + '_charactermark';
							player.marks[id]._name = target;
							player.marks[id].info = {
								name: name,
								content: content,
								id: id
							};
							player.marks[id].setBackground(target, 'character');
							game.addVideo('changeMarkCharacter', player, {
								id: id,
								name: name,
								content: content,
								target: target
							});
						}
						else {
							player.marks[id] = player.markCharacter(target, {
								name: name,
								content: content,
								id: id
							});
							player.marks[id]._name = target;
							game.addVideo('markCharacter', player, {
								name: name,
								content: content,
								id: id,
								target: target
							});
						}
					}, this, target, name, content, id);
					return this;
				},
				markCharacter: function (name, info, learn, learn2) {
					if (typeof name == 'object') {
						name = name.name;
					}
					var node;
					if (name.indexOf('unknown') == 0) {
						node = ui.create.div('.card.mark.drawinghidden');
						ui.create.div('.background.skillmark', node).innerHTML = get.translation(name)[0];
					}
					else {
						if (!lib.character[name]) return;
						node = ui.create.div('.card.mark.drawinghidden').setBackground(name, 'character');
					}
					this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
					node.name = name + '_charactermark';
					if (!info) {
						info = {};
					}
					if (!info.name) {
						info.name = get.translation(name);
					}
					if (!info.content) {
						info.content = get.skillintro(name, learn, learn2)
					}
					node.info = info;
					node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
					if (!lib.config.touchscreen) {
						if (lib.config.hover_all) {
							lib.setHover(node, ui.click.hoverplayer);
						}
						if (lib.config.right_info) {
							node.oncontextmenu = ui.click.rightplayer;
						}
					}
					ui.updatem(this);
					return node;
				},
				mark: function (name, info, skill) {
					if (get.itemtype(name) == 'cards') {
						var marks = [];
						for (var i = 0; i < name.length; i++) {
							marks.push(this.mark(name[i], info));
						}
						return marks;
					}
					else {
						var node;
						if (get.itemtype(name) == 'card') {
							node = name.copy('mark');
							node.classList.add('drawinghidden');
							this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
							node.suit = name.suit;
							node.number = name.number;
							// if(name.name&&lib.card[name.name]&&lib.card[name.name].markimage){
							// 	node.node.image.style.left=lib.card[name.name].markimage;
							// }

							if (name.classList.contains('fullborder')) {
								node.classList.add('fakejudge');
								node.classList.add('fakemark');
								(node.querySelector('.background') || ui.create.div('.background', node)).innerHTML = lib.translate[name.name + '_bg'] || get.translation(name.name)[0];
							}

							name = name.name;
						}
						else {
							node = ui.create.div('.card.mark.drawinghidden');
							this.node.marks.insertBefore(node, this.node.marks.childNodes[1]);
							var str = lib.translate[name + '_bg'];
							if (!str || str[0] == '+' || str[0] == '-') {
								str = get.translation(name)[0];
							}
							ui.create.div('.background.skillmark', node).innerHTML = str;
							// node.style.fontFamily=lib.config.card_font;
						}
						node.name = name;
						node.skill = skill || name;
						if (typeof info == 'object') {
							node.info = info;
						}
						else if (typeof info == 'string') {
							node.markidentifer = info;
						}
						node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
						if (!lib.config.touchscreen) {
							if (lib.config.hover_all) {
								lib.setHover(node, ui.click.hoverplayer);
							}
							if (lib.config.right_info) {
								node.oncontextmenu = ui.click.rightplayer;
							}
						}
						this.updateMarks();
						ui.updatem(this);
						return node;
					}
				},
				unmark: function (name, info) {
					game.addVideo('unmarkname', this, name);
					if (get.itemtype(name) == 'card') {
						this.unmark(name.name, info);
					}
					else if (get.itemtype(name) == 'cards') {
						for (var i = 0; i < name.length; i++) {
							this.unmark(name[i].name, info);
						}
					}
					else {
						for (var i = 0; i < this.node.marks.childNodes.length; i++) {
							if (this.node.marks.childNodes[i].name == name &&
								(!info || this.node.marks.childNodes[i].markidentifer == info)) {
								this.node.marks.childNodes[i].delete();
								this.node.marks.childNodes[i].style.transform += ' scale(0.2)';
								ui.updatem(this);
								return;
							}
						}
					}
				},
				addLink: function () {
					if (get.is.linked2(this)) {
						this.classList.add('linked2');
					}
					else {
						this.classList.add('linked');
					}
				},
				removeLink: function () {
					if (get.is.linked2(this)) {
						this.classList.remove('linked2');
					}
					else {
						this.classList.remove('linked');
					}
				},
				canUse: function (card, target, distance, includecard) {
					if (typeof card == 'string') card = { name: card, isCard: true };
					var info = get.info(card);
					if (info.multicheck && !info.multicheck(card, this)) return false;
					if (includecard != false && !lib.filter.cardEnabled(card, this)) return false;
					if (includecard && !lib.filter.cardUsable(card, this)) return false;
					if (distance == false) return lib.filter.targetEnabled(card, this, target);
					return lib.filter.filterTarget(card, this, target);
				},
				hasUseTarget: function (card, distance, includecard) {
					var player = this;
					return game.hasPlayer(function (current) {
						return player.canUse(card, current, distance, includecard);
					});
				},
				hasValueTarget: function () {
					return this.getUseValue.apply(this, arguments) > 0;
				},
				getUseValue: function (card, distance, includecard) {
					if (typeof (card) == 'string') {
						card = { name: card, isCard: true };
					}
					var player = this;
					var targets = game.filterPlayer();
					var value = [];
					var min = 0;
					var info = get.info(card);
					if (!info || info.notarget) return 0;
					var range;
					var select = get.copy(info.selectTarget);
					if (select == undefined) {
						if (info.filterTarget == undefined) return true;
						range = [1, 1];
					}
					else if (typeof select == 'number') range = [select, select];
					else if (get.itemtype(select) == 'select') range = select;
					else if (typeof select == 'function') range = select(card, player);
					if (info.singleCard) range = [1, 1];
					game.checkMod(card, player, range, 'selectTarget', player);
					if (!range) return 0;

					for (var i = 0; i < targets.length; i++) {
						if (player.canUse(card, targets[i], distance, includecard)) {
							var eff = get.effect(targets[i], card, player, player);
							value.push(eff);
						}
					}
					value.sort(function (a, b) {
						return b - a;
					});
					for (var i = 0; i < value.length; i++) {
						if (i == range[1] || range[1] != -1 && value[i] <= 0) break;
						min += value[i];
					}
					return min;
				},
				addSubPlayer: function (cfg) {
					var skill = 'subplayer_' + cfg.name + '_' + get.id();
					game.log(this, '获得了随从', '#g' + get.translation(cfg.name))
					cfg.hs = cfg.hs || [];
					cfg.es = cfg.es || [];
					cfg.skills = cfg.skills || [];
					cfg.hp = cfg.hp || 1;
					cfg.maxHp = cfg.maxHp || 1;
					cfg.sex = cfg.sex || 'male';
					cfg.group = cfg.group || 'qun';
					cfg.skill = cfg.skill || _status.event.name;
					if (!cfg.source) {
						if (this.hasSkill(_status.event.name) && this.name2 && lib.character[this.name2] &&
							lib.character[this.name2][3].contains(_status.event.name)) {
							cfg.source = this.name2;
						}
						else {
							cfg.source = this.name;
						}
					}
					game.broadcastAll(function (player, skill, cfg) {
						lib.skill[skill] = {
							intro: {
								content: cfg.intro || ''
							},
							mark: 'character',
							subplayer: cfg.skill,
							ai: {
								subplayer: true
							}
						}
						lib.character[skill] = [cfg.sex, cfg.group, cfg.maxHp, cfg.skills, ['character:' + cfg.name]];
						lib.translate[skill] = cfg.caption || get.rawName(cfg.name);
						player.storage[skill] = cfg;
					}, this, skill, cfg);
					game.addVideo('addSubPlayer', this, [skill, lib.skill[skill], lib.character[skill], lib.translate[skill], { name: cfg.name }]);
					this.addSkill(skill);
					return skill;
				},
				removeSubPlayer: function (name) {
					if (this.hasSkill('subplayer') && this.name == name) {
						this.exitSubPlayer(true);
					}
					else {
						if (player.storage[name].onremove) {
							player.storage[name].onremove(player);
						}
						this.removeSkill(name);
						delete this.storage[name];
						game.log(player, '牺牲了随从', '#g' + name);
						_status.event.trigger('removeSubPlayer');
					}
				},
				callSubPlayer: function () {
					if (this.hasSkill('subplayer')) return;
					var next = game.createEvent('callSubPlayer');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'string') {
							next.directresult = arguments[i];
						}
					}
					next.setContent('callSubPlayer');
					return next;
				},
				toggleSubPlayer: function () {
					if (!this.hasSkill('subplayer')) return;
					var next = game.createEvent('toggleSubPlayer');
					next.player = this;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'string') {
							next.directresult = arguments[i];
						}
					}
					next.setContent('toggleSubPlayer');
					return next;
				},
				exitSubPlayer: function (remove) {
					if (!this.hasSkill('subplayer')) return;
					var next = game.createEvent('exitSubPlayer');
					next.player = this;
					next.remove = remove;
					next.setContent('exitSubPlayer');
					return next;
				},
				getSubPlayers: function (tag) {
					var skills = this.getSkills();
					var list = [];
					for (var i = 0; i < skills.length; i++) {
						var name = skills[i];
						var info = lib.skill[name];
						if (tag && info.subplayer != tag) continue;
						if (info.ai && info.ai.subplayer && this.storage[name] && this.storage[name].name) {
							list.push(name);
						}
					}
					return list;
				},
				addSkillTrigger: function (skill, hidden, triggeronly) {
					var info = lib.skill[skill];
					if (!info) return;
					if (typeof info.group == 'string') {
						this.addSkillTrigger(info.group, hidden);
					}
					else if (Array.isArray(info.group)) {
						for (var i = 0; i < info.group.length; i++) {
							this.addSkillTrigger(info.group[i], hidden);
						}
					}
					if (!triggeronly) {
						if (info.global && (!hidden || info.globalSilent)) {
							if (typeof info.global == 'string') {
								game.addGlobalSkill(info.global, this);
							}
							else {
								for (var j = 0; j < info.global.length; j++) {
									game.addGlobalSkill(info.global[j], this);
								}
							}
						}
						if (this.initedSkills.contains(skill)) return this;
						this.initedSkills.push(skill);
						if (info.init && !_status.video) {
							info.init(this, skill);
						}
					}
					if (info.trigger && this.playerid) {
						var playerid = this.playerid;
						var setTrigger = function (i, evt) {
							if (i == 'global') {
								if (!lib.hook.globaltrigger[evt]) {
									lib.hook.globaltrigger[evt] = {};
								}
								if (!lib.hook.globaltrigger[evt][playerid]) {
									lib.hook.globaltrigger[evt][playerid] = [];
								}
								lib.hook.globaltrigger[evt][playerid].add(skill);
							}
							else {
								var name = playerid + '_' + i + '_' + evt;
								if (!lib.hook[name]) {
									lib.hook[name] = [];
								}
								lib.hook[name].add(skill);
							}
							lib.hookmap[evt] = true;
						}
						for (var i in info.trigger) {
							if (typeof info.trigger[i] == 'string') {
								setTrigger(i, info.trigger[i]);
							}
							else if (Array.isArray(info.trigger[i])) {
								for (var j = 0; j < info.trigger[i].length; j++) {
									setTrigger(i, info.trigger[i][j]);
								}
							}
						}
					}
					if (info.hookTrigger) {
						if (!this._hookTrigger) {
							this._hookTrigger = [];
						}
						this._hookTrigger.add(skill);
					}
					if (_status.event && _status.event.addTrigger) _status.event.addTrigger(skill, this);
					return this;
				},
				addSkillLog: function (skill) {
					this.addSkill(skill);
					this.popup(skill);
					game.log(this, '获得了技能', '#g【' + get.translation(skill) + '】');
				},
				addSkill: function (skill, checkConflict, nobroadcast) {
					if (Array.isArray(skill)) {
						for (var i = 0; i < skill.length; i++) {
							this.addSkill(skill[i]);
						}
					}
					else {
						if (this.skills.contains(skill)) return;
						var info = lib.skill[skill];
						if (!info) return;
						if (!nobroadcast) {
							game.broadcast(function (player, skill) {
								player.skills.add(skill);
							}, this, skill);
						}
						this.skills.add(skill);
						this.addSkillTrigger(skill);
						if (this.awakenedSkills.contains(skill)) {
							this.awakenSkill(skill);
							return;
						}
						if (info.init2 && !_status.video) {
							info.init2(this, skill);
						}
						if (info.mark) {
							if (info.mark == 'card' &&
								get.itemtype(this.storage[skill]) == 'card') {
								this.markSkill(skill, null, this.storage[skill]);
							}
							else if (info.mark == 'card' &&
								get.itemtype(this.storage[skill]) == 'cards') {
								this.markSkill(skill, null, this.storage[skill][0]);
							}
							else if (info.mark == 'image') {
								this.markSkill(skill, null, ui.create.card(null, 'noclick').init([null, null, skill]));
							}
							else if (info.mark == 'character') {
								var intro = info.intro.content;
								if (typeof intro == 'function') {
									intro = intro(this.storage[skill], this);
								}
								else if (typeof intro == 'string') {
									intro = intro.replace(/#/g, this.storage[skill]);
									intro = intro.replace(/&/g, get.cnNumber(this.storage[skill]));
									intro = intro.replace(/\$/g, get.translation(this.storage[skill]));
								}
								var caption;
								if (typeof info.intro.name == 'function') {
									caption = info.intro.name(this.storage[skill], this);
								}
								else if (typeof info.intro.name == 'string') {
									caption = info.name;
								}
								else {
									caption = get.translation(skill);
								}
								this.markSkillCharacter(skill, this.storage[skill], caption, intro);
							}
							else {
								this.markSkill(skill);
							}
						}
					}
					if (checkConflict) this.checkConflict();
					return skill;
				},
				addAdditionalSkill: function (skill, skills, keep) {
					if (this.additionalSkills[skill]) {
						if (keep) {
							if (typeof this.additionalSkills[skill] == 'string') {
								this.additionalSkills[skill] = [this.additionalSkills[skill]];
							}
						}
						else {
							this.removeAdditionalSkill(skill);
							this.additionalSkills[skill] = [];
						}
					}
					else {
						this.additionalSkills[skill] = [];
					}
					if (typeof skills == 'string') {
						skills = [skills];
					}
					for (var i = 0; i < skills.length; i++) {
						this.addSkill(skills[i], null, true);
						this.skills.remove(skills[i]);
						this.additionalSkills[skill].push(skills[i]);
					}
					this.checkConflict();
					return this;
				},
				removeAdditionalSkill: function (skill, target) {
					if (this.additionalSkills[skill]) {
						var additionalSkills = this.additionalSkills[skill];
						if (Array.isArray(additionalSkills) && typeof target == 'string') {
							if (additionalSkills.contains(target)) {
								additionalSkills.remove(target);
								this.removeSkill(target);
							}
						}
						else {
							delete this.additionalSkills[skill];
							if (typeof additionalSkills == 'string') {
								this.removeSkill(additionalSkills);
							}
							else if (Array.isArray(additionalSkills)) {
								for (var i = 0; i < additionalSkills.length; i++) {
									this.removeSkill(additionalSkills[i]);
								}
							}
						}
					}
					return this;
				},
				awakenSkill: function (skill, nounmark) {
					if (!nounmark) this.unmarkSkill(skill);
					this.disableSkill(skill + '_awake', skill);
					this.awakenedSkills.add(skill);
					if (this.storage[skill] === false) this.storage[skill] = true;
					return this;
				},
				restoreSkill: function (skill, nomark) {
					if (this.storage[skill] === true) this.storage[skill] = false;
					this.awakenedSkills.remove(skill);
					this.enableSkill(skill + '_awake', skill);
					if (!nomark) this.markSkill(skill);
					return this;
				},
				disableSkill: function (skill, skills) {
					if (typeof skills == 'string') {
						if (!this.disabledSkills[skills]) {
							this.disabledSkills[skills] = [];
							var info = get.info(skills);
							if (info.ondisable && info.onremove) {
								info.onremove(this);
							}
						}
						this.disabledSkills[skills].add(skill);
						var group = lib.skill[skills].group;
						if (typeof group == 'string' || Array.isArray(group)) {
							this.disableSkill(skill, group);
						}
					}
					else if (Array.isArray(skills)) {
						for (var i = 0; i < skills.length; i++) {
							this.disableSkill(skill, skills[i]);
						}
					}
					return this;
				},
				enableSkill: function (skill) {
					for (var i in this.disabledSkills) {
						this.disabledSkills[i].remove(skill);
						if (this.disabledSkills[i].length == 0) {
							delete this.disabledSkills[i];
						}
					}
					return this;
				},
				checkMarks: function () {
					var skills = this.getSkills();
					game.expandSkills(skills);
					for (var i in this.marks) {
						if (!skills.contains(i) && !this.marks[i].info.fixed) {
							this.unmarkSkill(i);
						}
					}
					return this;
				},
				addEquipTrigger: function (card) {
					if (card) {
						var info = get.info(card);
						if (info.skills) {
							for (var j = 0; j < info.skills.length; j++) {
								this.addSkillTrigger(info.skills[j]);
							}
						}
					}
					else {
						var es = this.getCards('e');
						for (var i = 0; i < es.length; i++) {
							this.addEquipTrigger(es[i]);
						}
					}
					return this;
				},
				removeEquipTrigger: function (card) {
					if (card) {
						var info = get.info(card);
						var skills = this.getSkills(null, false);
						if (info.skills) {
							for (var j = 0; j < info.skills.length; j++) {
								if (skills.contains(info.skills[j])) continue;
								this.removeSkillTrigger(info.skills[j]);
							}
						}
						if (info.clearLose && typeof info.onLose == 'function') {
							var next = game.createEvent('lose_' + card.name);
							next.setContent(info.onLose);
							next.player = this;
							next.card = card;
						}
					}
					else {
						var es = this.getCards('e');
						for (var i = 0; i < es.length; i++) {
							this.removeEquipTrigger(es[i]);
						}
					}
					return this;
				},
				removeSkillTrigger: function (skill, triggeronly) {
					var info = lib.skill[skill];
					if (!info) return;
					if (typeof info.group == 'string') {
						this.removeSkillTrigger(info.group);
					}
					else if (Array.isArray(info.group)) {
						for (var i = 0; i < info.group.length; i++) {
							this.removeSkillTrigger(info.group[i]);
						}
					}
					if (!triggeronly) this.initedSkills.remove(skill);
					if (info.trigger) {
						var playerid = this.playerid;
						var removeTrigger = function (i, evt) {
							if (i == 'global') {
								for (var j in lib.hook.globaltrigger) {
									if (lib.hook.globaltrigger[j][playerid]) {
										lib.hook.globaltrigger[j][playerid].remove(skill);
										if (lib.hook.globaltrigger[j][playerid].length == 0) {
											delete lib.hook.globaltrigger[j][playerid];
										}
										if (get.is.empty(lib.hook.globaltrigger[j])) {
											delete lib.hook.globaltrigger[j];
										}
									}
								}
							}
							else {
								var name = playerid + '_' + i + '_' + evt;
								if (lib.hook[name]) {
									lib.hook[name].remove(skill);
									if (lib.hook[name].length == 0) {
										delete lib.hook[name];
									}
								}
							}
						}
						for (var i in info.trigger) {
							if (typeof info.trigger[i] == 'string') {
								removeTrigger(i, info.trigger[i]);
							}
							else if (Array.isArray(info.trigger[i])) {
								for (var j = 0; j < info.trigger[i].length; j++) {
									removeTrigger(i, info.trigger[i][j]);
								}
							}
						}
					}
					if (info.hookTrigger) {
						if (this._hookTrigger) {
							this._hookTrigger.remove(skill);
							if (!this._hookTrigger.length) {
								delete this._hookTrigger;
							}
						}
					}
					return this;
				},
				removeSkill: function (skill) {
					if (!skill) return;
					if (Array.isArray(skill)) {
						for (var i = 0; i < skill.length; i++) {
							this.removeSkill(skill[i]);
						}
					}
					else {
						var info = lib.skill[skill];
						if (info && info.fixed && arguments[1] !== true) return skill;
						this.unmarkSkill(skill);
						game.broadcastAll(function (player, skill) {
							player.skills.remove(skill);
							player.hiddenSkills.remove(skill);
						}, this, skill);
						this.checkConflict(skill);
						delete this.tempSkills[skill];
						if (info) {
							if (info.onremove) {
								if (typeof info.onremove == 'function') {
									info.onremove(this, skill);
								}
								else if (typeof info.onremove == 'string') {
									if (info.onremove == 'storage') {
										delete this.storage[skill];
									}
									else {
										var cards = this.storage[skill];
										if (get.itemtype(cards) == 'card') {
											cards = [cards];
										}
										if (get.itemtype(cards) == 'cards') {
											if (this.onremove == 'discard') {
												this.$throw(cards);
											}
											if (this.onremove == 'discard' || this.onremove == 'lose') {
												game.cardsDiscard(cards);
												delete this.storage[skill];
											}
										}
									}
								}
								else if (Array.isArray(info.onremove)) {
									for (var i = 0; i < info.onremove.length; i++) {
										delete this.storage[info.onremove[i]];
									}
								}
								else if (info.onremove === true) {
									delete this.storage[skill];
								}
							}
							this.removeSkillTrigger(skill);
							if (!info.keepSkill) {
								this.removeAdditionalSkill(skill);
							}
						}
						this.enableSkill(skill + '_awake');
					}
					return skill;
				},
				addTempSkill: function (skill, expire, checkConflict) {
					if (this.hasSkill(skill) && this.tempSkills[skill] == undefined) return;
					var noremove = this.skills.contains(skill);
					this.addSkill(skill, checkConflict, true);
					if (!noremove) this.skills.remove(skill);

					if (!expire) {
						expire = 'phaseAfter';
					}
					this.tempSkills[skill] = expire;

					if (typeof expire == 'string') {
						lib.hookmap[expire] = true;
					}
					else if (Array.isArray(expire)) {
						for (var i = 0; i < expire.length; i++) {
							lib.hookmap[expire[i]] = true;
						}
					}
					else if (get.objtype(expire) == 'object') {
						var roles = ['player', 'source', 'target'];
						for (var i = 0; i < roles.length; i++) {
							if (typeof expire[roles[i]] == 'string') {
								lib.hookmap[expire[roles[i]]] = true;
							}
							else if (Array.isArray(expire[roles[i]])) {
								for (var j = 0; j < expire[roles[i]].length; j++) {
									lib.hookmap[expire[roles[i]][j]] = true;
								}
							}
						}
					}

					for (var i in expire) {
						if (typeof expire[i] == 'string') {
							lib.hookmap[expire[i]] = true;
						}
						else if (Array.isArray(expire[i])) {
							for (var j = 0; j < expire.length; j++) {
								lib.hookmap[expire[i][j]] = true;
							}
						}
					}
					return skill;
				},
				attitudeTo: function (target) {
					if (typeof get.attitude == 'function') return get.attitude(this, target);
					return 0;
				},
				clearSkills: function (all) {
					var list = [];
					var exclude = [];
					for (var i = 0; i < arguments.length; i++) {
						exclude.push(arguments[i]);
					}
					for (i = 0; i < this.skills.length; i++) {
						if (lib.skill[this.skills[i]].superCharlotte) continue;
						if (!all && (lib.skill[this.skills[i]].temp || lib.skill[this.skills[i]].charlotte)) continue;
						if (!exclude.contains(this.skills[i])) {
							list.push(this.skills[i]);
						}
					}
					if (all) {
						for (var i in this.additionalSkills) {
							this.removeAdditionalSkill(i);
						}
					}
					this.removeSkill(list);
					this.checkConflict();
					this.checkMarks();
					return list;
				},
				checkConflict: function (skill) {
					if (skill) {
						if (this.forbiddenSkills[skill]) {
							delete this.forbiddenSkills[skill];
						}
						else {
							for (var i in this.forbiddenSkills) {
								if (this.forbiddenSkills[i].remove(skill)) {
									if (!this.forbiddenSkills[i].length) {
										delete this.forbiddenSkills[i];
									}
								}
							}
						}
					}
					else {
						this.forbiddenSkills = {};
						var forbid = [];
						var getName = function (arr) {
							var str = '';
							for (var i = 0; i < arr.length; i++) {
								str += arr[i] + '+';
							}
							return str.slice(0, str.length - 1);
						}
						var forbidlist = lib.config.forbid.concat(lib.config.customforbid);
						var skills = this.getSkills();
						for (var i = 0; i < forbidlist.length; i++) {
							if (lib.config.customforbid.contains(forbidlist[i]) ||
								!lib.config.forbidlist.contains(getName(forbidlist[i]))) {
								for (var j = 0; j < forbidlist[i].length; j++) {
									if (!skills.contains(forbidlist[i][j])) break;
								}
								if (j == forbidlist[i].length) {
									forbid.push(forbidlist[i]);
								}
							}
						}
						for (var i = 0; i < forbid.length; i++) {
							if (forbid[i][1] || this.name2) {
								this.forbiddenSkills[forbid[i][0]] = this.forbiddenSkills[forbid[i][0]] || [];
								if (forbid[i][1]) {
									this.forbiddenSkills[forbid[i][0]].add(forbid[i][1]);
								}
							}
						}
					}
				},
				getHistory: function (key, filter, last) {
					if (!key) return this.actionHistory[this.actionHistory.length - 1];
					if (!filter) return this.actionHistory[this.actionHistory.length - 1][key];
					else {
						var history = this.getHistory(key).slice(0);
						if (last) history = history.slice(0, history.indexOf(last) + 1);
						for (var i = 0; i < history.length; i++) {
							if (!filter(history[i])) history.splice(i--, 1);
						}
						return history;
					}
				},
				getLastHistory: function (key, filter, last) {
					var history = false;
					for (var i = this.actionHistory.length - 1; i >= 0; i--) {
						if (this.actionHistory[i].isMe) {
							history = this.actionHistory[i]; break;
						}
					}
					if (!history) return null;
					if (!key) return history;
					if (!filter) return history[key];
					else {
						history = history.slice(0);
						if (last) history = history.slice(0, history.indexOf(last) + 1);
						for (var i = 0; i < history.length; i++) {
							if (!filter(history[i])) history.splice(i--, 1);
						}
						return history;
					}
				},
				getAllHistory: function (key, filter, last) {
					var list = [];
					var all = this.actionHistory;
					for (var j = 0; j < all.length; j++) {
						if (!key || !all[j][key]) {
							list.push(all[j]);
						}
						else {
							if (!filter) list.addArray(all[j][key]);
							else {
								var history = all[j][key].slice(0);
								if (last) history = history.slice(0, history.indexOf(last) + 1);
								for (var i = 0; i < history.length; i++) {
									if (filter(history[i])) list.push(history[i]);
								}
							}
						}
					}
					return list;
				},
				getLastUsed: function (num) {
					if (typeof num != 'number') num = 0;
					var history = this.getHistory('useCard');
					if (history.length <= num) return null;
					return history[history.length - num - 1];
				},
				getStat: function (key) {
					if (!key) return this.stat[this.stat.length - 1];
					return this.stat[this.stat.length - 1][key];
				},
				getLastStat: function (key) {
					var stat = false;
					for (var i = this.stat.length - 1; i >= 0; i--) {
						if (this.stat[i].isMe) {
							stat = this.stat[i]; break;
						}
					}
					if (!stat) return null
					if (!key) return stat;
					return stat[key];
				},
				queue: function (time) {
					if (time == false) {
						clearTimeout(this.queueTimeout);
						this.queueCount = 0;
						return;
					}
					if (time == undefined) time = 500;
					var player = this;
					player.queueCount++;
					this.queueTimeout = setTimeout(function () {
						player.queueCount--;
						if (player.queueCount == 0) {
							player.style.transform = '';
							player.node.avatar.style.transform = '';
							player.node.avatar2.style.transform = '';
							if (game.chess) {
								ui.placeChess(player, player.dataset.position);
							}
							if (player == game.me) ui.me.removeAttribute('style');
						}
					}, time)
				},
				getCardUsable: function (card, pure) {
					var player = this;
					if (typeof card == 'string') {
						card = { name: card };
					}
					card = get.autoViewAs(card, null, player);
					var num = get.info(card).usable;
					if (typeof num == 'function') num = num(card, player);
					num = game.checkMod(card, player, num, 'cardUsable', player);
					if (typeof num != 'number') return Infinity;
					if (!pure && _status.currentPhase == player) {
						return num - player.countUsed(card);
					}
					return num;
				},
				getAttackRange: function (raw) {
					var player = this;
					var range = 0;
					if (raw) range = game.checkMod(player, player, range, 'globalFrom', player);
					range = game.checkMod(player, player, range, 'attackFrom', player);
					var equips = player.getCards('e', function (card) {
						return !ui.selected.cards || !ui.selected.cards.contains(card);
					});
					for (var i = 0; i < equips.length; i++) {
						var info = get.info(equips[i]).distance;
						if (!info) continue;
						if (raw && info.globalFrom) {
							range += info.globalFrom;
						}
						if (info.attackFrom) {
							range += info.attackFrom;
						}
					}
					return (1 - range);
				},
				getGlobalFrom: function () {
					var player = this;
					var range = 0;
					range = game.checkMod(player, player, range, 'globalFrom', player);
					var equips = player.getCards('e', function (card) {
						return !ui.selected.cards || !ui.selected.cards.contains(card);
					});
					for (var i = 0; i < equips.length; i++) {
						var info = get.info(equips[i]).distance;
						if (!info) continue;
						if (info.globalFrom) {
							range += info.globalFrom;
						}
					}
					return (-range);
				},
				getGlobalTo: function () {
					var player = this;
					var range = 0;
					range = game.checkMod(player, player, range, 'globalTo', player);
					var equips = player.getCards('e', function (card) {
						return !ui.selected.cards || !ui.selected.cards.contains(card);
					});
					for (var i = 0; i < equips.length; i++) {
						var info = get.info(equips[i]).distance;
						if (!info) continue;
						if (info.globalTo) {
							range += info.globalTo;
						}
					}
					return (range);
				},
				getHandcardLimit: function () {
					var num = Math.max(this.hp, 0);
					num = game.checkMod(this, num, 'maxHandcardBase', this);
					num = game.checkMod(this, num, 'maxHandcard', this);
					num = game.checkMod(this, num, 'maxHandcardFinal', this);
					return Math.max(0, num);
				},
				getEnemies: function (func) {
					var player = this;
					var targets;
					var mode = get.mode();
					switch(mode){
						case 'identity':
								if (_status.mode == 'purple') {
									switch (player.identity) {
										case 'bZhu': case 'bZhong': case 'rNei': targets = game.filterPlayer(function (target) {
											if (func && !func(target)) return false;
											return ['rZhu', 'rZhong', 'bNei'].contains(target.identity);
										}); break;
										case 'rZhu': case 'rZhong': case 'bNei': targets = game.filterPlayer(function (target) {
											if (func && !func(target)) return false;
											return ['bZhu', 'bZhong', 'rNei'].contains(target.identity);
										}); break;
										case 'rYe': case 'bYe': targets = game.filterPlayer(function (target) {
											if (func && !func(target)) return false;
											return !['rYe', 'bYe'].contains(target.identity);
										}); break;
									}
								}
								else {
									var num = get.population('fan');
									switch (player.identity) {
										case 'zhu': case 'zhong': case 'mingzhong': targets = game.filterPlayer(function (target) {
											if (func && !func(target)) return false;
											if (num >= 3) return target.identity == 'fan';
											return target.identity == 'nei' || target.identity == 'fan';
										}); break;
										case 'nei': targets = game.filterPlayer(function (target) {
											if (func && !func(target)) return false;
											if (num >= 3) return target.identity == 'fan';
											if (game.players.length == 2) return target != player;
											return target.identity == 'zhong' || target.identity == 'mingzhong' || target.identity == 'fan';
										}); break;
										case 'fan': targets = game.filterPlayer(function (target) {
											if (func && !func(target)) return false;
											return target.identity != 'fan';
										}); break;
									}
								}
							break;
						case 'guozhan':
							if (player.identity == 'ye') {
								targets = game.filterPlayer(function (target) {
									if (func && !func(target)) return false;
									return true;
								});
							}
							else {
								var group = lib.character[player.name1][1];
								targets = game.filterPlayer(function (target) {
									if (func && !func(target)) return false;
									return target.identity == 'ye' || lib.character[target.name1][1] != group;
								});
							}
							break;
						case 'SNH48':
							if (player.identity == 'guan') {
								targets = game.filterPlayer(function (target) {
									if (func && !func(target)) return false;
									return true;
								});
							} else {
								var group = lib.character[player.name1][1];
								targets = game.filterPlayer(function (target) {
									if (func && !func(target)) return false;
									return target.identity == 'guan' || lib.character[target.name1][1] != group;
								});
							}
							break;
						case 'doudizhu':
							targets = game.filterPlayer(function (target) {
								if (func && !func(target)) return false;
								return target.identity != player.identity;
							});
							break;
						default:
							targets = game.filterPlayer(function (target) {
								if (func && !func(target)) return false;
								return target.side != player.side;
							});
							break;
					}
					targets.remove(player);
					return targets;
				},
				getFriends: function (func) {
					var player = this;
					var targets;
					var mode = get.mode();
					var self = false;
					if (func === true) {
						func = null;
						self = true;
					}
					switch (mode) {
						case 'identity':
							if (_status.mode == 'purple') {
								switch (player.identity) {
									case 'rZhu': case 'rZhong': case 'bNei': targets = game.filterPlayer(function (target) {
										if (func && !func(target)) return false;
										return ['rZhu', 'rZhong', 'bNei'].contains(target.identity);
									}); break;
									case 'bZhu': case 'bZhong': case 'rNei': targets = game.filterPlayer(function (target) {
										if (func && !func(target)) return false;
										return ['bZhu', 'bZhong', 'rNei'].contains(target.identity);
									}); break;
									case 'rYe': case 'bYe': targets = game.filterPlayer(function (target) {
										if (func && !func(target)) return false;
										return ['rYe', 'bYe'].contains(target.identity);
									}); break;
								}
							}
							else {
								switch (player.identity) {
									case 'zhu': case 'zhong': case 'mingzhong': targets = game.filterPlayer(function (target) {
										if (func && !func(target)) return false;
										return ['zhu', 'zhong', 'mingzhong'].contains(target.identity);
									}); break;
									case 'nei': targets = []; break;
									case 'fan': targets = game.filterPlayer(function (target) {
										if (func && !func(target)) return false;
										return target.identity == 'fan';
									}); break;
								}
							}
							break;
						case 'guozhan':
							if (player.identity == 'ye') {
							targets = [];
						}
						else {
							var group = lib.character[player.name1][1];
							targets = game.filterPlayer(function (target) {
								if (func && !func(target)) return false;
								return target.identity != 'ye' && lib.character[target.name1][1] == group;
							});
						}
							break;
						case 'SNH48':
							if (player.identity == 'guan') {
								targets = [];
							} else {
								var group = lib.character[player.name1][1];
								targets = game.filterPlayer(function (target) {
									if (func && !func(target)) return false;
									return target.identity != 'guan' && lib.character[target.name1][1] == group;
								});
							}
							break;
						case 'doudizhu':
							targets = game.filterPlayer(function (target) {
								if (func && !func(target)) return false;
								return target.identity == player.identity;
							});
							break;
						default:
							targets = game.filterPlayer(function (target) {
								if (func && !func(target)) return false;
								return target.side == player.side;
							});
							break;
					}
					if (self) {
						targets.add(player);
					}
					else {
						targets.remove(player);
					}
					return targets;
				},
				isEnemyOf: function () {
					return !this.isFriendOf.apply(this, arguments);
				},
				isFriendOf: function (player) {
					switch (get.mode()) {
						case 'guozhan':
							if (this == player) return true;
							if (this.identity == 'unknown' || this.identity == 'ye') return false;
							if (player.identity == 'unknown' || player.identity == 'ye') return false;
							return this.identity == player.identity;
						case 'SNH48':
							if (this == player) return true;
							if (this.identity == 'unknown' || this.identity == 'guan') return false;
							if (player.identity == 'unknown' || player.identity == 'guan') return false;
							return this.identity == player.identity;
						case 'doudizhu':
							return this.identity == player.identity;
						default:
							break;
					}
					if (this.side != undefined && typeof player.side == 'boolean') {
						return this.side == player.side;
					}
					return this == player;
				},
				isFriendsOf: function (player) {
					return player.getFriends(true).contains(this);
				},
				isEnemiesOf: function (player) {
					return player.getEnemies().contains(this);
				},
				isAlive: function () {
					return this.classList.contains('dead') == false;
				},
				isDead: function () {
					return this.classList.contains('dead');
				},
				isDying: function () {
					return _status.dying.contains(this) && this.hp <= 0 && this.isAlive();
				},
				isDamaged: function () {
					return this.hp < this.maxHp;
				},
				isHealthy: function () {
					return this.hp == this.maxHp;
				},
				isMaxHp: function (equal) {
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].hp >= this.hp) return false;
						}
						else {
							if (game.players[i].hp > this.hp) return false;
						}
					}
					return true;
				},
				isMinHp: function (equal) {
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].hp <= this.hp) return false;
						}
						else {
							if (game.players[i].hp < this.hp) return false;
						}
					}
					return true;
				},
				isMaxCard: function (equal) {
					var nh = this.countCards('he');
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].countCards('he') >= nh) return false;
						}
						else {
							if (game.players[i].countCards('he') > nh) return false;
						}
					}
					return true;
				},
				isMinCard: function (equal) {
					var nh = this.countCards('he');
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].countCards('he') <= nh) return false;
						}
						else {
							if (game.players[i].countCards('he') < nh) return false;
						}
					}
					return true;
				},
				isMaxHandcard: function (equal) {
					var nh = this.countCards('h');
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].countCards('h') >= nh) return false;
						}
						else {
							if (game.players[i].countCards('h') > nh) return false;
						}
					}
					return true;
				},
				isMinHandcard: function (equal) {
					var nh = this.countCards('h');
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].countCards('h') <= nh) return false;
						}
						else {
							if (game.players[i].countCards('h') < nh) return false;
						}
					}
					return true;
				},
				isMaxEquip: function (equal) {
					var nh = this.countCards('e');
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].countCards('e') >= nh) return false;
						}
						else {
							if (game.players[i].countCards('e') > nh) return false;
						}
					}
					return true;
				},
				isMinEquip: function (equal) {
					var nh = this.countCards('e');
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut() || game.players[i] == this) continue;
						if (equal) {
							if (game.players[i].countCards('e') <= nh) return false;
						}
						else {
							if (game.players[i].countCards('e') < nh) return false;
						}
					}
					return true;
				},
				isLinked: function () {
					if (get.is.linked2(this)) {
						return this.classList.contains('linked2');
					}
					return this.classList.contains('linked');
				},
				isTurnedOver: function () {
					return this.classList.contains('turnedover');
				},
				isOut: function () {
					return this.classList.contains('out');
				},
				isMin: function (distance) {
					if (distance && lib.config.mode != 'stone') return false;
					if (this.forcemin) return true;
					return this.classList.contains('minskin') && !game.chess;
				},
				isIn: function () {
					return this.classList.contains('dead') == false && this.classList.contains('out') == false && !this.removed;
				},
				isUnseen: function (num) {
					switch (num) {
						case 0: return this.classList.contains('unseen');
						case 1: return this.classList.contains('unseen2');
						case 2: return this.classList.contains('unseen') || this.classList.contains('unseen2');
						default: return this.classList.contains('unseen') && this.classList.contains('unseen2');
					}
				},
				isUnderControl: function (self, me) {
					me = (me || game.me);
					var that = this._trueMe || this;
					if (that.isMad() || game.notMe) return false;
					if (this === me) {
						if (self) return true;
						return false;
					}
					if (that === me || this == me._trueMe) return true;
					if (_status.connectMode) return false;
					if (lib.config.mode == 'versus') {
						if (_status.mode == 'three') return this.side == me.side;
						if (_status.mode == 'standard') return lib.storage.single_control && this.side == me.side;
						if (_status.mode == 'four') return get.config('four_phaseswap') && this.side == me.side;
						if (_status.mode == 'two') return get.config('two_phaseswap') && this.side == me.side;
						return false;
					}
					else if (lib.config.mode == 'boss') {
						if (me.side) return false;
						return this.side == me.side && get.config('single_control');
					}
					else if (game.chess) {
						if (lib.config.mode == 'chess') {
							if (_status.mode == 'combat' && !get.config('single_control')) return false;
						}
						return this.side == me.side;
					}
					return false;
				},
				isOnline: function () {
					if (this.ws && lib.node && !this.ws.closed && this.ws.inited && !this.isAuto) {
						return true;
					}
					return false;
				},
				isOnline2: function () {
					if (this.ws && lib.node && !this.ws.closed) {
						return true;
					}
					return false;
				},
				isOffline: function () {
					if (this.ws && lib.node && this.ws.closed) {
						return true;
					}
					return false;
				},
				checkShow: function (skill, showonly) {
					var sourceSkill = get.info(skill);
					var noshow = false;
					if (sourceSkill && sourceSkill.sourceSkill) {
						skill = sourceSkill.sourceSkill;
					}
					if (lib.skill.global.contains(skill)) return false;
					if (get.mode() != 'guozhan' || game.expandSkills(this.getSkills()).contains(skill)) {
						if (showonly) {
							return false;
						}
						else {
							noshow = true;
						}
					}
					var unseen0 = this.isUnseen(0);
					var name1 = this.name1 || this.name;
					if (lib.character[name1] && (!showonly || unseen0)) {
						var skills = game.expandSkills(lib.character[name1][3].slice(0));
						if (skills.contains(skill)) {
							if (!noshow && this.isUnseen(0)) this.showCharacter(0);
							return 'main';
						}
					}
					var unseen1 = this.isUnseen(1);
					var name2 = this.name2;
					if (lib.character[name2] && (!showonly || unseen1)) {
						var skills = game.expandSkills(lib.character[name2][3].slice(0));
						if (skills.contains(skill)) {
							if (!noshow && this.isUnseen(1)) this.showCharacter(1);
							return 'vice';
						}
					}
					return false;
				},
				needsToDiscard: function (num) {
					if (typeof num != 'number') num = 0;
					var hs = this.getCards('h');
					num += hs.length;
					for (var i = 0; i < hs.length; i++) {
						if (game.checkMod(hs[i], this, false, 'ignoredHandcard', this) == true) {
							num--;
						}
					}
					return Math.max(0, num - this.getHandcardLimit());
				},
				distanceTo: function (target, method) {
					return get.distance(this, target, method);
				},
				distanceFrom: function (target, method) {
					return get.distance(target, this, method);
				},
				hasSkill: function (skill, arg2, arg3, arg4) {
					return game.expandSkills(this.getSkills(arg2, arg3, arg4)).contains(skill);
				},
				hasStockSkill: function (skill, arg1, arg2, arg3) {
					return game.expandSkills(this.getStockSkills(arg1, arg2, arg3)).contains(skill);
				},
				hasZhuSkill: function (skill, player) {
					if (!this.hasSkill(skill)) return false;
					var mode = get.mode();
					if (mode == 'identity' || (mode == 'versus' && (_status.mode == 'four' || _status.mode == 'guandu'))) {
						if (mode != 'identity') {
							if (player && this.side != player.side) return false;
						}
						if (_status.mode == 'purple') {
							if (player && this.identity.slice(0, 1) != player.identity.slice(0, 1)) return false;
						}
						if (this.isZhu == true) return true;
						for (var i in this.storage) {
							if (i.indexOf('zhuSkill_') == 0 && this.storage[i].contains(skill)) return true;
						}
					}
					return false;
				},
				hasGlobalTag: function (tag, arg) {
					var skills = lib.skill.global.slice(0);
					game.expandSkills(skills);
					for (var i = 0; i < skills.length; i++) {
						var info = lib.skill[skills[i]];
						if (info && info.ai) {
							if (info.ai.skillTagFilter && info.ai[tag] &&
								info.ai.skillTagFilter(this, tag, arg) === false) continue;
							if (typeof info.ai[tag] == 'string') {
								if (info.ai[tag] == arg) return true;
							}
							else if (info.ai[tag]) {
								return true;
							}
						}
					}
					return false;
				},
				hasSkillTag: function (tag, hidden, arg, globalskill) {
					var skills = this.getSkills(hidden);
					if (globalskill) {
						skills.addArray(lib.skill.global);
					}
					game.expandSkills(skills);
					for (var i = 0; i < skills.length; i++) {
						var info = lib.skill[skills[i]];
						if (info && info.ai) {
							if (info.ai.skillTagFilter && info.ai[tag] &&
								info.ai.skillTagFilter(this, tag, arg) === false) continue;
							if (typeof info.ai[tag] == 'string') {
								if (info.ai[tag] == arg) return true;
							}
							else if (info.ai[tag]) {
								return true;
							}
						}
					}
					return false;
				},
				hasJudge: function (name) {
					if (name && typeof name == 'object') {
						name = name.viewAs || name.name;
					}
					var judges = this.node.judges.childNodes;
					for (var i = 0; i < judges.length; i++) {
						if (judges[i].classList.contains('removing')) continue;
						if ((judges[i].viewAs || judges[i].name) == name) {
							return true;
						}
					}
					return false;
				},
				hasFriend: function () {
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isOut()) continue;
						if (game.players[i] != this && get.attitude(game.players[i], this) > 0) {
							return true;
						}
					}
					return false;
				},
				hasUnknown: function (num) {
					var mode = get.mode();
					if (typeof num != 'number') {
						num = 0;
					}
					if (mode == 'identity' || mode == 'guozhan') {
						for (var i = 0; i < game.players.length; i++) {
							if (game.players[i].ai.shown == 0 && game.players[i] != this) {
								num--;
								if (num <= 0) {
									return true;
								}
							}
						}
					}
					return false;
				},
				isUnknown: function (player) {
					var mode = get.mode();
					if (mode == 'identity' || mode == 'guozhan') {
						if (this.ai.shown == 0 && this != player) {
							return true;
						}
					}
					return false;
				},
				hasWuxie: function () {
					if (this.countCards('h', 'wuxie')) return true;
					var skills = this.getSkills(true).concat(lib.skill.global);
					game.expandSkills(skills);
					for (var i = 0; i < skills.length; i++) {
						var ifo = get.info(skills[i]);
						if (ifo.viewAs && typeof ifo.viewAs != 'function' && ifo.viewAs.name == 'wuxie') {
							if (!ifo.viewAsFilter || ifo.viewAsFilter(this)) {
								return true;
							}
						}
						else {
							var hiddenCard = get.info(skills[i]).hiddenCard;
							if (typeof hiddenCard == 'function' && hiddenCard(this, 'wuxie')) {
								return true;
							}
						}
					}
					return false;
				},
				hasSha: function (respond, noauto) {
					if (this.countCards('h', 'sha')) return true;
					if (this.countCards('h', 'hufu')) return true;
					if (!noauto && this.countCards('h', 'yuchanqian')) return true;
					if (this.hasSkillTag('respondSha', true, respond ? 'respond' : 'use', true)) return true;
					return false;
				},
				hasShan: function () {
					if (this.countCards('h', 'shan')) return true;
					if (this.countCards('h', 'hufu')) return true;
					if (this.hasSkillTag('respondShan', true, null, true)) return true;
					return false;
				},
				mayHaveShan: function () {
					return this.hasShan();
					// modify: After AngelBeats! -2nd Beat-
				},
				hasCard: function (name, position) {
					if (typeof name == 'function') {
						var hs = this.getCards(position);
						for (var i = 0; i < hs.length; i++) {
							if (name(hs[i])) return true;
						}
					}
					else {
						if (this.countCards(position, name)) return true;
						var mn = this.getEquip('muniu');
						if (mn && mn.cards && mn.cards.length) {
							for (var i = 0; i < mn.cards.length; i++) {
								if (mn.cards[i].name == name) return true;
							}
						}
					}
					return false;
				},
				canEquip: function (name, replace) {
					if (get.type(name) == 'card') {
						name = get.equiptype(name);
					}
					var range = get.subtype(name);
					if (this.isDisabled(range)) return false;
					if (['equip3', 'equip4'].contains(range) && this.getEquip(6)) return false;
					if (!replace && !this.isEmpty(range)) return false;
					return true;
				},
				getEquip: function (name) {
					var es = this.getCards('e');
					if (typeof name == 'object' && get.info(name)) {
						name = get.info(name).subtype;
						if (name) {
							name = parseInt(name[5]);
						}
					}
					else if (typeof name == 'string' && name.indexOf('equip') == 0 && name.length == 6) {
						name = parseInt(name[5]);
					}
					if (!name) {
						return null;
					}
					for (var i = 0; i < es.length; i++) {
						if (typeof name === 'number') {
							if (get.info(es[i]).subtype === 'equip' + name) {
								return es[i];
							}
						}
						else {
							if (es[i].name === name) return es[i];
							var source = get.info(es[i]).source;
							if (Array.isArray(source) && source.contains(name)) {
								return es[i];
							}
						}
					}
					return null;
				},
				getJudge: function (name) {
					var judges = this.node.judges.childNodes;
					for (var i = 0; i < judges.length; i++) {
						if (judges[i].classList.contains('removing')) continue;
						if ((judges[i].viewAs || judges[i].name) == name) {
							return judges[i];
						}
					}
					return null;
				},
				$drawAuto: function (cards, target) {
					if (this.isUnderControl(true, target)) {
						this.$draw(cards);
					}
					else {
						this.$draw(cards.length);
					}
				},
				$draw: function (num, init, config) {
					if (init !== false && init !== 'nobroadcast') {
						game.broadcast(function (player, num, init, config) {
							player.$draw(num, init, config)
						}, this, num, init, config);
					}
					var cards, node;
					if (get.itemtype(num) == 'cards') {
						cards = num;
						num = cards.length;
					}
					else if (get.itemtype(num) == 'card') {
						cards = [num];
						num = 1;
					}
					if (init !== false) {
						if (cards) {
							game.addVideo('drawCard', this, get.cardsInfo(cards));
						}
						else {
							game.addVideo('draw', this, num);
						}
					}
					if (cards) {
						cards = cards.slice(0);
						node = cards.shift().copy('thrown', 'drawingcard');
					}
					else {
						node = ui.create.div('.card.thrown.drawingcard');
					}
					node.fixed = true;
					node.hide();

					var dx, dy;
					if (game.chess) {
						var rect = this.getBoundingClientRect();

						if (rect.left <= 80) {
							dx = -10;
							if (rect.top <= 80) {
								dy = -10;
							}
							else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
								dy = 10;
							}
							else {
								dy = 0;
							}
						}
						else if (rect.left + rect.width + 80 >= ui.chessContainer.offsetWidth) {
							dx = 10;
							if (rect.top <= 80) {
								dy = -10;
							}
							else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
								dy = 10;
							}
							else {
								dy = 0;
							}
						}
						else if (rect.top <= 80) {
							dx = 0;
							dy = -10;
						}
						else if (rect.top + rect.height + 80 >= ui.chessContainer.offsetHeight) {
							dx = 0;
							dy = 10;
						}
						else {
							dx = rect.left + this.offsetWidth / 2 - ui.arena.offsetWidth / 2;
							dy = rect.top + this.offsetHeight / 2 - ui.arena.offsetHeight / 2;
						}

						var coeff = 240 / Math.sqrt(dx * dx + dy * dy);
						dx *= coeff;
						dy *= coeff;

						node.style.left = (this.getLeft() + this.offsetWidth / 2 - 52 - dx) + 'px';
						node.style.top = (this.getTop() + this.offsetHeight / 2 - 52 - dy) + 'px';
						this.parentNode.appendChild(node);
					}
					else {
						this.parentNode.appendChild(node);
						node.style.left = 'calc(50% - 52px)';
						node.style.top = 'calc(50% - 52px)';

						dx = this.getLeft() + this.offsetWidth / 2 - 52 - node.offsetLeft;
						dy = this.getTop() + this.offsetHeight / 2 - 52 - node.offsetTop;

						if (get.is.mobileMe(this)) {
							dx += get.cardOffset();
							if (ui.arena.classList.contains('oblongcard')) {
								dy -= 16;
							}
						}
					}
					node.style.transitionDuration = '0.8s';
					ui.refresh(node);
					if (typeof num == 'number' && init !== false) {
						config = {
							total: num,
							current: 1
						}
					}
					if (config && config.total > 1) {
						var total = config.total, current = config.current;
						var dxtotal;
						if (total <= 5) {
							dxtotal = Math.min(80, (total - 1) * 20);
							dx += -dxtotal + 2 * dxtotal * (current - 1) / (total - 1)
						}
						else {
							var total2 = Math.floor(total / 2);
							if (current <= total2) {
								total = total2;
								dy -= 20;
							}
							else {
								current -= total2;
								total -= total2;
								dy += 20;
							}
							dxtotal = Math.min(80, (total - 1) * 20);
							dx += -dxtotal + 2 * dxtotal * (current - 1) / (total - 1)
						}
						config.current++;
					}
					if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
						node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
					}
					else {
						node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
					}
					node.show();

					node.listenTransition(function () {
						node.style.transitionDuration = '0.5s';
						ui.refresh(node);
						node.delete();
					});
					var that = this;
					if (num && num > 1) {
						if (config && config.total > 1) {
							setTimeout(function () {
								if (cards) {
									that.$draw(cards, false, config)
								}
								else {
									that.$draw(num - 1, false, config)
								}
							}, 50)
						}
						else {
							setTimeout(function () {
								if (cards) {
									that.$draw(cards, false, config)
								}
								else {
									that.$draw(num - 1, false, config)
								}
							}, 200);
						}
					}
				},
				$compareMultiple: function (card1, targets, cards) {
					game.broadcast(function (player, card1, targets, cards) {
						player.$compareMultiple(card1, targets, cards);
					}, this, card1, targets, cards);
					game.addVideo('compareMultiple', this, [get.cardInfo(card1), get.targetsInfo(targets), get.cardsInfo(cards)]);
					var player = this;
					var node1 = player.$throwxy2(card1,
						'calc(50% - 52px)', 'calc(50% + 10px)', 'perspective(600px) rotateY(180deg)', true
					);
					if (lib.config.cardback_style != 'default') {
						node1.style.transitionProperty = 'none';
						ui.refresh(node1);
						node1.classList.add('infohidden');
						ui.refresh(node1);
						node1.style.transitionProperty = '';
					}
					else {
						node1.classList.add('infohidden');
					}

					node1.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
					var onEnd01 = function () {
						node1.removeEventListener('webkitTransitionEnd', onEnd01);
						setTimeout(function () {
							node1.style.transition = 'all ease-in 0.3s';
							node1.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
							var onEnd = function () {
								node1.classList.remove('infohidden');
								node1.style.transition = 'all 0s';
								ui.refresh(node1);
								node1.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
								ui.refresh(node1);
								node1.style.transition = '';
								ui.refresh(node1);
								node1.style.transform = '';
								node1.removeEventListener('webkitTransitionEnd', onEnd);
							}
							node1.listenTransition(onEnd);
						}, 300);
					};
					node1.listenTransition(onEnd01);

					setTimeout(function () {
						var left0 = -targets.length * 52 - (targets.length - 1) * 8;
						for (var i = 0; i < targets.length; i++) {
							(function (target, card2, i) {
								var left = left0 + i * 120;
								var node2;
								if (left < 0) {
									node2 = target.$throwxy2(card2,
										'calc(50% - ' + (-left) + 'px)', 'calc(50% - 114px)', 'perspective(600px) rotateY(180deg)', true
									);
								}
								else {
									node2 = target.$throwxy2(card2,
										'calc(50% + ' + left + 'px)', 'calc(50% - 114px)', 'perspective(600px) rotateY(180deg)', true
									);
								}
								if (lib.config.cardback_style != 'default') {
									node2.style.transitionProperty = 'none';
									ui.refresh(node2);
									node2.classList.add('infohidden');
									ui.refresh(node2);
									node2.style.transitionProperty = '';
								}
								else {
									node2.classList.add('infohidden');
								}
								node2.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
								var onEnd02 = function () {
									node2.removeEventListener('webkitTransitionEnd', onEnd02);
									setTimeout(function () {
										node2.style.transition = 'all ease-in 0.3s';
										node2.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
										var onEnd = function () {
											node2.classList.remove('infohidden');
											node2.style.transition = 'all 0s';
											ui.refresh(node2);
											node2.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
											ui.refresh(node2);
											node2.style.transition = '';
											ui.refresh(node2);
											node2.style.transform = '';
											node2.removeEventListener('webkitTransitionEnd', onEnd);
										}
										node2.listenTransition(onEnd);
									}, 200);
								};
								node2.listenTransition(onEnd02);
							}(targets[i], cards[i], i))
						}
					}, 200);
				},
				$compare: function (card1, target, card2) {
					game.broadcast(function (player, target, card1, card2) {
						player.$compare(card1, target, card2);
					}, this, target, card1, card2);
					game.addVideo('compare', this, [get.cardInfo(card1), target.dataset.position, get.cardInfo(card2)]);
					var player = this;
					var node1 = player.$throwxy2(card1,
						'calc(50% - 114px)', 'calc(50% - 52px)', 'perspective(600px) rotateY(180deg)', true
					);
					if (lib.config.cardback_style != 'default') {
						node1.style.transitionProperty = 'none';
						ui.refresh(node1);
						node1.classList.add('infohidden');
						ui.refresh(node1);
						node1.style.transitionProperty = '';
					}
					else {
						node1.classList.add('infohidden');
					}

					node1.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
					var onEnd01 = function () {
						node1.removeEventListener('webkitTransitionEnd', onEnd01);
						setTimeout(function () {
							node1.style.transition = 'all ease-in 0.3s';
							node1.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
							var onEnd = function () {
								node1.classList.remove('infohidden');
								node1.style.transition = 'all 0s';
								ui.refresh(node1);
								node1.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
								ui.refresh(node1);
								node1.style.transition = '';
								ui.refresh(node1);
								node1.style.transform = '';
								node1.removeEventListener('webkitTransitionEnd', onEnd);
							}
							node1.listenTransition(onEnd);
						}, 300);
					};
					node1.listenTransition(onEnd01);
					setTimeout(function () {
						var node2 = target.$throwxy2(card2,
							'calc(50% + 10px)', 'calc(50% - 52px)', 'perspective(600px) rotateY(180deg)', true
						);
						if (lib.config.cardback_style != 'default') {
							node2.style.transitionProperty = 'none';
							ui.refresh(node2);
							node2.classList.add('infohidden');
							ui.refresh(node2);
							node2.style.transitionProperty = '';
						}
						else {
							node2.classList.add('infohidden');
						}
						node2.style.transform = 'perspective(600px) rotateY(180deg) translateX(0)';
						var onEnd02 = function () {
							node2.removeEventListener('webkitTransitionEnd', onEnd02);
							setTimeout(function () {
								node2.style.transition = 'all ease-in 0.3s';
								node2.style.transform = 'perspective(600px) rotateY(270deg) translateX(52px)';
								var onEnd = function () {
									node2.classList.remove('infohidden');
									node2.style.transition = 'all 0s';
									ui.refresh(node2);
									node2.style.transform = 'perspective(600px) rotateY(-90deg) translateX(52px)';
									ui.refresh(node2);
									node2.style.transition = '';
									ui.refresh(node2);
									node2.style.transform = '';
									node2.removeEventListener('webkitTransitionEnd', onEnd);
								}
								node2.listenTransition(onEnd);
							}, 200);
						};
						node2.listenTransition(onEnd02);
					}, 200);
				},
				$throw: function (card, time, init, nosource) {
					if (typeof card == 'number') {
						var tmp = card;
						card = [];
						while (tmp--) {
							var cardx = ui.create.card();
							cardx.classList.add('infohidden');
							cardx.classList.add('infoflip');
							card.push(cardx);
						}
					}
					if (init !== false) {
						if (init !== 'nobroadcast') {
							game.broadcast(function (player, card, time, init, nosource) {
								player.$throw(card, time, init, nosource);
							}, this, card, time, init);
						}
						if (get.itemtype(card) != 'cards') {
							if (get.itemtype(card) == 'card') {
								card = [card];
							}
							else {
								return;
							}
						}
						game.addVideo('throw', this, [get.cardsInfo(card), time, nosource]);
					}
					if (game.chess) {
						this.chessFocus();
					}
					if (get.itemtype(card) == 'cards') {
						var node;
						for (var i = 0; i < card.length; i++) {
							node = this.$throw(card[i], time, false, nosource);
						}
						return node;
					}
					else {
						var node;
						if (card == undefined || card.length == 0) return;
						node = this.$throwordered(card.copy('thrown'), nosource);
						if (time != undefined) {
							node.fixed = true;
							setTimeout(function () { node.delete() }, time);
						}
						lib.listenEnd(node);
						return node;
					}
				},
				$throwordered: function () {
					return this.$throwordered2.apply(this, arguments);
					// if(lib.config.low_performance){
					// 	return this.$throwordered2.apply(this,arguments);
					// }
					// else{
					// 	return this.$throwordered1.apply(this,arguments);
					// }
				},
				$throwordered1: function (node, nosource) {
					node.classList.add('thrown');
					node.hide();
					node.style.transitionProperty = 'left,top,opacity,transform';
					for (var i = 0; i < ui.thrown.length; i++) {
						if (ui.thrown[i].parentNode != ui.arena ||
							ui.thrown[i].classList.contains('removing')) {
							ui.thrown.splice(i--, 1);
						}
					}
					ui.thrown.push(node);
					var uithrowns = ui.thrown.slice(0);
					var tops;
					if (game.chess) {
						switch (Math.floor((ui.thrown.length - 1) / 4)) {
							case 0:
								tops = ['calc(50% - 82px)'];
								break;
							case 1:
								tops = ['calc(50% - 139px)', 'calc(50% - 25px)'];
								break;
							case 2:
								tops = ['calc(50% - 196px)', 'calc(50% - 82px)', 'calc(50% + 32px)'];
								break;
							default:
								tops = ['calc(50% - 253px)', 'calc(50% - 139px)',
									'calc(50% - 25px)', 'calc(50% + 89px)'];
						}
					}
					else {
						switch (Math.floor((ui.thrown.length - 1) / 4)) {
							case 0:
								tops = ['calc(50% - 52px)'];
								break;
							case 1:
								tops = ['calc(50% - 109px)', 'calc(50% + 5px)'];
								break;
							case 2:
								tops = ['calc(50% - 166px)', 'calc(50% - 52px)', 'calc(50% + 62px)'];
								break;
							default:
								tops = ['calc(50% - 223px)', 'calc(50% - 109px)',
									'calc(50% + 5px)', 'calc(50% + 119px)'];
						}
					}
					while (uithrowns.length) {
						var throwns = uithrowns.splice(0, Math.min(uithrowns.length, 4));
						switch (throwns.length) {
							case 1:
								throwns[0].style.left = 'calc(50% - 52px)';
								break;
							case 2:
								throwns[0].style.left = 'calc(50% - 109px)';
								throwns[1].style.left = 'calc(50% + 5px)';
								break;
							case 3:
								throwns[0].style.left = 'calc(50% - 166px)';
								throwns[1].style.left = 'calc(50% - 52px)';
								throwns[2].style.left = 'calc(50% + 62px)';
								break;
							case 4:
								throwns[0].style.left = 'calc(50% - 223px)';
								throwns[1].style.left = 'calc(50% - 109px)';
								throwns[2].style.left = 'calc(50% + 5px)';
								throwns[3].style.left = 'calc(50% + 119px)';
								break;
						}
						var top;
						if (tops.length) {
							top = tops.shift();
						}
						else {
							if (game.chess) {
								top = 'calc(50% - 82px)';
							}
							else {
								top = 'calc(50% - 52px)';
							}
						}
						for (var i = 0; i < throwns.length; i++) {
							throwns[i].style.top = top;
						}
					}
					if (nosource) {
						node.style.transform = 'scale(0)';
						node.classList.add('center');
					}
					else {
						var parseCalc = function (str) {
							var per = str.slice(str.indexOf('calc(') + 5, str.indexOf('%'));
							var add = str.slice(str.indexOf('%') + 1, str.indexOf('px')).replace(/\s/g, '');
							return [parseInt(per), parseInt(add)];
						}
						var nx = parseCalc(node.style.left);
						var ny = parseCalc(node.style.top);
						nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
						ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
						var dx, dy;
						if (game.chess) {
							var rect = this.getBoundingClientRect();
							dx = rect.left + this.offsetWidth / 2 - 52 - nx;
							dy = rect.top + this.offsetHeight / 2 - 52 - ny;
						}
						else {
							dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
							dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
							if (get.is.mobileMe(this)) {
								dx += get.cardOffset();
								if (ui.arena.classList.contains('oblongcard')) {
									dy -= 16;
								}
							}
						}
						if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
							node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
						}
						else {
							node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
						}
					}
					ui.arena.appendChild(node);
					ui.refresh(node);
					node.style.transform = '';
					node.show();
					lib.listenEnd(node);
					return node;
				},
				$throwordered2: function (node, nosource) {
					node.classList.add('thrown');
					node.classList.add('center');
					node.hide();
					node.style.transitionProperty = 'left,top,opacity,transform';

					if (nosource) {
						// node.style.transform='scale(0)';
					}
					else {
						var nx = [50, -52];
						var ny = [50, -52];
						nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
						ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
						var dx, dy;
						if (game.chess) {
							var rect = this.getBoundingClientRect();
							dx = rect.left + this.offsetWidth / 2 - 52 - nx;
							dy = rect.top + this.offsetHeight / 2 - 52 - ny;
						}
						else {
							dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
							dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
							if (get.is.mobileMe(this)) {
								dx += get.cardOffset();
								if (ui.arena.classList.contains('oblongcard')) {
									dy -= 16;
								}
							}
						}
						if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
							node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
						}
						else {
							node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
						}
					}
					ui.arena.appendChild(node);
					ui.refresh(node);

					for (var i = 0; i < ui.thrown.length; i++) {
						if (ui.thrown[i].parentNode != ui.arena ||
							ui.thrown[i].classList.contains('removing')) {
							ui.thrown.splice(i--, 1);
						}
					}
					ui.thrown.push(node);
					var uithrowns = ui.thrown.slice(0);
					var tops;
					switch (Math.floor((ui.thrown.length - 1) / 4)) {
						case 0:
							tops = [0];
							break;
						case 1:
							tops = [-57, 57];
							break;
						case 2:
							tops = [-114, 0, 114];
							break;
						default:
							tops = [-171, -57, 57, 171];
					}
					while (uithrowns.length) {
						var throwns = uithrowns.splice(0, Math.min(uithrowns.length, 4));
						switch (throwns.length) {
							case 1:
								throwns[0]._transthrown = 'translate(0px,';
								break;
							case 2:
								throwns[0]._transthrown = 'translate(-57px,';
								throwns[1]._transthrown = 'translate(57px,';
								break;
							case 3:
								throwns[0]._transthrown = 'translate(-114px,';
								throwns[1]._transthrown = 'translate(0,';
								throwns[2]._transthrown = 'translate(114px,';
								break;
							case 4:
								throwns[0]._transthrown = 'translate(-171px,';
								throwns[1]._transthrown = 'translate(-57px,';
								throwns[2]._transthrown = 'translate(57px,';
								throwns[3]._transthrown = 'translate(171px,';
								break;
						}
						var top;
						if (tops.length) {
							top = tops.shift();
						}
						else {
							top = 0;
						}
						if (game.chess) {
							top -= 30;
						}
						for (var i = 0; i < throwns.length; i++) {
							throwns[i].style.transform = throwns[i]._transthrown + top + 'px)';
							delete throwns[i]._transthrown;
						}
					}

					node.show();
					lib.listenEnd(node);
					return node;
				},
				$throwxy: function (card, left, top) {
					var node = card.copy('thrown', 'thrownhighlight');
					node.dataset.position = this.dataset.position;
					node.hide();
					node.style.transitionProperty = 'left,top,opacity';

					ui.arena.appendChild(node);
					ui.refresh(node);
					node.show();
					node.style.left = left;
					node.style.top = top;
					lib.listenEnd(node);
					return node;
				},
				$throwxy2: function (card, left, top, trans, flipx, flipy) {
					if (game.chess) {
						return this.$throwxy.apply(this, arguments);
					}
					var node = card.copy('thrown', 'thrownhighlight');
					node.style.left = left;
					node.style.top = top;
					node.hide();
					// node.style.transitionProperty='left,top,opacity,transform';

					var parseCalc = function (str) {
						var per = str.slice(str.indexOf('calc(') + 5, str.indexOf('%'));
						var add = str.slice(str.indexOf('%') + 1, str.indexOf('px')).replace(/\s/g, '');
						return [parseInt(per), parseInt(add)];
					}
					var nx = parseCalc(node.style.left);
					var ny = parseCalc(node.style.top);
					nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
					ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
					var dx = this.getLeft() + this.offsetWidth / 2 - 52 - nx;
					var dy = this.getTop() + this.offsetHeight / 2 - 52 - ny;
					if (flipx) dx = -dx;
					if (flipy) dy = -dy;
					if (trans) {
						node.style.transform = trans + ' translate(' + dx + 'px,' + dy + 'px)';
					}
					else {
						node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
					}

					ui.arena.appendChild(node);
					ui.refresh(node);
					node.show();
					// node.style.transform=trans||'';
					lib.listenEnd(node);
					return node;
				},
				throwDice: function (num) {
					if (typeof num != 'number') {
						num = get.rand(6) + 1;
						_status.event.num = num;
					}
					if (!game.online) {
						game.pause();
					}
					game.broadcastAll(function (num) {
						var diceContainer = ui.create.div('.fullsize.dice-container', ui.window);
						ui.window.classList.add('dicepaused');
						var dice = ui.create.div('.dice');
						var side;

						side = ui.create.div('.side.front', dice);
						ui.create.div('.dot.center', side);
						ui.create.div('.side.front.inner', dice);

						side = ui.create.div('.side.top', dice);
						ui.create.div('.dot.dtop.dleft', side);
						ui.create.div('.dot.dbottom.dright', side);
						ui.create.div('.side.top.inner', dice);

						side = ui.create.div('.side.right', dice);
						ui.create.div('.dot.dtop.dleft', side);
						ui.create.div('.dot.center', side);
						ui.create.div('.dot.dbottom.dright', side);
						ui.create.div('.side.right.inner', dice);

						side = ui.create.div('.side.left', dice);
						ui.create.div('.dot.dtop.dleft', side);
						ui.create.div('.dot.dtop.dright', side);
						ui.create.div('.dot.dbottom.dleft', side);
						ui.create.div('.dot.dbottom.dright', side);
						ui.create.div('.side.left.inner', dice);

						side = ui.create.div('.side.bottom', dice);
						ui.create.div('.dot.center', side);
						ui.create.div('.dot.dtop.dleft', side);
						ui.create.div('.dot.dtop.dright', side);
						ui.create.div('.dot.dbottom.dleft', side);
						ui.create.div('.dot.dbottom.dright', side);
						ui.create.div('.side.bottom.inner', dice);

						side = ui.create.div('.side.back', dice);
						ui.create.div('.dot.dtop.dleft', side);
						ui.create.div('.dot.dtop.dright', side);
						ui.create.div('.dot.dbottom.dleft', side);
						ui.create.div('.dot.dbottom.dright', side);
						ui.create.div('.dot.center dleft', side);
						ui.create.div('.dot.center dright', side);
						ui.create.div('.side.back.inner', dice);

						ui.create.div('.side.cover.x', dice);
						ui.create.div('.side.cover.y', dice);
						ui.create.div('.side.cover.z', dice);

						var map = {
							1: [75, 0, 45],
							2: [-15, 45, 0],
							3: [165, -45, 90],
							4: [345, -45, 90],
							5: [345, -45, 180],
							6: [255, 0, 135]
						};
						dice.roll = function (deg) {
							if (typeof deg == 'number') {
								dice.current[0] += deg;
								deg = dice.current;
							}
							deg = deg.slice(0);
							dice.current = deg;
							this.style.transform = 'rotateX(' + deg[0] + 'deg) rotateY(' + deg[1] + 'deg) rotateZ(' + deg[2] + 'deg)';
						};
						dice.roll(map[num]);
						diceContainer.appendChild(dice);
						ui.refresh(dice);
						dice.roll(1025);

						dice.addEventListener('webkitTransitionEnd', function () {
							if (!dice.over) {
								dice.style.transition = 'transform 0.8s ease';
								dice.roll(-20);
								dice.over = true;
							}
							else if (!dice.resumed) {
								setTimeout(function () {
									diceContainer.delete();
									ui.window.classList.remove('dicepaused');
								}, 300);
								if (!game.online) {
									setTimeout(game.resume, 800);
								}
								dice.resumed = true;
							}
						});
					}, num);
				},
				$giveAuto: function (card, player) {
					if (Array.isArray(card) && card.length == 0) return;
					var args = Array.from(arguments);
					if (_status.connectMode || (!this.isUnderControl(true) && !player.isUnderControl(true))) {
						if (Array.isArray(card)) {
							card = card.length;
						}
						else {
							card = 1;
						}
						args[0] = card;
					}
					return this.$give.apply(this, args);
				},
				$give: function (card, player, log, init) {
					if (init !== false) {
						game.broadcast(function (source, card, player, init) {
							source.$give(card, player, false, init);
						}, this, card, player, init);
						if (typeof card == 'number' && card >= 0) {
							game.addVideo('give', this, [card, player.dataset.position]);
						}
						else {
							if (get.itemtype(card) == 'card') {
								card = [card];
							}
							if (get.itemtype(card) == 'cards') {
								game.addVideo('giveCard', this, [get.cardsInfo(card), player.dataset.position]);
							}
						}
					}
					if (get.itemtype(card) == 'cards') {
						if (log != false && !_status.video) {
							game.log(player, '从', this, '获得了', card);
						}
						if (this.$givemod) {
							this.$givemod(card, player);
						}
						else {
							for (var i = 0; i < card.length; i++) {
								this.$give(card[i], player, false, false);
							}
						}
					}
					else if (typeof card == 'number' && card >= 0) {
						if (log != false && !_status.video) {
							game.log(player, '从', this, '获得了' + get.cnNumber(card) + '张牌');
						}
						if (this.$givemod) {
							this.$givemod(card, player);
						}
						else {
							while (card--) this.$give('', player, false, false);
						}
					}
					else {
						if (log != false && !_status.video) {
							if (get.itemtype(card) == 'card' && log != false) {
								game.log(player, '从', this, '获得了', card);
							}
							else {
								game.log(player, '从', this, '获得了一张牌');
							}
						}
						if (this.$givemod) {
							this.$givemod(card, player);
						}
						else {
							var node;
							if (get.itemtype(card) == 'card') {
								node = card.copy('card', 'thrown', false);
							}
							else {
								node = ui.create.div('.card.thrown');
							}
							// node.dataset.position=this.dataset.position;
							node.fixed = true;
							this.$throwordered(node);
							// lib.listenEnd(node);
							// node.hide();
							// node.style.transitionProperty='left,top,opacity';
							//
							// node.style.transform='rotate('+(Math.random()*16-8)+'deg)';
							//
							// ui.arena.appendChild(node);
							// ui.refresh(node);
							// node.show();
							// node.style.left='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*100+'px)';
							// node.style.top='calc(50% - 52px '+((Math.random()-0.5<0)?'+':'-')+' '+Math.random()*80+'px)';

							node.listenTransition(function () {
								var dx = player.getLeft() + player.offsetWidth / 2 - 52 - node.offsetLeft;
								var dy = player.getTop() + player.offsetHeight / 2 - 52 - node.offsetTop;
								if (node.style.transform && node.style.transform != 'none' && node.style.transform.indexOf('translate') == -1) {
									node.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
								}
								else {
									node.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
								}

								node.delete();
							});
							// setTimeout(function(){
							// 	// node.removeAttribute('style');
							// 	// node.dataset.position=player.dataset.position;
							// 	var dx=player.offsetLeft+player.offsetWidth/2-52-node.offsetLeft;
							// 	var dy=player.offsetTop+player.offsetHeight/2-52-node.offsetTop;
							// 	if(node.style.transform&&node.style.transform!='none'&&node.style.transform.indexOf('translate')==-1){
							// 		node.style.transform+=' translate('+dx+'px,'+dy+'px)';
							// 	}
							// 	else{
							// 		node.style.transform='translate('+dx+'px,'+dy+'px)';
							// 	}
							//
							// 	node.delete();
							// },700);
						}
					}
				},
				$equip: function (card) {
					if (this.storage.disableEquip != undefined && this.storage.disableEquip.contains(get.subtype(card))) {
						this.gain(card, 'gain2');
						game.log(this, '装备失败');
					}
					else {
						game.broadcast(function (player, card) {
							player.$equip(card);
						}, this, card);
						card.fix();
						card.style.transform = '';
						card.classList.remove('drawinghidden');
						delete card._transform;
						var player = this;
						var equipNum = get.equipNum(card);
						var equipped = false;
						for (var i = 0; i < player.node.equips.childNodes.length; i++) {
							if (get.equipNum(player.node.equips.childNodes[i]) >= equipNum) {
								player.node.equips.insertBefore(card, player.node.equips.childNodes[i]);
								equipped = true;
								break;
							}
						}
						if (!equipped) {
							player.node.equips.appendChild(card);
							if (_status.discarded) {
								_status.discarded.remove(card);
							}
						}
						var info = get.info(card);
						if (info.skills) {
							for (var i = 0; i < info.skills.length; i++) {
								player.addSkillTrigger(info.skills[i]);
							}
						}
						return player;
					};
				},
				$gain: function (card, log, init) {
					if (init !== false) {
						game.broadcast(function (player, card, init) {
							player.$gain(card, false, init);
						}, this, card, init);
						if (typeof card == 'number' && card >= 0) {
							game.addVideo('gain', this, card);
						}
						else {
							if (get.itemtype(card) == 'card') {
								card = [card];
							}
							if (get.itemtype(card) == 'cards') {
								game.addVideo('gainCard', this, get.cardsInfo(card));
							}
							else {
								game.addVideo('gain', this, 1);
							}
						}
					}
					if (get.itemtype(card) == 'cards') {
						if (log != false && !_status.video) {
							game.log(this, '获得了', card);
						}
						if (this.$gainmod) {
							this.$gainmod(card);
						}
						else {
							for (var i = 0; i < card.length; i++) {
								this.$gain(card[i], false, false);
							}
						}
					}
					else if (typeof card == 'number' && card > 1) {
						if (log != false && !_status.video) {
							game.log(this, '获得了' + get.cnNumber(card) + '张牌');
						}
						if (this.$gainmod) {
							this.$gainmod(card);
						}
						else {
							for (var i = 0; i < card; i++) {
								this.$gain(1, false, false);
							}
						}
					}
					else {
						if (get.itemtype(card) == 'card' && log != false && !_status.video) {
							game.log(this, '获得了', card);
						}
						if (this.$gainmod) {
							this.$gainmod(card);
						}
						else {
							var node;
							if (get.itemtype(card) == 'card') {
								// node=this.$throwordered(card.copy(),true);
								node = card.copy('thrown', false);
							}
							else {
								// node=this.$throwordered(ui.create.div('.card.thrown'),true);
								node = ui.create.div('.card.thrown');
								node.moveTo = lib.element.card.moveTo;
								node.moveDelete = lib.element.card.moveDelete;
							}
							node.fixed = true;
							node.style.left = 'calc(50% - 52px ' + ((Math.random() - 0.5 < 0) ? '+' : '-') + ' ' + Math.random() * 100 + 'px)';
							node.style.top = 'calc(50% - 52px ' + ((Math.random() - 0.5 < 0) ? '+' : '-') + ' ' + Math.random() * 100 + 'px)';
							node.style.transform = 'scale(0)';
							node.hide();
							ui.arena.appendChild(node);
							ui.refresh(node);
							node.show();
							node.style.transform = '';

							lib.listenEnd(node);
							var player = this;
							setTimeout(function () {
								node.moveDelete(player);
							}, 700);
						}
					}
				},
				$gain2: function (cards, log) {
					if (log === true) {
						game.log(this, '获得了', cards);
					}
					game.broadcast(function (player, cards) {
						player.$gain2(cards);
					}, this, cards);
					if (get.itemtype(cards) == 'card') cards = [cards];
					else if (get.itemtype(cards) != 'cards') return;
					var list = [], list2 = [];
					for (var i = 0; i < cards.length; i++) {
						if (cards[i].clone &&
							(cards[i].clone.parentNode == this.parentNode ||
								cards[i].clone.parentNode == ui.arena) &&
							parseFloat(getComputedStyle(cards[i].clone).opacity) > 0.3) {
							cards[i].clone.moveDelete(this);
							list2.push(cards[i].clone);
						}
						else {
							list.push(cards[i]);
						}
					}
					if (list2.length) {
						game.addVideo('gain2', this, get.cardsInfo(list2));
					}
					if (list.length) {
						this.$draw(list, 'nobroadcast');
						return true;
					}
				},
				$skill: function (name, type, color, avatar) {
					if (typeof type != 'string') type = 'legend';
					if (!avatar) {
						this.playerfocus(1500);
						game.delay(2);
					}
					else {
						game.addVideo('playerfocus2');
						game.broadcastAll(function () {
							ui.arena.classList.add('playerfocus');
							setTimeout(function () {
								ui.arena.classList.remove('playerfocus');
							}, 1800)
						});
						game.delay(3);
					}
					var that = this;
					setTimeout(function () {
						game.broadcastAll(function (that, type, name, color, avatar) {
							if (lib.config.animation && !lib.config.low_performance) {
								if (game.chess) {
									that['$' + type + '2'](1200);
								}
								else {
									that['$' + type](1200);
								}
							}
							if (name) {
								that.$fullscreenpop(name, color, avatar);
							}
						}, that, type, name, color, avatar);
					}, avatar ? 0 : 300);
				},
				$fire: function () {
					game.addVideo('flame', this, 'fire');
					var left, top;
					if (game.chess) {
						var rect = this.getBoundingClientRect();
						left = rect.left;
						top = rect.top;
					}
					else {
						left = this.getLeft();
						top = this.getTop();
					}
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 20, 700, 'fire');
				},
				$thunder: function () {
					game.addVideo('flame', this, 'thunder');
					var left, top;
					if (game.chess) {
						var rect = this.getBoundingClientRect();
						left = rect.left;
						top = rect.top;
					}
					else {
						left = this.getLeft();
						top = this.getTop();
					}
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, 700, 'thunder');
				},
				$rare2: function () {
					game.addVideo('flame', this, 'rare2');
					var rect = this.getBoundingClientRect();
					var left = rect.left;
					var top = rect.top + 15;
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, 700, 'rare');
				},
				$epic2: function () {
					game.addVideo('flame', this, 'epic2');
					var rect = this.getBoundingClientRect();
					var left = rect.left;
					var top = rect.top + 15;
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, 700, 'epic');
				},
				$legend2: function () {
					game.addVideo('flame', this, 'legend2');
					var rect = this.getBoundingClientRect();
					var left = rect.left;
					var top = rect.top + 15;
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, 700, 'legend');
				},
				$rare: function (time) {
					time = time || 700;
					game.addVideo('flame', this, 'rare');
					var left, top;
					if (game.chess) {
						left = this.getLeft() - ui.arena.offsetLeft;
						top = this.getTop() - ui.arena.offsetTop;
					}
					else {
						left = this.getLeft();
						top = this.getTop();
					}
					if (this.classList.contains('minskin')) {
						top += 15;
					}
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, time, 'rare');
				},
				$epic: function (time) {
					time = time || 700;
					game.addVideo('flame', this, 'epic');
					var left, top;
					if (game.chess) {
						left = this.getLeft() - ui.arena.offsetLeft;
						top = this.getTop() - ui.arena.offsetTop;
					}
					else {
						left = this.getLeft();
						top = this.getTop();
					}
					if (this.classList.contains('minskin')) {
						top += 15;
					}
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, time, 'epic');
				},
				$legend: function (time) {
					time = time || 700;
					game.addVideo('flame', this, 'legend');
					var left, top;
					if (game.chess) {
						left = this.getLeft() - ui.arena.offsetLeft;
						top = this.getTop() - ui.arena.offsetTop;
					}
					else {
						left = this.getLeft();
						top = this.getTop();
					}
					if (this.classList.contains('minskin')) {
						top += 15;
					}
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, time, 'legend');
				},
				$coin: function () {
					game.broadcast(function (player) {
						if (!lib.config.low_performance) {
							player.$coin();
						}
					}, this);
					game.addVideo('flame', this, 'coin');
					var left = this.getLeft() - ui.arena.offsetLeft;
					var top = this.getTop() - ui.arena.offsetTop;
					if (this.classList.contains('minskin')) {
						top += 15;
					}
					top -= 25;
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, 700, 'coin');
				},
				$dust: function () {
					game.broadcast(function (player) {
						if (!lib.config.low_performance) {
							player.$dust();
						}
					}, this);
					game.addVideo('flame', this, 'dust');
					var left = this.getLeft() - ui.arena.offsetLeft;
					var top = this.getTop() - ui.arena.offsetTop;
					if (this.classList.contains('minskin')) {
						top += 15;
					}
					top -= 25;
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, 700, 'dust');
				},
				$recover: function () {
					game.addVideo('flame', this, 'recover');
					var left, top;
					if (game.chess) {
						var rect = this.getBoundingClientRect();
						left = rect.left;
						top = rect.top;
					}
					else {
						left = this.getLeft();
						top = this.getTop();
					}
					game.animate.flame(left + this.offsetWidth / 2,
						top + this.offsetHeight - 30, 700, 'recover');
				},
				$fullscreenpop: function (str, nature, avatar) {
					game.broadcast(function (player, str, nature, avatar) {
						player.$fullscreenpop(str, nature, avatar);
					}, this, str, nature, avatar);
					game.addVideo('fullscreenpop', this, [str, nature, avatar]);
					var node = ui.create.div('.damage');
					if (avatar && this.node) {
						if (avatar == 'vice') {
							if (lib.character[this.name2]) {
								avatar = this.node.avatar2;
							}
						}
						else {
							if (lib.character[this.name]) {
								avatar = this.node.avatar;
							}
						}
						if (!get.is.div(avatar)) {
							avatar = false;
						}
					}
					else {
						avatar = false;
					}
					if (avatar) {
						node.classList.add('fullscreenavatar');
						ui.create.div('', ui.create.div(node));
						// ui.create.div('',str.split('').join('<br>'),ui.create.div('.text.textbg',node));
						ui.create.div('', '<div>' + str.split('').join('</div><br><div>') + '</div>', ui.create.div('.text', node));
						node.firstChild.firstChild.style.backgroundImage = avatar.style.backgroundImage;
						node.dataset.nature = nature || 'unknown';
						var num = 0;
						var nodes = node.lastChild.firstChild.querySelectorAll('div');
						var interval = setInterval(function () {
							if (num < nodes.length) {
								nodes[num].classList.add('flashtext');
								num++;
							}
							else {
								clearInterval(interval);
							}
						}, 100);
					}
					else {
						avatar = false;
						node.innerHTML = str;
						node.dataset.nature = nature || 'soil';
					}
					if (avatar) {
						var rect1 = ui.window.getBoundingClientRect();
						var rect2 = this.getBoundingClientRect();
						var dx = Math.round(2 * rect2.left + rect2.width - rect1.width);
						var dy = Math.round(2 * rect2.top + rect2.height - rect1.height);
						node.style.transform = 'scale(0.5) translate(' + dx + 'px,' + dy + 'px)';
					}
					ui.window.appendChild(node);
					ui.refresh(node);
					if (avatar) {
						node.style.transform = 'scale(1)';
						node.style.opacity = 1;
					}
					else {
						node.classList.add('damageadded');
					}
					setTimeout(function () {
						node.delete();
						node.style.transform = 'scale(1.5)'
					}, avatar ? 1600 : 1000);
				},
				$damagepop: function (num, nature, font, nobroadcast) {
					if (typeof num == 'number' || typeof num == 'string') {
						game.addVideo('damagepop', this, [num, nature, font]);
						if (nobroadcast !== false) game.broadcast(function (player, num, nature, font) {
							player.$damagepop(num, nature, font);
						}, this, num, nature, font);
						var node = ui.create.div('.damage');
						if (font) {
							node.classList.add('normal-font');
						}
						if (typeof num == 'number' && num > 0) {
							if (num == Infinity) num = '+∞'
							else num = '+' + num;
						}
						else if (num == -Infinity) num = '-∞';
						node.innerHTML = num;
						this.damagepopups.push(node);
						node.dataset.nature = nature || 'soil';
						if (this.damagepopups.length == 1) {
							this.$damagepop();
						}
					}
					else if (this.damagepopups.length) {
						var node = this.damagepopups[0];
						this.appendChild(node);
						ui.refresh(node);
						node.classList.add('damageadded');
						node.listenTransition(function () {
							setTimeout(function () {
								node.delete();
							}, 200);
						});
						// setTimeout(function(){
						// 	node.delete();
						// },500);
						var that = this;
						setTimeout(function () {
							that.damagepopups.shift();
							that.$damagepop();
						}, 500);
					}
				},
				$damage: function (source) {
					if (get.itemtype(source) == 'player') {
						game.addVideo('damage', this, source.dataset.position);
					}
					else {
						game.addVideo('damage', this);
					}
					game.broadcast(function (player, source) {
						player.$damage(source);
					}, this, source);
					if (source && source != this && lib.config.damage_shake) {
						var left, top;
						if (source.getTop() == this.getTop()) {
							left = 20;
							top = 0;
						}
						else {
							var ratio = (source.getLeft() - this.getLeft()) / (source.getTop() - this.getTop());
							left = Math.abs(20 * ratio / Math.sqrt(1 + ratio * ratio));
							top = Math.abs(20 / Math.sqrt(1 + ratio * ratio));
						}
						if (source.getLeft() - this.getLeft() > 0) left = -left;
						if (source.getTop() - this.getTop() > 0) top = -top;
						if (get.is.mobileMe(this)) {
							if (this.classList.contains('linked')) {
								this.node.avatar.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
								this.node.avatar2.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
							}
							else {
								this.node.avatar.style.transform = 'translate(' + left + 'px,' + top + 'px)';
								this.node.avatar2.style.transform = 'translate(' + left + 'px,' + top + 'px)';
							}
						}
						else if (this.classList.contains('linked') && get.is.newLayout()) {
							this.style.transform = 'translate(' + left + 'px,' + top + 'px) rotate(-90deg)';
						}
						else if (this._chesstransform) {
							this.style.transform = 'translate(' + (left + this._chesstransform[0]) + 'px,' + (top + this._chesstransform[1]) + 'px)';
						}
						else {
							this.style.transform = 'translate(' + left + 'px,' + top + 'px)';
						}
					}
					else {
						var zoom1 = 0.9, zoom2 = 0.95;
						if (arguments[1] == 'phase') {
							zoom1 = 1.05;
							zoom2 = 1.05;
						}
						if (get.is.mobileMe(this)) {
							if (this.classList.contains('linked')) {
								this.node.avatar.style.transform = 'scale(' + zoom1 + ') rotate(-90deg)';
								this.node.avatar2.style.transform = 'scale(' + zoom1 + ') rotate(-90deg)';
							}
							else {
								this.node.avatar.style.transform = 'scale(' + zoom1 + ')';
								this.node.avatar2.style.transform = 'scale(' + zoom1 + ')';
							}
						}
						else if (this.classList.contains('linked') && get.is.newLayout()) {
							this.style.transform = 'scale(' + zoom2 + ') rotate(-90deg)';
						}
						else if (game.chess && this._chesstransform) {
							this.style.transform = 'translate(' + this._chesstransform[0] + 'px,' + this._chesstransform[1] + 'px) scale(' + zoom2 + ')';
						}
						else {
							this.style.transform = 'scale(' + zoom2 + ')';
						}
					}
					this.queue();
				},
				$die: function () {
					game.addVideo('die', this);
					game.broadcast(function (player) {
						player.$die();
					}, this);
					if (lib.config.die_move != 'off') {
						this.$dieflip(lib.config.die_move);
					}
					if (lib.element.player.$dieAfter) {
						lib.element.player.$dieAfter.call(this);
					}
				},
				$dieflip: function (type) {
					var top0 = ui.window.offsetHeight / 2;
					var left0 = ui.window.offsetWidth / 2;
					var ratio = (left0 - this.getLeft()) / (top0 - this.getTop());
					var left = Math.abs(50 * ratio / Math.sqrt(1 + ratio * ratio));
					var top = Math.abs(50 / Math.sqrt(1 + ratio * ratio));
					if (left0 - this.getLeft() > 0) left = -left;
					if (top0 - this.getTop() > 0) top = -top;
					if (get.is.mobileMe(this)) {
						left = -Math.random() * 5 - 10;
						top = Math.random() * 5 + 10;
					}
					if (this._chesstransform) {
						left += this._chesstransform[0];
						top += this._chesstransform[1];
					}
					var transform = 'translate(' + left + 'px,' + top + 'px) ' +
						'rotate(' + (Math.random() * 20 - 10) + 'deg) ';
					if (type == 'flip') {
						if (game.layout == 'long' || game.layout == 'long2') {
							transform += 'rotateY(180deg)';
						}
						else {
							transform += ((Math.random() - 0.5 < 0) ? 'rotateX(180deg)' : 'rotateY(180deg)');
						}
					}
					if (get.is.mobileMe(this)) {
						this.node.avatar.style.transform = transform;
						this.node.avatar2.style.transform = transform;
						this.style.transform = '';
					}
					else {
						this.node.avatar.style.transform = '';
						this.node.avatar2.style.transform = '';
						this.style.transform = transform;
					}
					this.queue(false);
				},
				$phaseJudge: function (card) {
					game.addVideo('phaseJudge', this, get.cardInfo(card));
					var player = this;
					var clone = player.$throw(card);
					if (lib.config.low_performance && card && card.clone) {
						var waitingForTransition = get.time();
						_status.waitingForTransition = waitingForTransition;
						card.clone.listenTransition(function () {
							if (_status.waitingForTransition == waitingForTransition && _status.paused) {
								game.resume();
							}
						});
						game.pause();
					}
					else {
						game.delay();
					}
				}
			},
			card: {
				init: function (card) {
					if (Array.isArray(card)) {
						if (card[2] == 'huosha') {
							card[2] = 'sha';
							card[3] = 'fire';
						}
						if (card[2] == 'leisha') {
							card[2] = 'sha';
							card[3] = 'thunder';
						}
						if (card[2] == 'kamisha') {
							card[2] = 'sha';
							card[3] = 'kami';
						}
					}
					else if (typeof card == 'object') {
						card = [card.suit, card.number, card.name, card.nature];
					}
					var cardnum = card[1] || '';
					if (parseInt(cardnum) == cardnum) cardnum = parseInt(cardnum);
					if ([1, 11, 12, 13].contains(cardnum)) {
						cardnum = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K' }[cardnum];
					}
					if (!lib.card[card[2]]) {
						lib.card[card[2]] = {};
					}
					var info = lib.card[card[2]];
					if (info.global && !this.classList.contains('button')) {
						if (Array.isArray(info.global)) {
							while (info.global.length) {
								game.addGlobalSkill(info.global.shift());
							}
						}
						else if (typeof info.global == 'string') {
							game.addGlobalSkill(info.global);
						}
						delete info.global;
					}
					if (this.name) {
						this.classList.remove('epic');
						this.classList.remove('legend');
						this.classList.remove('gold');
						this.classList.remove('unique');
						this.style.background = '';
						var subtype = get.subtype(this);
						if (subtype) {
							this.classList.remove(subtype);
						}
					}
					if (info.epic) {
						this.classList.add('epic');
					}
					else if (info.legend) {
						this.classList.add('legend');
					}
					else if (info.gold) {
						this.classList.add('gold');
					}
					else if (info.unique) {
						this.classList.add('unique');
					}
					var bg = card[2];
					if (info.cardimage) {
						bg = info.cardimage;
					}
					var img = lib.card[bg].image;
					if (img) {
						if (img.indexOf('db:') == 0) {
							img = img.slice(3);
						}
						else if (img.indexOf('ext:') != 0) {
							img = null;
						}
					}
					this.classList.remove('fullskin');
					this.classList.remove('fullimage');
					this.classList.remove('fullborder');
					this.dataset.cardName = card[2];
					this.dataset.cardType = info.type || '';
					this.dataset.cardSubype = info.subtype || '';
					this.dataset.cardMultitarget = info.multitarget ? '1' : '0';
					this.node.name.dataset.nature = '';
					this.node.info.classList.remove('red');
					if (!lib.config.hide_card_image && lib.card[bg].fullskin) {
						this.classList.add('fullskin');
						if (img) {
							if (img.indexOf('ext:') == 0) {
								this.node.image.setBackgroundImage(img.replace(/ext:/, 'extension/'));
							}
							else {
								this.node.image.setBackgroundDB(img);
							}
						}
						else {
							if (lib.card[bg].modeimage) {
								this.node.image.setBackgroundImage('image/mode/' + lib.card[bg].modeimage + '/card/' + bg + '.png');
							}
							else {
								this.node.image.setBackgroundImage('image/card/' + bg + '.png');
							}
						}
					}
					else if (lib.card[bg].image == 'background') {
						if (card[3]) this.node.background.setBackground(bg + '_' + card[3], 'card');
						else this.node.background.setBackground(bg, 'card');
					}
					else if (lib.card[bg].fullimage) {
						this.classList.add('fullimage');
						if (img) {
							if (img.indexOf('ext:') == 0) {
								this.setBackgroundImage(img.replace(/ext:/, 'extension/'));
								this.style.backgroundSize = 'cover';
							}
							else {
								this.setBackgroundDB(img);
							}
						}
						else if (lib.card[bg].image) {
							if (lib.card[bg].image.indexOf('character:') == 0) {
								this.setBackground(lib.card[bg].image.slice(10), 'character');
							}
							else {
								this.setBackground(lib.card[bg].image);
							}
						}
						else {
							var cardPack = lib.cardPack['mode_' + get.mode()];
							if (Array.isArray(cardPack) && cardPack.contains(bg)) {
								this.setBackground('mode/' + get.mode() + '/card/' + bg);
							}
							else {
								this.setBackground('card/' + bg);
							}
						}
					}
					else if (lib.card[bg].fullborder) {
						this.classList.add('fullborder');
						if (lib.card[bg].fullborder == 'gold') {
							this.node.name.dataset.nature = 'metalmm';
						}
						else if (lib.card[bg].fullborder == 'silver') {
							this.node.name.dataset.nature = 'watermm';
						}
						if (!this.node.avatar) {
							this.node.avatar = ui.create.div('.cardavatar');
							this.insertBefore(this.node.avatar, this.firstChild);
						}
						if (!this.node.framebg) {
							this.node.framebg = ui.create.div('.cardframebg');
							this.node.framebg.dataset.auto = lib.card[bg].fullborder;
							this.insertBefore(this.node.framebg, this.firstChild);
						}
						if (img) {
							if (img.indexOf('ext:') == 0) {
								this.node.avatar.setBackgroundImage(img.replace(/ext:/, 'extension/'));
								this.node.avatar.style.backgroundSize = 'cover';
							}
							else {
								this.node.avatar.setBackgroundDB(img);
							}
						}
						else if (lib.card[bg].image) {
							if (lib.card[bg].image.indexOf('character:') == 0) {
								this.node.avatar.setBackground(lib.card[bg].image.slice(10), 'character');
							}
							else {
								this.node.avatar.setBackground(lib.card[bg].image);
							}
						}
						else {
							var cardPack = lib.cardPack['mode_' + get.mode()];
							if (Array.isArray(cardPack) && cardPack.contains(bg)) {
								this.node.avatar.setBackground('mode/' + get.mode() + '/card/' + bg);
							}
							else {
								this.node.avatar.setBackground('card/' + bg);
							}
						}
					}
					else if (lib.card[bg].image == 'card') {
						if (card[3]) this.setBackground(bg + '_' + card[3], 'card');
						else this.setBackground(bg, 'card');
					}
					else if (typeof lib.card[bg].image == 'string' && !lib.card[bg].fullskin) {
						if (img) {
							if (img.indexOf('ext:') == 0) {
								this.setBackgroundImage(img.replace(/ext:/, 'extension/'));
								this.style.backgroundSize = 'cover';
							}
							else {
								this.setBackgroundDB(img);
							}
						}
						else {
							this.setBackground(lib.card[bg].image);
						}
					}
					else {
						this.node.background.innerHTML = lib.translate[bg + '_cbg'] || lib.translate[bg + '_bg'] || get.translation(bg)[0];
						// this.node.background.style.fontFamily=lib.config.card_font;
						if (this.node.background.innerHTML.length > 1) this.node.background.classList.add('tight');
						else this.node.background.classList.remove('tight');
					}
					if (!lib.card[bg].fullborder && this.node.avatar && this.node.framebg) {
						this.node.avatar.remove();
						this.node.framebg.remove();
						delete this.node.avatar;
						delete this.node.framebg;
					}
					if (info.noname && !this.classList.contains('button')) {
						this.node.name.style.display = 'none';
					}
					if (info.color) {
						this.style.color = info.color;
					}
					if (info.textShadow) {
						this.style.textShadow = info.textShadow;
					}
					if (info.opacity) {
						this.node.info.style.opacity = info.opacity;
						this.node.name.style.opacity = info.opacity;
					}
					if (info.modinfo) {
						this.node.info.innerHTML = info.modinfo;
					}
					else {
						this.node.info.innerHTML = get.translation(card[0]) + '<span> </span>' + cardnum;
					}
					if (info.addinfo) {
						if (!this.node.addinfo) {
							this.node.addinfo = ui.create.div('.range', this);
						}
						this.node.addinfo.innerHTML = info.addinfo;
					}
					else if (this.node.addinfo) {
						this.node.addinfo.remove();
						delete this.node.addinfo;
					}
					if (card[0] == 'heart' || card[0] == 'diamond') {
						this.node.info.classList.add('red');
					}
					this.node.name.innerHTML = '';
					this.node.image.className = 'image';
					var name = get.translation(card[2]);
					if (card[2] == 'sha') {
						if (card[3] == 'fire') {
							name = '火' + name;
							this.node.image.classList.add('fire');
						}
						else if (card[3] == 'thunder') {
							name = '雷' + name;
							this.node.image.classList.add('thunder');
						}
						else if (card[3] == 'kami') {
							name = '神' + name;
							this.node.image.classList.add('kami');
						}
					}
					for (var i = 0; i < name.length; i++) {
						this.node.name.innerHTML += name[i] + '<br/>';
					}
					if (name.length >= 5) {
						this.node.name.classList.add('long');
						if (name.length >= 7) {
							this.node.name.classList.add('longlong');
						}
					}
					this.node.name2.innerHTML = get.translation(card[0]) + cardnum + ' ' + name;
					this.suit = card[0];
					this.number = parseInt(card[1]) || 0;
					this.name = card[2];
					this.classList.add('card');
					if (card[3]) {
						if (lib.nature.contains(card[3])) this.nature = card[3];
						this.classList.add(card[3]);
					}
					else if (this.nature) {
						this.classList.remove(this.nature);
						delete this.nature;
					}
					if (info.subtype) this.classList.add(info.subtype);
					if (this.inits) {
						for (var i = 0; i < lib.element.card.inits.length; i++) {
							lib.element.card.inits[i](this);
						}
					}
					if (typeof info.init == 'function') info.init();
					this.node.range.innerHTML = '';
					switch (get.subtype(this)) {
						case 'equip1':
							var added = false;
							if (lib.card[this.name] && lib.card[this.name].distance) {
								var dist = lib.card[this.name].distance;
								if (dist.attackFrom) {
									added = true;
									this.node.range.innerHTML = '范围: ' + (-dist.attackFrom + 1);
								}
							}
							if (!added) {
								this.node.range.innerHTML = '范围: 1';
							}
							break;
						case 'equip3':
							if (info.distance && info.distance.globalTo) {
								this.node.range.innerHTML = '防御: ' + info.distance.globalTo;
								this.node.name2.innerHTML += '+';
							}
							break;
						case 'equip4':
							if (info.distance && info.distance.globalFrom) {
								this.node.range.innerHTML = '进攻: ' + (-info.distance.globalFrom);
								this.node.name2.innerHTML += '-';
							}
							break;
					}
					if (_status.connectMode && !game.online && lib.cardOL && !this.cardid) {
						this.cardid = get.id();
						lib.cardOL[this.cardid] = this;
					}
					if (!_status.connectMode && !_status.video) {
						this.cardid = get.id();
					}
					var tags = [];
					if (Array.isArray(card[4])) {
						tags.addArray(card[4]);
					}
					if (this.cardid) {
						if (!_status.cardtag) {
							_status.cardtag = {};
						}
						for (var i in _status.cardtag) {
							if (_status.cardtag[i].contains(this.cardid)) {
								tags.add(i);
							}
						}
						if (tags.length) {
							var tagstr = ' <span class="cardtag">';
							for (var i = 0; i < tags.length; i++) {
								var tag = tags[i];
								if (!_status.cardtag[tag]) {
									_status.cardtag[tag] = [];
								}
								_status.cardtag[tag].add(this.cardid);
								tagstr += lib.translate[tag + '_tag'];
							}
							tagstr += '</span>';
							this.node.range.innerHTML += tagstr;
						}
					}
					return this;
				},
				updateTransform: function (bool, delay) {
					if (delay) {
						var that = this;
						setTimeout(function () {
							that.updateTransform(that.classList.contains('selected'));
						}, delay);
					}
					else {
						if (_status.event.player != game.me) return;
						if (this._transform && this.parentNode && this.parentNode.parentNode &&
							this.parentNode.parentNode.parentNode == ui.me &&
							(!_status.mousedown || _status.mouseleft) &&
							(!this.parentNode.parentNode.classList.contains('scrollh') || (game.layout == 'long2' || game.layout == 'nova'))) {
							if (bool) {
								this.style.transform = this._transform + ' translateY(-20px)';
							}
							else {
								this.style.transform = this._transform || '';
							}
						}
					}
				},
				aiexclude: function () {
					_status.event._aiexclude.add(this);
				},
				getSource: function (name) {
					if (this.name == name) return true;
					var info = lib.card[this.name];
					if (info && Array.isArray(info.source)) {
						return info.source.contains(name);
					}
					return false;
				},
				moveDelete: function (player) {
					this.fixed = true;
					if (!this._listeningEnd || this._transitionEnded) {
						this.moveTo(player);
						var that = this;
						setTimeout(function () {
							that.delete();
						}, 200);
					}
					else {
						this._onEndMoveDelete = player;
					}
				},
				moveTo: function (player) {
					this.fixed = true;
					var dx, dy;
					if (this.classList.contains('center')) {
						var nx = [50, -52];
						var ny = [50, -52];
						nx = nx[0] * ui.arena.offsetWidth / 100 + nx[1];
						ny = ny[0] * ui.arena.offsetHeight / 100 + ny[1];
						dx = player.getLeft() + player.offsetWidth / 2 - 52 - nx;
						dy = player.getTop() + player.offsetHeight / 2 - 52 - ny;
					}
					else {
						this.style.left = this.offsetLeft + 'px';
						this.style.top = this.offsetTop + 'px';

						dx = player.getLeft() + player.offsetWidth / 2 - 52 - this.offsetLeft;
						dy = player.getTop() + player.offsetHeight / 2 - 52 - this.offsetTop;
					}
					if (get.is.mobileMe(player)) {
						dx += get.cardOffset();
						if (ui.arena.classList.contains('oblongcard')) {
							dy -= 16;
						}
					}


					if (this.style.transform && this.style.transform != 'none' && this.style.transform.indexOf('translate') == -1) {
						this.style.transform += ' translate(' + dx + 'px,' + dy + 'px)';
					}
					else {
						this.style.transform = 'translate(' + dx + 'px,' + dy + 'px)';
					}
					return this;
				},
				copy: function () {
					var node = this.cloneNode(true);
					node.style.transform = '';
					node.name = this.name;
					node.suit = this.suit;
					node.number = this.number;
					node.classList.remove('hidden');
					node.classList.remove('start');
					node.classList.remove('thrown');
					node.classList.remove('selectable');
					node.classList.remove('selected');
					node.classList.remove('removing');
					node.classList.remove('drawinghidden');
					node.node = {
						name: node.querySelector('.name'),
						info: node.querySelector('.info'),
						intro: node.querySelector('.intro'),
						background: node.querySelector('.background'),
						image: node.querySelector('.image'),
					}
					var clone = true;
					var position;
					for (var i = 0; i < arguments.length; i++) {
						if (typeof arguments[i] == 'string') node.classList.add(arguments[i]);
						else if (get.objtype(arguments[i]) == 'div') position = arguments[i];
						else if (typeof arguments[i] == 'boolean') clone = arguments[i];
					}
					node.moveTo = lib.element.card.moveTo;
					node.moveDelete = lib.element.card.moveDelete;
					if (clone) this.clone = node;
					if (position) position.appendChild(node);
					return node;
				},
				uncheck: function (skill) {
					if (skill) this._uncheck.add(skill);
					this.classList.add('uncheck');
				},
				recheck: function (skill) {
					if (skill) this._uncheck.remove(skill);
					else this._uncheck.length = 0;
					if (this._uncheck.length == 0) this.classList.remove('uncheck');
				},
				discard: function (bool) {
					if (!this.destroyed) {
						ui.discardPile.appendChild(this);
					}
					this.fix();
					this.classList.remove('glow');
					if (bool === false) {
						ui.cardPile.insertBefore(this, ui.cardPile.childNodes[Math.floor(Math.random() * ui.cardPile.childNodes.length)]);
					}
					else {
						if (_status.discarded) {
							_status.discarded.add(this);
						}
					}
				},
				hasTag: function (tag) {
					if (this.cardid && _status.cardtag && _status.cardtag[tag] && _status.cardtag[tag].contains(this.cardid)) {
						return true;
					}
					return false;
				},
				hasPosition: function () {
					return ['h', 'e', 'j'].contains(get.position(this));
				},
				isInPile: function () {
					return ['c', 'd'].contains(get.position(this));
				}
			},
			button: {
				exclude: function () {
					if (_status.event.excludeButton == undefined) {
						_status.event.excludeButton = [];
					}
					_status.event.excludeButton.add(this);
				}
			},
			event: {
				changeToZero: function () {
					this.num = 0;
					this.numFixed = true;
				},
				finish: function () {
					this.finished = true;
				},
				cancel: function (arg1, arg2, notrigger) {
					this.untrigger.call(this, arguments);
					this.finish();
					if (notrigger != 'notrigger') {
						this.trigger(this.name + 'Cancelled');
						if (this.player && lib.phaseName.contains(this.name)) this.player.getHistory('skipped').add(this.name)
					}
				},
				goto: function (step) {
					this.step = step - 1;
				},
				redo: function () {
					this.step--;
				},
				set: function (key, value) {
					if (arguments.length == 1 && Array.isArray(arguments[0])) {
						for (var i = 0; i < arguments[0].length; i++) {
							if (Array.isArray(arguments[0][i])) {
								this.set(arguments[0][i][0], arguments[0][i][1]);
							}
						}
					}
					else {
						if (typeof key != 'string') {
							console.log('warning: using non-string object as event key');
							console.log(key, value);
							console.log(_status.event);
						}
						this[key] = value;
						this._set.push([key, value]);
					}
					return this;
				},
				setContent: function (name) {
					if (typeof name == 'function') {
						this.content = lib.init.parse(name);
					}
					else {
						if (!lib.element.content[name]._parsed) {
							lib.element.content[name] = lib.init.parse(lib.element.content[name]);
							lib.element.content[name]._parsed = true;
						}
						this.content = lib.element.content[name];
					}
					return this;
				},
				getLogv: function () {
					for (var i = 1; i <= 3; i++) {
						var event = this.getParent(i);
						if (event && event.logvid) return event.logvid;
					}
					return null;
				},
				send: function () {
					this.player.send(function (name, args, set, event, skills) {
						game.me.applySkills(skills);
						var next = game.me[name].apply(game.me, args);
						for (var i = 0; i < set.length; i++) {
							next.set(set[i][0], set[i][1]);
						}
						if (next._backupevent) {
							next.backup(next._backupevent);
						}
						next._modparent = event;
						game.resume();
					}, this.name, this._args || [], this._set,
						get.stringifiedResult(this.parent, 3), get.skillState(this.player));
					this.player.wait();
					game.pause();
				},
				resume: function () {
					delete this._cardChoice;
					delete this._targetChoice;
					delete this._skillChoice;
				},
				getParent: function (level, forced) {
					var parent;
					if (this._modparent && game.online) {
						parent = this._modparent;
					}
					else {
						parent = this.parent;
					}
					var toreturn = {};
					if (typeof level == 'string' && forced == true) {
						toreturn = null;
					}
					if (!parent) return toreturn;
					if (typeof level == 'number') {
						for (var i = 1; i < level; i++) {
							if (!parent) return toreturn;
							parent = parent.parent;
						}
					}
					else if (typeof level == 'string') {
						for (var i = 0; i < 20; i++) {
							if (!parent) return toreturn;
							if (parent.name == level) return parent;
							parent = parent.parent;
						}
						if (!parent) return toreturn;
					}
					if (toreturn === null) {
						return null;
					}
					return parent;
				},
				getTrigger: function () {
					return this.getParent()._trigger;
				},
				getRand: function () {
					if (!this._rand) this._rand = Math.random();
					return this._rand;
				},
				insert: function (func, map) {
					var next = game.createEvent(this.name + 'Inserted', false, this);
					next.setContent(func);
					for (var i in map) {
						next.set(i, map[i]);
					}
					return next;
				},
				insertAfter: function (func, map) {
					var next = game.createEvent(this.name + 'Inserted', false, { next: [] });
					this.after.push(next);
					next.setContent(func);
					for (var i in map) {
						next.set(i, map[i]);
					}
					return next;
				},
				backup: function (skill) {
					this._backup = {
						filterButton: this.filterButton,
						selectButton: this.selectButton,
						filterTarget: this.filterTarget,
						selectTarget: this.selectTarget,
						filterCard: this.filterCard,
						selectCard: this.selectCard,
						position: this.position,
						forced: this.forced,
						fakeforce: this.fakeforce,
						_aiexclude: this._aiexclude,
						complexSelect: this.complexSelect,
						complexCard: this.complexCard,
						complexTarget: this.complexTarget,
						_cardChoice: this._cardChoice,
						_targetChoice: this._targetChoice,
						_skillChoice: this._skillChoice,
						ai1: this.ai1,
						ai2: this.ai2,
					}
					if (skill) {
						var info = get.info(skill);
						this.skill = skill;
						this._aiexclude = [];
						if (typeof info.viewAs == 'function') {
							if (info.filterButton != undefined) this.filterButton = get.filter(info.filterButton);
							if (info.selectButton != undefined) this.selectButton = info.selectButton;
							if (info.filterTarget != undefined) this.filterTarget = get.filter(info.filterTarget);
							if (info.selectTarget != undefined) this.selectTarget = info.selectTarget;
							if (info.filterCard != undefined) {
								if (info.ignoreMod) this.ignoreMod = true;
								this.filterCard2 = get.filter(info.filterCard);
								this.filterCard = function (card, player, event) {
									var evt = event || _status.event;
									if (!evt.ignoreMod && player) {
										var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
										if (mod != 'unchanged') return mod;
										if (evt._backup && evt._backup.filterCard) {
											var cardx2 = lib.skill[evt.skill].viewAs(ui.selected.cards.concat([card]), player);
											if (get.is.object(cardx2)) {
												var cardx = get.autoViewAs(cardx2, ui.selected.cards.concat([card]));
												if (!get.filter(evt._backup.filterCard)(cardx, player, evt)) return false;
											}
										}
									}
									return get.filter(evt.filterCard2).apply(this, arguments);
								};
							}
							if (info.selectCard != undefined) this.selectCard = info.selectCard;
							if (info.position != undefined) this.position = info.position;
							if (info.forced != undefined) this.forced = info.forced;
							if (info.complexSelect != undefined) this.complexSelect = info.complexSelect;
							if (info.complexCard != undefined) this.complexCard = info.complexCard;
							if (info.complexTarget != undefined) this.complexTarget = info.complexTarget;
							if (info.ai1 != undefined) this.ai1 = info.ai1;
							if (info.ai2 != undefined) this.ai2 = info.ai2;
						}
						else if (info.viewAs) {
							if (info.filterButton != undefined) this.filterButton = get.filter(info.filterButton);
							if (info.selectButton != undefined) this.selectButton = info.selectButton;
							if (info.filterTarget != undefined) this.filterTarget = get.filter(info.filterTarget);
							if (info.selectTarget != undefined) this.selectTarget = info.selectTarget;
							if (info.filterCard != undefined) {
								if (info.ignoreMod) this.ignoreMod = true;
								this.filterCard2 = get.filter(info.filterCard);
								this.filterCard = function (card, player, event) {
									var evt = event || _status.event;
									if (!evt.ignoreMod && player) {
										var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
										if (mod != 'unchanged') return mod;
										if (evt._backup && evt._backup.filterCard) {
											var cardx = get.autoViewAs(lib.skill[evt.skill].viewAs, ui.selected.cards.concat([card]));
											if (!get.filter(evt._backup.filterCard)(cardx, player, evt)) return false;
										};
									}
									return get.filter(evt.filterCard2).apply(this, arguments);
								};
							}
							if (info.selectCard != undefined) this.selectCard = info.selectCard;
							if (info.position != undefined) this.position = info.position;
							if (info.forced != undefined) this.forced = info.forced;
							if (info.complexSelect != undefined) this.complexSelect = info.complexSelect;
							if (info.complexCard != undefined) this.complexCard = info.complexCard;
							if (info.complexTarget != undefined) this.complexTarget = info.complexTarget;
							if (info.ai1 != undefined) this.ai1 = info.ai1;
							if (info.ai2 != undefined) this.ai2 = info.ai2;
						}
						else {
							this.filterButton = info.filterButton ? get.filter(info.filterButton) : undefined;
							this.selectButton = info.selectButton;
							this.filterTarget = info.filterTarget ? get.filter(info.filterTarget) : undefined;
							this.selectTarget = info.selectTarget;
							this.filterCard = info.filterCard ? get.filter(info.filterCard) : undefined;
							this.selectCard = info.selectCard;
							this.position = info.position;
							this.forced = info.forced;
							this.complexSelect = info.complexSelect;
							this.complexCard = info.complexCard;
							this.complexTarget = info.complexTarget;
							if (info.ai1 != undefined) this.ai1 = info.ai1;
							if (info.ai2 != undefined) this.ai2 = info.ai2;
						}
						delete this.fakeforce;
					}
					delete this._cardChoice;
					delete this._targetChoice;
					delete this._skillChoice;
				},
				restore: function () {
					if (this._backup) {
						this.filterButton = this._backup.filterButton;
						this.selectButton = this._backup.selectButton;
						this.filterTarget = this._backup.filterTarget;
						this.selectTarget = this._backup.selectTarget;
						this.filterCard = this._backup.filterCard;
						this.selectCard = this._backup.selectCard;
						this.position = this._backup.position;
						this.forced = this._backup.forced;
						this.fakeforce = this._backup.fakeforce;
						this._aiexclude = this._backup._aiexclude;
						this.complexSelect = this._backup.complexSelect;
						this.complexCard = this._backup.complexCard;
						this.complexTarget = this._backup.complexTarget;
						this.ai1 = this._backup.ai1;
						this.ai2 = this._backup.ai2;
						this._cardChoice = this._backup._cardChoice;
						this._targetChoice = this._backup._targetChoice;
						this._skillChoice = this._backup._skillChoice;
					}
					delete this.skill;
					delete this.ignoreMod;
					delete this.filterCard2;
				},
				isMine: function () {
					return (this.player && this.player == game.me && !_status.auto && !this.player.isMad() && !game.notMe);
				},
				isOnline: function () {
					return (this.player && this.player.isOnline());
				},
				notLink: function () {
					return this.getParent().name != '_lianhuan' && this.getParent().name != '_lianhuan2';
				},
				isPhaseUsing: function (player) {
					var evt = this.getParent('phaseUse');
					if (!evt || evt.name != 'phaseUse') return false;
					return !player || player == evt.player;
				},
				addTrigger: function (skill, player) {
					if (!player) return;
					var evt = this;
					while (true) {
						var evt = evt.getParent('arrangeTrigger');
						if (!evt || evt.name != 'arrangeTrigger' || !evt.map) return;
						if (typeof skill == 'string') skill = [skill];
						game.expandSkills(skill);
						var filter = function (content) {
							if (typeof content == 'string') return content == triggername;
							return content.contains(triggername);
						};
						var trigger = evt._trigger;
						var triggername = evt.triggername;
						var map = false;
						if (evt.doing && evt.doing.player == player) map = evt.doing;
						else {
							for (var i = 0; i < evt.map.length; i++) {
								if (evt.map[i].player == player) { map = evt.map[i]; break; }
							}
						}
						if (!map) return;
						var func = function (skillx) {
							var info = lib.skill[skillx];
							var bool = false;
							for (var i in info.trigger) {
								if (filter(info.trigger[i])) { bool = true; break }
							}
							if (!bool) return;
							var priority = 0;
							if (info.priority) {
								priority = info.priority * 100;
							}
							if (info.silent) {
								priority++;
							}
							if (info.equipSkill) priority -= 25;
							if (info.cardSkill) priority -= 50;
							if (info.ruleSkill) priority -= 75;
							var toadd = [skillx, player, priority];
							if (map.list2) {
								for (var i = 0; i < map.list2.length; i++) {
									if (map.list2[i][0] == toadd[0] && map.list2[i][1] == toadd[1]) return;
								}
							};
							for (var i = 0; i < map.list.length; i++) {
								if (map.list[i][0] == toadd[0] && map.list[i][1] == toadd[1]) return;
							}
							map.list.add(toadd);
							map.list.sort(function (a, b) {
								return b[2] - a[2];
							});
						}
						for (var j = 0; j < skill.length; j++) {
							func(skill[j]);
						}
					}
				},
				trigger: function (name) {
					if (_status.video) return;
					if ((this.name === 'gain' || this.name === 'lose') && !_status.gameDrawed) return;
					if (name === 'gameDrawEnd') _status.gameDrawed = true;
					if (name === 'gameStart') {
						if (_status.brawl && _status.brawl.gameStart) {
							_status.brawl.gameStart();
						}
						if (lib.config.show_cardpile) {
							ui.cardPileButton.style.display = '';
						}
						_status.gameStarted = true;
						game.showHistory();
					}
					if (!lib.hookmap[name] && !lib.config.compatiblemode) return;
					if (!game.players || !game.players.length) return;
					var event = this;
					var start = false;
					var starts = [_status.currentPhase, event.source, event.player, game.me, game.players[0]];
					for (var i = 0; i < starts.length; i++) {
						if (get.itemtype(starts[i]) == 'player') {
							start = starts[i]; break;
						}
					}
					if (!start) return;
					if (!game.players.contains(start)) {
						start = game.findNext(start);
					}
					var list = [];
					var list2 = [];
					var mapx = [];
					var allbool = false;
					var roles = ['player', 'source', 'target'];
					var listAdded;
					var mapxx;
					var addList = function (skill, player) {
						if (listAdded[skill]) return;
						if (player.forbiddenSkills[skill]) return;
						if (player.disabledSkills[skill]) return;
						listAdded[skill] = true;
						var info = lib.skill[skill];
						var num = 0;
						if (info.priority) {
							num = info.priority * 100;
						}
						if (info.silent) {
							num++;
						}
						if (info.equipSkill) num -= 30;
						if (info.ruleSkill) num -= 30;
						if (info.firstDo) {
							list.push([skill, player, num]);
							list.sort(function (a, b) {
								return b[2] - a[2];
							});
							allbool = true;
							return;
						}
						else if (info.lastDo) {
							list2.push([skill, player, num]);
							list2.sort(function (a, b) {
								return b[2] - a[2];
							});
							allbool = true;
							return;
						}
						mapxx.list.push([skill, player, num]);
						mapxx.list.sort(function (a, b) {
							return b[2] - a[2];
						});
						allbool = true;
					};
					var totalPopulation = game.players.length + game.dead.length + 1;
					var player = start;;
					var globalskill = 'global_' + name;
					var map = _status.connectMode ? lib.playerOL : game.playerMap;
					for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
						var id = player.playerid;
						var mapxx = {
							player: player,
							list: [],
							list2: [],
						};
						listAdded = {};
						var notemp = player.skills.slice(0);
						for (var j in player.additionalSkills) {
							if (j.indexOf('hidden:') != 0) notemp.addArray(player.additionalSkills[j]);
						}
						for (var j in player.tempSkills) {
							if (notemp.contains(j)) return;
							var expire = player.tempSkills[j];
							if (expire === name ||
								(Array.isArray(expire) && expire.contains(name)) ||
								(typeof expire === 'function' && expire(event, player, name))) {
								delete player.tempSkills[j];
								player.removeSkill(j);
							}
							else if (get.objtype(expire) === 'object') {
								for (var i = 0; i < roles.length; i++) {
									if (expire[roles[i]] && player === event[roles[i]] &&
										(expire[roles[i]] === name || (Array.isArray(expire[roles[i]]) && expire[roles[i]].contains(name)))) {
										delete player.tempSkills[j];
										player.removeSkill(j);
									}
								}
							}
						}
						if (lib.config.compatiblemode) {
							(function () {
								var skills = player.getSkills(true).concat(lib.skill.global);
								game.expandSkills(skills);
								for (var i = 0; i < skills.length; i++) {
									var info = get.info(skills[i]);
									if (info && info.trigger) {
										var trigger = info.trigger;
										var add = false;
										if (trigger.player) {
											if (typeof trigger.player === 'string') {
												if (trigger.player === name) add = true;
											}
											else if (trigger.player.contains(name)) add = true;
										}
										if (trigger.target) {
											if (typeof trigger.target === 'string') {
												if (trigger.target === name) add = true;
											}
											else if (trigger.target.contains(name)) add = true;
										}
										if (trigger.source) {
											if (typeof trigger.source === 'string') {
												if (trigger.source === name) add = true;
											}
											else if (trigger.source.contains(name)) add = true;
										}
										if (trigger.global) {
											if (typeof trigger.global === 'string') {
												if (trigger.global === name) add = true;
											}
											else if (trigger.global.contains(name)) add = true;
										}
										if (add) {
											addList(skills[i], player);
										}
									}
								}
							}());
						}
						else {
							for (var i = 0; i < roles.length; i++) {
								var triggername = player.playerid + '_' + roles[i] + '_' + name;
								if (lib.hook[triggername]) {
									for (var j = 0; j < lib.hook[triggername].length; j++) {
										addList(lib.hook[triggername][j], player);
									}
								}
								triggername = roles[i] + '_' + name;
								if (lib.hook.globalskill[triggername]) {
									for (var j = 0; j < lib.hook.globalskill[triggername].length; j++) {
										addList(lib.hook.globalskill[triggername][j], player);
									}
								}
							}
							if (lib.hook.globalskill[globalskill]) {
								for (var j = 0; j < lib.hook.globalskill[globalskill].length; j++) {
									addList(lib.hook.globalskill[globalskill][j], player);
								}
							}
							for (var i in lib.hook.globaltrigger[name]) {
								if (map[i] === player) {
									for (var j = 0; j < lib.hook.globaltrigger[name][i].length; j++) {
										addList(lib.hook.globaltrigger[name][i][j], map[i]);
									}
								}
							}
						}
						mapx.push(mapxx);
						player = player.nextSeat;
						if (!player || player === start) {
							break;
						}
					}

					if (allbool) {
						var next = game.createEvent('arrangeTrigger', false, event);
						next.setContent('arrangeTrigger');
						next.list = list;
						next.list2 = list2;
						next.map = mapx;
						next._trigger = event;
						next.triggername = name;
						//next.starter=start;
						event._triggering = next;
					}
				},
				untrigger: function (all, player) {
					var evt = this._triggering;
					if (all) {
						if (evt && evt.map) {
							for (var i = 0; i < evt.map.length; i++) {
								evt.map[i].list = [];
							}
							evt.list = [];
							if (evt.doing) evt.doing.list = [];
						};
						this._triggered = 5;
					}
					else {
						if (player) {
							this._notrigger.add(player);
							if (!evt || !evt.map) return;
							for (var i = 0; i < evt.map.length; i++) {
								if (evt.map[i].player == player) evt.map[i].list = [];
							}
						}
					}
				}
			},
			dialog: {
				add: function (item, noclick, zoom) {
					if (typeof item == 'string') {
						if (item.indexOf('###') == 0) {
							var items = item.slice(3).split('###');
							this.add(items[0], noclick, zoom);
							this.addText(items[1], items[1].length <= 20, zoom);
						}
						else if (noclick) {
							var strstr = item;
							item = ui.create.div('', this.content);
							item.innerHTML = strstr;
						}
						else {
							item = ui.create.caption(item, this.content);
						}
					}
					else if (get.objtype(item) == 'div') {
						this.content.appendChild(item);
					}
					else if (get.itemtype(item) == 'cards') {
						var buttons = ui.create.div('.buttons', this.content);
						if (zoom) buttons.classList.add('smallzoom');
						this.buttons = this.buttons.concat(ui.create.buttons(item, 'card', buttons, noclick));
					}
					else if (get.itemtype(item) == 'players') {
						var buttons = ui.create.div('.buttons', this.content);
						if (zoom) buttons.classList.add('smallzoom');
						this.buttons = this.buttons.concat(ui.create.buttons(item, 'player', buttons, noclick));
					}
					else {
						var buttons = ui.create.div('.buttons', this.content);
						if (zoom) buttons.classList.add('smallzoom');
						this.buttons = this.buttons.concat(ui.create.buttons(item[0], item[1], buttons, noclick));
					}
					if (this.buttons.length) {
						if (this.forcebutton !== false) this.forcebutton = true;
						if (this.buttons.length > 3 || (zoom && this.buttons.length > 5)) {
							this.classList.remove('forcebutton-auto');
						}
						else if (!this.noforcebutton) {
							this.classList.add('forcebutton-auto');
						}
					}
					ui.update();
					return item;
				},
				addText: function (str, center) {
					if (center !== false) {
						this.add('<div class="text center">' + str + '</div>');
					}
					else {
						this.add('<div class="text">' + str + '</div>');
					}
					return this;
				},
				addSmall: function (item, noclick) {
					return this.add(item, noclick, true);
				},
				addAuto: function (content) {
					if (content && content.length > 4 && !this._hovercustomed) {
						this.addSmall(content);
					}
					else {
						this.add(content);
					}
				},
				open: function () {
					if (this.noopen) return;
					for (var i = 0; i < ui.dialogs.length; i++) {
						if (ui.dialogs[i] == this) {
							this.show();
							this.refocus();
							ui.dialogs.remove(this);
							ui.dialogs.unshift(this);
							ui.update();
							return this;
						}
						if (ui.dialogs[i].static) ui.dialogs[i].unfocus();
						else ui.dialogs[i].hide();
					}
					ui.dialog = this;
					var translate;
					if (lib.config.remember_dialog && lib.config.dialog_transform && !this.classList.contains('fixed')) {
						translate = lib.config.dialog_transform;
						this._dragtransform = translate;
						this.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px) scale(0.8)';
					}
					else {
						this.style.transform = 'scale(0.8)';
					}
					this.style.transitionProperty = 'opacity,transform';
					this.style.opacity = 0;
					ui.arena.appendChild(this);
					ui.dialogs.unshift(this);
					ui.update();
					ui.refresh(this);
					if (lib.config.remember_dialog && lib.config.dialog_transform && !this.classList.contains('fixed')) {
						this.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px) scale(1)';
					}
					else {
						this.style.transform = 'scale(1)';
					}
					this.style.opacity = 1;
					var that = this;
					setTimeout(function () {
						that.style.transitionProperty = '';
					}, 500);
					return this;
				},
				close: function () {
					ui.dialogs.remove(this);
					this.delete();
					if (ui.dialogs.length > 0) {
						ui.dialog = ui.dialogs[0];
						ui.dialog.show();
						ui.dialog.refocus();
						ui.update();
					}
					// if(ui.arenalog){
					// 	ui.arenalog.classList.remove('withdialog');
					// }
					return this;
				},
				setCaption: function (str) {
					this.querySelector('.caption').innerHTML = str;
					return this;
				}
			},
			control: {
				open: function () {
					ui.control.insertBefore(this, _status.createControl || ui.confirm);
					ui.controls.unshift(this);
					if (this.childNodes.length) {
						this.style.transition = 'opacity 0.5s';
						ui.refresh(this);
						this.style.transform = 'translateX(-' + (this.offsetWidth / 2) + 'px)';
						this.style.opacity = 1;
						ui.refresh(this);
						this.style.transition = '';
					}
					else {
						this.animate('controlpressdownx', 500);
					}
					ui.updatec();
					return this;
				},
				add: function (item) {
					var node = document.createElement('div');
					this.appendChild(node);
					node.link = item;
					node.innerHTML = get.translation(item);
					node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.control);
				},
				close: function () {
					this.animate('controlpressdownx', 500);

					ui.controls.remove(this);
					this.delete();

					setTimeout(ui.updatec, 100);


					if (ui.confirm == this) delete ui.confirm;
					if (ui.skills == this) delete ui.skills;
					if (ui.skills2 == this) delete ui.skills2;
					if (ui.skills3 == this) delete ui.skills3;
				},
				replace: function () {
					// this.animate('controlpressdownx',500);
					if (this.replaceTransition === false) {
						this.style.transitionProperty = 'none';
						ui.refresh(this);
					}

					while (this.childNodes.length) this.firstChild.remove();
					var i, controls;
					if (Array.isArray(arguments[0])) controls = arguments[0];
					else controls = arguments;
					delete this.custom;
					for (i = 0; i < controls.length; i++) {
						if (typeof controls[i] == 'function') {
							this.custom = controls[i];
						}
						else {
							this.add(controls[i]);
						}
					}
					if (this.childNodes.length) {
						var width = 0;
						for (i = 0; i < this.childNodes.length; i++) width += this.childNodes[i].offsetWidth;
						ui.refresh(this);
						this.style.width = width + 'px';
					}
					ui.updatec();
					if (this.replaceTransition === false) {
						var that = this;
						setTimeout(function () {
							that.style.transitionProperty = '';
						}, 200);
					}
					return this;
				}
			},
			client: {
				send: function () {
					if (this.closed) return this;
					var args = Array.from(arguments);
					if (typeof args[0] == 'function') {
						args.unshift('exec');
					}
					for (var i = 1; i < args.length; i++) {
						args[i] = get.stringifiedResult(args[i]);
					}
					try {
						this.ws.send(JSON.stringify(args));
					}
					catch (e) {
						this.ws.close();
					}
					return this;
				},
				close: function () {
					lib.node.clients.remove(this);
					lib.node.observing.remove(this);
					if (ui.removeObserve && !lib.node.observing.length) {
						ui.removeObserve.remove();
						delete ui.removeObserve;
					}
					this.closed = true;
					if (_status.waitingForPlayer) {
						for (var i = 0; i < game.connectPlayers.length; i++) {
							if (game.connectPlayers[i].playerid == this.id) {
								game.connectPlayers[i].uninitOL();
								delete game.connectPlayers[i].playerid;
							}
						}
						if (game.onlinezhu == this.id) {
							game.onlinezhu = null;
						}
						game.updateWaiting();
					}
					else if (lib.playerOL[this.id]) {
						var player = lib.playerOL[this.id];
						player.setNickname(player.nickname + ' - 离线');
						game.broadcast(function (player) {
							player.setNickname(player.nickname + ' - 离线');
						}, player);
						player.unwait('ai');
					}

					if (window.isNonameServer) {
						document.querySelector('#server_count').innerHTML = lib.node.clients.length;
					}
					return this;
				}
			},
			nodews: {
				send: function (message) {
					game.send('server', 'send', this.wsid, message);
				},
				on: function (type, func) {
					this['on' + type] = func;
				},
				close: function () {
					game.send('server', 'close', this.wsid);
				}
			},
			ws: {
				onopen: function () {
					if (_status.connectCallback) {
						_status.connectCallback(true);
						delete _status.connectCallback;
					}
				},
				onmessage: function (messageevent) {
					if (messageevent.data == 'heartbeat') {
						this.send('heartbeat');
						return;
					}
					var message;
					try {
						message = JSON.parse(messageevent.data);
						if (!Array.isArray(message) ||
							typeof lib.message.client[message[0]] !== 'function') {
							throw ('err');
						}
						for (var i = 1; i < message.length; i++) {
							message[i] = get.parsedResult(message[i]);
						}
					}
					catch (e) {
						console.log(e);
						console.log('invalid message: ' + messageevent.data);
						return;
					}
					lib.message.client[message.shift()].apply(null, message);
				},
				onerror: function (e) {
					if (this._nocallback) return;
					if (_status.connectCallback) {
						_status.connectCallback(false);
						delete _status.connectCallback;
					}
					else {
						alert('连接失败');
					}
				},
				onclose: function () {
					if (this._nocallback) return;
					if (_status.connectCallback) {
						_status.connectCallback(false);
						delete _status.connectCallback;
					}
					if (game.online || game.onlineroom) {
						if ((game.servermode || game.onlinehall) && _status.over) {

						}
						else {
							localStorage.setItem(lib.configprefix + 'directstart', true);
							game.reload();
						}
					}
					else {
						// game.saveConfig('reconnect_info');
					}
					game.online = false;
					game.ws = null;
				}
			}
		},
		card: {
			list: [],
		},
		filter: {
			all: function () {
				return true;
			},
			buttonIncluded: function (button) {
				return !(_status.event.excludeButton && _status.event.excludeButton.contains(button));
			},
			filterButton: function (button) {
				return true;
			},
			filterTrigger: function (event, player, name, skill) {
				if (player._hookTrigger) {
					for (var i = 0; i < player._hookTrigger.length; i++) {
						var info = lib.skill[player._hookTrigger[i]].hookTrigger;
						if (info) {
							if (info.block && info.block(event, player, name, skill)) {
								return false;
							}
						}
					}
				}
				var fullskills = game.expandSkills(player.getSkills().concat(lib.skill.global));
				var info = get.info(skill);
				if (info.noHidden && !fullskills.contains(skill)) {
					return false;
				}
				if (!info.trigger) return false;
				var bool = false;
				var has = function (obj) {
					if (typeof obj == 'string') return obj == name;
					else if (obj.contains(name)) return true;
					return false;
				}
				for (var i in info.trigger) {
					if ((i == 'global' || player == event[i]) && has(info.trigger[i])) {
						bool = true; break;
					}
				}
				if (!bool) return false;
				if (info.filter && !info.filter(event, player, name)) {
					return false;
				}
				if (event._notrigger.contains(player) && !lib.skill.global.contains(skill)) {
					return false;
				}
				if (typeof info.usable == 'number' && player.hasSkill('counttrigger') &&
					player.storage.counttrigger && player.storage.counttrigger[skill] >= info.usable) {
					return false;
				}
				if (info.round && (info.round - (game.roundNumber - player.storage[skill + '_roundcount']) > 0)) {
					return false;
				}
				return true;
			},
			characterDisabled: function (i, libCharacter) {
				if (lib.character[i][4] && lib.character[i][4].contains('forbidai')) return true;
				if (lib.character[i][4] && lib.character[i][4].contains('unseen')) return true;
				if (lib.config.forbidai.contains(i)) return true;
				if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode())) return true;
				if (_status.connectMode) {
					if (lib.configOL.banned.contains(i) || lib.connectBanned.contains(i)) return true;
					var double_character = false;
					if (lib.configOL.mode == 'guozhan') {
						double_character = true;
					}
					else if (lib.configOL.double_character && (lib.configOL.mode == 'identity' || lib.configOL.mode == 'stone')) {
						double_character = true;
					}
					else if (lib.configOL.double_character_jiange && (lib.configOL.mode == 'versus' && _status.mode == 'jiange')) {
						double_character = true;
					}
					if (double_character && lib.config.forbiddouble.contains(i)) {
						return true;
					}
					// if(lib.configOL.ban_weak){
					// 	if(lib.config.replacecharacter[i]&&libCharacter&&libCharacter[lib.config.replacecharacter[i]]) return true;
					// 	if(lib.config.forbidall.contains(i)) return true;
					// 	if(!double_character&&get.rank(i,true)<=2){
					// 		return true;
					// 	}
					// }
					// if(lib.configOL.ban_strong&&get.rank(i,true)>=8){
					// 	return true;
					// }
				}
				else {
					if (lib.config.banned.contains(i)) return true;
					var double_character = false;
					if (get.mode() == 'guozhan') {
						double_character = true;
					}
					else if (get.config('double_character') && (lib.config.mode == 'identity' || lib.config.mode == 'stone')) {
						double_character = true;
					}
					else if (get.config('double_character_jiange') && (lib.config.mode == 'versus' && _status.mode == 'jiange')) {
						double_character = true;
					}
					if (double_character && lib.config.forbiddouble.contains(i)) {
						return true;
					}
					// if(get.config('ban_weak')){
					// 	if(lib.config.replacecharacter[i]&&lib.character[lib.config.replacecharacter[i]]) return true;
					// 	if(lib.config.forbidall.contains(i)) return true;
					// 	if(!double_character&&get.rank(i,true)<=2){
					// 		return true;
					// 	}
					// }
					// if(get.config('ban_strong')&&get.rank(i,true)>=8){
					// 	return true;
					// }
				}
			},
			characterDisabled2: function (i) {
				var info = lib.character[i];
				if (info[4]) {
					if (info[4].contains('boss')) return true;
					if (info[4].contains('hiddenboss')) return true;
					if (info[4].contains('minskin')) return true;
					if (info[4].contains('unseen')) return true;
					if (info[4].contains('forbidai') && (!_status.event.isMine || !_status.event.isMine())) return true;
					if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode())) return true;
				}
				return false;
			},
			skillDisabled: function (skill) {
				if (!lib.translate[skill] || !lib.translate[skill + '_info']) return true;
				var info = lib.skill[skill];
				if (info && !info.unique && !info.temp && !info.sub && !info.fixed && !info.vanish) {
					return false;
				}
				return true;
			},
			cardEnabled: function (card, player, event) {
				if (player == undefined) player = _status.event.player;
				if (!player) return false;
				var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
				if (mod2 != 'unchanged') return mod2;
				card = get.autoViewAs(card, null, player);
				if (event === 'forceEnable') {
					var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled', player);
					if (mod != 'unchanged') return mod;
					return true;
				}
				else {
					var filter = get.info(card).enable;
					if (!filter) return;
					var mod = game.checkMod(card, player, 'unchanged', 'cardEnabled', player);
					if (mod != 'unchanged') return mod;
					if (typeof filter == 'boolean') return filter;
					if (typeof filter == 'function') return filter(card, player, event);
				}
			},
			cardRespondable: function (card, player, event) {
				event = event || _status.event;
				if (event.name != 'chooseToRespond') return true;
				var source = event.getParent().player;
				if (source && source != player) {
					if (source.hasSkillTag('norespond', false, [card, player, event], true)) {
						return false;
					}
				}
				if (player == undefined) player = _status.event.player;
				var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
				if (mod2 != 'unchanged') return mod2;
				var mod = game.checkMod(card, player, 'unchanged', 'cardRespondable', player);
				if (mod != 'unchanged') return mod;
				return true;
			},
			cardUsable2: function (card, player, event) {
				card = get.autoViewAs(card, null, player);
				var info = get.info(card);
				if (info.updateUsable == 'phaseUse') {
					event = event || _status.event;
					if (player != _status.event.player) return true;
					if (event.getParent().name != 'phaseUse') return true;
					if (event.getParent().player != player) return true;
				}
				var num = info.usable;
				if (typeof num == 'function') num = num(card, player);
				num = game.checkMod(card, player, num, 'cardUsable', player);
				if (typeof num != 'number') return true;
				else return (player.countUsed(card) < num);
			},
			cardUsable: function (card, player, event) {
				card = get.autoViewAs(card, null, player);
				var info = get.info(card);
				if (info.updateUsable == 'phaseUse') {
					event = event || _status.event;
					if (player != _status.event.player) return true;
					if (event.getParent().name != 'phaseUse') return true;
					if (event.getParent().player != player) return true;
				}
				var num = info.usable;
				if (typeof num == 'function') num = num(card, player);
				num = game.checkMod(card, player, num, 'cardUsable', player);
				if (typeof num != 'number') return true;
				if (player.countUsed(card) < num) return true;
				if (game.hasPlayer(function (current) {
					return game.checkMod(card, player, current, false, 'cardUsableTarget', player);
				})) {
					_status.event.addCount_extra = true;
					return true;
				}
				return false;
			},
			cardDiscardable: function (card, player, event) {
				event = event || _status.event;
				var mod = game.checkMod(card, player, event.getParent().name, 'unchanged', 'cardDiscardable', player);
				if (mod != 'unchanged') return mod;
				return true;
			},
			canBeDiscarded: function (card, player, target, event) {
				event = event || _status.event;
				var mod = game.checkMod(card, player, target, event.getParent().name, 'unchanged', 'canBeDiscarded', target);
				if (mod != 'unchanged') return mod;
				return true;
			},
			canBeGained: function (card, player, target, event) {
				event = event || _status.event;
				var mod = game.checkMod(card, player, target, event.getParent().name, 'unchanged', 'canBeGained', target);
				if (mod != 'unchanged') return mod;
				return true;
			},
			cardAiIncluded: function (card) {
				if (_status.event.isMine()) return true;
				return (_status.event._aiexclude.contains(card) == false);
			},
			filterCard: function (card, player, event) {
				var info = get.info(card);
				//if(info.toself&&!lib.filter.targetEnabled(card,player,player)) return false;
				if (player == undefined) player = _status.event.player;
				if (!lib.filter.cardEnabled(card, player, event) || !lib.filter.cardUsable(card, player, event)) return false;
				if (info.notarget) return true;
				var range;
				var select = get.copy(info.selectTarget);
				if (select == undefined) {
					if (info.filterTarget == undefined) return true;
					range = [1, 1];
				}
				else if (typeof select == 'number') range = [select, select];
				else if (get.itemtype(select) == 'select') range = select;
				else if (typeof select == 'function') range = select(card, player);
				game.checkMod(card, player, range, 'selectTarget', player);
				if (!range || range[1] != -1) return true;
				var filterTarget = (event && event.filterTarget) ? event.filterTarget : lib.filter.filterTarget;
				return game.hasPlayer(function (current) {
					return filterTarget(card, player, current);
				});
			},
			targetEnabled: function (card, player, target) {
				if (!card) return false;
				if (_status.event.addCount_extra && !lib.filter.cardUsable2(card, player) && !game.checkMod(card, player, target, false, 'cardUsableTarget', player)) return false;
				var info = get.info(card);
				var filter = info.filterTarget;
				var mod = game.checkMod(card, player, target, 'unchanged', 'playerEnabled', player);
				if (mod == false) return false;
				if (!info.singleCard || ui.selected.targets.length == 0) {
					var mod = game.checkMod(card, player, target, 'unchanged', 'targetEnabled', target);
					if (mod != 'unchanged') return mod;
				}
				if (typeof filter == 'boolean') return filter;
				if (typeof filter == 'function') return filter(card, player, target);
			},
			targetEnabled2: function (card, player, target) {
				if (lib.filter.targetEnabled(card, player, target)) return true;
				if (!card) return false;

				if (game.checkMod(card, player, target, 'unchanged', 'playerEnabled', player) == false) return false;
				if (game.checkMod(card, player, target, 'unchanged', 'targetEnabled', target) == false) return false;

				var filter = get.info(card).modTarget;
				if (typeof filter == 'boolean') return filter;
				if (typeof filter == 'function') return filter(card, player, target);
				return false;
			},
			targetEnabled3: function (card, player, target) {
				if (!card) return false;
				var info = get.info(card);

				if (info.filterTarget == true) return true;
				if (typeof info.filterTarget == 'function' && info.filterTarget(card, player, target)) return true;

				if (info.modTarget == true) return true;
				if (typeof info.modTarget == 'function' && info.modTarget(card, player, target)) return true;
				return false;
			},
			targetInRange: function (card, player, target) {
				var mod = game.checkMod(card, player, target, 'unchanged', 'targetInRange', player);
				var extra = 0;
				if (mod != 'unchanged') {
					if (typeof mod == 'boolean') return mod;
					if (typeof mod == 'number') extra = mod;
				}
				var info = get.info(card);
				var range = info.range;
				var outrange = info.outrange;
				if (range == undefined && outrange == undefined) return true;

				if (player.hasSkill('undist') || target.hasSkill('undist')) return false;
				for (var i in range) {
					if (i == 'attack') {
						if (player.inRange(target)) return true;
						var range2 = player.getAttackRange();
						if (range2 <= 0) return false;
						var distance = get.distance(player, target) + extra;
						if (range[i] <= distance - range2) return false;
					}
					else {
						var distance = get.distance(player, target, i) + extra;
						if (range[i] < distance) return false;
					}
				}
				for (var i in outrange) {
					if (i == 'attack') {
						var range2 = player.getAttackRange();
						if (range2 <= 0) return false;
						var distance = get.distance(player, target) + extra;
						if (outrange[i] > distance - range2 + 1) return false;
					}
					else {
						var distance = get.distance(player, target, i) + extra;
						if (outrange[i] > distance) return false;
					}
				}
				return true;
			},
			filterTarget: function (card, player, target) {
				return (lib.filter.targetEnabled(card, player, target) &&
					lib.filter.targetInRange(card, player, target));
			},
			filterTarget2: function (card, player, target) {
				return (lib.filter.targetEnabled2(card, player, target) &&
					lib.filter.targetInRange(card, player, target));
			},
			notMe: function (card, player, target) {
				return player != target;
			},
			isMe: function (card, player, target) {
				return player == target;
			},
			attackFrom: function (card, player, target) {
				return get.distance(player, target, 'attack') <= 1;
			},
			globalFrom: function (card, player, target) {
				return get.distance(player, target) <= 1;
			},
			selectCard: function () {
				return [1, 1];
			},
			selectTarget: function () {
				var card = get.card(), player = get.player();
				if (card == undefined) return;
				var range;
				var select = get.copy(get.info(card).selectTarget);
				if (select == undefined) {
					if (get.info(card).filterTarget == undefined) return [0, 0];
					range = [1, 1];
				}
				else if (typeof select == 'number') range = [select, select];
				else if (get.itemtype(select) == 'select') range = select;
				else if (typeof select == 'function') range = select(card, player);
				game.checkMod(card, player, range, 'selectTarget', player);
				return range;
			},
			judge: function (card, player, target) {
				var judges = target.getCards('j');
				for (var i = 0; i < judges.length; i++) {
					if ((judges[i].viewAs || judges[i].name) == card.name) return false;
				}
				return true;
			},
			autoRespondSha: function () {
				return !this.player.hasSha(true);
			},
			autoRespondShan: function () {
				return !this.player.hasShan();
			},
			wuxieSwap: function (event) {
				if (event.type == 'wuxie') {
					if (ui.wuxie && ui.wuxie.classList.contains('glow')) {
						return true;
					}
					if (ui.tempnowuxie && ui.tempnowuxie.classList.contains('glow') && event.state > 0) {
						var triggerevent = event.getTrigger();
						if (triggerevent) {
							if (ui.tempnowuxie._origin == triggerevent.parent.id) {
								return true;
							}
						}
						else if (ui.tempnowuxie._origin == _status.event.id2) {
							return true;
						}
					}
					if (!_status.connectMode && lib.config.wuxie_self && event.getParent().state) {
						var tw = event.getTrigger().parent;
						if (tw.player.isUnderControl(true) && !tw.player.hasSkillTag('noautowuxie') &&
							tw.targets && tw.targets.length == 1 && !tw.noai) {
							return true;
						}
					}
				}
			}
		},
		sort: {
			character: function (a, b) {
				var groupSort = function (name) {
					if (!lib.character[name]) return 6;
					if (lib.character[name][1] == 'shen') return -1;
					if (lib.character[name][1] == 'wei') return 0;
					if (lib.character[name][1] == 'shu') return 1;
					if (lib.character[name][1] == 'wu') return 2;
					if (lib.character[name][1] == 'qun') return 3;
					if (lib.character[name][1] == 'key') return 4;
					if (lib.character[name][1] == 'western') return 5;
					return 6;
				}
				var del = groupSort(a) - groupSort(b);
				if (del != 0) return del;
				var aa = a, bb = b;
				if (a.indexOf('_') != -1) {
					a = a.slice(a.indexOf('_') + 1);
				}
				if (b.indexOf('_') != -1) {
					b = b.slice(b.indexOf('_') + 1);
				}
				if (a != b) {
					return a > b ? 1 : -1;
				}
				return aa > bb ? 1 : -1;
			},
			card: function (a, b) {
				var typeSort = function (name) {
					var type = get.type(name);
					if (!type) return 10;
					if (type == 'basic') return -1;
					if (type == 'trick') return 0;
					if (type == 'delay') return 1;
					if (type == 'equip') {
						var type2 = get.subtype(name);
						if (type2 && type2.slice) return 1 + parseInt(type2.slice(5) || 7);
						return 8.5
					}
					return 9;
				}
				var del = typeSort(a) - typeSort(b);
				if (del != 0) return del;
				var aa = a, bb = b;
				if (a.indexOf('_') != -1) {
					a = a.slice(a.indexOf('_') + 1);
				}
				if (b.indexOf('_') != -1) {
					b = b.slice(b.indexOf('_') + 1);
				}
				if (a != b) {
					return a > b ? 1 : -1;
				}
				return aa > bb ? 1 : -1;
			},
			random: function () {
				return (Math.random() - 0.5);
			},
			seat: function (a, b) {
				var player = lib.tempSortSeat || _status.event.player;
				var delta = get.distance(player, a, 'absolute') - get.distance(player, b, 'absolute');
				if (delta) return delta;
				delta = parseInt(a.dataset.position) - parseInt(b.dataset.position);
				if (player.side == game.me.side) return delta;
				return -delta;
			},
			position: function (a, b) {
				return parseInt(a.dataset.position) - parseInt(b.dataset.position);
			},
			priority: function (a, b) {
				var i1 = get.info(a[0]), i2 = get.info(b[0]);
				if (i1.priority == undefined) i1.priority = 0;
				if (i2.priority == undefined) i2.priority = 0;
				if (i1.priority == i2.priority) {
					if (i1.forced == undefined && i2.forced == undefined) return 0;
					if (i1.forced && i2.forced) return 0;
					if (i1.forced) return 1;
					if (i2.forced) return -1;
				}
				return i2.priority - i1.priority;
			},
			number: function (a, b) {
				return get.number(a) - get.number(b);
			},
			number2: function (a, b) {
				return get.number(b) - get.number(a);
			},
			capt: function (a, b) {
				var aa = a, bb = b;
				if (aa.indexOf('_') != -1) {
					aa = aa.slice(aa.indexOf('_') + 1);
				}
				if (bb.indexOf('_') != -1) {
					bb = bb.slice(bb.indexOf('_') + 1);
				}
				if (aa != bb) {
					return aa > bb ? 1 : -1;
				}
				return a > b ? 1 : -1;
			},
			name: function (a, b) {
				if (a > b) return 1;
				if (a < b) return -1;
				return 0;
			}
		},
		skill: {
			_kamisha: {
				trigger: { source: 'damageBegin2' },
				//forced:true,
				popup: false,
				prompt: function (event, player) {
					return '是否防止即将对' + get.translation(event.player) + '造成的伤害，改为令其减少' + get.cnNumber(event.num) + '点体力上限？';
				},
				filter: function (event, player) {
					return event.nature == 'kami' && event.num > 0;
				},
				ruleSkill: true,
				check: function (event, player) {
					var att = get.attitude(player, event.player);
					if (event.player.hp == event.player.maxHp) return att < 0;
					if (event.player.hp == event.player.maxHp - 1 &&
						(event.player.maxHp <= 3 || event.player.hasSkillTag('maixie'))) return att < 0;
					return att > 0;
				},
				content: function () {
					trigger.cancel();
					trigger.player.loseMaxHp(trigger.num).source = player;
				},
			},
			aozhan: {
				charlotte: true,
				mod: {
					targetEnabled: function (card) {
						if (card.name == 'tao' && (card.isCard && card.cardid || get.itemtype(card) == 'card')) return false;
					},
					cardSavable: function (card) {
						if (card.name == 'tao' && (card.isCard && card.cardid || get.itemtype(card) == 'card')) return false;
					},
				},
				group: ["aozhan_sha", "aozhan_shan"],
				subSkill: {
					sha: {
						enable: ["chooseToUse", "chooseToRespond"],
						filterCard: {
							name: "tao",
						},
						viewAs: {
							name: "sha",
						},
						viewAsFilter: function (player) {
							if (!player.countCards('h', 'tao')) return false;
						},
						prompt: "将一张桃当杀使用或打出",
						check: function () { return 1 },
						ai: {
							effect: {
								target: function (card, player, target, current) {
									if (get.tag(card, 'respondSha') && current < 0) return 0.6
								},
							},
							respondSha: true,
							skillTagFilter: function (player) {
								if (!player.countCards('h', 'tao')) return false;
							},
							order: function () {
								return get.order({ name: 'sha' }) - 0.1;
							},
						},
						sub: true,
					},
					shan: {
						enable: ["chooseToRespond", "chooseToUse"],
						filterCard: {
							name: "tao",
						},
						viewAs: {
							name: "shan",
						},
						prompt: "将一张桃当闪打出",
						check: function () { return 1 },
						viewAsFilter: function (player) {
							if (!player.countCards('h', 'tao')) return false;
						},
						ai: {
							respondShan: true,
							skillTagFilter: function (player) {
								if (!player.countCards('h', 'tao')) return false;
							},
							effect: {
								target: function (card, player, target, current) {
									if (get.tag(card, 'respondShan') && current < 0) return 0.6
								},
							},
						},
						sub: true,
					},
				},
			},
			global: [],
			globalmap: {},
			storage: {},
			undist: {},
			others: {},
			zhu: {},
			zhuSkill: {},
			land_used: {},
			unequip: { ai: { unequip: true } },
			subplayer: {
				trigger: { player: 'dieBefore' },
				forced: true,
				priority: -9,
				onremove: true,
				mark: 'character',
				intro: {
					content: function (storage, player) {
						if (typeof storage.intro2 == 'string') return storage.intro2;
						if (typeof storage.intro2 == 'function') return storage.intro2(storage, player);
						return '死亡前切换回主武将'
					},
					name: function (storage) {
						return get.rawName(storage.name);
					}
				},
				content: function () {
					trigger.cancel();
					var evt = trigger.getParent('damage');
					if (evt.player == player) {
						evt.untrigger(false, player);
					}
					player.exitSubPlayer(true);
				},
				ai: {
					nosave: true
				}
			},
			autoswap: {
				firstDo: true,
				trigger: {
					player: ['playercontrol', 'chooseToUseBegin', 'chooseToRespondBegin', 'chooseToDiscardBegin', 'chooseToCompareBegin',
						'chooseButtonBegin', 'chooseCardBegin', 'chooseTargetBegin', 'chooseCardTargetBegin', 'chooseControlBegin',
						'chooseBoolBegin', 'choosePlayerCardBegin', 'discardPlayerCardBegin', 'gainPlayerCardBegin']
				},
				forced: true,
				priority: 100,
				popup: false,
				filter: function (event, player) {
					if (event.autochoose && event.autochoose()) return false;
					if (lib.filter.wuxieSwap(event)) return false;
					if (_status.auto || !player.isUnderControl()) return false;
					return true;
				},
				content: function () {
					game.swapPlayerAuto(player);
				},
			},
			dualside: {
				subSkill: {
					turn: {
						trigger: { player: ['turnOverAfter', 'dieBefore'] },
						silent: true,
						filter: function (event, player) {
							if (player.storage.dualside_over) return false;
							return Array.isArray(player.storage.dualside);
						},
						content: function () {
							var cfg = player.storage.dualside;
							var bool = player.isTurnedOver();
							if (trigger.name == 'die') {
								bool = !bool;
							}
							if (bool) {
								cfg[1] = player.hp;
								cfg[2] = player.maxHp;
								player.reinit(cfg[0], cfg[3], [cfg[4], cfg[5]]);
								player.unmarkSkill('dualside');
								player.markSkillCharacter('dualside', { name: cfg[0] }, '正面', '当前体力：' + cfg[1] + '/' + cfg[2]);
							}
							else {
								cfg[4] = player.hp;
								cfg[5] = player.maxHp;
								player.reinit(cfg[3], cfg[0], [cfg[1], cfg[2]]);
								player.unmarkSkill('dualside');
								player.markSkillCharacter('dualside', { name: cfg[3] }, '背面', '当前体力：' + cfg[4] + '/' + cfg[5]);
							}

							if (trigger.name == 'die') {
								trigger.cancel();
								delete player.storage.dualside;
								player.storage.dualside_over = true;
								player.unmarkSkill('dualside');
							}
						}
					},
					init: {
						trigger: { global: 'gameStart', player: 'enterGame' },
						silent: true,
						content: function () {
							var list = [player.name, player.name1, player.name2];
							for (var i = 0; i < list.length; i++) {
								if (list[i] && lib.character[list[i]]) {
									var info = lib.character[list[i]];
									if (info[3].contains('dualside') && info[4]) {
										player.storage.dualside = [list[i], player.hp, player.maxHp];
										for (var j = 0; j < info[4].length; j++) {
											if (info[4][j].indexOf('dualside:') == 0) {
												var name2 = info[4][j].slice(9);
												var info2 = lib.character[name2];
												player.storage.dualside.push(name2);
												player.storage.dualside.push(get.infoHp(info2[2]));
												player.storage.dualside.push(get.infoMaxHp(info2[2]));
											}
										}
									}
								}
							}
							var cfg = player.storage.dualside;
							if (get.mode() == 'guozhan') {
								if (player.name1 == cfg[0]) {
									player.showCharacter(0);
								}
								else {
									player.showCharacter(1);
								}
							}
							player.markSkillCharacter('dualside', { name: cfg[3] }, '背面', '当前体力：' + cfg[4] + '/' + cfg[5]);
						}
					}
				},
				group: ['dualside_init', 'dualside_turn']
			},
			_disableJudge: {
				marktext: "废",
				intro: {
					content: "已经废除了判定区",
				},
				mod: {
					targetEnabled: function (card, player, target) {
						if (target.storage._disableJudge && get.type(card) == 'delay') return false;
					},
				},
			},
			"_disableEquip": {
				marktext: "废",
				intro: {
					content: function (storage, player, skill) {
						var str = '';
						for (var i = 0; i < player.storage.disableEquip.length; i++) {
							str += '、' + get.translation(player.storage.disableEquip[i]) + '栏';
						};
						str = str.slice(1, str.length)
						str = '已经废除了' + str;
						return str;
					},
				},
				mod: {
					targetEnabled: function (card, player, target) {
						if (target.isDisabled(get.subtype(card))) return false;
					},
				},
				trigger: {
					player: ['disableEquipBefore', 'enableEquipBefore', 'enterGame'],
					global: 'gameStart',
				},
				forced: true,
				popup: false,
				filter: function (event, player) {
					return player.storage.disableEquip == undefined;
				},
				content: function () {
					player.storage.disableEquip = [];
				},
			},
			fengyin: {
				init: function (player, skill) {
					var skills = player.getSkills(true, false);
					for (var i = 0; i < skills.length; i++) {
						if (get.is.locked(skills[i]) || lib.skill[skills[i]].charlotte) {
							skills.splice(i--, 1);
						}
					}
					player.disableSkill(skill, skills);
				},
				onremove: function (player, skill) {
					player.enableSkill(skill);
				},
				locked: true,
				charlotte: true,
				mark: true,
				intro: {
					content: function (storage, player, skill) {
						var list = [];
						for (var i in player.disabledSkills) {
							if (player.disabledSkills[i].contains(skill)) {
								list.push(i)
							}
						}
						if (list.length) {
							var str = '失效技能：';
							for (var i = 0; i < list.length; i++) {
								if (lib.translate[list[i] + '_info']) {
									str += get.translation(list[i]) + '、';
								}
							}
							return str.slice(0, str.length - 1);
						}
					}
				}
			},
			baiban: {
				init: function (player, skill) {
					var skills = player.getSkills(true, false);
					for (var i = 0; i < skills.length; i++) {
						if (get.skills[i] || lib.skill[skills[i]].charlotte) {
							skills.splice(i--, 1);
						}
					}
					player.disableSkill(skill, skills);
				},
				onremove: function (player, skill) {
					player.enableSkill(skill);
				},
				mark: true,
				locked: true,
				intro: {
					content: function (storage, player, skill) {
						var list = [];
						for (var i in player.disabledSkills) {
							if (player.disabledSkills[i].contains(skill)) {
								list.push(i)
							}
						}
						if (list.length) {
							var str = '失效技能：';
							for (var i = 0; i < list.length; i++) {
								if (lib.translate[list[i] + '_info']) {
									str += get.translation(list[i]) + '、';
								}
							}
							return str.slice(0, str.length - 1);
						}
					},
				},
			},
			qianxing: {
				mark: true,
				nopop: true,
				init: function (player) {
					game.log(player, '获得了', '【潜行】');
				},
				intro: {
					content: '锁定技，你不能成为其他角色的卡牌的目标'
				},
				mod: {
					targetEnabled: function (card, player, target) {
						if (player != target) return false;
					}
				}
			},
			mianyi: {
				trigger: { player: 'damageBefore' },
				mark: true,
				forced: true,
				init: function (player) {
					game.log(player, '获得了', '【免疫】');
				},
				content: function () {
					trigger.cancel();
				},
				ai: {
					nofire: true,
					nothunder: true,
					nodamage: true,
					effect: {
						target: function (card, player, target, current) {
							if (get.tag(card, 'damage')) return [0, 0];
						}
					},
				},
				intro: {
					content: '防止一切伤害'
				}
			},
			mad: {
				mark: true,
				locked: true,
				intro: {
					content: '已进入混乱状态',
					name: '混乱',
					onunmark: function (storage, player) {
						game.log(player, '解除混乱状态');
					}
				}
			},
			ghujia: {
				intro: {
					content: function (content, player) {
						return '已有' + get.cnNumber(player.hujia) + '点护甲值';
					}
				}
			},
			counttrigger: {
				trigger: { global: 'phaseAfter' },
				silent: true,
				charlotte: true,
				priority: -100,
				content: function () {
					player.removeSkill('counttrigger');
					delete player.storage.counttrigger;
				}
			},
			_recovercheck: {
				trigger: { player: 'recoverBefore' },
				forced: true,
				priority: 100,
				firstDo: true,
				popup: false,
				filter: function (event, player) {
					return player.hp >= player.maxHp;
				},
				content: function () {
					trigger.cancel();
				},
			},
			_turnover: {
				trigger: { player: 'phaseBefore' },
				forced: true,
				priority: 100,
				popup: false,
				firstDo: true,
				content: function () {
					// for(var i=0;i<game.players.length;i++){
					// 	game.players[i].in();
					// }
					if (player.isTurnedOver()) {
						trigger.cancel();
						player.turnOver();
						player.phaseSkipped = true;
					}
					else {
						player.phaseSkipped = false;
					}
					if ((player == _status.roundStart || _status.roundSkipped) && !trigger.skill) {
						delete _status.roundSkipped;
						game.roundNumber++;
						trigger._roundStart = true;
						game.updateRoundNumber();
						for (var i = 0; i < game.players.length; i++) {
							if (game.players[i].isOut() && game.players[i].outCount > 0) {
								game.players[i].outCount--;
								if (game.players[i].outCount == 0 && !game.players[i].outSkills) {
									game.players[i].in();
								}
							}
						}
						event.trigger('roundStart');
					}
				},
			},
			_usecard: {
				trigger: { global: 'useCardAfter' },
				forced: true,
				popup: false,
				priority: -100,
				lastDo: true,
				filter: function (event) {
					return !event._cleared && event.card.name != 'wuxie';
				},
				content: function () {
					game.broadcastAll(function () {
						ui.clear();
					});
					event._cleared = true;
				}
			},
			_discard: {
				trigger: { global: 'discardAfter' },
				forced: true,
				popup: false,
				priority: -100,
				lastDo: true,
				filter: function (event) {
					return ui.todiscard[event.discardid] ? true : false;
				},
				content: function () {
					game.broadcastAll(function (id) {
						var todiscard = ui.todiscard[id];
						delete ui.todiscard[id];
						if (todiscard) {
							var time = 1000;
							if (typeof todiscard._discardtime == 'number') {
								time += todiscard._discardtime - get.time();
							}
							if (time < 0) {
								time = 0;
							}
							setTimeout(function () {
								for (var i = 0; i < todiscard.length; i++) {
									todiscard[i].delete();
								}
							}, time);
						}
					}, trigger.discardid);
				}
			},
			_save: {
				trigger: { source: 'dying2', player: 'dying2' },
				priority: 5,
				forced: true,
				popup: false,
				filter: function (event, player) {
					//if(!event.player.isDying()) return false;
					//if(event.source&&event.source.isIn()&&event.source!=player) return false;
					//return true;
					return false;
				},
				content: function () {
					"step 0"
					event.dying = trigger.player;
					if (!event.acted) event.acted = [];
					"step 1"
					if (trigger.player.isDead()) {
						event.finish();
						return;
					}
					event.acted.push(player);
					var str = get.translation(trigger.player) + '濒死，是否帮助？';
					var str2 = '当前体力：' + trigger.player.hp;
					if (lib.config.tao_enemy && event.dying.side != player.side && lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && !event.dying.hasSkillTag('revertsave')) {
						event._result = { bool: false }
					}
					else if (player.isOnline() || (_status.connectMode && player == game.me) || player.hasSkillTag('save', true, null, true) || player.hasCard(function (card) {
						var savable = get.info(card).savable;
						if (typeof savable == 'function') savable = savable(card, player, event.dying);
						return savable;
					})) {
						player.chooseToUse({
							filterCard: function (card, player, event) {
								event = event || _status.event;
								var mod2 = game.checkMod(card, player, 'unchanged', 'cardEnabled2', player);
								if (mod2 != 'unchanged') return mod2;
								var mod = game.checkMod(card, player, 'unchanged', 'cardSavable', player);
								if (mod != 'unchanged') return mod;
								var savable = get.info(card).savable;
								if (typeof savable == 'function') savable = savable(card, player, event.dying);
								return savable;
							},
							filterTarget: trigger.player,
							prompt: str,
							prompt2: str2,
							ai1: function (card) {
								if (typeof card == 'string') {
									var info = get.info(card);
									if (info.ai && info.ai.order) {
										if (typeof info.ai.order == 'number') {
											return info.ai.order;
										}
										else if (typeof info.ai.order == 'function') {
											return info.ai.order();
										}
									}
								}
								return 1;
							},
							ai2: get.effect_use,
							type: 'dying',
							targetRequired: true,
							dying: event.dying
						});
					}
					else {
						event._result = { bool: false }
					}
					"step 2"
					if (result.bool) {
						if (trigger.player.hp <= 0 && !trigger.player.nodying && trigger.player.isAlive() && !trigger.player.isOut() && !trigger.player.removed) event.goto(0);
						else trigger.untrigger();
					}
					else {
						for (var i = 0; i < 20; i++) {
							if (event.acted.contains(event.player.next)) {
								break;
							}
							else {
								event.player = event.player.next;
								if (!event.player.isOut()) {
									event.goto(1);
									break;
								}
							}
						}
					}
				}
			},
			_ismin: {
				mod: {
					cardEnabled: function (card, player) {
						if (player.isMin()) {
							if (get.type(card) == 'equip') return false;
						}
					}
				}
			},
			_chongzhu: {
				enable: 'phaseUse',
				logv: false,
				visible: true,
				prompt: '将要重铸的牌置入弃牌堆并摸一张牌',
				filter: function (event, player) {
					return player.hasCard(function (card) {
						var info = get.info(card);
						if (typeof info.chongzhu == 'function') {
							return info.chongzhu(event, player);
						}
						return info.chongzhu;
					});
				},
				filterCard: function (card) {
					var info = get.info(card);
					if (typeof info.chongzhu == 'function') {
						return info.chongzhu(event, _status.event.player);
					}
					return info.chongzhu;
				},
				prepare: function (cards, player) {
					player.$throw(cards, 1000);
					game.log(player, '将', cards, '置入了弃牌堆');
				},
				check: function (card) {
					// if(get.type(card)=='stonecharacter'&&_status.event.player.countCards('h',{type:'stonecharacter'})<=1){
					// 	return 0;
					// }
					return 1;
				},
				discard: false,
				loseTo: 'discardPile',
				delay: 0.5,
				content: function () {
					"step 0"
					if (lib.config.mode == 'stone' && _status.mode == 'deck' &&
						!player.isMin() && get.type(cards[0]).indexOf('stone') == 0) {
						var list = get.stonecard(1, player.career);
						if (list.length) {
							player.gain(game.createCard(list.randomGet()), 'draw');
						}
						else {
							player.draw({ drawDeck: 1 })
						}
					}
					else if (get.subtype(cards[0]) == 'spell_gold') {
						var list = get.libCard(function (info) {
							return info.subtype == 'spell_silver';
						});
						if (list.length) {
							player.gain(game.createCard(list.randomGet()), 'draw');
						}
						else {
							player.draw();
						}
					}
					else if (get.subtype(cards[0]) == 'spell_silver') {
						var list = get.libCard(function (info) {
							return info.subtype == 'spell_bronze';
						});
						if (list.length) {
							player.gain(game.createCard(list.randomGet()), 'draw');
						}
						else {
							player.draw();
						}
					}
					else {
						player.draw();
					}
				},
				ai: {
					basic: {
						order: 6
					},
					result: {
						player: 1,
					},
				}
			},
			_lianhuan: {
				trigger: { player: 'damageAfter' },
				filter: function (event, player) {
					return event.lianhuanable == true;
				},
				forced: true,
				popup: false,
				logv: false,
				forceDie: true,
				//priority:-5,
				content: function () {
					"step 0"
					event.logvid = trigger.getLogv();
					"step 1"
					event.targets = game.filterPlayer(function (current) {
						return current != event.player && current.isLinked();
					});
					lib.tempSortSeat = _status.currentPhase || player;
					event.targets.sort(lib.sort.seat);
					delete lib.tempSortSeat;
					event._args = [trigger.num, trigger.nature, trigger.cards, trigger.card];
					if (trigger.source) event._args.push(trigger.source);
					else event._args.push("nosource");
					"step 2"
					if (event.targets.length) {
						var target = event.targets.shift();
						target.damage.apply(target, event._args.slice(0));
						event.redo();
					}
				},
			},
			_lianhuan2: {
				trigger: { global: 'damageAfter' },
				filter: function (event, player) {
					return false;
					return (event.nature && lib.linked.contains(event.nature) && event.player.isLinked() &&
						event.player.classList.contains('dead') && player.isLinked());
				},
				silent: true,
				popup: false,
				forced: true,
				priority: -5,
				content: function () {
					"step 0"
					event.forceDie = true;
					trigger.player.removeLink();
					if (!trigger.notLink()) event.finish();
					"step 1"
					event.targets = game.filterPlayer(function (current) {
						return current.isLinked();
					});
					lib.tempSortSeat = _status.currentPhase || trigger.player;
					event.targets.sort(lib.sort.seat);
					delete lib.tempSortSeat;
					event._args = [trigger.num, trigger.nature, trigger.cards, trigger.card];
					if (trigger.source) event._args.push(trigger.source);
					else event._args.push("nosource");
					"step 2"
					if (event.targets.length) {
						var target = event.targets.shift();
						target.damage.apply(target, event._args.slice(0));
						event.redo();
					}
				}
			},
			_lianhuan3: {
				trigger: { global: 'damageAfter' },
				priority: -10,
				forced: true,
				popup: false,
				filter: function (event, player) {
					return false;
					return event.player.classList.contains('dead');
				},
				content: function () {
					trigger.player.removeLink();
				}
			},
			_lianhuan4: {
				trigger: { player: 'changeHp' },
				priority: -10,
				forced: true,
				popup: false,
				forceDie: true,
				filter: function (event, player) {
					var evt = event.getParent();
					return evt && evt.name == 'damage' && evt.nature && lib.linked.contains(evt.nature) && player.isLinked();
				},
				content: function () {
					player.link();
					if (trigger.getParent().notLink()) trigger.getParent().lianhuanable = true;
				}
			}
		},
		character: {},
		perfectPair: {},
		cardPile: {},
		message: {
			server: {
				init: function (version, config, banned_info) {
					if (lib.node.banned.contains(banned_info)) {
						this.send('denied', 'banned');
					}
					else if (config.id && lib.playerOL && lib.playerOL[config.id]) {
						var player = lib.playerOL[config.id];
						player.setNickname();
						player.ws = this;
						player.isAuto = false;
						this.id = config.id;
						game.broadcast(function (player) {
							player.setNickname();
						}, player);
						this.send('reinit', lib.configOL, get.arenaState(), game.getState ? game.getState() : {}, game.ip, null, _status.onreconnect);
					}
					else if (version != lib.versionOL) {
						this.send('denied', 'version');
						lib.node.clients.remove(this);
						this.closed = true;
					}
					else if (!_status.waitingForPlayer) {
						if (game.phaseNumber && lib.configOL.observe) {
							lib.node.observing.push(this);
							this.send('reinit', lib.configOL, get.arenaState(), game.getState ? game.getState() : {}, game.ip, game.players[0].playerid);
							if (!ui.removeObserve) {
								ui.removeObserve = ui.create.system('移除旁观', function () {
									lib.configOL.observe = false;
									if (game.onlineroom) {
										game.send('server', 'config', lib.configOL);
									}
									while (lib.node.observing.length) {
										lib.node.observing.shift().ws.close();
									}
									this.remove();
									delete ui.removeObserve;
								}, true);
							}
						}
						else {
							this.send('denied', 'gaming');
							lib.node.clients.remove(this);
							this.closed = true;
						}
					}
					else if (lib.node.clients.length - (window.isNonameServer ? 1 : 0) >= parseInt(lib.configOL.number)) {
						this.send('denied', 'number');
						lib.node.clients.remove(this);
						this.closed = true;
					}
					else {
						if (config) {
							this.avatar = config.avatar;
							this.nickname = config.nickname;
						}
						for (var i = 0; i < game.connectPlayers.length; i++) {
							if (game.connectPlayers[i].classList.contains('unselectable2')) continue;
							if (game.connectPlayers[i] != game.me && !game.connectPlayers[i].playerid) {
								game.connectPlayers[i].playerid = this.id;
								game.connectPlayers[i].initOL(this.nickname, this.avatar);
								game.connectPlayers[i].ws = this;
								break;
							}
						}
						this.send('init', this.id, lib.configOL, game.ip, window.isNonameServer, game.roomId);
					}
				},
				inited: function () {
					this.inited = true;
					if (_status.waitingForPlayer) {
						game.updateWaiting();
					}
				},
				reinited: function () {
					this.inited = true;
				},
				result: function (result) {
					var player = lib.playerOL[this.id];
					if (player) {
						player.unwait(result);
					}
				},
				startGame: function () {
					if (this.id == game.onlinezhu) {
						game.resume();
					}
				},
				changeRoomConfig: function (config) {
					if (this.id == game.onlinezhu) {
						game.broadcastAll(function (config) {
							for (var i in config) {
								lib.configOL[i] = config[i];
							}
							if (ui.connectStartBar) {
								ui.connectStartBar.firstChild.innerHTML = get.modetrans(lib.configOL, true);
							}
						}, config);
						if (lib.configOL.mode == 'identity' && lib.configOL.identity_mode == 'zhong' && game.connectPlayers) {
							for (var i = 0; i < game.connectPlayers.length; i++) {
								game.connectPlayers[i].classList.remove('unselectable2');
							}
							lib.configOL.number = 8;
							game.updateWaiting();
						}
						if (game.onlineroom) {
							game.send('server', 'config', lib.configOL);
						}
						for (var i = 0; i < game.connectPlayers.length; i++) {
							if (game.connectPlayers[i].playerid == this.id) {
								game.connectPlayers[i].chat('房间设置已更改');
							}
						}
					}
				},
				changeNumConfig: function (num, index, bool) {
					if (this.id == game.onlinezhu) {
						lib.configOL.number = num;
						game.send('server', 'config', lib.configOL);
						if (game.connectPlayers && game.connectPlayers[index]) {
							if (bool) {
								game.connectPlayers[index].classList.add('unselectable2');
							}
							else {
								game.connectPlayers[index].classList.remove('unselectable2');
							}
							game.updateWaiting();
						}
					}
				},
				emotion: function (id, pack, emotion) {
					var that = this;
					if (!this.id || (!lib.playerOL[this.id] && (!game.connectPlayers || !function () {
						for (var i = 0; i < game.connectPlayers.length; i++) {
							if (game.connectPlayers[i].playerid == that.id) {
								return true;
							}
						}
						return false;
					}()))) return;
					var player;
					if (lib.playerOL[id]) {
						player = lib.playerOL[id];
					}
					else if (game.connectPlayers) {
						for (var i = 0; i < game.connectPlayers.length; i++) {
							if (game.connectPlayers[i].playerid == id) {
								player = game.connectPlayers[i]; break;
							}
						}
					}
					if (player) lib.element.player.emotion.apply(player, [pack, emotion]);
				},
				chat: function (id, str) {
					var that = this;
					if (!this.id || (!lib.playerOL[this.id] && (!game.connectPlayers || !function () {
						for (var i = 0; i < game.connectPlayers.length; i++) {
							if (game.connectPlayers[i].playerid == that.id) {
								return true;
							}
						}
						return false;
					}()))) return;
					var player;
					if (lib.playerOL[id]) {
						player = lib.playerOL[id];
					}
					else if (game.connectPlayers) {
						for (var i = 0; i < game.connectPlayers.length; i++) {
							if (game.connectPlayers[i].playerid == id) {
								player = game.connectPlayers[i]; break;
							}
						}
					}
					if (player) lib.element.player.chat.call(player, str);
				},
				giveup: function (player) {
					_status.event.next.length = 0;
					game.createEvent('giveup', false).setContent(function () {
						game.log(player, '投降');
						player.popup('投降');
						player.die('nosource');
					}).player = player;
				},
				auto: function () {
					var player = lib.playerOL[this.id];
					if (player) {
						player.isAuto = true;
						player.setNickname(player.nickname + ' - 托管');
						game.broadcast(function (player) {
							player.setNickname(player.nickname + ' - 托管');
						}, player);
					}
				},
				unauto: function () {
					var player = lib.playerOL[this.id];
					if (player) {
						player.isAuto = false;
						player.setNickname(player.nickname);
						game.broadcast(function (player) {
							player.setNickname(player.nickname);
						}, player);
					}
				},
				exec: function (func) {
					// if(typeof func=='function'){
					//     var args=Array.from(arguments);
					//     args.shift();
					//     func.apply(this,args);
					// }
				},
				log: function () {
					var items = [];
					try {
						for (var i = 0; i < arguments.length; i++) {
							eval('items.push(' + arguments[i] + ')');
						}
					}
					catch (e) {
						this.send('log', ['err']);
						return;
					}
					this.send('log', items);
				}
			},
			client: {
				log: function (arr) {
					if (Array.isArray(arr)) {
						for (var i = 0; i < arr.length; i++) {
							console.log(arr[i]);
						}
					}
				},
				opened: function () {
					game.send('init', lib.versionOL, {
						id: game.onlineID,
						avatar: lib.config.connect_avatar,
						nickname: lib.config.connect_nickname
					}, lib.config.banned_info);
					if (ui.connecting && !ui.connecting.splashtimeout) {
						ui.connecting.firstChild.innerHTML = '重连成功';
					}
				},
				onconnection: function (id) {
					var ws = { wsid: id };
					for (var i in lib.element.nodews) {
						ws[i] = lib.element.nodews[i];
					}
					lib.wsOL[id] = ws;
					lib.init.connection(ws);
				},
				onmessage: function (id, message) {
					if (lib.wsOL[id]) {
						lib.wsOL[id].onmessage(message);
					}
				},
				onclose: function (id) {
					if (lib.wsOL[id]) {
						lib.wsOL[id].onclose();
					}
				},
				selfclose: function () {
					if (game.online || game.onlineroom) {
						if ((game.servermode || game.onlinehall) && _status.over) {
							// later
						}
						else {
							game.saveConfig('tmp_user_roomId');
						}
					}
					game.ws.close();
				},
				reloadroom: function (forced) {
					if (window.isNonameServer && (forced || !_status.protectingroom)) {
						game.reload();
					}
				},
				createroom: function (index, config, mode) {
					game.online = false;
					game.onlineroom = true;
					game.roomId = index;
					lib.node = {};
					if (config && mode && window.isNonameServer) {
						if (mode == 'auto') {
							mode = lib.configOL.mode;
						}
						game.switchMode(mode, config);
					}
					else {
						game.switchMode(lib.configOL.mode);
					}
					ui.create.connecting(true);
				},
				enterroomfailed: function () {
					alert('请稍后再试');
					_status.enteringroom = false;
					ui.create.connecting(true);
				},
				roomlist: function (list, events, clients, wsid) {
					game.send('server', 'key', game.onlineKey);
					game.online = true;
					game.onlinehall = true;
					lib.config.recentIP.remove(_status.ip);
					lib.config.recentIP.unshift(_status.ip);
					lib.config.recentIP.splice(5);
					if (!lib.config.reconnect_info || lib.config.reconnect_info[0] != _status.ip) {
						game.saveConfig('reconnect_info', [_status.ip, null]);
					}
					game.saveConfig('recentIP', lib.config.recentIP);
					_status.connectMode = true;

					game.clearArena();
					game.clearConnect();
					ui.pause.hide();
					ui.auto.hide();

					clearTimeout(_status.createNodeTimeout);
					game.send('server', 'changeAvatar', lib.config.connect_nickname, lib.config.connect_avatar);

					var proceed = function () {
						ui.rooms = [];
						game.ip = get.trimip(_status.ip);
						for (var i = 0; i < list.length; i++) {
							var player = ui.create.player(ui.window).animate('start');
							if (list.length == 8) player.dataset.position = i.toString();
							else player.dataset.position = 'c' + i;
							player.classList.add('connect');
							player.roomindex = i;
							player.node.hp.classList.add('room');
							ui.rooms.push(player);
						}
						if (events) {
							ui.connectRoom = ui.create.div('.forceopaque.menubutton.large.connectevents.server.pointerdiv', '创建服务器', ui.window, function () {
								if (confirm('通过此选项可创建一个新房间但不加入游戏。是否继续？')) {
									localStorage.setItem(lib.configprefix + 'asserver', 'hall');
									game.reload();
								}
							});
							if (!get.config('room_button')) {
								ui.connectRoom.style.display = 'none';
							}

							ui.connectEvents = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv', '约战', ui.window, ui.click.connectEvents);
							ui.connectEventsCount = ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.hidden', '', ui.window);
							ui.connectClients = ui.create.div('.forceopaque.menubutton.large.connectevents.pointerdiv.left', '在线', ui.window, ui.click.connectClients);
							ui.connectClientsCount = ui.create.div('.forceopaque.menubutton.icon.connectevents.highlight.left', '1', ui.window);
							if (events.length) {
								ui.connectEventsCount.innerHTML = events.filter(function (evt) {
									return evt.creator == game.onlineKey || !get.is.banWords(evt.content)
								}).length;
								ui.connectEventsCount.show();
							}
						}
						game.wsid = wsid;
						lib.message.client.updaterooms(list, clients);
						lib.message.client.updateevents(events);
						ui.exitroom = ui.create.system('退出房间', function () {
							game.saveConfig('tmp_owner_roomId');
							game.saveConfig('tmp_user_roomId');
							if (ui.rooms) {
								game.saveConfig('reconnect_info');
							}
							else {
								if (lib.config.reconnect_info) {
									lib.config.reconnect_info.length = 1;
									game.saveConfig('reconnect_info', lib.config.reconnect_info);
								}
							}
							game.reload();
						}, true);

						if (typeof lib.config.tmp_owner_roomId == 'number') {
							if (typeof game.roomId != 'number' && ui.rooms[lib.config.tmp_owner_roomId].roomempty) {
								lib.configOL.mode = lib.config.connect_mode;
								game.roomId = lib.config.tmp_owner_roomId;
							}
							game.saveConfig('tmp_owner_roomId');
						}
						if (typeof lib.config.tmp_user_roomId == 'number') {
							if (typeof game.roomId != 'number') {
								if (!ui.rooms[lib.config.tmp_user_roomId].roomempty) {
									game.roomId = lib.config.tmp_user_roomId;
								}
								else {
									ui.create.connecting();
									(function () {
										var n = 10;
										var id = lib.config.tmp_user_roomId;
										var interval = setInterval(function () {
											if (n > 0) {
												n--;
												if (!ui.rooms[id].roomempty) {
													clearInterval(interval);
													game.send('server', 'enter', game.roomId, lib.config.connect_nickname, lib.config.connect_avatar);
												}
											}
											else {
												ui.create.connecting(true);
												clearInterval(interval);
											}
										}, 500);
									}());
								}
							}
							game.saveConfig('tmp_user_roomId');
						}

						if (window.isNonameServer) {
							var cfg = 'pagecfg' + window.isNonameServer;
							if (lib.config[cfg]) {
								lib.configOL = lib.config[cfg][0];
								game.send('server', 'server', lib.config[cfg].slice(1));
								game.saveConfig(cfg);
								_status.protectingroom = true;
								setTimeout(function () {
									_status.protectingroom = false;
									if (!lib.node || !lib.node.clients || !lib.node.clients.length) {
										game.reload();
									}
								}, 15000);
							}
							else {
								game.send('server', 'server');
							}
						}
						else if (typeof game.roomId == 'number') {
							var room = ui.rooms[game.roomId];
							if (game.roomIdServer && (room.serving || !room.version)) {
								console.log();
								if (lib.config.reconnect_info) {
									lib.config.reconnect_info[2] = null;
									game.saveConfig('reconnect_info', lib.config.reconnect_info);
								}
							}
							else {
								ui.create.connecting();
								game.send('server', 'enter', game.roomId, lib.config.connect_nickname, lib.config.connect_avatar);
							}
						}
						lib.init.onfree();
					}
					if (_status.event.parent) {
						game.forceOver('noover', proceed);
					}
					else {
						proceed();
					}
				},
				updaterooms: function (list, clients) {
					if (ui.rooms) {
						ui.window.classList.add('more_room');
						var list2 = ['re_caocao', 're_liubei', 're_sunquan', 're_zhangjiao', 're_caopi', 'ol_liushan', 're_sunce', 'ol_yuanshao'];
						for (var i = 0; i < ui.rooms.length; i++) {
							ui.rooms[i].initRoom(list[i], list2[i]);
						}
					}
					lib.message.client.updateclients(clients, true);
				},
				updateclients: function (clients, bool) {
					if (clients && ui.connectClients) {
						ui.connectClients.info = clients;
						ui.connectClientsCount.innerHTML = clients.length;
					}
					if (_status.connectClientsCallback) {
						_status.connectClientsCallback();
					}
				},
				updateevents: function (events) {
					if (events && ui.connectEvents) {
						ui.connectEvents.info = events;
						var num = events.filter(function (evt) {
							return typeof evt.creator == 'string' && (evt.creator == game.onlineKey || !get.is.banWords(evt.content))
						}).length;
						if (num) {
							ui.connectEventsCount.innerHTML = num;
							ui.connectEventsCount.show();
						}
						else {
							ui.connectEventsCount.hide();
						}
						if (_status.connectEventsCallback) {
							_status.connectEventsCallback();
						}
					}
				},
				eventsdenied: function (reason) {
					var str = '创建约战失败';
					if (reason == 'total') {
						str += '，约战总数不能超过20';
					}
					else if (reason == 'time') {
						str += '，时间已过';
					}
					else if (reason == 'ban') {
						str += '，请注意文明发言';
					}
					alert(str);
				},
				init: function (id, config, ip, servermode, roomId) {
					game.online = true;
					game.onlineID = id;
					game.ip = ip;
					game.servermode = servermode;
					game.roomId = roomId;
					if (game.servermode) {
						game.saveConfig('reconnect_info', [_status.ip, id, game.roomId]);
					}
					else {
						game.saveConfig('reconnect_info', [_status.ip, id]);
						game.saveConfig('tmp_user_roomId', roomId);
					}
					lib.config.recentIP.remove(_status.ip);
					lib.config.recentIP.unshift(_status.ip);
					lib.config.recentIP.splice(5);
					game.saveConfig('recentIP', lib.config.recentIP);
					_status.connectMode = true;
					lib.configOL = config;
					lib.playerOL = {};
					lib.cardOL = {};

					game.clearArena();
					game.finishCards();
					ui.create.roomInfo();
					ui.create.chat();
					if (game.servermode) {
						ui.create.connectPlayers(get.modetrans(config, true));
					}
					else {
						ui.create.connectPlayers(ip);
					}
					ui.pause.hide();
					ui.auto.hide();
					game.clearConnect();
					clearTimeout(_status.createNodeTimeout);

					var proceed = function () {
						game.loadModeAsync(config.mode, function (mode) {
							for (var i in mode.ai) {
								if (typeof mode.ai[i] == 'object') {
									if (ai[i] == undefined) ai[i] = {};
									for (var j in mode.ai[i]) {
										ai[i][j] = mode.ai[i][j];
									}
								}
								else {
									ai[i] = mode.ai[i];
								}
							}
							for (var i in mode.get) {
								if (typeof mode.get[i] == 'object') {
									if (get[i] == undefined) get[i] = {};
									for (var j in mode.get[i]) {
										get[i][j] = mode.get[i][j];
									}
								}
								else {
									get[i] = mode.get[i];
								}
							}
							for (var i in mode.translate) {
								lib.translate[i] = mode.translate[i];
							}
							if (mode.game) {
								game.getIdentityList = mode.game.getIdentityList;
								game.updateState = mode.game.updateState;
								game.getRoomInfo = mode.game.getRoomInfo;
							}
							if (mode.element && mode.element.player) {
								for (var i in mode.element.player) {
									lib.element.player[i] = mode.element.player[i];
								}
							}
							if (mode.skill) {
								for (var i in mode.skill) {
									lib.skill[i] = mode.skill[i];
								}
							}
							game.finishCards();
							_status.event = {
								finished: true,
								next: [],
								after: []
							};
							_status.paused = false;
							game.createEvent('game', false).setContent(lib.init.startOnline);
							game.loop();
							game.send('inited');
							ui.create.connecting(true);
						});
					}
					if (_status.event.parent) {
						game.forceOver('noover', proceed);
					}
					else {
						proceed();
					}
					for (var i in lib.characterPack) {
						for (var j in lib.characterPack[i]) {
							lib.character[j] = lib.character[j] || lib.characterPack[i][j];
						}
					}
				},
				reinit: function (config, state, state2, ip, observe, onreconnect) {
					ui.auto.show();
					ui.pause.show();
					game.clearConnect();
					clearTimeout(_status.createNodeTimeout);
					game.online = true;
					game.ip = ip;
					game.servermode = state.servermode;
					game.roomId = state.roomId;
					if (state.over) {
						_status.over = true;
					}
					if (observe) {
						game.observe = true;
						game.onlineID = null;
						game.roomId = null;
					}
					if (game.servermode && !observe) {
						game.saveConfig('reconnect_info', [_status.ip, game.onlineID, game.roomId]);
					}
					else {
						game.saveConfig('reconnect_info', [_status.ip, game.onlineID]);
						if (!observe) {
							game.saveConfig('tmp_user_roomId', game.roomId);
						}
					}
					_status.connectMode = true;
					lib.configOL = config;
					lib.playerOL = {};
					lib.cardOL = {};

					game.loadModeAsync(config.mode, function (mode) {
						for (var i in mode.ai) {
							if (typeof mode.ai[i] == 'object') {
								if (ai[i] == undefined) ai[i] = {};
								for (var j in mode.ai[i]) {
									ai[i][j] = mode.ai[i][j];
								}
							}
							else {
								ai[i] = mode.ai[i];
							}
						}
						for (var i in mode.get) {
							if (typeof mode.get[i] == 'object') {
								if (get[i] == undefined) get[i] = {};
								for (var j in mode.get[i]) {
									get[i][j] = mode.get[i][j];
								}
							}
							else {
								get[i] = mode.get[i];
							}
						}
						for (var i in mode.translate) {
							lib.translate[i] = mode.translate[i];
						}
						if (mode.game) {
							game.getIdentityList = mode.game.getIdentityList;
							game.updateState = mode.game.updateState;
						}
						if (mode.element && mode.element.player) {
							for (var i in mode.element.player) {
								lib.element.player[i] = mode.element.player[i];
							}
						}
						if (mode.skill) {
							for (var i in mode.skill) {
								lib.skill[i] = mode.skill[i];
							}
						}
						game.finishCards();
						if (mode.characterPack) {
							for (var i in mode.characterPack) {
								lib.characterPack[i] = mode.characterPack[i];
							}
						}
						if (mode.onreinit) {
							mode.onreinit();
						}
						state = get.parsedResult(state);
						game.players = [];
						game.dead = [];
						for (var i in lib.characterPack) {
							for (var j in lib.characterPack[i]) {
								lib.character[j] = lib.character[j] || lib.characterPack[i][j];
							}
						}
						game.clearArena();
						game.finishCards();
						if (!observe) {
							ui.create.chat();
							if (ui.exitroom) {
								ui.exitroom.remove();
								delete ui.exitroom;
							}
						}
						else {
							if (!ui.exitroom) {
								ui.create.system('退出旁观', function () {
									game.saveConfig('reconnect_info');
									game.reload();
								}, true);
							}
							if (!lib.configOL.observe_handcard) {
								ui.arena.classList.add('observe');
							}
						}
						ui.arena.setNumber(state.number);
						_status.mode = state.mode;
						lib.inpile = state.inpile;
						var pos = state.players[observe || game.onlineID].position;
						for (var i in state.players) {
							var info = state.players[i];
							var player = ui.create.player(ui.arena).animate('start');
							player.dataset.position = (info.position < pos) ? info.position - pos + parseInt(state.number) : info.position - pos;
							if (i == observe || i == game.onlineID) {
								game.me = player;
							}
							if (player.setModeState) {
								player.setModeState(info);
							}
							else {
								player.init(info.name, info.name2);
							}
							player.playerid = i;
							player.nickname = info.nickname;
							player.changeGroup(info.group, false, false);
							player.identity = info.identity;
							player.identityShown = info.identityShown;
							player.hp = info.hp;
							player.maxHp = info.maxHp;
							player.hujia = info.hujia;
							player.sex = info.sex;
							player.side = info.side;
							player.phaseNumber = info.phaseNumber,
								player.setNickname();
							if (info.dead) {
								player.classList.add('dead');
								if (lib.config.die_move) {
									player.$dieflip();
								}
								if (lib.element.player.$dieAfter) {
									lib.element.player.$dieAfter.call(player);
								}
								game.dead.push(player);
							}
							else {
								game.players.push(player);
							}
							if (info.linked) {
								player.addLink();
							}
							if (info.turnedover) {
								player.classList.add('turnedover');
							}
							if (info.disableJudge) {
								player.$disableJudge();
							}
							if (Array.isArray(info.disableEquip)) {
								for (var ii = 0; ii < info.disableEquip.length; ii++) {
									player.$disableEquip(info.disableEquip[ii]);
								}
							}

							player.directgain(info.handcards);
							lib.playerOL[i] = player;
							for (var i = 0; i < info.equips.length; i++) {
								player.$equip(info.equips[i]);
							}
							for (var i = 0; i < info.judges.length; i++) {
								if (info.views[i] && info.views[i] != info.judges[i]) {
									info.judges[i].classList.add('fakejudge');
									info.judges[i].viewAs = info.views[i];
									info.judges[i].node.background.innerHTML = lib.translate[info.views[i] + '_bg'] || get.translation(info.views[i])[0]
								}
								player.node.judges.appendChild(info.judges[i]);
							}
							ui.updatej(player);
							if (!player.setModeState) {
								if (!game.getIdentityList && info.identityNode) {
									player.node.identity.innerHTML = info.identityNode[0];
									player.node.identity.dataset.color = info.identityNode[1];
								}
								else if (player == game.me || player.identityShown || observe) {
									player.setIdentity();
									player.forceShown = true;
								}
								else {
									player.setIdentity('cai');
								}
								if (!lib.configOL.observe_handcard && (lib.configOL.mode == 'identity' || lib.configOL.mode == 'guozhan')) {
									if (observe && !player.identityShown) {
										player.setIdentity('cai');
										player.forceShown = false;
									}
								}
							}
							player.update();
						}
						game.arrangePlayers();
						ui.create.me(true);

						_status.event = {
							finished: true,
							next: [],
							after: []
						};
						_status.paused = false;
						_status.dying = get.parsedResult(state.dying) || [];

						if (game.updateState) {
							game.updateState(state2);
						}
						var next = game.createEvent('game', false);
						next.setContent(lib.init.startOnline);
						if (observe) {
							next.custom.replace.target = function (player) {
								if (!lib.configOL.observe_handcard && lib.configOL.mode == 'guozhan') {
									return;
								}
								if (player.isAlive()) {
									if (!game.me.identityShown && lib.configOL.mode == 'guozhan') {
										game.me.node.identity.firstChild.innerHTML = '猜';
										game.me.node.identity.dataset.color = 'unknown';
									}
									game.swapPlayer(player);
									if (!game.me.identityShown && lib.configOL.mode == 'guozhan') {
										game.me.node.identity.firstChild.innerHTML = '';
									}
								}
							}
						}
						else {
							if (Array.isArray(onreconnect)) {
								onreconnect.shift().apply(this, onreconnect);
							}
						}
						game.loop();
						game.send('reinited');
						game.showHistory();
						_status.gameStarted = true;
						if (lib.config.show_cardpile) {
							ui.cardPileButton.style.display = '';
						}
						if (!observe && game.me && (game.me.isDead() || _status.over)) {
							ui.create.exit();
						}
						ui.updatehl();
						ui.create.connecting(true);
					});
				},
				exec: function (func) {
					if (typeof func == 'function') {
						var args = Array.from(arguments);
						args.shift();
						func.apply(this, args);
					}
				},
				denied: function (reason) {
					switch (reason) {
						case 'version': alert('加入失败：版本不匹配'); break;
						case 'gaming': alert('加入失败：游戏已开始'); break;
						case 'number': alert('加入失败：房间已满'); break;
						case 'banned': alert('加入失败：房间拒绝你加入'); break;
						case 'key':
							alert('您的游戏版本过低，请升级到最新版');
							game.saveConfig('tmp_owner_roomId');
							game.saveConfig('tmp_user_roomId');
							game.saveConfig('reconnect_info');
							break;
						case 'offline':
							if (_status.paused && _status.event.name == 'game') {
								setTimeout(game.resume, 500);
							}
							break;
					}
					game.ws.close();
					if (_status.connectDenied) {
						_status.connectDenied();
					}
				},
				cancel: function (id) {
					if (_status.event.id == id && _status.event.isMine() && _status.paused && _status.imchoosing) {
						ui.click.cancel();
						if (ui.confirm) {
							ui.confirm.close();
						}
						if (_status.event.result) {
							_status.event.result.id = id;
						}
					}
				},
				closeDialog: function (id) {
					var dialog = get.idDialog(id);
					if (dialog) {
						dialog.close();
					}
				},
				createDialog: function (id) {
					var args = Array.from(arguments);
					args.shift();
					ui.create.dialog.apply(this, args).videoId = id;
				},
				gameStart: function () {
					for (var i = 0; i < game.connectPlayers.length; i++) {
						game.connectPlayers[i].delete();
					}
					delete game.connectPlayers;
					if (ui.connectStartButton) {
						ui.connectStartButton.delete();
						delete ui.connectStartButton;
					}
					if (ui.connectStartBar) {
						ui.connectStartBar.delete();
						delete ui.connectStartBar;
					}
					if (ui.roomInfo) {
						ui.roomInfo.remove();
						delete ui.roomInfo;
					}
					if (ui.exitroom) {
						ui.exitroom.remove();
						delete ui.exitroom;
					}
					ui.auto.show();
					ui.pause.show();
					if (lib.config.show_cardpile) {
						ui.cardPileButton.style.display = '';
					}
					_status.gameStarted = true;
					game.showHistory();
				},
				updateWaiting: function (map) {
					if (!game.connectPlayers) return;
					if (!lib.translate.zhu) {
						lib.translate.zhu = '主';
					}
					game.onlinezhu = false;
					_status.waitingForPlayer = true;
					for (var i = 0; i < map.length; i++) {
						if (map[i] == 'disabled') {
							game.connectPlayers[i].classList.add('unselectable2');
						}
						else {
							game.connectPlayers[i].classList.remove('unselectable2');
							if (map[i]) {
								game.connectPlayers[i].initOL(map[i][0], map[i][1]);
								game.connectPlayers[i].playerid = map[i][2];
								if (map[i][3] == 'zhu') {
									game.connectPlayers[i].setIdentity('zhu');
									if (map[i][2] == game.onlineID) {
										game.onlinezhu = true;
										if (ui.roomInfo) {
											ui.roomInfo.innerHTML = '房间设置';
										}
										if (ui.connectStartButton) {
											ui.connectStartButton.innerHTML = '开始游戏';
										}
									}
								}
								else {
									game.connectPlayers[i].node.identity.firstChild.innerHTML = '';
								}
							}
							else {
								game.connectPlayers[i].uninitOL();
								delete game.connectPlayers[i].playerid;
							}
						}
					}
				}
			}
		},
		suit: ['club', 'spade', 'diamond', 'heart'],
		group: ['wei', 'shu', 'wu', 'qun', 'shen'],
		nature: ['fire', 'thunder', 'poison', 'kami'],
		linked: ['fire', 'thunder', 'kami'],
		groupnature: {
			shen: 'thunder',
			wei: 'water',
			shu: 'soil',
			wu: 'wood',
			qun: 'metal',
			western: 'thunder',
			key: 'key',
		},
		phaseName: ['phaseZhunbei', 'phaseJudge', 'phaseDraw', 'phaseUse', 'phaseDiscard', 'phaseJieshu'],
	};
	var game = {
		getGlobalHistory: function (key, filter) {
			if (!key) return _status.globalHistory[_status.globalHistory.length - 1];
			if (!filter) return _status.globalHistory[_status.globalHistory.length - 1][key];
			else {
				var history = game.getGlobalHistory(key).slice(0);
				for (var i = 0; i < history.length; i++) {
					if (!filter(history[i])) history.splice(i--, 1);
				}
				return history;
			}
		},
		cardsDiscard: function (cards) {
			var type = get.itemtype(cards);
			if (type != 'cards' && type != 'card') return;
			var next = game.createEvent('cardsDiscard');
			next.cards = type == 'cards' ? cards.slice(0) : [cards];
			next.setContent('cardsDiscard');
			return next;
		},
		cardsGotoOrdering: function (cards) {
			var type = get.itemtype(cards);
			if (type != 'cards' && type != 'card') return;
			var next = game.createEvent('cardsGotoOrdering');
			next.cards = type == 'cards' ? cards.slice(0) : [cards];
			next.setContent('cardsGotoOrdering');
			return next;
		},
		cardsGotoSpecial: function (cards, bool) {
			var type = get.itemtype(cards);
			if (type != 'cards' && type != 'card') return;
			var next = game.createEvent('cardsDiscard');
			next.cards = type == 'cards' ? cards.slice(0) : [cards];
			if (bool === false) next.notrigger = true;
			next.setContent('cardsGotoSpecial');
			return next;
		},
		online: false,
		onlineID: null,
		onlineKey: null,
		showHistory: function (pause) {
			if (lib.config.show_history == 'left') {
				ui.window.classList.add('leftbar');
			}
			else if (lib.config.show_history == 'right') {
				ui.window.classList.add('rightbar');
			}
			if (pause != false && ui.pause) {
				ui.pause.show();
			}
		},
		createBackground: function (src, blur) {
			var current = document.body.querySelector('.background.upper');
			if (current) {
				current.delete();
			}
			var node = ui.create.div('.background.blurbg', document.body);
			node.setBackgroundImage(src);
			node.style.backgroundSize = 'cover';
			if (blur) {
				node.classList.add('paused')
			}
			return node;
		},
		changeLand: function (url, player) {
			game.addVideo('changeLand', player, url);
			if (url.indexOf('/') === -1) {
				url = 'image/card/' + url;
			}
			if (url.indexOf('.png') == -1 && url.indexOf('.jpg') == -1) {
				url += '.jpg';
			}
			var name = url.slice(url.lastIndexOf('/') + 1, url.lastIndexOf('.'));
			var skill = name + '_skill';
			var node = ui.create.div('.background.upper.land');
			node.setBackgroundImage(url);
			node.destroy = function () {
				if (this.skill) {
					game.removeGlobalSkill(this.skill);
					if (this.system) {
						this.system.remove();
					}
				}
				this.classList.add('hidden');
				var node = this;
				setTimeout(function () {
					node.remove();
				}, 3000);
				if (ui.land == this) {
					ui.land = null;
				}
			}
			if (ui.land) {
				document.body.insertBefore(node, ui.land);
				ui.land.destroy();
			}
			else {
				node.classList.add('hidden');
				document.body.insertBefore(node, ui.window);
				ui.refresh(node);
				node.classList.remove('hidden');
			}
			ui.land = node;
			if (name) {
				node.name = name;
				node.skill = skill;
				if (player) {
					node.player = player;
					player.addTempSkill('land_used');
				}
				node.system = ui.create.system(lib.translate[skill], null, true, true);
				lib.setPopped(node.system, function () {
					var uiintro = ui.create.dialog('hidden');
					var str = '地图';
					if (player) {
						str = '来源：' + get.translation(player);
					}
					var caption = uiintro.addText(str);
					caption.style.margin = '0';
					uiintro._place_text = uiintro.add('<div class="text">' + lib.translate[skill + '_info'] + '</div>');
					uiintro.add(ui.create.div('.placeholder.slim'));
					return uiintro;
				}, 200);
				game.addGlobalSkill(skill);
			}
		},
		checkFileList: function (updates, proceed) {
			var n = updates.length;
			if (!n) {
				proceed(n);
			}
			for (var i = 0; i < updates.length; i++) {
				if (lib.node && lib.node.fs) {
					lib.node.fs.access(__dirname + '/' + updates[i], (function (entry) {
						return function (err) {
							if (!err) {
								var stat = lib.node.fs.statSync(__dirname + '/' + entry);
								if (stat.size == 0) {
									err = true;
								}
							}
							if (err) {
								n--;
								if (n == 0) {
									proceed();
								}
							}
							else {
								n--;
								updates.remove(entry);
								if (n == 0) {
									proceed();
								}
							}
						}
					}(updates[i])));
				}
				else {
					resolveLocalFileSystemURL(lib.assetURL + updates[i], (function (name) {
						return function (entry) {
							n--;
							updates.remove(name);
							if (n == 0) {
								proceed();
							}
						}
					}(updates[i])), function () {
						n--;
						if (n == 0) {
							proceed();
						}
					});
				}
			}
		},
		replaceHandcards: function () {
			var next = game.createEvent('replaceHandcards');
			if (Array.isArray(arguments[0])) {
				next.players = arguments[0];
			}
			else {
				next.players = [];
				for (var i = 0; i < arguments.length; i++) {
					if (get.itemtype(arguments[i]) == 'player') {
						next.players.push(arguments[i]);
					}
				}
			}
			if (_status.connectMode) {
				next.setContent('replaceHandcardsOL');
			}
			else {
				next.setContent('replaceHandcards');
			}
		},
		removeCard: function (name) {
			for (var i = 0; i < lib.card.list.length; i++) {
				if (lib.card.list[i][2] == name) {
					lib.card.list.splice(i--, 1);
				}
			}
			var list = [];
			for (var i = 0; i < ui.cardPile.childElementCount; i++) {
				if (ui.cardPile.childNodes[i].name == name) {
					list.push(ui.cardPile.childNodes[i]);
				}
			}
			for (var i = 0; i < list.length; i++) {
				list[i].remove();
			}
		},
		randomMapOL: function (type) {
			if (type == 'hidden') {
				ui.arena.classList.add('playerhidden');
			}
			game.prepareArena();
			if (window.isNonameServer) {
				game.me = ui.create.player();
			}
			var list = [];
			for (var i = 0; i < game.players.length; i++) {
				if (game.players[i] != game.me) {
					list.push(game.players[i]);
				}
			}
			var map = [];
			for (var i = 0; i < lib.node.clients.length; i++) {
				if (!list.length) break;
				var current = list.randomRemove();
				current.ws = lib.node.clients[i];
				current.playerid = current.ws.id;
				current.nickname = current.ws.nickname;
				current.setNickname();
			}
			if (!window.isNonameServer) {
				game.me.playerid = get.id();
				game.me.nickname = lib.config.connect_nickname;
				game.me.setNickname();
			}
			for (var i = 0; i < game.players.length; i++) {
				if (!game.players[i].playerid) {
					game.players[i].playerid = get.id();
				}
				map.push([game.players[i].playerid, game.players[i].nickname]);
				lib.playerOL[game.players[i].playerid] = game.players[i];
			}
			game.broadcast(function (map, config, hidden) {
				if (hidden) {
					ui.arena.classList.add('playerhidden');
				}
				lib.configOL = config;
				ui.create.players();
				ui.create.me();
				game.me.playerid = game.onlineID;
				game.me.nickname = lib.config.connect_nickname;
				for (var i = 0; i < map.length; i++) {
					if (map[i][0] == game.me.playerid) {
						map = map.concat(map.splice(0, i));
						break;
					}
				}
				for (var i = 0; i < game.players.length; i++) {
					game.players[i].playerid = map[i][0];
					game.players[i].nickname = map[i][1];
					game.players[i].setNickname();
					lib.playerOL[game.players[i].playerid] = game.players[i];
				}
				_status.mode = lib.configOL[lib.configOL.mode + '_mode'];
			}, map, lib.configOL, type == 'hidden');
			_status.mode = lib.configOL[lib.configOL.mode + '_mode'];
			game.chooseCharacterOL();
		},
		closeMenu: function () {
			if (ui.menuContainer && !ui.menuContainer.classList.contains('hidden')) {
				ui.click.configMenu();
			}
		},
		closeConnectMenu: function () {
			if (ui.connectMenuContainer && !ui.connectMenuContainer.classList.contains('hidden')) {
				ui.click.connectMenu();
			}
		},
		closePopped: function () {
			if (ui.currentpopped) {
				if (ui.currentpopped._uiintro) {
					ui.currentpopped._uiintro.delete();
					delete ui.currentpopped._uiintro;
				}
				delete ui.currentpopped;
			}
		},
		broadcast: function () {
			if (!lib.node || !lib.node.clients || game.online) return;
			for (var i = 0; i < lib.node.clients.length; i++) {
				if (lib.node.clients[i].inited) {
					lib.node.clients[i].send.apply(lib.node.clients[i], arguments);
				}
			}
		},
		broadcastAll: function () {
			if (game.online) return;
			var argc = arguments.length;
			var args = new Array(argc);
			for (var i = 0; i < argc; i++) {
				args[i] = arguments[i];
			}
			game.broadcast.apply(this, args);
			var func = args.shift();
			if (typeof func == 'string') {
				func = lib.message.client[func];
			}
			if (typeof func == 'function') {
				func.apply(this, args);
			}
		},
		syncState: function () {
			var state = null;
			if (game.getState) {
				state = game.getState();
			}
			game.broadcast(function (state, current, number) {
				if (game.updateState && state) game.updateState(state);
				_status.currentPhase = current;
				game.phaseNumber = number;
			}, state, _status.currentPhase, game.phaseNumber);
		},
		updateWaiting: function () {
			var map = [];
			for (var i = 0; i < game.connectPlayers.length; i++) {
				var player = game.connectPlayers[i];
				if (player.playerid) {
					if (!game.onlinezhu) {
						game.onlinezhu = player.playerid;
						game.send('server', 'changeAvatar', player.nickname, player.avatar);
						_status.onlinenickname = player.nickname;
						_status.onlineavatar = player.avatar;
					}
					map[i] = [player.nickname, player.avatar, player.playerid];
					if (player.playerid == game.onlinezhu) {
						map[i].push('zhu');
					}
				}
				else if (player.classList.contains('unselectable2')) {
					map[i] = 'disabled';
				}
				else {
					map[i] = null;
				}
			}
			game.broadcast('updateWaiting', map);
		},
		waitForPlayer: function (func) {
			var next = game.createEvent('waitForPlayer', false);
			next.func = func;
			next.setContent('waitForPlayer');
		},
		countDown: function (time, onEnd) {
			time = parseInt(time);
			if (!time) return;
			if (time <= 0) return;
			var current = time;
			ui.timer.set(current, 1);
			_status.countDown = setInterval(function () {
				if (--current) {
					ui.timer.set(current, current / time);
				}
				else {
					ui.timer.set(0, 0);
					clearInterval(_status.countDown);
					delete _status.countDown;
					if (onEnd) onEnd();
				}
			}, 1000);
		},
		countChoose: function (clear) {
			if (_status.imchoosing) {
				return;
			}
			_status.imchoosing = true;
			if (_status.connectMode && !_status.countDown) {
				ui.timer.show();
				var num;
				//这么一大行都是为了祢衡
				if (_status.event && _status.event.name == 'chooseToUse' && _status.event.type == 'phase' &&
					_status.event.player && _status.event.player.forceCountChoose &&
					typeof _status.event.player.forceCountChoose.phaseUse == 'number') {
					num = _status.event.player.forceCountChoose.phaseUse;
				}
				else if (_status.connectMode) {
					num = lib.configOL.choose_timeout;
				}
				else {
					num = get.config('choose_timeout');
				}
				game.countDown(parseInt(num), function () {
					ui.click.auto();
					ui.timer.hide();
				});
				if (!game.online && game.me) {
					if (_status.event.getParent().skillHidden) {
						for (var i = 0; i < game.players.length; i++) {
							game.players[i].showTimer();
						}
						game.me._hide_all_timer = true;
					}
					else if (!_status.event._global_waiting) {
						game.me.showTimer();
					}
				}
			}
			else if (_status.event.player.forceCountChoose && _status.event.isMine() && !_status.countDown) {
				var info = _status.event.player.forceCountChoose;
				var num;
				if (_status.event.name == 'chooseToUse' && _status.event.type == 'phase' && typeof info.phaseUse == 'number') {
					num = info.phaseUse;
				}
				else if (typeof info[_status.event.name] == 'number') {
					num = info[_status.event.name]
				}
				else if (info.default) {
					num = info.default;
				}
				else return;
				var finish = function () {
					if (_status.event.endButton) {
						if (_status.event.skill) {
							ui.click.cancel();
						}
						ui.click.cancel();
					}
					else {
						if (ui.confirm && ui.confirm.str) {
							if (ui.confirm.str.indexOf('c') != -1) {
								ui.click.cancel();
							}
							else if (ui.confirm.str.indexOf('o') != -1) {
								ui.click.ok();
							}
						}
						else if (['chooseControl', 'chooseBool'].contains(_status.event.name) && _status.paused) {
							_status.event.result = 'ai';
							game.resume();
						}
						else {
							ui.click.auto('forced');
							setTimeout(function () {
								ui.click.auto('forced');
							}, 200);
						}
					}
					ui.timer.hide();
				};
				if (!num) {
					ui.timer.hide();
					game.uncheck();
					setTimeout(finish, 200);
				}
				else {
					ui.timer.show();
					game.countDown(num, finish);
				}
			}
		},
		stopCountChoose: function () {
			if (_status.countDown) {
				clearInterval(_status.countDown);
				delete _status.countDown;
				ui.timer.hide();
			}
			if (_status.connectMode && !game.online && game.me) {
				if (game.me._hide_all_timer) {
					delete game.me._hide_all_timer;
					for (var i = 0; i < game.players.length; i++) {
						game.players[i].hideTimer();
					}
				}
				else if (!_status.event._global_waiting) {
					game.me.hideTimer();
				}
			}
		},
		connect: function (ip, callback) {
			if (game.online) return;
			var withport = false;
			var index = ip.lastIndexOf(':');
			if (index != -1) {
				index = parseFloat(ip.slice(index + 1));
				if (index && Math.floor(index) == index) {
					withport = true;
				}
			}
			if (!withport) {
				ip = ip + ':8080';
			}
			_status.connectCallback = callback;
			try {
				if (game.ws) {
					game.ws._nocallback = true;
					game.ws.close();
					delete game.ws;
				}
				game.ws = new WebSocket('ws://' + ip + '');
			}
			catch (e) {
				alert('错误：无效联机地址');
				if (callback) {
					callback(false);
				}
				return;
			}
			game.ws.onopen = lib.element.ws.onopen;
			game.ws.onmessage = lib.element.ws.onmessage;
			game.ws.onerror = lib.element.ws.onerror;
			game.ws.onclose = lib.element.ws.onclose;
			_status.ip = ip;
		},
		send: function () {
			if (game.observe && arguments[0] != 'reinited') return;
			if (game.ws) {
				var args = Array.from(arguments);
				if (typeof args[0] == 'function') {
					args.unshift('exec');
				}
				game.ws.send(JSON.stringify(get.stringifiedResult(args)));
			}
		},
		sendTo: function (id, message) {
			var ws = { wsid: id };
			for (var i in lib.element.nodews) {
				ws[i] = lib.element.nodews[i];
			}
			var client = {
				ws: ws,
				id: ws.wsid,
				closed: false
			};
			for (var i in lib.element.client) {
				client[i] = lib.element.client[i];
			}
			client.send(message);
		},
		createServer: function () {
			lib.node.clients = [];
			lib.node.banned = [];
			lib.node.observing = [];
			lib.node.torespond = {};
			lib.node.torespondtimeout = {};
			lib.playerOL = {};
			lib.cardOL = {};
			lib.wsOL = {};
			ui.create.roomInfo();
			ui.create.chat();

			if (game.onlineroom) {

			}
			else {
				var WebSocketServer = require('ws').Server;
				var wss = new WebSocketServer({ port: 8080 });

				game.ip = get.ip();

				wss.on('connection', lib.init.connection);
			}
		},
		playAudio: function () {
			if (_status.video && arguments[1] != 'video') return;
			var str = '';
			var onerror = null;
			for (var i = 0; i < arguments.length; i++) {
				if (typeof arguments[i] === 'string' || typeof arguments[i] == 'number') {
					str += '/' + arguments[i];
				}
				else if (typeof arguments[i] == 'function') {
					onerror = arguments[i]
				}
				if (_status.video) break;
			}
			if (!lib.config.repeat_audio && _status.skillaudio.contains(str)) return;
			_status.skillaudio.add(str);
			game.addVideo('playAudio', null, str);
			setTimeout(function () {
				_status.skillaudio.remove(str);
			}, 1000);
			var audio = document.createElement('audio');
			audio.autoplay = true;
			audio.volume = lib.config.volumn_audio / 8;
			if (str.indexOf('.mp3') != -1 || str.indexOf('.ogg') != -1) {
				audio.src = lib.assetURL + 'audio' + str;
			}
			else {
				audio.src = lib.assetURL + 'audio' + str + '.mp3';
			}
			audio.addEventListener('ended', function () {
				this.remove();
			});
			audio.onerror = function () {
				if (this._changed) {
					this.remove();
					if (onerror) {
						onerror();
					}
				}
				else {
					this.src = lib.assetURL + 'audio' + str + '.ogg';
					this._changed = true;
				}
			};
			ui.window.appendChild(audio);
			return audio;
		},
		trySkillAudio: function (skill, player, directaudio) {
			game.broadcast(game.trySkillAudio, skill, player, directaudio);
			var info = get.info(skill);
			if (!info) return;
			if ((!info.direct || directaudio) && lib.config.background_speak &&
				(!lib.skill.global.contains(skill) || lib.skill[skill].forceaudio)) {
				var audioname = skill;
				if (info.audioname2 && info.audioname2[player.name]) {
					audioname = info.audioname2[player.name];
					info = lib.skill[audioname];
				}
				var audioinfo = info.audio;
				if (typeof audioinfo == 'string' && lib.skill[audioinfo]) {
					audioname = audioinfo;
					audioinfo = lib.skill[audioname].audio;
				}
				if (typeof audioinfo == 'string') {
					if (audioinfo.indexOf('ext:') == 0) {
						audioinfo = audioinfo.split(':');
						if (audioinfo.length == 3) {
							if (audioinfo[2] == 'true') {
								game.playAudio('..', 'extension', audioinfo[1], audioname);
							}
							else {
								audioinfo[2] = parseInt(audioinfo[2]);
								if (audioinfo[2]) {
									game.playAudio('..', 'extension', audioinfo[1], audioname + Math.ceil(audioinfo[2] * Math.random()));
								}
							}
						}
						return;
					}
				}
				else if (Array.isArray(audioinfo)) {
					audioname = audioinfo[0];
					audioinfo = audioinfo[1];
				}
				if (Array.isArray(info.audioname) && player) {
					if (info.audioname.contains(player.name)) {
						audioname += '_' + player.name;
					}
					else if (info.audioname.contains(player.name1)) {
						audioname += '_' + player.name1;
					}
					else if (info.audioname.contains(player.name2)) {
						audioname += '_' + player.name2;
					}
				}
				if (typeof audioinfo == 'number') {
					game.playAudio('skill', audioname + Math.ceil(audioinfo * Math.random()));
				}
				else if (audioinfo) {
					game.playAudio('skill', audioname);
				}
				else if (true && info.audio !== false) {
					game.playSkillAudio(audioname);
				}
			}
		},
		playSkillAudio: function (name, index) {
			if (_status.video && arguments[1] != 'video') return;
			if (!lib.config.repeat_audio && _status.skillaudio.contains(name)) return;
			game.addVideo('playSkillAudio', null, name);
			if (name.indexOf('|') < name.lastIndexOf('|')) {
				name = name.slice(name.lastIndexOf('|') + 1);
			}
			_status.skillaudio.add(name);
			setTimeout(function () {
				_status.skillaudio.remove(name);
			}, 1000);
			var str = 'audio/skill/';
			var audio = document.createElement('audio');
			audio.autoplay = true;
			audio.volume = lib.config.volumn_audio / 8;
			audio.src = lib.assetURL + str + name + '.mp3';
			audio.addEventListener('ended', function () {
				this.remove();
			});
			if (typeof index != 'number') {
				index = Math.ceil(Math.random() * 2);
			}
			audio._changed = 1;
			audio.onerror = function () {
				switch (this._changed) {
					case 1: {
						audio.src = lib.assetURL + str + name + '.ogg';
						this._changed = 2;
						break;
					}
					case 2: {
						audio.src = lib.assetURL + str + name + index + '.mp3';
						this._changed = 3;
						break;
					}
					case 3: {
						audio.src = lib.assetURL + str + name + index + '.ogg';
						this._changed = 4;
						break;
					}
					default: {
						this.remove();
					}
				}
			};
			ui.window.appendChild(audio);
		},
		playBackgroundMusic: function () {
			if (lib.config.background_music == 'music_off') {
				ui.backgroundMusic.src = '';
			}
			else if (_status._aozhan == true && lib.config.mode_config.guozhan.aozhan_bgm != 'disabled') {
				var aozhan = lib.config.mode_config.guozhan.aozhan_bgm;
				ui.backgroundMusic.src = lib.assetURL + 'audio/background/aozhan_' + aozhan + '.mp3';
			}
			else {
				var music = lib.config.background_music;
				if (music == 'music_random') {
					music = lib.config.all.background_music.randomGet('music_off', 'music_random', _status.currentMusic);
				}
				_status.currentMusic = music;
				if (music == 'music_custom') {
					if (lib.config.background_music_src) {
						ui.backgroundMusic.src = lib.config.background_music_src;
					}
				}
				else {
					ui.backgroundMusic.src = lib.assetURL + 'audio/background/' + music + '.mp3';
				}
			}
		},
		import: function (type, content) {
			if (type == 'extension') {
				game.loadExtension(content);
			}
			else {
				if (!lib.imported[type]) {
					lib.imported[type] = {};
				}
				var content2 = content(lib, game, ui, get, ai, _status);
				if (content2.name) {
					lib.imported[type][content2.name] = content2;
					delete content2.name;
				}
			}
		},
		loadExtension: function (obj) {
			var noeval = false;
			if (typeof obj == 'function') {
				obj = obj(lib, game, ui, get, ai, _status);
				noeval = true;
			}
			lib.extensionMenu['extension_' + obj.name] = {
				enable: {
					name: '开启',
					init: true
				}
			};
			if (obj.package && obj.package.author) {
				lib.extensionMenu['extension_' + obj.name].author = {
					name: '作者：' + obj.package.author,
					clear: true,
					nopointer: true,
				}
			}
			if (obj.package && obj.package.intro) {
				lib.extensionMenu['extension_' + obj.name].intro = {
					name: obj.package.intro,
					clear: true,
					nopointer: true,
				}
			}
			for (var i in obj.config) {
				lib.extensionMenu['extension_' + obj.name][i] = obj.config[i];
			}
			for (var i in obj.help) {
				lib.help[i] = obj.help[i];
			}
			if (obj.editable !== false && lib.config.show_extensionmaker) {
				lib.extensionMenu['extension_' + obj.name].edit = {
					name: '编辑此扩展',
					clear: true,
					onclick: function () {
						if (game.editExtension && lib.extensionPack && lib.extensionPack[obj.name]) {
							game.editExtension(obj.name);
						}
						else {
							alert('无法编辑未启用的扩展，请启用此扩展并重启后重试')
						}
					}
				}
			}
			lib.extensionMenu['extension_' + obj.name].delete = {
				name: '删除此扩展',
				clear: true,
				onclick: function () {
					if (this.innerHTML == '<span>确认删除</span>') {
						var prefix = 'extension_' + obj.name;
						var page = this.parentNode;
						var start = page.parentNode.previousSibling;
						page.remove();
						if (start) {
							for (var i = 0; i < start.childElementCount; i++) {
								if (start.childNodes[i].link == page) {
									var active = false;
									if (start.childNodes[i].classList.contains('active')) {
										active = true;
									}
									start.childNodes[i].remove();
									if (active) {
										start.firstChild.classList.add('active');
										start.nextSibling.appendChild(start.firstChild.link);
									}
									break;
								}
							}
						}
						game.removeExtension(obj.name);
						if (obj.onremove) {
							obj.onremove();
						}
					}
					else {
						this.innerHTML = '<span>确认删除</span>';
						var that = this;
						setTimeout(function () {
							that.innerHTML = '<span>删除此扩展</span>';
						}, 1000);
					}
				}
			}

			if (!_status.importingExtension) {
				if (obj && lib.config['extension_' + obj.name + '_enable']) {
					if (!noeval) lib.init.eval(obj);
					var cfg = {};
					for (var j in lib.config) {
						if (j.indexOf('extension_' + obj.name) == 0 &&
							j != 'extension_' + obj.name) {
							cfg[j.slice(11 + obj.name.length)] = lib.config[j];
						}
					}
					try {
						if (obj.package) {
							lib.extensionPack[obj.name] = obj.package;
							lib.extensionPack[obj.name].files = obj.files || {};
							if (!lib.extensionPack[obj.name].files.character) {
								lib.extensionPack[obj.name].files.character = [];
							}
							if (!lib.extensionPack[obj.name].files.card) {
								lib.extensionPack[obj.name].files.card = [];
							}
							if (!lib.extensionPack[obj.name].files.skill) {
								lib.extensionPack[obj.name].files.skill = [];
							}
						}
						else {
							lib.extensionPack[obj.name] = {};
						}
						lib.extensionPack[obj.name].code = {
							content: obj.content,
							precontent: obj.precontent,
							help: obj.help,
							config: obj.config
						}
						if (obj.precontent) {
							_status.extension = obj.name;
							obj.precontent(cfg);
							delete _status.extension;
						}
						if (obj.content) {
							lib.extensions.push([obj.name, obj.content, cfg, _status.evaluatingExtension, obj.package || {}]);
						}
					}
					catch (e) {
						console.log(e);
					}
				}
			}
			else {
				game.importedPack = obj;
			}
		},
		createDir: function (dir, success, error) {
			var nullFC = function () { };
			success = success || nullFC;
			error = error || nullFC;
			dir = dir.split("/");
			if (window.resolveLocalFileSystemURL) {
				window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
					(function redo(entry) {
						var i = dir.shift();
						entry.getDirectory(i, { create: true }, function (dirEntry) {
							if (dir.length) redo(dirEntry);
							else success();
						});
					})(entry);
				}, error);
			}
			else {
				var fs = require("fs");
				var str = __dirname;
				(function redo() {
					str += "/";
					str += dir.shift();
					fs.exists(str, function (exists) {
						if (exists) {
							//已存在此目录
							if (dir.length) redo();
							else success();
						}
						else {
							fs.mkdir(str, function () {
								if (dir.length) redo();
								else success();
							});
						}
					});
				})();
			}
		},
		importExtension: function (data, finishLoad, exportext, pkg) {
			//by 来瓶可乐加冰
			if (!window.JSZip) {
				lib.init.js(lib.assetURL + 'game', 'jszip', function () {
					game.importExtension(data, finishLoad, exportext, pkg);
				});
			}
			else if (get.objtype(data) == 'object') {
				//导出
				var zip = new JSZip();
				var filelist = [];
				var filelist2 = [];
				if (data._filelist) {
					filelist2 = data._filelist;
					delete data._filelist;
				}
				for (var i in data) {
					zip.file(i, data[i]);
					filelist.push(i);
				}
				if (exportext) {
					if (pkg) {
						filelist.remove('extension.js');
						pkg.files = filelist.slice(0);
						pkg.files.addArray(filelist2);
						pkg.size = zip.generate({ type: "arraybuffer" }).byteLength;
						if (pkg.size < 1000) {
							pkg.size = pkg.size + 'B';
						}
						else if (pkg.size < 1000000) {
							pkg.size = Math.round(pkg.size / 1000) + 'KB';
						}
						else {
							pkg.size = Math.round(pkg.size / 100000) / 10 + 'MB';
						}
						var pkgstr = 'extension["' + exportext + '"]={\n';
						for (var i in pkg) {
							var pkgfrag;
							if (i == 'files') {
								var pkgjs = JSON.stringify(pkg[i]);
								var pkgfrag = '';
								var pkgbuffer = 0;
								for (var j = 0; j < pkgjs.length; j++) {
									pkgfrag += pkgjs[j];
									pkgbuffer++;
									if (pkgbuffer >= 80 && pkgjs[j] == ',' && pkgjs[j - 1] == '"') {
										pkgfrag += '\n\t\t';
										pkgbuffer = 0;
									}
								}
							}
							else {
								pkgfrag = JSON.stringify(pkg[i]);
							}
							pkgstr += '\t' + i + ':' + pkgfrag + ',\n'
						}
						pkgstr = pkgstr.slice(0, pkgstr.length - 2);
						pkgstr += '\n};';
						zip.file('package.js', pkgstr);
					}
					var blob = zip.generate({ type: "blob" });
					var fileNameToSaveAs = exportext;
					fileNameToSaveAs = fileNameToSaveAs.replace(/\\|\/|\:|\?|\"|\*|<|>|\|/g, '.');
					fileNameToSaveAs += '.zip';

					if (lib.device) {
						var directory;
						if (lib.device == 'android') {
							directory = cordova.file.externalDataDirectory;
						}
						else {
							directory = cordova.file.documentsDirectory;
						}
						window.resolveLocalFileSystemURL(directory, function (entry) {
							entry.getFile(fileNameToSaveAs, { create: true }, function (fileEntry) {
								fileEntry.createWriter(function (fileWriter) {
									fileWriter.onwriteend = function () {
										alert('文件已导出至' + directory + fileNameToSaveAs);
									}
									fileWriter.write(blob)
								});
							});
						});
					}
					else {
						var downloadLink = document.createElement("a");
						downloadLink.download = fileNameToSaveAs;
						downloadLink.innerHTML = "Download File";
						downloadLink.href = window.URL.createObjectURL(blob);
						downloadLink.click();
					}

					if (typeof finishLoad == 'function') {
						finishLoad();
					}
				}
				else {
					game.importExtension.apply(this, [zip.generate({ type: 'arraybuffer' }), finishLoad]);
				}
			}
			else {
				//导入
				function UHP() {
					alert("导入失败");
				};
				var zip = new JSZip();
				try {
					zip.load(data);
					// alert(zip.file('文件夹/加扩展.js').asText())
					var str = zip.file('extension.js').asText();
					if (str === "" || undefined) throw ('你导入的不是扩展！请选择正确的文件');
					_status.importingExtension = true;
					eval(str);
					_status.importingExtension = false;
					if (!game.importedPack) throw ('err');
					var extname = game.importedPack.name;
					if (lib.config.all.plays.contains(extname)) {
						throw ('禁止安装游戏原生扩展');
					}
					if (lib.config.extensions.contains(extname)) {
						game.removeExtension(extname, true);
					}
					lib.config.extensions.add(extname);
					game.saveConfig('extensions', lib.config.extensions);
					game.saveConfig('extension_' + extname + '_enable', true);
					for (var i in game.importedPack.config) {
						if (game.importedPack.config[i] && game.importedPack.config[i].hasOwnProperty('init')) {
							game.saveConfig('extension_' + extname + '_' + i, game.importedPack.config[i].init);
						}
					}
					if (game.download) {
						var filelist = [];
						for (var i in zip.files) {
							//alert(zip.files[i].dir+i)
							if (!zip.files[i].dir && i[0] != '.' && i[0] != '_') {
								filelist.push(i);
							}
						}
						//alert(filelist)
						if (lib.node && lib.node.fs) {
							//电脑端
							//具备nodeJS环境
							game.ensureDirectory('extension/' + extname, function () {
								var writeFile = function (e) {
									if (e) {
										finishLoad();
										UHP();
										return;
									}
									if (filelist.length) {
										var filename = filelist.shift();
										//filename 数组 ...dir+/+file
										var zipdir = filename;
										filename = filename.split("/");
										var name = filename.pop();
										if (filename.length) game.createDir('extension/' + extname + "/" + filename.join("/"), function () {
											//这里需要个创文件夹的函数
											Letgo(filename.join("/") + "/" + name);
										}, UHP);
										else Letgo(name);
										function Letgo(name) {
											lib.node.fs.writeFile(__dirname + '/extension/' + extname + "/" + name, zip.file(zipdir).asNodeBuffer(), null, writeFile);
										}
									}
									else {
										finishLoad();
									}
								}
								writeFile();
							});
						}
						else {
							window.resolveLocalFileSystemURL(lib.assetURL, function (entry) {
								entry.getDirectory('extension/' + extname, { create: true }, function (dirEntry) {
									//扩展文件夹
									writeFile();
									function writeFile() {
										if (filelist.length) {
											var filename = filelist.shift();
											//filename 数组 ...dir+/+file
											var zipdir = filename;
											filename = filename.split("/");
											var name = filename.pop();
											if (filename.length) game.createDir('extension/' + extname + "/" + filename.join("/"), function () {
												Letgo(filename.join("/") + "/" + name);
											}, UHP);
											else Letgo(name);
											function Letgo(name) {
												dirEntry.getFile(name, { create: true }, function (fileEntry) {
													fileEntry.createWriter(function (fileWriter) {
														fileWriter.onwriteend = writeFile;
														fileWriter.write(zip.file(zipdir).asArrayBuffer());
													});
												}, UHP);
											}
										}
										else {
											finishLoad();
										}
									};

								});
							});
						}
					}
					else {
						localStorage.setItem(lib.configprefix + 'extension_' + extname, str);
						var imglist = [];
						for (var i in zip.files) {
							if (i[0] != '.' && i[0] != '_') {
								if (i.indexOf('.jpg') != -1 || i.indexOf('.png') != -1) {
									imglist.push(i);
								}
							}
						}
						if (imglist.length && lib.db) {
							lib.config.extensionInfo[extname] = {
								image: imglist
							}
							game.saveConfig('extensionInfo', lib.config.extensionInfo);
							for (var i = 0; i < imglist.length; i++) {
								var imgname = imglist[i];
								var str = zip.file(imgname).asArrayBuffer();
								if (str) {
									var blob = new Blob([str]);
									var fileReader = new FileReader();
									fileReader.onload = (function (imgname) {
										return function (fileLoadedEvent) {
											var data = fileLoadedEvent.target.result;
											game.putDB('image', 'extension-' + extname + ':' + imgname, data);
										};
									}(imgname))
									fileReader.readAsDataURL(blob, "UTF-8");
								}
							}
						}
						finishLoad();
					}
					delete game.importedPack;
				}
				catch (e) {
					console.log(e);
					alert('导入失败');
					return false;
				}
			};
		},
		export: function (textToWrite, name) {
			var textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
			var fileNameToSaveAs = name || 'noname';
			fileNameToSaveAs = fileNameToSaveAs.replace(/\\|\/|\:|\?|\"|\*|<|>|\|/g, '.');

			if (lib.device) {
				var directory;
				if (lib.device == 'android') {
					directory = cordova.file.externalDataDirectory;
				}
				else {
					directory = cordova.file.documentsDirectory;
				}
				window.resolveLocalFileSystemURL(directory, function (entry) {
					entry.getFile(fileNameToSaveAs, { create: true }, function (fileEntry) {
						fileEntry.createWriter(function (fileWriter) {
							fileWriter.onwriteend = function () {
								alert('文件已导出至' + directory + fileNameToSaveAs);
							}
							fileWriter.write(textFileAsBlob)
						});
					});
				});
			}
			else {
				var downloadLink = document.createElement("a");
				downloadLink.download = fileNameToSaveAs;
				downloadLink.innerHTML = "Download File";
				downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
				downloadLink.click();
			}
		},
		multiDownload2: function (list, onsuccess, onerror, onfinish, process, dev) {
			list = list.slice(0);
			var download = function () {
				if (list.length) {
					var current = list.shift();
					var current2;
					if (typeof process == 'function') {
						current2 = process(current);
					}
					else {
						current2 = current;
					}
					if (current.indexOf('theme') == 0) {
						game.print(current.slice(6));
					}
					else if (current.indexOf('image/skin') == 0) {
						game.print(current.slice(11));
					}
					else {
						game.print(current.slice(current.lastIndexOf('/') + 1));
					}
					game.download(current, current2, function () {
						if (onsuccess) onsuccess(list.length);
						download();
					}, function () {
						if (onerror) onerror(list.length);
						download();
					}, dev);
				}
				else {
					if (onfinish) onfinish();
				}
			}
			download();
		},
		multiDownload: function (list, onsuccess, onerror, onfinish, process, dev) {
			if (lib.config.dev) game.print(get.url());
			var args = Array.from(arguments);
			if (list.length <= 3) {
				game.multiDownload2.apply(this, args);
			}
			else {
				var num = Math.round(list.length / 3);
				var left = 3;
				args[3] = function () {
					left--;
					if (left == 0) {
						onfinish();
					}
				};
				setTimeout(function () {
					args[0] = list.slice(0, num); game.multiDownload2.apply(game, args);
				});
				setTimeout(function () {
					args[0] = list.slice(num, 2 * num); game.multiDownload2.apply(this, args);
				}, 200);
				setTimeout(function () {
					args[0] = list.slice(2 * num); game.multiDownload2.apply(this, args);
				}, 400);
			}
		},
		fetch: function (url, onload, onerror, onprogress) {
			var tmpName = '~tmp' + get.id();
			game.download(encodeURI(url), tmpName, function () {
				game.readFile(tmpName, function (data) {
					onload(data);
					game.removeFile(tmpName);
				}, onerror);
			}, onerror, null, onprogress);
		},
		playVideo: function (time, mode) {
			if (!_status.replayvideo) {
				localStorage.setItem(lib.configprefix + 'playbackmode', lib.config.mode);
			}
			game.saveConfig('mode', mode);
			localStorage.setItem(lib.configprefix + 'playback', time);
			game.reload();
		},
		playVideoContent: function (video) {
			var next = game.createEvent('video', false);
			next.video = video;
			ui.system.style.display = 'none';
			ui.system.hide();
			ui.arena.style.display = 'none';
			ui.arena.hide();
			ui.window.classList.remove('leftbar');
			ui.window.classList.remove('rightbar');
			ui.historybar.style.display = 'none';
			_status.event = next;
			_status.paused = false;
			_status.paused2 = false;
			_status.over = false;
			_status.video = true;
			clearTimeout(_status.timeout);

			for (var i in lib.characterPack) {
				for (var j in lib.characterPack[i]) {
					lib.character[j] = lib.character[j] || lib.characterPack[i][j];
				}
			}
			next.setContent('playVideoContent');
			game.loop();
		},
		videoContent: {
			arrangeLib: function (content) {
				for (var i in content) {
					for (var j in content[i]) {
						lib[i][j] = content[i][j];
					}
				}
			},
			jiuNode: function (player, bool) {
				//Powered by 升麻
				if (bool) {
					if (!player.node.jiu && lib.config.jiu_effect) {
						player.node.jiu = ui.create.div('.playerjiu', player.node.avatar);
						player.node.jiu2 = ui.create.div('.playerjiu', player.node.avatar2);
					}
				}
				else {
					if (player.node.jiu) {
						player.node.jiu.delete();
						player.node.jiu2.delete();
						delete player.node.jiu;
						delete player.node.jiu2;
					}
				}
			},
			init: function (players) {
				if (game.chess) return;
				if (lib.config.mode == 'versus') {
					players.bool = players.pop();
				}
				ui.arena.setNumber(players.length);
				ui.arena.classList.add('video');
				game.players.length = 0;
				game.dead.length = 0;
				ui.create.players(players.length);
				game.me = game.players[0];
				ui.handcards1 = game.me.node.handcards1;
				ui.handcards2 = game.me.node.handcards2;
				ui.handcards1Container.appendChild(ui.handcards1);
				ui.handcards2Container.appendChild(ui.handcards2);
				if (lib.config.mode == 'versus') {
					if (players.bool) {
						ui.arena.setNumber(parseInt(ui.arena.dataset.number) + 1);
						for (var i = 0; i < game.players.length; i++) {
							game.players[i].dataset.position = parseInt(game.players[i].dataset.position) + 1;
						}
						game.singleHandcard = true;
						ui.arena.classList.add('single-handcard');
						ui.window.classList.add('single-handcard');
						ui.fakeme = ui.create.div('.fakeme.avatar', ui.me);
					}
					ui.arena.style.display = '';
					ui.refresh(ui.arena);
					ui.arena.show();
				}
				else if (lib.config.mode == 'boss') {
					if (!players.boss) {
						game.singleHandcard = true;
						ui.arena.classList.add('single-handcard');
						ui.window.classList.add('single-handcard');
						ui.fakeme = ui.create.div('.fakeme.avatar', ui.me);
					}
					ui.arena.setNumber(8);
				}
				ui.updatehl();
				for (var i = 0; i < players.length; i++) {
					if (lib.config.mode == 'identity') {
						game.players[i].init(players[i].name, players[i].name2);
						game.players[i].setIdentity(players[i].identity);
					}
					else if (lib.config.mode == 'doudizhu' || lib.config.mode == 'single') {
						game.players[i].init(players[i].name, players[i].name2);
						game.players[i].setIdentity(players[i].identity);
					}
					else if (lib.config.mode == 'stone') {
						game.players[i].init(players[i].name, players[i].name2);
						game.players[i].classList.add('noidentity');
						game.players[i].updateActCount(null, players[i].count, 0);
					}
					else if (lib.config.mode == 'boss') {
						game.players[i].init(players[i].name, players[i].name2);
						game.players[i].setIdentity(players[i].identity);
						game.players[i].dataset.position = players[i].position;
						game.players[i].node.action.innerHTML = '行动';
					}
					else if (lib.config.mode == 'versus') {
						game.players[i].init(players[i].name, players[i].name2);
						game.players[i].node.identity.firstChild.innerHTML = players[i].identity;
						game.players[i].node.identity.dataset.color = players[i].color;
						game.players[i].node.action.innerHTML = '行动';
					}
					else if (lib.config.mode == 'guozhan') {
						game.players[i].name = players[i].name;
						game.players[i].name1 = players[i].name1;
						game.players[i].name2 = players[i].name2;

						game.players[i].sex = 'unknown';
						game.players[i].identity = 'unknown';

						lib.translate[game.players[i].name] = players[i].translate;
						game.players[i].init(players[i].name1, players[i].name2);

						game.players[i].classList.add('unseen_v');
						game.players[i].classList.add('unseen2_v');
						if (game.players[i] != game.me) {
							game.players[i].node.identity.firstChild.innerHTML = '猜';
							game.players[i].node.identity.dataset.color = 'unknown';
						}
						else {
							game.players[i].setIdentity(game.players[i].group);
						}
					}
				}
				for (var i = 0; i < game.players.length; i++) {
					game.playerMap[game.players[i].dataset.position] = game.players[i];
				}

				if (lib.config.mode == 'versus') {
					if (players.bool) {
						game.onSwapControl();
					}
				}
				else if (lib.config.mode == 'boss') {
					if (!players.boss) {
						game.onSwapControl();
					}
					ui.arena.style.display = '';
					ui.refresh(ui.arena);
					ui.arena.show();
					ui.updatehl();
				}
			},
			newcard: function (content) {
				if (content) {
					lib.translate[content.name] = content.translate;
					lib.translate[content.name + '_info'] = content.info;
					lib.card[content.name] = {};
					lib.card[content.name].cardimage = content.card
					for (var i in lib.card[content.card]) {
						lib.card[content.name][i] = lib.card[content.card][i];
					}
					if (content.legend) {
						lib.card[content.name].legend = true;
					}
					else if (content.epic) {
						lib.card[content.name].epic = true;
					}
					else if (content.unique) {
						lib.card[content.name].unique = true;
					}
				}
			},
			changeLand: function (player, url) {
				game.changeLand(url, player);
			},
			destroyLand: function () {
				if (ui.land) {
					ui.land.destroy();
				}
			},
			playAudio: function (str) {
				game.playAudio(str, 'video');
			},
			playSkillAudio: function (name) {
				game.playSkillAudio(name, 'video');
			},
			phaseChange: function (player) {
				if (player) {
					var glowing = document.querySelector('.glow_phase');
					if (glowing) {
						glowing.classList.remove('glow_phase');
					}
					if (lib.config.glow_phase) {
						player.classList.add('glow_phase');
						// player.dataset.glow_phase=lib.config.glow_phase;
					}
				}
				else {
					console.log(player);
				}
			},
			playerfocus: function (player, time) {
				if (player && player.playerfocus) {
					player.playerfocus(time);
				}
				else {
					console.log(player);
				}
			},
			playerfocus2: function () {
				ui.arena.classList.add('playerfocus');
				setTimeout(function () {
					ui.arena.classList.remove('playerfocus');
				}, 1500)
			},
			identityText: function (player, str) {
				if (player && str) {
					player.node.identity.firstChild.innerHTML = str;
				}
				else {
					console.log(player);
				}
			},
			identityColor: function (player, str) {
				if (player && str) {
					player.node.identity.dataset.color = str;
				}
				else {
					console.log(player);
				}
			},
			chessSwap: function (content) {
				var me = game.playerMap[content[0]];
				var player = game.playerMap[content[1]];
				if (me) {
					me.classList.remove('current_action');
				}
				if (player) {
					player.classList.add('current_action');
				}
			},
			chessgainmod: function (player, num) {
				if (Array.isArray(num)) {
					num = get.infoCards(num);
				}
				if (player && player.$gainmod) {
					player.$gainmod(num);
				}
				else {
					console.log(player);
				}
			},
			moveTo: function (player, pos) {
				if (player && player.moveTo && pos) {
					player.moveTo(pos[0], pos[1]);
				}
				else {
					console.log(player)
				}
			},
			addObstacle: function (pos) {
				if (pos) {
					game.addObstacle(pos[0], pos[1]);
				}
			},
			removeObstacle: function (pos) {
				game.removeObstacle(pos);
			},
			moveObstacle: function (pos) {
				if (pos) {
					game.moveObstacle(pos[0], pos[1], pos[2]);
				}
			},
			colorObstacle: function (pos) {
				if (pos) {
					game.colorObstacle(pos[0], pos[1]);
				}
			},
			thrownhighlight1: function () {
				ui.arena.classList.add('thrownhighlight');
			},
			thrownhighlight2: function () {
				ui.arena.classList.remove('thrownhighlight');
			},
			chessFocus: function (player) {
				if (player) {
					player.chessFocus();
				}
				else {
					console.log('chessFocus');
				}
			},
			removeTreasure: function (pos) {
				if (game.playerMap[pos]) {
					game.playerMap[pos].delete();
					delete game.playerMap[pos];
				}
				else {
					console.log(pos);
				}
			},
			initobs: function (obs) {
				if (obs) {
					for (var i = 0; i < obs.length; i++) {
						game.addObstacle(obs[i]);
					}
				}
				else {
					console.log(obs);
				}
			},
			stonePosition: function (content) {
				var player = game.playerMap[content[0]];
				if (player) {
					delete game.playerMap[content[0]];
					player.dataset.position = content[1];
					game.playerMap[content[1]] = player;
				}
				else {
					console.log(content);
				}
			},
			bossSwap: function (player, name) {
				if (player && name) {
					player.delete();
					var noboss = false;
					if (name[0] == '_') {
						name = name.slice(1);
						noboss = true;
					}
					var boss = ui.create.player().init(name);
					boss.dataset.position = player.dataset.position;
					game.playerMap[player.dataset.position] = boss;
					if (game.me == player) {
						game.me = boss;
					}
					game.players.push(boss);
					game.arrangePlayers();
					if (!noboss) {
						game.boss = boss;
						boss.setIdentity('zhu');
						boss.identity = 'zhu';
					}
					else {
						boss.setIdentity('zhong');
						boss.identity = 'zhong';
					}
					ui.arena.appendChild(boss.animate('zoominanim'));
				}
			},
			stoneSwap: function (info) {
				var player = ui.create.player();
				player.classList.add('noidentity');
				player.dataset.position = info.position;
				player.animate(info.me ? 'replaceme' : 'replaceenemy');
				player.actcount = info.actcount;
				player.init(info.name, info.name2);
				game.players.push(player);
				player.updateActCount(null, info.actcount, 0);
				ui.arena.appendChild(player);
				game.playerMap[player.dataset.position] = player;
				game.arrangePlayers();
			},
			chess_tongshuai: function (player, content) {
				if (player && player.storage) {
					player.storage.tongshuai.owned = content;
				}
				else {
					console.log(player);
				}
			},
			chess_tongshuai_skill: function (player, content) {
				if (player && content) {
					if (player.marks.tongshuai.firstChild) {
						player.marks.tongshuai.firstChild.remove();
					}
					player.marks.tongshuai.setBackground(content[0], 'character');
					player.additionalSkills.tongshuai = content[1];
				}
				else {
					console.log(player);
				}
			},
			smoothAvatar: function (player, vice) {
				if (player && player.node) {
					if (vice) {
						if (player.node.avatar2) {
							player.smoothAvatar(vice);
						}
					}
					else {
						if (player.node.avatar) {
							player.smoothAvatar(vice);
						}
					}
				}
			},
			setAvatar: function (player, content) {
				if (player && content && content.length == 2) {
					player.setAvatar(content[0], content[1])
				}
			},
			setAvatarQueue: function (player, content) {
				if (player && content && content.length == 2) {
					player.setAvatarQueue(content[0], content[1])
				}
			},
			addSubPlayer: function (player, content) {
				if (player && content && content[0] && content[1] &&
					content[2] && content[3] && content[4]) {
					var skill = content[0];
					lib.skill[skill] = content[1];
					lib.character[skill] = content[2];
					lib.translate[skill] = content[3];
					player.storage[skill] = content[4];
				}
			},
			arenaNumber: function (content) {
				ui.arena.dataset.number = content;
			},
			reinit: function (source, content) {
				if (source && content) {
					source.uninit();
					source.init(content[0]);
					source.node.identity.dataset.color = content[1];
				}
				else {
					console.log(source);
				}
			},
			reinit2: function (source, name) {
				if (source && name) {
					source.init(name);
				}
				else {
					console.log(source);
				}
			},
			reinit3: function (source, content) {
				if (source && content) {
					var info1 = lib.character[content.from];
					var info2 = lib.character[content.to];
					if (content.avatar2) {
						source.name2 = content.to;
						if (source.isUnseen(0)) {
							source.sex = info2[0];
						}
						source.node.avatar2.setBackground(content.to, 'character');
						source.node.name2.innerHTML = get.slimName(content.to);
					}
					else {
						source.name = content.to;
						source.sex = info2[0];
						source.node.avatar.setBackground(content.to, 'character');
						source.node.name.innerHTML = get.slimName(content.to);
					}
					source.maxHp = content.hp;
					this.update();
					for (var i = 0; i < info1[3].length; i++) {
						source.removeSkill(info1[3][i]);
					}
					for (var i = 0; i < info2[3].length; i++) {
						source.addSkill(info2[3][i]);
					}
				}
			},
			skill: function (player, content) {
				if (typeof content == 'string') {
					lib.skill[content].video(player);
				}
				else if (Array.isArray(content)) {
					lib.skill[content[0]].video(player, content[1]);
				}
				else {
					console.log(player, content)
				}
			},
			addFellow: function (content) {
				var player = game.addFellow(content[0], content[1], content[2]);
				game.playerMap[player.dataset.position] = player;
			},
			windowzoom1: function () {
				ui.window.style.transition = 'all 0.5s';
				ui.window.classList.add('zoomout3');
				ui.window.hide();
			},
			windowzoom2: function () {
				ui.window.style.transition = 'all 0s';
				ui.refresh(ui.window);
			},
			windowzoom3: function () {
				ui.window.classList.remove('zoomout3');
				ui.window.classList.add('zoomin3');
			},
			windowzoom4: function () {
				ui.window.style.transition = 'all 0.5s';
				ui.refresh(ui.window);
				ui.window.show();
				ui.window.classList.remove('zoomin3');
			},
			windowzoom5: function () {
				ui.window.style.transition = '';
			},
			updateActCount: function (player, content) {
				if (player && content) {
					player.updateActCount(content[0], content[1], content[2]);
				}
				else {
					console.log(player);
				}
			},
			setIdentity: function (player, identity) {
				if (player && identity) {
					player.setIdentity(identity);
				}
				else {
					console.log(num);
				}
			},
			showCharacter: function (player, num) {
				if (player && player.classList) {
					switch (num) {
						case 0:
							player.classList.remove('unseen_v');
							break;
						case 1:
							player.classList.remove('unseen2_v');
							break;
						case 2:
							player.classList.remove('unseen_v');
							player.classList.remove('unseen2_v');
							break;
					}
				}
				else {
					console.log(num);
				}
			},
			hidePlayer: function (player) {
				if (player) {
					player.hide();
				}
			},
			deleteHandcards: function (player) {
				if (player) {
					player.node.handcards1.delete();
					player.node.handcards2.delete();
				}
			},
			hideCharacter: function (player, num) {
				if (player && player.classList) {
					switch (num) {
						case 0:
							player.classList.add('unseen_v');
							break;
						case 1:
							player.classList.add('unseen2_v');
							break;
						case 2:
							player.classList.add('unseen_v');
							player.classList.add('unseen2_v');
							break;
					}
				}
				else {
					console.log(num);
				}
			},
			popup: function (player, info) {
				if (player && info) {
					player.popup(info[0], info[1]);
				}
				else {
					console.log(player);
				}
			},
			log: function (str) {
				game.log(str);
			},
			draw: function (player, info) {
				if (player && player.$draw) {
					player.$draw(info);
				}
				else {
					console.log(player);
				}
			},
			drawCard: function (player, info) {
				if (player && info) {
					player.$draw(get.infoCards(info));
				}
				else {
					console.log(player);
				}
			},
			throw: function (player, info) {
				if (player && info) {
					player.$throw(get.infoCards(info[0]), info[1], null, info[2]);
				}
				else {
					console.log(player);
				}
			},
			compare: function (player, info) {
				if (player && info) {
					player.$compare(get.infoCard(info[0]), game.playerMap[info[1]], get.infoCard(info[2]));
				}
				else {
					console.log(player);
				}
			},
			compareMultiple: function (player, info) {
				if (player && info) {
					player.$compareMultiple(get.infoCard(info[0]), get.infoTargets(info[1]), get.infoCards(info[2]));
				}
				else {
					console.log(player);
				}
			},
			give: function (player, info) {
				if (player && info) {
					player.$give(info[0], game.playerMap[info[1]]);
				}
				else {
					console.log(player);
				}
			},
			giveCard: function (player, info) {
				if (player && info) {
					player.$give(get.infoCards(info[0]), game.playerMap[info[1]]);
				}
				else {
					console.log(player);
				}
			},
			gain: function (player, info) {
				if (player && player.$gain) {
					player.$gain(info);
				}
				else {
					console.log(player);
				}
			},
			gainCard: function (player, info) {
				if (player && info) {
					player.$gain(get.infoCards(info));
				}
				else {
					console.log(player);
				}
			},
			gain2: function (player, cards) {
				if (player && player.$draw) {
					var nodeList = document.querySelectorAll('#arena>.card,#chess>.card');
					var nodes = [];
					for (var i = 0; i < nodeList.length; i++) {
						nodes.push(nodeList[i]);
					}
					for (var i = 0; i < cards.length; i++) {
						for (var j = 0; j < nodes.length; j++) {
							if (cards[i][2] == nodes[j].name && cards[i][0] == nodes[j].suit && cards[i][1] == nodes[j].number) {
								nodes[j].moveDelete(player);
								cards.splice(i--, 1);
								nodes.splice(j--, 1);
								break;
							}
						}
					}
					if (cards.length) {
						player.$draw(get.infoCards(cards));
					}
				}
				else {
					console.log(player);
				}
			},
			deletenode: function (player, cards, method) {
				if (cards) {
					var nodeList = document.querySelectorAll('#arena>.card,#chess>.card');
					var nodes = [];
					for (var i = 0; i < nodeList.length; i++) {
						nodes.push(nodeList[i]);
					}
					for (var i = 0; i < cards.length; i++) {
						for (var j = 0; j < nodes.length; j++) {
							if (cards[i][2] == nodes[j].name && cards[i][0] == nodes[j].suit && cards[i][1] == nodes[j].number) {
								nodes[j].delete();
								if (method == 'zoom') {
									nodes[j].style.transform = 'scale(0)';
								}
								cards.splice(i--, 1);
								nodes.splice(j--, 1);
								break;
							}
						}
					}
				}
				else {
					console.log(player, cards);
				}
			},
			highlightnode: function (player, card) {
				if (card) {
					var nodeList = document.querySelectorAll('#arena>.card,#chess>.card');
					var nodes = [];
					for (var i = 0; i < nodeList.length; i++) {
						nodes.push(nodeList[i]);
					}
					for (var j = nodes.length - 1; j >= 0; j--) {
						if (card[2] == nodes[j].name && card[0] == nodes[j].suit && card[1] == nodes[j].number) {
							nodes[j].classList.add('thrownhighlight');
							break;
						}
					}
				}
				else {
					console.log(player, cards);
				}
			},
			uiClear: function () {
				ui.clear();
			},
			judge1: function (player, content) {
				if (player && content) {
					var judging = get.infoCard(content[0]);
					if (game.chess) {
						judging.copy('thrown', 'center', 'thrownhighlight', ui.arena).animate('start');
					}
					else {
						player.$throwordered(judging.copy('thrownhighlight'), true);
					}

					ui.create.dialog(content[1]).videoId = content[2];
					ui.arena.classList.add('thrownhighlight');
				}
				else {
					console.log(player);
				}
			},
			centernode: function (content) {
				get.infoCard(content).copy('thrown', 'center', 'thrownhighlight', ui.arena).animate('start');
			},
			judge2: function (videoId) {
				for (var i = 0; i < ui.dialogs.length; i++) {
					if (ui.dialogs[i].videoId == videoId) {
						ui.dialogs[i].close();
					}
				}
				ui.arena.classList.remove('thrownhighlight');
			},
			unmarkname: function (player, name) {
				if (player && player.unmark) {
					player.unmark(name);
				}
				else {
					console.log(player);
				}
			},
			unmark: function (player, name) {
				if (player && player.marks && player.marks[name]) {
					player.marks[name].delete();
					player.marks[name].style.transform += ' scale(0.2)';
					delete player.marks[name];
					ui.updatem(this);
				}
			},
			flame: function (player, type) {
				if (player && type) {
					player['$' + type]();
				}
				else {
					console.log(player);
				}
			},
			line: function (player, content) {
				if (player && content) {
					player.line(game.playerMap[content[0]], content[1]);
				}
				else {
					console.log(player);
				}
			},
			fullscreenpop: function (player, content) {
				if (player && content) {
					player.$fullscreenpop(content[0], content[1], content[2]);
				}
				else {
					console.log(player);
				}
			},
			damagepop: function (player, content) {
				if (player && content) {
					player.$damagepop(content[0], content[1], content[2]);
				}
				else {
					console.log(player);
				}
			},
			damage: function (player, source) {
				if (player && player.$damage) {
					player.$damage(game.playerMap[source]);
				}
				else {
					console.log(player);
				}
			},
			diex: function (player) {
				if (!player) {
					console.log('diex');
					return;
				}
				var cards = player.getCards('hej');
				for (var i = 0; i < cards.length; i++) {
					cards[i].discard();
				}
				while (player.node.marks.childNodes.length > 1) {
					player.node.marks.lastChild.remove();
				}
				player.classList.add('dead');
				player.classList.remove('turnedover');
				player.classList.remove('out');
				player.node.count.innerHTML = '0';
				player.node.hp.hide();
				player.node.equips.hide();
				player.node.count.hide();
				player.previous.next = player.next;
				player.next.previous = player.previous;
				game.players.remove(player);
				game.dead.push(player);
				if (lib.config.mode == 'stone') {
					setTimeout(function () {
						player.delete();
					}, 500);
				}
			},
			tafangMe: function (player) {
				if (player) {
					game.me = player;
					ui.me.lastChild.show();
					ui.create.fakeme();
					ui.handcards1 = player.node.handcards1.animate('start').fix();
					ui.handcards2 = player.node.handcards2.animate('start').fix();
					ui.handcards1Container.appendChild(ui.handcards1);
					ui.handcards2Container.appendChild(ui.handcards2);
					ui.updatehl();
					game.setChessInfo();
				}
			},
			deleteChessPlayer: function (player) {
				if (player) {
					player.delete();
					delete game.playerMap[player.dataset.position];
					game.players.remove(player);
					for (var i = 0; i < ui.phasequeue.length; i++) {
						if (ui.phasequeue[i].link == player) {
							ui.phasequeue[i].remove();
							ui.phasequeue.splice(i, 1);
							break;
						}
					}
				}
			},
			addChessPlayer: function (content) {
				game.addChessPlayer.apply(this, content);
			},
			die: function (player) {
				if (!player) {
					console.log('die');
					return;
				}
				player.$die();
				if (game.chess) {
					delete lib.posmap[player.dataset.position];
					setTimeout(function () {
						player.delete();
					}, 500);
					for (var i = 0; i < ui.phasequeue.length; i++) {
						if (ui.phasequeue[i].link == player) {
							ui.phasequeue[i].remove();
							ui.phasequeue.splice(i, 1);
							break;
						}
					}
				}
			},
			revive: function (player) {
				if (!player) {
					console.log('revive');
					return;
				}
				player.classList.remove('dead');
				player.node.hp.show();
				player.node.equips.show();
				player.node.count.show();
				player.node.avatar.style.transform = '';
				player.node.avatar2.style.transform = '';
				player.removeAttribute('style');
			},
			update: function (player, info) {
				if (player && info) {
					player.hp = info[1];
					player.maxHp = info[2];
					player.hujia = info[3];
					player.update(info[0]);
				}
				else {
					console.log(player);
				}
			},
			phaseJudge: function (player, card) {
				if (player && card) {
					// player.$phaseJudge(get.infoCard(card));
				}
				else {
					console.log(player);
				}
			},
			directgain: function (player, cards) {
				if (player && cards) {
					player.directgain(get.infoCards(cards));
				}
				else {
					console.log(player);
				}
			},
			directequip: function (player, cards) {
				if (player && cards) {
					player.directequip(get.infoCards(cards));
				}
				else {
					console.log(player);
				}
			},
			gain12: function (player, cards12) {
				if (player && cards12) {
					var cards1 = get.infoCards(cards12[0]);
					var cards2 = get.infoCards(cards12[1]);
					for (var i = 0; i < cards1.length; i++) {
						cards1[i].classList.add('drawinghidden');
						player.node.handcards1.insertBefore(cards1[i], player.node.handcards1.firstChild);
					}
					for (var i = 0; i < cards2.length; i++) {
						cards2[i].classList.add('drawinghidden');
						player.node.handcards2.insertBefore(cards2[i], player.node.handcards2.firstChild);
					}
					ui.updatehl();
				}
				else {
					console.log(player);
				}
			},
			equip: function (player, card) {
				if (player && card) {
					player.$equip(get.infoCard(card));
				}
				else {
					console.log(player);
				}
			},
			addJudge: function (player, content) {
				if (player && content) {
					var card = get.infoCard(content[0]);
					card.viewAs = content[1];
					if (card.viewAs && card.viewAs != card.name && (card.classList.contains('fullskin') || card.classList.contains('fullborder'))) {
						card.classList.add('fakejudge');
						card.node.background.innerHTML = lib.translate[card.viewAs + '_bg'] || get.translation(card.viewAs)[0]
					}
					card.classList.add('drawinghidden');
					player.node.judges.insertBefore(card, player.node.judges.firstChild);
					ui.updatej(player);
				}
				else {
					console.log(player);
				}
			},
			markCharacter: function (player, content) {
				if (player && content) {
					if (game.playerMap[content.target]) {
						content.target = game.playerMap[content.target];
					}
					var mark = player.markCharacter(content.target, content);
					if (content.id) {
						player.marks[content.id] = mark;
					}
				}
				else {
					console.log(player);
				}
			},
			changeMarkCharacter: function (player, content) {
				if (player && content && player.marks[content.id]) {
					player.marks[content.id].info = {
						name: content.name,
						content: content.content
					};
					player.marks[content.id].setBackground(content.target, 'character');
				}
			},
			mark: function (player, content) {
				if (player && content) {
					var mark = player.mark(content.id, content);
				}
				else {
					console.log(player);
				}
			},
			markSkill: function (player, content) {
				if (player && content) {
					if (content[1]) {
						player.markSkill(content[0], null, get.infoCard(content[1]));
					}
					else {
						player.markSkill(content[0]);
					}
				}
				else {
					console.log(player);
				}
			},
			unmarkSkill: function (player, name) {
				if (player && player.unmarkSkill) {
					player.unmarkSkill(name);
				}
				else {
					console.log(player);
				}
			},
			storage: function (player, content) {
				if (player && content) {
					if (content[2]) {
						switch (content[2]) {
							case 'cards': content[1] = get.infoCards(content[1]); break;
							case 'card': content[1] = get.infoCard(content[1]); break;
						}
					}
					player.storage[content[0]] = content[1];
				}
				else {
					console.log(player);
				}
			},
			markId: function (player, content) {
				if (player && content) {
					player.mark(get.infoCard(content[0]), content[1]);
				}
				else {
					console.log(player);
				}
			},
			unmarkId: function (player, content) {
				if (player && content) {
					player.unmark(get.infoCard(content[0]), content[1]);
				}
				else {
					console.log(player);
				}
			},
			lose: function (player, info) {
				if (player && info) {
					var hs = info[0], es = info[1], js = info[2];
					var phs = player.getCards('h'), pes = player.getCards('e'), pjs = player.getCards('j');
					var checkMatch = function (l1, l2) {
						for (var i = 0; i < l1.length; i++) {
							for (var j = 0; j < l2.length; j++) {
								if (l2[j].suit == l1[i][0] && l2[j].number == l1[i][1] && l2[j].name == l1[i][2]) {
									l2[j].delete();
									l2.splice(j--, 1);
									break;
								}
							}
						}
					}
					checkMatch(hs, phs);
					checkMatch(es, pes);
					checkMatch(js, pjs);
					ui.updatehl();
				}
				else {
					console.log(player);
				}
			},
			loseAfter: function (player) {
				if (!player) {
					console.log('loseAfter');
					return;
				}
			},
			link: function (player, bool) {
				if (player && player.classList) {
					if (bool) {
						player.addLink();
					}
					else {
						player.removeLink();
					}
				}
				else {
					console.log(player);
				}
			},
			turnOver: function (player, bool) {
				if (player && player.classList) {
					if (bool) {
						player.classList.add('turnedover');
					}
					else {
						player.classList.remove('turnedover');
					}
				}
				else {
					console.log(player);
				}
			},
			showCards: function (player, info) {
				if (info) {
					var dialog = ui.create.dialog(info[0], get.infoCards(info[1]));
					setTimeout(function () {
						dialog.close();
					}, 1000);
				}
				else {
					console.log(player);
				}
			},
			cardDialog: function (content) {
				if (Array.isArray(content)) {
					ui.create.dialog(content[0], get.infoCards(content[1])).videoId = content[2];
				}
				else if (typeof content == 'number') {
					for (var i = 0; i < ui.dialogs.length; i++) {
						if (ui.dialogs[i].videoId == content) {
							ui.dialogs[i].close();
							return;
						}
					}
				}
			},
			changeSeat: function (player, info) {
				if (player && player.getBoundingClientRect && player.changeSeat) {
					player.changeSeat(info);
					game.playerMap = {};
					var players = game.players.concat(game.dead);
					for (var i = 0; i < players.length; i++) {
						game.playerMap[players[i].dataset.position] = players[i];
					}
				}
			},
			dialogCapt: function (content) {
				for (var i = 0; i < ui.dialogs.length; i++) {
					if (ui.dialogs[i].videoId == content[0]) {
						ui.dialogs[i].content.firstChild.innerHTML = content[1];
						return;
					}
				}
			},
			swapSeat: function (content) {
				var player1 = game.playerMap[content[0]];
				var player2 = game.playerMap[content[1]];
				if (!player1 || !player2) {
					console.log(content);
					return;
				}
				var temp1, pos, i, num;
				temp1 = player1.dataset.position;
				player1.dataset.position = player2.dataset.position;
				player2.dataset.position = temp1;
				game.arrangePlayers();
				if (player1.dataset.position == '0' || player2.dataset.position == '0') {
					pos = parseInt(player1.dataset.position);
					if (pos == 0) pos = parseInt(player2.dataset.position);
					num = game.players.length + game.dead.length;
					for (i = 0; i < game.players.length; i++) {
						temp1 = parseInt(game.players[i].dataset.position) - pos;
						if (temp1 < 0) temp1 += num;
						game.players[i].dataset.position = temp1;
					}
					for (i = 0; i < game.dead.length; i++) {
						temp1 = parseInt(game.dead[i].dataset.position) - pos;
						if (temp1 < 0) temp1 += num;
						game.dead[i].dataset.position = temp1;
					}
				}
				game.playerMap = {};
				var players = game.players.concat(game.dead);
				for (var i = 0; i < players.length; i++) {
					game.playerMap[players[i].dataset.position] = players[i];
				}
			},
			removeTafangPlayer: function () {
				ui.fakeme.hide();
				ui.handcards1Container.innerHTML = '';
				ui.handcards2Container.innerHTML = '';
				game.me = ui.create.player();
			},
			swapControl: function (player, hs) {
				if (player && player.node) {
					var cards = get.infoCards(hs);
					player.node.handcards1.innerHTML = '';
					player.node.handcards2.innerHTML = '';
					player.directgain(cards, false);

					game.me.node.handcards1.remove();
					game.me.node.handcards2.remove();

					ui.handcards1 = player.node.handcards1.animate('start').fix();
					ui.handcards2 = player.node.handcards2.animate('start').fix();
					ui.handcards1Container.insertBefore(ui.handcards1, ui.handcards1Container.firstChild);
					ui.handcards2Container.insertBefore(ui.handcards2, ui.handcards2Container.firstChild);

					game.me = player;
					ui.updatehl();
					if (game.chess) {
						ui.create.fakeme();
					}
				}
				else {
					console.log(player);
				}
			},
			onSwapControl: function () {
				game.onSwapControl();
			},
			swapPlayer: function (player, hs) {
				if (player && player.node) {
					var cards = get.infoCards(hs);
					player.node.handcards1.innerHTML = '';
					player.node.handcards2.innerHTML = '';
					player.directgain(cards, false);

					var pos = parseInt(player.dataset.position);
					var num = game.players.length + game.dead.length;
					var players = game.players.concat(game.dead);
					var temp;
					for (var i = 0; i < players.length; i++) {
						temp = parseInt(players[i].dataset.position) - pos;
						if (temp < 0) temp += num;
						players[i].dataset.position = temp;
					}
					game.me.node.handcards1.remove();
					game.me.node.handcards2.remove();
					game.me = player;
					ui.handcards1 = player.node.handcards1.animate('start').fix();
					ui.handcards2 = player.node.handcards2.animate('start').fix();
					ui.handcards1Container.appendChild(ui.handcards1);
					ui.handcards2Container.appendChild(ui.handcards2);

					ui.updatehl();

					game.playerMap = {};
					var players = game.players.concat(game.dead);
					for (var i = 0; i < players.length; i++) {
						game.playerMap[players[i].dataset.position] = players[i];
					}
				}
				else {
					console.log(player);
				}
			},
			over: function (str) {
				var dialog = ui.create.dialog('hidden');
				dialog.noforcebutton = true;
				dialog.content.innerHTML = str;
				dialog.forcebutton = true;
				dialog.open();
				if (game.chess) {
					dialog.classList.add('center');
				}
				if ((game.layout == 'long2' || game.layout == 'nova') && !game.chess) {
					ui.arena.classList.add('choose-character');
					if (ui.me) ui.me.hide();
					if (ui.mebg) ui.mebg.hide()
					if (ui.autonode) ui.autonode.hide();
					if (lib.config.radius_size != 'off') {
						if (ui.historybar) ui.historybar.style.borderRadius = '0 0 0 4px';
					}
				}
			}
		},
		reload: function () {
			if (_status) {
				if (_status.reloading) return;
				_status.reloading = true;
			}
			if (_status.video && !_status.replayvideo) {
				localStorage.removeItem(lib.configprefix + 'playbackmode');
			}
			localStorage.setItem('show_splash_off', true);
			if (lib.status.reload) {
				_status.waitingToReload = true;
			}
			else {
				window.location.reload();
			}
		},
		reload2: function () {
			lib.status.reload--;
			if (lib.status.reload == 0 && lib.ondb2.length) {
				var command = lib.ondb2.shift();
				game[command[0]].apply(game, command[1]);
			}
			if (lib.status.reload == 0 && lib.ondb.length) {
				var command = lib.ondb.shift();
				game[command[0]].apply(game, command[1]);
			}
			if (lib.status.reload == 0) {
				if (_status.waitingToReload) {
					window.location.reload();
					delete _status.waitingToReload;
				}
			}
		},
		exit: function () {
			if (lib.device == 'ios') {
				game.saveConfig('mode');
				if (_status) {
					if (_status.reloading) return;
					_status.reloading = true;
				}
				if (_status.video && !_status.replayvideo) {
					localStorage.removeItem(lib.configprefix + 'playbackmode');
				}
				window.location.reload();
			}
			else {
				if (navigator.app && navigator.app.exitApp) {
					navigator.app.exitApp();
				}
			}
		},
		open: function (url) {
			if (lib.device) {
				if (cordova.InAppBrowser) {
					cordova.InAppBrowser.open(url, '_system');
				}
				else {
					ui.create.iframe(url);
				}
			}
			else {
				window.open(url);
			}
		},
		reloadCurrent: function () {
			game.saveConfig('continue_name', [game.me.name1 || game.me.name, game.me.name2]);
			game.saveConfig('mode', lib.config.mode);
			localStorage.setItem(lib.configprefix + 'directstart', true);
			game.reload();
		},
		update: function (func) {
			lib.updates.push(func);
			if (lib.updates.length === 1) {
				game.run();
			}
			return func;
		},
		unupdate: function (func) {
			lib.updates.remove(func);
		},
		stop: function () {
			cancelAnimationFrame(lib.status.frameId);
		},
		run: function () {
			if (lib.updates.length) {
				cancelAnimationFrame(lib.status.frameId);
				lib.status.frameId = requestAnimationFrame(function (time) {
					if (lib.status.time !== 0) {
						lib.status.delayed += time - lib.status.time;
					}
					lib.status.frameId = requestAnimationFrame(lib.run);
				});
			}
		},
		addVideo: function (type, player, content) {
			if (_status.video || game.online) return;
			if (!_status.videoInited) {
				if (type == 'arrangeLib') {
					lib.video.push({
						type: type,
						player: player,
						content: content,
						delay: 0
					});
				}
				return;
			}
			if (type == 'storage' && player && player.updateMarks) {
				player.updateMarks();
			}
			if (game.getVideoName) {
				var time = get.time();
				if (!_status.lastVideoLog) {
					_status.lastVideoLog = time;
				}
				if (get.itemtype(player) == 'player') {
					player = player.dataset.position;
				}
				lib.video.push({
					type: type,
					player: player,
					content: content,
					delay: time - _status.lastVideoLog
				});
				_status.lastVideoLog = time;
			}
		},
		draw: function (func) {
			lib.canvasUpdates.push(func);
			if (!lib.status.canvas) {
				lib.status.canvas = true;
				game.update(lib.updateCanvas);
			}
		},
		vibrate: function (time) {
			if (typeof navigator.vibrate == 'function') {
				navigator.vibrate(time || 500);
			}
		},
		prompt: function () {
			var str, forced, callback, noinput = false, str2 = '';
			for (var i = 0; i < arguments.length; i++) {
				if (arguments[i] == 'alert') {
					forced = true;
					callback = function () { };
					noinput = true;
				}
				else if (typeof arguments[i] == 'string') {
					if (arguments[i].indexOf('###') == 0) {
						var list = arguments[i].slice(3).split('###');
						str = list[0];
						str2 = list[1];
					}
					else str = arguments[i];
				}
				else if (typeof arguments[i] == 'boolean') {
					forced = arguments[i];
				}
				else if (typeof arguments[i] == 'function') {
					callback = arguments[i];
				}
			}
			if (!callback) {
				return;
			}
			//try{
			//	if(noinput){
			//		throw('e');
			//	}
			//	var result=prompt(str);
			//	callback(result);
			//}
			//catch(e){
			var promptContainer = ui.create.div('.popup-container', ui.window, function () {
				if (this.clicked) {
					this.clicked = false;
				}
				else {
					clickCancel();
				}
			});
			var dialogContainer = ui.create.div('.prompt-container', promptContainer);
			var dialog = ui.create.div('.menubg', ui.create.div(dialogContainer), function () {
				promptContainer.clicked = true;
			});
			var strnode = ui.create.div('', str || '', dialog);
			var input = ui.create.node('input', ui.create.div(dialog));
			input.value = str2;
			if (noinput) {
				input.style.display = 'none';
			}
			var controls = ui.create.div(dialog);
			var clickConfirm = function () {
				if (noinput) {
					promptContainer.remove();
				}
				else if (input.value) {
					callback(input.value);
					promptContainer.remove();
				}
			}
			var clickCancel = function () {
				if (!forced) {
					callback(false);
					promptContainer.remove();
				}
			}
			var confirmNode = ui.create.div('.menubutton.large.disabled', '确定', controls, clickConfirm);
			if (!forced) {
				ui.create.div('.menubutton.large', '取消', controls, clickCancel);
			}
			if (noinput) {
				confirmNode.classList.remove('disabled');
			}
			else {
				input.onkeydown = function (e) {
					if (e.keyCode == 13) {
						clickConfirm();
					}
					else if (e.keyCode == 27) {
						clickCancel();
					}
				}
				input.onkeyup = function () {
					if (input.value) {
						confirmNode.classList.remove('disabled');
					}
					else {
						confirmNode.classList.remove('disabled');
					}
				}
				input.focus();
			}
			//}
		},
		alert: function (str) {
			game.prompt(str, 'alert');
		},
		print: function () {
			if (!_status.toprint) {
				_status.toprint = [];
			}
			_status.toprint.push(Array.from(arguments));
		},
		animate: {
			window: function (num) {
				switch (num) {
					case 1: {
						ui.window.style.transition = 'all 0.5s';
						ui.window.classList.add('zoomout3');
						ui.window.hide();
						game.addVideo('windowzoom1');
						game.delay(0, 500);
						break;
					}
					case 2: {
						ui.window.style.transition = 'all 0s';
						ui.refresh(ui.window);
						game.addVideo('windowzoom2');
						game.pause();
						setTimeout(function () {
							ui.window.classList.remove('zoomout3');
							ui.window.classList.add('zoomin3');
							game.addVideo('windowzoom3');
							setTimeout(function () {
								ui.window.style.transition = 'all 0.5s';
								ui.refresh(ui.window);
								ui.window.show();
								ui.window.classList.remove('zoomin3');
								game.addVideo('windowzoom4');
								setTimeout(function () {
									ui.window.style.transition = '';
									game.addVideo('windowzoom5');
									game.resume();
								}, 500);
							}, 100);
						}, 100);
						break;
					}
				}
			},
			flame: function (x, y, duration, type) {
				var particles = [];
				var particle_count = 50;
				if (type == 'thunder' || type == 'recover') {
					particle_count = 30;
				}
				else if (type == 'coin' || type == 'dust') {
					particle_count = 50;
				}
				else if (type == 'legend') {
					particle_count = 120;
				}
				else if (type == 'epic') {
					particle_count = 80;
				}
				else if (type == 'rare') {
					particle_count = 50;
				}
				for (var i = 0; i < particle_count; i++) {
					particles.push(new particle());
				}
				function particle() {
					this.speed = { x: -1 + Math.random() * 2, y: -5 + Math.random() * 5 };
					if (type == 'thunder' || type == 'coin' || type == 'dust') {
						this.speed.y = -3 + Math.random() * 5;
						this.speed.x = -2 + Math.random() * 4;
					}
					if (type == 'legend' || type == 'rare' || type == 'epic') {
						this.speed.x *= 3;
						this.speed.y *= 1.5;
					}
					this.location = { x: x, y: y };

					this.radius = 0.5 + Math.random() * 1;

					this.life = 10 + Math.random() * 10;
					this.death = this.life;

					switch (type) {
						case 'thunder': {
							this.b = 255;
							this.r = Math.round(Math.random() * 255);
							this.g = Math.round(Math.random() * 255);
							this.x += Math.random() * 20 - 10;
							this.y += Math.random() * 20 - 10;

							break;
						}
						case 'fire': {
							this.r = 255;
							this.g = Math.round(Math.random() * 155);
							this.b = 0;
							break;
						}
						case 'coin': {
							this.r = 255;
							this.g = Math.round(Math.random() * 25 + 230);
							this.b = Math.round(Math.random() * 100 + 50);
							this.location.x += Math.round(Math.random() * 60) - 30;
							this.location.y += Math.round(Math.random() * 40) - 20;
							if (this.location.x < x) {
								this.speed.x = -Math.abs(this.speed.x);
							}
							else if (this.location.x > x) {
								this.speed.x = Math.abs(this.speed.x);
							}
							this.life *= 1.3;
							this.death *= 1.3;
							break;
						}
						case 'dust': {
							this.r = Math.round(Math.random() * 55) + 105;
							this.g = Math.round(Math.random() * 55) + 150;
							this.b = 255;
							this.location.x += Math.round(Math.random() * 60) - 30;
							this.location.y += Math.round(Math.random() * 40) - 20;
							if (this.location.x < x) {
								this.speed.x = -Math.abs(this.speed.x);
							}
							else if (this.location.x > x) {
								this.speed.x = Math.abs(this.speed.x);
							}
							this.life *= 1.3;
							this.death *= 1.3;
							break;
						}
						case 'legend': {
							this.r = 255;
							this.g = Math.round(Math.random() * 100 + 155);
							this.b = Math.round(Math.random() * 100 + 50);
							this.location.x += Math.round(Math.random() * 60) - 30;
							this.location.y += Math.round(Math.random() * 40) - 20;
							if (this.location.x < x) {
								this.speed.x = -Math.abs(this.speed.x);
							}
							else if (this.location.x > x) {
								this.speed.x = Math.abs(this.speed.x);
							}
							this.speed.x /= 2;
							this.speed.y /= 2;
							this.life *= 2;
							this.death *= 2;
							break;
						}
						case 'epic': {
							this.r = Math.round(Math.random() * 55) + 200;
							this.g = Math.round(Math.random() * 100) + 55;
							this.b = 255;
							this.location.x += Math.round(Math.random() * 60) - 30;
							this.location.y += Math.round(Math.random() * 40) - 20;
							if (this.location.x < x) {
								this.speed.x = -Math.abs(this.speed.x);
							}
							else if (this.location.x > x) {
								this.speed.x = Math.abs(this.speed.x);
							}
							this.speed.x /= 2;
							this.speed.y /= 2;
							this.life *= 2;
							this.death *= 2;
							break;
						}
						case 'rare': {
							this.r = Math.round(Math.random() * 55) + 105;
							this.g = Math.round(Math.random() * 55) + 150;
							this.b = 255;
							this.location.x += Math.round(Math.random() * 60) - 30;
							this.location.y += Math.round(Math.random() * 40) - 20;
							if (this.location.x < x) {
								this.speed.x = -Math.abs(this.speed.x);
							}
							else if (this.location.x > x) {
								this.speed.x = Math.abs(this.speed.x);
							}
							this.speed.x /= 2;
							this.speed.y /= 2;
							this.life *= 2;
							this.death *= 2;
							break;
						}
						case 'recover': {
							this.g = 255;
							this.r = Math.round(Math.random() * 200 + 55);
							this.b = Math.round(Math.random() * 155 + 55);
							this.location.x += Math.round(Math.random() * 60) - 30;
							this.location.y += Math.round(Math.random() * 40) - 20;
							if (this.location.x < x) {
								this.speed.x = -Math.abs(this.speed.x);
							}
							else if (this.location.x > x) {
								this.speed.x = Math.abs(this.speed.x);
							}
							this.speed.x /= 2;
							this.speed.y /= 2;
							this.life *= 2;
							this.death *= 2;
							break;
						}
						default: {
							this.r = 255;
							this.g = Math.round(Math.random() * 155);
							this.b = 0;
						}
					}
				}

				game.draw(function (time, surface) {
					surface.globalCompositeOperation = "source-over";
					surface.globalCompositeOperation = "lighter";

					for (var i = 0; i < particles.length; i++) {
						var p = particles[i];

						surface.beginPath();
						var middle = 0.5;
						var radius = p.radius;
						if (type == 'recover' || type == 'legend' || type == 'rare' ||
							type == 'epic' || type == 'coin' || type == 'dust') {
							middle = 0.7;
							radius /= 3;
						}

						p.opacity = Math.round(p.death / p.life * 100) / 100
						var gradient = surface.createRadialGradient(p.location.x, p.location.y, 0, p.location.x, p.location.y, p.radius);
						gradient.addColorStop(0, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", " + p.opacity + ")");
						gradient.addColorStop(middle, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", " + p.opacity + ")");
						gradient.addColorStop(1, "rgba(" + p.r + ", " + p.g + ", " + p.b + ", 0)");
						surface.fillStyle = gradient;
						surface.arc(p.location.x, p.location.y, radius, Math.PI * 2, false);
						surface.fill();
						p.death--;
						if (type == 'recover') {
							p.radius += 0.5;
						}
						else if (type == 'coin' || type == 'dust') {
							p.radius += 0.7;
						}
						else if (type == 'legend' || type == 'rare' || type == 'epic') {
							p.radius += 0.5;
						}
						else {
							p.radius++;
						}
						p.location.x += (p.speed.x);
						p.location.y += (p.speed.y);

						if (p.death < 0 || p.radius < 0) {
							if (typeof duration == 'number' && time + 500 >= duration) {
								particles.splice(i--, 1);
							}
							else {
								particles[i] = new particle();
							}
						}
					}
					if (particles.length == 0) {
						return false;
					}
				});
			}
		},
		linexy: function (path) {
			var from = [path[0], path[1]];
			var to = [path[2], path[3]];
			var total = typeof arguments[1] === 'number' ? arguments[1] : lib.config.duration * 2;
			var opacity = 1;
			var color = [255, 255, 255];
			var dashed = false;
			var drag = false;
			if (typeof arguments[1] == 'object') {
				for (var i in arguments[1]) {
					switch (i) {
						case 'opacity': opacity = arguments[1][i]; break;
						case 'color': color = arguments[1][i]; break;
						case 'dashed': dashed = arguments[1][i]; break;
						case 'duration': total = arguments[1][i]; break;
					}
				}
			}
			else if (arguments[1] == 'fire' || arguments[1] == 'thunder' || arguments[1] == 'green') {
				color = arguments[1];
			}
			if (color == 'fire') {
				color = [255, 146, 68];
			}
			else if (color == 'thunder') {
				color = [141, 216, 255];
			}
			else if (color == 'green') {
				color = [141, 255, 216];
			}
			var node;
			if (arguments[1] == 'drag') {
				color = [236, 201, 71];
				drag = true;
				if (arguments[2]) {
					node = arguments[2]
				}
				else {
					node = ui.create.div('.linexy.drag');
					node.style.left = from[0] + 'px';
					node.style.top = from[1] + 'px';
					node.style.background = 'linear-gradient(transparent,rgba(' + color.toString() + ',' + opacity + '),rgba(' + color.toString() + ',' + opacity + '))';
					if (game.chess) {
						ui.chess.appendChild(node);
					}
					else {
						ui.arena.appendChild(node);
					}
				}
			}
			else {
				node = ui.create.div('.linexy.hidden');
				node.style.left = from[0] + 'px';
				node.style.top = from[1] + 'px';
				node.style.background = 'linear-gradient(transparent,rgba(' + color.toString() + ',' + opacity + '),rgba(' + color.toString() + ',' + opacity + '))';
				node.style.transitionDuration = (total / 3000) + 's';
			}
			var dy = to[1] - from[1];
			var dx = to[0] - from[0];
			var deg = Math.atan(Math.abs(dy) / Math.abs(dx)) / Math.PI * 180;
			if (dx >= 0) {
				if (dy <= 0) {
					deg += 90;
				}
				else {
					deg = 90 - deg;
				}
			}
			else {
				if (dy <= 0) {
					deg = 270 - deg;
				}
				else {
					deg += 270;
				}
			}
			if (drag) {
				node.style.transform = 'rotate(' + (-deg) + 'deg)';
				node.style.height = get.xyDistance(from, to) + 'px';
			}
			else {
				node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(0)';
				node.style.height = get.xyDistance(from, to) + 'px';
				if (game.chess) {
					ui.chess.appendChild(node);
				}
				else {
					ui.arena.appendChild(node);
				}
				ui.refresh(node);
				node.show();
				node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(1)';
				node.listenTransition(function () {
					setTimeout(function () {
						if (node.classList.contains('removing')) return;
						node.delete();
					}, total / 3);
				});
			}
			return node;
		},
		_linexy: function (path) {
			var from = [path[0], path[1]];
			var to = [path[2], path[3]];
			var total = typeof arguments[1] === 'number' ? arguments[1] : lib.config.duration * 2;
			var opacity = 1;
			var color = [255, 255, 255];
			var dashed = false;
			if (typeof arguments[1] == 'object') {
				for (var i in arguments[1]) {
					switch (i) {
						case 'opacity': opacity = arguments[1][i]; break;
						case 'color': color = arguments[1][i]; break;
						case 'dashed': dashed = arguments[1][i]; break;
						case 'duration': total = arguments[1][i]; break;
					}
				}
			}
			else if (arguments[1] == 'fire' || arguments[1] == 'thunder' || arguments[1] == 'green') {
				color = arguments[1];
			}
			if (color == 'fire') {
				color = [255, 146, 68];
			}
			else if (color == 'thunder') {
				color = [141, 216, 255];
			}
			else if (color == 'green') {
				color = [141, 255, 216];
			}
			var drawfunc = function (time, ctx) {
				var current;
				if (time < total / 3) {
					ctx.strokeStyle = 'rgba(' + color.toString() + ',' + opacity * (time / (total / 3)) + ')';
					current = [from[0] + (to[0] - from[0]) * time / (total / 3),
					from[1] + (to[1] - from[1]) * time / (total / 3)];
				}
				else if (time <= total) {
					current = to;
					if (time > total / 1.5) {
						ctx.strokeStyle = 'rgba(' + color.toString() + ',' + opacity * (1 - (time - total / 1.5) / (total - total / 1.5)) + ')';
					}
					else {
						ctx.strokeStyle = 'rgba(' + color.toString() + ',' + opacity + ')';
					}
				}
				else {
					return false;
				}
				ctx.beginPath();
				if (dashed) {
					ctx.lineCap = 'butt';
					ctx.setLineDash([8, 2]);
				}
				else {
					ctx.lineCap = 'round';
				}
				ctx.moveTo(from[0], from[1]);
				ctx.lineTo(current[0], current[1]);
				ctx.stroke();
			};
			if (arguments[2] && game.chess) {
				game.draw2(drawfunc);
			}
			else {
				game.draw(drawfunc);
			}
		},
		createTrigger: function (name, skill, player, event) {
			if (player.isOut() || player.removed) return;
			if (player.isDead() && !lib.skill[skill].forceDie) return;
			var next = game.createEvent('trigger', false);
			next.skill = skill;
			next.player = player;
			next.triggername = name;
			next.forceDie = true;
			next._trigger = event;
			next.setContent('createTrigger');
		},
		createEvent: function (name, trigger, triggerevent) {
			var next = {
				name: name,
				step: 0,
				finished: false,
				next: [],
				after: [],
				custom: {
					add: {},
					replace: {}
				},
				_aiexclude: [],
				_notrigger: [],
				_result: {},
				_set: [],
			}
			if (trigger !== false && !game.online) next._triggered = 0;
			for (var i in lib.element.event) {
				next[i] = lib.element.event[i];
			}
			(triggerevent || _status.event).next.push(next);
			return next;
		},
		addCharacter: function (name, info) {
			var extname = (_status.extension || info.extension);
			var imgsrc;
			if (_status.evaluatingExtension) {
				imgsrc = 'db:extension-' + extname + ':' + name + '.jpg';
			}
			else {
				imgsrc = 'ext:' + extname + '/' + name + '.jpg';
			}
			var character = [info.sex, info.group, info.hp, info.skills || [], [imgsrc]];
			if (info.tags) {
				character[4] = character[4].concat(info.tags);
			}
			lib.character[name] = character;
			var packname = 'mode_extension_' + extname;
			if (!lib.characterPack[packname]) {
				lib.characterPack[packname] = {};
			}
			lib.translate[name] = info.translate;
			lib.characterPack[packname][name] = character;
			lib.translate[packname + '_character_config'] = extname;
		},
		addCharacterPack: function (pack, packagename) {
			var extname = _status.extension || '扩展';
			packagename = packagename || extname;
			for (var i in pack) {
				if (i == 'mode' || i == 'forbid') continue;
				for (var j in pack[i]) {
					if (i == 'character') {
						if (!pack[i][j][4]) {
							pack[i][j][4] = [];
						}
						var imgsrc;
						if (_status.evaluatingExtension) {
							imgsrc = 'db:extension-' + extname + ':' + j + '.jpg';
						}
						else {
							imgsrc = 'ext:' + extname + '/' + j + '.jpg';
						}
						pack[i][j][4].push(imgsrc);
						if (pack[i][j][4].contains('boss') ||
							pack[i][j][4].contains('hiddenboss')) {
							lib.config.forbidai.add(j);
						}
						if (lib.config.forbidai_user && lib.config.forbidai_user.contains(j)) {
							lib.config.forbidai.add(j);
						}
						for (var l = 0; l < pack[i][j][3].length; l++) {
							lib.skilllist.add(pack[i][j][3][l]);
						}
					}
					else if (i == 'skill') {
						if (typeof pack[i][j].audio == 'number' || typeof pack[i][j].audio == 'boolean') {
							pack[i][j].audio = 'ext:' + extname + ':' + pack[i][j].audio;
						}
					}
					if (lib[i][j] == undefined) {
						lib[i][j] = pack[i][j];
					}
				}
			}
			var packname = 'mode_extension_' + packagename;
			lib.characterPack[packname] = pack.character;
			lib.translate[packname + '_character_config'] = packagename;
		},
		addCard: function (name, info, info2) {
			var extname = (_status.extension || info2.extension);
			if (info.audio == true) {
				info.audio = 'ext:' + extname;
			}
			if (info.fullskin) {
				if (_status.evaluatingExtension) {
					info.image = 'db:extension-' + extname + ':' + name + '.png';
				}
				else {
					info.image = 'ext:' + extname + '/' + name + '.png';
				}
			}
			else if (info.fullimage) {
				if (_status.evaluatingExtension) {
					info.image = 'db:extension-' + extname + ':' + name + '.jpg';
				}
				else {
					info.image = 'ext:' + extname + '/' + name + '.jpg';
				}
			}
			lib.card[name] = info;
			lib.translate[name] = info2.translate;
			lib.translate[name + '_info'] = info2.description;
			if (typeof info2.number == 'number') {
				var suits = ['heart', 'spade', 'diamond', 'club'];
				if (info2.color == 'red') {
					suits = ['heart', 'diamond'];
				}
				else if (info2.color == 'black') {
					suits = ['club', 'spade'];
				}
				for (var i = 0; i < info2.number; i++) {
					lib.card.list.push([suits[Math.floor(Math.random() * suits.length)], Math.ceil(Math.random() * 13), name]);
				}
			}
			var packname = 'mode_extension_' + extname;
			if (!lib.cardPack[packname]) {
				lib.cardPack[packname] = [];
				lib.translate[packname + '_card_config'] = extname;
			}
			lib.cardPack[packname].push(name);
		},
		addCardPack: function (pack, packagename) {
			var extname = _status.extension || '扩展';
			packagename = packagename || extname;
			var packname = 'mode_extension_' + packagename;
			lib.cardPack[packname] = [];
			lib.translate[packname + '_card_config'] = packagename;
			for (var i in pack) {
				if (i == 'mode' || i == 'forbid') continue;
				if (i == 'list') {
					for (var j = 0; j < pack[i].length; j++) {
						lib.card.list.push(pack[i][j]);
					}
					continue;
				}
				for (var j in pack[i]) {
					if (i == 'card') {
						if (pack[i][j].audio == true) {
							pack[i][j].audio = 'ext:' + extname;
						}
						if (pack[i][j].fullskin) {
							if (_status.evaluatingExtension) {
								pack[i][j].image = 'db:extension-' + extname + ':' + j + '.png';
							}
							else {
								pack[i][j].image = 'ext:' + extname + '/' + j + '.png';
							}
						}
						else if (pack[i][j].fullimage) {
							if (_status.evaluatingExtension) {
								pack[i][j].image = 'db:extension-' + extname + ':' + j + '.jpg';
							}
							else {
								pack[i][j].image = 'ext:' + extname + '/' + j + '.jpg';
							}
						}
						lib.cardPack[packname].push(j);
					}
					else if (i == 'skill') {
						if (typeof pack[i][j].audio == 'number' || typeof pack[i][j].audio == 'boolean') {
							pack[i][j].audio = 'ext:' + extname + ':' + pack[i][j].audio;
						}
					}
					if (lib[i][j] == undefined) lib[i][j] = pack[i][j];
				}
			}
		},
		addSkill: function (name, info, translate, description) {
			if (lib.skill[name]) {
				return false;
			}
			if (typeof info.audio == 'number' || typeof info.audio == 'boolean') {
				info.audio = 'ext:' + _status.extension + ':' + info.audio;
			}
			lib.skill[name] = info;
			lib.translate[name] = translate;
			lib.translate[name + '_info'] = description;
			return true;
		},
		addMode: function (name, info, info2) {
			lib.config.all.mode.push(name);
			lib.translate[name] = info2.translate;
			var imgsrc;
			var extname = _status.extension || info2.extension;
			if (_status.evaluatingExtension) {
				imgsrc = 'extension-' + extname + ':' + name + '.jpg';
			}
			else {
				imgsrc = 'ext:' + extname + '/' + name + '.jpg';
			}
			lib.mode[name] = {
				name: info2.translate,
				config: info2.config,
				splash: imgsrc,
				fromextension: true
			}
			lib.init['setMode_' + name] = function () {
				game.import('mode', function (lib, game, ui, get, ai, _status) {
					info.name = name;
					return info;
				});
			}
			if (!lib.config.extensionInfo[extname]) {
				lib.config.extensionInfo[extname] = {};
			}
			if (!lib.config.extensionInfo[extname].mode) {
				lib.config.extensionInfo[extname].mode = [];
			}
			if (lib.config.extensionInfo[extname].mode.indexOf(name) == -1) {
				lib.config.extensionInfo[extname].mode.push(name);
			}
			game.saveConfig('extensionMode', lib.config.extensionInfo);
		},
		addGlobalSkill: function (skill, player) {
			var info = lib.skill[skill];
			if (!info) return false;
			lib.skill.global.add(skill);
			if (player) {
				if (!lib.skill.globalmap[skill]) {
					lib.skill.globalmap[skill] = [];
				}
				lib.skill.globalmap[skill].add(player);
			}
			if (info.trigger) {
				var setTrigger = function (i, evt) {
					var name = i + '_' + evt;
					if (!lib.hook.globalskill[name]) {
						lib.hook.globalskill[name] = [];
					}
					lib.hook.globalskill[name].add(skill);
					lib.hookmap[evt] = true;
				}
				for (var i in info.trigger) {
					if (typeof info.trigger[i] == 'string') {
						setTrigger(i, info.trigger[i]);
					}
					else if (Array.isArray(info.trigger[i])) {
						for (var j = 0; j < info.trigger[i].length; j++) {
							setTrigger(i, info.trigger[i][j]);
						}
					}
				}
			}
			return true;
		},
		removeGlobalSkill: function (skill) {
			lib.skill.global.remove(skill);
			delete lib.skill.globalmap[skill];
			for (var i in lib.hook.globalskill) {
				lib.hook.globalskill[i].remove(skill);
			}
		},
		resetSkills: function () {
			for (var i = 0; i < game.players.length; i++) {
				for (var j in game.players[i].tempSkills) {
					game.players[i].removeSkill(j);
				}
				var skills = game.players[i].getSkills();
				for (var j = 0; j < skills.length; j++) {
					if (lib.skill[skills[j]].vanish) {
						game.players[i].removeSkill(skills[j]);
					}
				}
				game.players[i].in(true);
			}
			ui.clear();
		},
		removeExtension: function (extname, keepfile) {
			var prefix = 'extension_' + extname;
			for (var i in lib.config) {
				if (i.indexOf(prefix) == 0) {
					game.saveConfig(i);
				}
			}
			localStorage.removeItem(lib.configprefix + prefix);
			game.deleteDB('data', prefix);
			lib.config.extensions.remove(extname);
			game.saveConfig('extensions', lib.config.extensions);
			var modelist = lib.config.extensionInfo[extname];
			if (modelist) {
				if (modelist.image) {
					for (var i = 0; i < modelist.image.length; i++) {
						game.deleteDB('image', 'extension-' + extname + ':' + modelist.image[i]);
					}
				}
				if (modelist.mode) {
					for (var i = 0; i < modelist.mode.length; i++) {
						game.clearModeConfig(modelist.mode[i]);
					}
				}
				delete lib.config.extensionInfo[extname];
				game.saveConfig('extensionInfo', lib.config.extensionInfo);
			}
			if (game.download && !keepfile) {
				if (lib.node && lib.node.fs) {
					try {
						lib.node.fs.readdir(__dirname + '/extension/' + extname, function (err, list) {
							if (err) {
								return;
							}
							var removeFile = function () {
								if (list.length) {
									var filename = list.shift();
									lib.node.fs.unlink(__dirname + '/extension/' + extname + '/' + filename, removeFile);
								}
								else {
									try {
										lib.node.fs.rmdir(__dirname + '/extension/' + extname, function () { });
									}
									catch (e) { }
								}
							}
							removeFile();
						});
					}
					catch (e) { }
				}
				else {
					window.resolveLocalFileSystemURL(lib.assetURL + 'extension/' + extname, function (entry) {
						entry.removeRecursively();
					});
				}
			}
		},
		addRecentCharacter: function () {
			var list = get.config('recentCharacter') || [];
			for (var i = 0; i < arguments.length; i++) {
				if (lib.character[arguments[i]]) {
					list.remove(arguments[i]);
					list.unshift(arguments[i]);
				}
			}
			var num = parseInt(lib.config.recent_character_number);
			if (list.length > num) {
				list.splice(num);
			}
			game.saveConfig('recentCharacter', list, true);
		},
		createCard: function (name, suit, number, nature) {
			if (typeof name == 'object') {
				nature = name.nature;
				number = name.number;
				suit = name.suit;
				name = name.name;
			}
			if (typeof name != 'string') {
				name = 'sha';
			}
			var noclick = false;
			if (suit == 'noclick') {
				noclick = true;
				suit = null;
			}
			if (!suit && lib.card[name].cardcolor) {
				suit = lib.card[name].cardcolor;
			}
			if (!nature && lib.card[name].cardnature) {
				nature = lib.card[name].cardnature;
			}
			if (typeof suit != 'string') {
				suit = ['heart', 'diamond', 'club', 'spade'].randomGet();
			}
			else if (suit == 'black') {
				suit = Math.random() < 0.5 ? 'club' : 'spade';
			}
			else if (suit == 'red') {
				suit = Math.random() < 0.5 ? 'diamond' : 'heart';
			}
			if (typeof number != 'number' && typeof number != 'string') {
				number = Math.ceil(Math.random() * 13);
			}
			var card;
			if (noclick) {
				card = ui.create.card(ui.special, 'noclick', true);
			}
			else {
				card = ui.create.card(ui.special);
			}
			card.storage.vanish = true;
			return card.init([suit, number, name, nature]);
		},
		createCard2: function () {
			var card = game.createCard.apply(this, arguments);
			delete card.storage.vanish;
			return card;
		},
		forceOver: function (bool, callback) {
			_status.event.next.length = 0;
			var next = game.createEvent('finish_game');
			next.bool = bool;
			next.callback = callback;
			next.setContent('forceOver');
			if (_status.paused) {
				game.uncheck();
				game.resume();
			}
		},
		over: function (result) {
			if (_status.over) return;
			if (game.me._trueMe) game.swapPlayer(game.me._trueMe);
			var i, j, k, num, table, tr, td, dialog;
			_status.over = true;
			ui.control.show();
			ui.clear();
			game.stopCountChoose();
			if (ui.time3) {
				clearInterval(ui.time3.interval);
			}
			if ((game.layout == 'long2' || game.layout == 'nova') && !game.chess) {
				ui.arena.classList.add('choose-character');
				ui.me.hide();
				ui.mebg.hide()
				ui.autonode.hide();
				if (lib.config.radius_size != 'off') {
					ui.historybar.style.borderRadius = '0 0 0 4px';
				}
			}
			if (game.online) {
				var dialog = ui.create.dialog();
				dialog.noforcebutton = true;
				dialog.content.innerHTML = result;
				dialog.forcebutton = true;
				var result2 = arguments[1];
				if (result2 == true) {
					dialog.content.firstChild.innerHTML = '战斗胜利';
				}
				else if (result2 == false) {
					dialog.content.firstChild.innerHTML = '战斗失败';
				}
				ui.update();
				dialog.add(ui.create.div('.placeholder'));
				for (var i = 0; i < game.players.length; i++) {
					var hs = game.players[i].getCards('h');
					if (hs.length) {
						dialog.add('<div class="text center">' + get.translation(game.players[i]) + '</div>');
						dialog.addSmall(hs);
					}
				}

				for (var j = 0; j < game.dead.length; j++) {
					var hs = game.dead[j].getCards('h');
					if (hs.length) {
						dialog.add('<div class="text center">' + get.translation(game.dead[j]) + '</div>');
						dialog.addSmall(hs);
					}
				}

				dialog.add(ui.create.div('.placeholder.slim'));
				if (lib.config.background_audio) {
					if (result2 === true) {
						game.playAudio('effect', 'win');
					}
					else if (result2 === false) {
						game.playAudio('effect', 'lose');
					}
					else {
						game.playAudio('effect', 'tie');
					}
				}
				if (!ui.exit) {
					ui.create.exit();
				}
				if (ui.giveup) {
					ui.giveup.remove();
					delete ui.giveup;
				}
				if (game.servermode) {
					ui.exit.firstChild.innerHTML = '返回房间';
					setTimeout(function () {
						ui.exit.firstChild.innerHTML = '退出房间';
						_status.roomtimeout = true;
						lib.config.reconnect_info[2] = null;
						game.saveConfig('reconnect_info', lib.config.reconnect_info);
					}, 10000);
				}
				if (ui.tempnowuxie) {
					ui.tempnowuxie.close();
					delete ui.tempnowuxie;
				}
				if (ui.auto) ui.auto.hide();
				if (ui.wuxie) ui.wuxie.hide();
				if (game.getIdentityList) {
					for (var i = 0; i < game.players.length; i++) {
						game.players[i].setIdentity();
					}
				}
				return;
			}
			if (lib.config.background_audio) {
				if (result === true) {
					game.playAudio('effect', 'win');
				}
				else if (result === false) {
					game.playAudio('effect', 'lose');
				}
				else {
					game.playAudio('effect', 'tie');
				}
			}
			var resultbool = result;
			if (typeof resultbool !== 'boolean') {
				resultbool = null;
			}
			if (result === true) result = '战斗胜利';
			if (result === false) result = '战斗失败';
			if (result == undefined) result = '战斗结束';
			dialog = ui.create.dialog(result);
			dialog.noforcebutton = true;
			dialog.forcebutton = true;
			if (game.addOverDialog) {
				game.addOverDialog(dialog, result);
			}
			if (typeof _status.coin == 'number' && !_status.connectMode) {
				var coeff = Math.random() * 0.4 + 0.8;
				var added = 0;
				var betWin = false;
				if (result == '战斗胜利') {
					if (_status.betWin) {
						betWin = true;
						_status.coin += 10;
					}
					_status.coin += 20;
					if (_status.additionalReward) {
						_status.coin += _status.additionalReward();
					}
					switch (lib.config.mode) {
						case 'identity': {
							switch (game.me.identity) {
								case 'zhu': case 'zhong': case 'mingzhong':
									if (get.config('enhance_zhu')) {
										added = 10;
									}
									else {
										added = 20;
									}
									break;
								case 'fan':
									if (get.config('enhance_zhu')) {
										added = 16;
									}
									else {
										added = 8;
									}
									break;
								case 'nei':
									added = 40;
									break;
							}
							added = added * (game.players.length + game.dead.length) / 8;
							break;
						}
						case 'guozhan':
							if (game.me.identity == 'ye') {
								added = 8;
							}
							else {
								added = 5 / get.totalPopulation(game.me.identity);
							}
							added = added * (game.players.length + game.dead.length);
							break;
						case 'versus':
							if (_status.friend) {
								added = 5 * (game.players.length + _status.friend.length);
							}
							break;
						default:
							added = 10;
					}
				}
				else {
					added = 10;
				}
				if (lib.config.mode == 'chess' && _status.mode == 'combat' && get.config('additional_player')) {
					added = 2;
				}
				_status.coin += added * coeff;
				if (_status.coinCoeff) {
					_status.coin *= _status.coinCoeff;
				}
				_status.coin = Math.ceil(_status.coin);
				dialog.add(ui.create.div('', '获得' + _status.coin + '金'));
				if (betWin) {
					game.changeCoin(20);
					dialog.content.appendChild(document.createElement('br'));
					dialog.add(ui.create.div('', '（下注赢得10金）'));
				}
				game.changeCoin(_status.coin);
			}
			if (get.mode() == 'versus' && _status.ladder) {
				var mmr = _status.ladder_mmr;
				mmr += 10 - get.rank(game.me.name, true) * 2;
				if (result == '战斗胜利') {
					mmr = 20 + Math.round(mmr);
					if (mmr > 40) {
						mmr = 40;
					}
					else if (mmr < 10) {
						mmr = 10;
					}
					dialog.add(ui.create.div('', '获得 ' + mmr + ' 积分'));
				}
				else {
					mmr = -30 + Math.round(mmr / 2);
					if (mmr > -20) {
						mmr = -20;
					}
					else if (mmr < -35) {
						mmr = -35;
					}
					if (lib.storage.ladder.current < 900) {
						mmr = Math.round(mmr / 4);
					}
					else if (lib.storage.ladder.current < 1400) {
						mmr = Math.round(mmr / 2);
					}
					else if (lib.storage.ladder.current < 2000) {
						mmr = Math.round(mmr / 1.5);
					}
					else if (lib.storage.ladder.current > 2500) {
						mmr = Math.round(mmr * 1.5);
					}
					dialog.add(ui.create.div('', '失去 ' + (-mmr) + ' 积分'));
				}
				if (_status.ladder_tmp) {
					lib.storage.ladder.current += 40;
					delete _status.ladder_tmp;
				}
				lib.storage.ladder.current += mmr;
				if (lib.storage.ladder.top < lib.storage.ladder.current) {
					lib.storage.ladder.top = lib.storage.ladder.current;
				}
				game.save('ladder', lib.storage.ladder);
				if (ui.ladder && game.getLadderName) {
					ui.ladder.innerHTML = game.getLadderName(lib.storage.ladder.current);
				}
			}
			// if(true){
			if (game.players.length) {
				table = document.createElement('table');
				tr = document.createElement('tr');
				tr.appendChild(document.createElement('td'));
				td = document.createElement('td');
				td.innerHTML = '伤害';
				tr.appendChild(td);
				td = document.createElement('td');
				td.innerHTML = '受伤';
				tr.appendChild(td);
				td = document.createElement('td');
				td.innerHTML = '摸牌';
				tr.appendChild(td);
				td = document.createElement('td');
				td.innerHTML = '出牌';
				tr.appendChild(td);
				td = document.createElement('td');
				td.innerHTML = '杀敌';
				tr.appendChild(td);
				table.appendChild(tr);
				for (i = 0; i < game.players.length; i++) {
					tr = document.createElement('tr');
					td = document.createElement('td');
					td.innerHTML = get.translation(game.players[i]);
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.players[i].stat.length; j++) {
						if (game.players[i].stat[j].damage != undefined) num += game.players[i].stat[j].damage;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.players[i].stat.length; j++) {
						if (game.players[i].stat[j].damaged != undefined) num += game.players[i].stat[j].damaged;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.players[i].stat.length; j++) {
						if (game.players[i].stat[j].gain != undefined) num += game.players[i].stat[j].gain;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.players[i].stat.length; j++) {
						for (k in game.players[i].stat[j].card) {
							num += game.players[i].stat[j].card[k];
						}
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.players[i].stat.length; j++) {
						if (game.players[i].stat[j].kill != undefined) num += game.players[i].stat[j].kill;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					table.appendChild(tr);
				}
				dialog.add(ui.create.div('.placeholder'));
				dialog.content.appendChild(table);
			}
			if (game.dead.length) {
				table = document.createElement('table');
				table.style.opacity = '0.5';
				if (game.players.length == 0) {
					tr = document.createElement('tr');
					tr.appendChild(document.createElement('td'));
					td = document.createElement('td');
					td.innerHTML = '伤害';
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = '受伤';
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = '摸牌';
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = '出牌';
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = '杀敌';
					tr.appendChild(td);
					table.appendChild(tr);
				}
				for (i = 0; i < game.dead.length; i++) {
					tr = document.createElement('tr');
					td = document.createElement('td');
					td.innerHTML = get.translation(game.dead[i]);
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.dead[i].stat.length; j++) {
						if (game.dead[i].stat[j].damage != undefined) num += game.dead[i].stat[j].damage;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.dead[i].stat.length; j++) {
						if (game.dead[i].stat[j].damaged != undefined) num += game.dead[i].stat[j].damaged;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.dead[i].stat.length; j++) {
						if (game.dead[i].stat[j].gain != undefined) num += game.dead[i].stat[j].gain;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.dead[i].stat.length; j++) {
						for (k in game.dead[i].stat[j].card) {
							num += game.dead[i].stat[j].card[k];
						}
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.dead[i].stat.length; j++) {
						if (game.dead[i].stat[j].kill != undefined) num += game.dead[i].stat[j].kill;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					table.appendChild(tr);
				}
				dialog.add(ui.create.div('.placeholder'));
				dialog.content.appendChild(table);
			}
			if (game.additionaldead && game.additionaldead.length) {
				table = document.createElement('table');
				table.style.opacity = '0.5';
				for (i = 0; i < game.additionaldead.length; i++) {
					tr = document.createElement('tr');
					td = document.createElement('td');
					td.innerHTML = get.translation(game.additionaldead[i]);
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.additionaldead[i].stat.length; j++) {
						if (game.additionaldead[i].stat[j].damage != undefined) num += game.additionaldead[i].stat[j].damage;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.additionaldead[i].stat.length; j++) {
						if (game.additionaldead[i].stat[j].damaged != undefined) num += game.additionaldead[i].stat[j].damaged;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.additionaldead[i].stat.length; j++) {
						if (game.additionaldead[i].stat[j].gain != undefined) num += game.additionaldead[i].stat[j].gain;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.additionaldead[i].stat.length; j++) {
						for (k in game.additionaldead[i].stat[j].card) {
							num += game.additionaldead[i].stat[j].card[k];
						}
					}
					td.innerHTML = num;
					tr.appendChild(td);
					td = document.createElement('td');
					num = 0;
					for (j = 0; j < game.additionaldead[i].stat.length; j++) {
						if (game.additionaldead[i].stat[j].kill != undefined) num += game.additionaldead[i].stat[j].kill;
					}
					td.innerHTML = num;
					tr.appendChild(td);
					table.appendChild(tr);
				}
				dialog.add(ui.create.div('.placeholder'));
				dialog.content.appendChild(table);
			}
			// }
			dialog.add(ui.create.div('.placeholder'));

			var clients = game.players.concat(game.dead);
			for (var i = 0; i < clients.length; i++) {
				if (clients[i].isOnline2()) {
					clients[i].send(game.over, dialog.content.innerHTML, game.checkOnlineResult(clients[i]));
				}
			}

			dialog.add(ui.create.div('.placeholder'));

			for (var i = 0; i < game.players.length; i++) {
				if (!_status.connectMode && game.players[i].isUnderControl(true) && game.layout != 'long2') continue;
				var hs = game.players[i].getCards('h');
				if (hs.length) {
					dialog.add('<div class="text center">' + get.translation(game.players[i]) + '</div>');
					dialog.addSmall(hs);
				}
			}
			for (var i = 0; i < game.dead.length; i++) {
				if (!_status.connectMode && game.dead[i].isUnderControl(true) && game.layout != 'long2') continue;
				var hs = game.dead[i].getCards('h');
				if (hs.length) {
					dialog.add('<div class="text center">' + get.translation(game.dead[i]) + '</div>');
					dialog.addSmall(hs);
				}
			}
			dialog.add(ui.create.div('.placeholder.slim'));
			game.addVideo('over', null, dialog.content.innerHTML);
			var vinum = parseInt(lib.config.video);
			if (!_status.video && vinum && game.getVideoName && window.indexedDB && _status.videoInited) {
				var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
				var videos = lib.videos.slice(0);
				for (var i = 0; i < videos.length; i++) {
					if (videos[i].starred) {
						videos.splice(i--, 1);
					}
				}
				for (var deletei = 0; deletei < 5; deletei++) {
					if (videos.length >= vinum) {
						var toremove = videos.pop();
						lib.videos.remove(toremove);
						store.delete(toremove.time);
					}
					else {
						break;
					}
				}
				var me = game.me || game.players[0];
				if (!me) return;
				var newvid = {
					name: game.getVideoName(),
					mode: lib.config.mode,
					video: lib.video,
					win: result == '战斗胜利',
					name1: me.name1 || me.name,
					name2: me.name2,
					time: lib.getUTC(new Date())
				};
				var modecharacters = lib.characterPack['mode_' + get.mode()];
				if (modecharacters) {
					if (get.mode() == 'guozhan') {
						if (modecharacters[newvid.name1]) {
							if (newvid.name1.indexOf('gz_shibing') == 0) {
								newvid.name1 = newvid.name1.slice(3, 11);
							}
							else {
								newvid.name1 = newvid.name1.slice(3);
							}
						}
						if (modecharacters[newvid.name2]) {
							if (newvid.name2.indexOf('gz_shibing') == 0) {
								newvid.name2 = newvid.name2.slice(3, 11);
							}
							else {
								newvid.name2 = newvid.name2.slice(3);
							}
						}
					}
					else {
						if (modecharacters[newvid.name1]) {
							newvid.name1 = get.mode() + '::' + newvid.name1;
						}
						if (modecharacters[newvid.name2]) {
							newvid.name2 = get.mode() + '::' + newvid.name2;
						}
					}
				}
				if (newvid.name1 && newvid.name1.indexOf('subplayer_') == 0) {
					newvid.name1 = newvid.name1.slice(10, newvid.name1.lastIndexOf('_'));
				}
				if (newvid.name2 && newvid.name2.indexOf('subplayer_') == 0) {
					newvid.name1 = newvid.name2.slice(10, newvid.name1.lastIndexOf('_'));
				}
				lib.videos.unshift(newvid);
				store.put(newvid);
				ui.create.videoNode(newvid, true);
			}
			// _status.auto=false;
			if (ui.auto) {
				// ui.auto.classList.remove('glow');
				ui.auto.hide();
			}
			if (ui.wuxie) ui.wuxie.hide();
			if (ui.giveup) {
				ui.giveup.remove();
				delete ui.giveup;
			}

			if (lib.config.test_game && !_status.connectMode) {
				if (typeof lib.config.test_game !== 'string') {
					switch (lib.config.mode) {
						case 'identity': game.saveConfig('mode', 'guozhan'); break;
						case 'guozhan': game.saveConfig('mode', 'versus'); break;
						case 'versus': game.saveConfig('mode', 'boss'); break;
						case 'boss': game.saveConfig('mode', 'chess'); break;
						case 'chess': game.saveConfig('mode', 'stone'); break;
						case 'stone': game.saveConfig('mode', 'identity'); break;
					}
				}
				setTimeout(game.reload, 500);
			}
			if (game.controlOver) {
				game.controlOver(); return;
			}
			if (!_status.brawl) {
				if (lib.config.mode == 'boss') {
					ui.create.control('再战', function () {
						var pointer = game.boss;
						var map = { boss: game.me == game.boss, links: [] };
						for (var iwhile = 0; iwhile < 10; iwhile++) {
							pointer = pointer.nextSeat;
							if (pointer == game.boss) {
								break;
							}
							if (!pointer.side) {
								map.links.push(pointer.name);
							}
						}
						game.saveConfig('continue_name_boss', map);
						game.saveConfig('mode', lib.config.mode);
						localStorage.setItem(lib.configprefix + 'directstart', true);
						game.reload();
					});
				}
				else if (lib.config.mode == 'versus') {
					if (_status.mode == 'standard' || _status.mode == 'three') {
						ui.create.control('再战', function () {
							game.saveConfig('continue_name_versus' + (_status.mode == 'three' ? '_three' : ''), {
								friend: _status.friendBackup,
								enemy: _status.enemyBackup,
								color: _status.color
							});
							game.saveConfig('mode', lib.config.mode);
							localStorage.setItem(lib.configprefix + 'directstart', true);
							game.reload();
						});
					}
				}
				else if (!_status.connectMode && get.config('continue_game') && !ui.continue_game && !_status.brawl) {
					ui.continue_game = ui.create.control('再战', game.reloadCurrent);
				}
			}
			if (!ui.restart) {
				if (game.onlineroom && typeof game.roomId == 'number') {
					ui.restart = ui.create.control('restart', function () {
						game.broadcastAll(function () {
							if (ui.exit) {
								ui.exit.stay = true;
								ui.exit.firstChild.innerHTML = '返回房间';
							}
						});
						game.saveConfig('tmp_owner_roomId', game.roomId);
						setTimeout(game.reload, 100);
					});
				}
				else {
					ui.restart = ui.create.control('restart', game.reload);
				}
			}
			if (ui.tempnowuxie) {
				ui.tempnowuxie.close();
				delete ui.tempnowuxie;
			}

			if (ui.revive) {
				ui.revive.close();
				delete ui.revive;
			}
			if (ui.swap) {
				ui.swap.close();
				delete ui.swap;
			}
			for (var i = 0; i < lib.onover.length; i++) {
				lib.onover[i](resultbool);
			}
			if (game.addRecord) {
				game.addRecord(resultbool);
			}
			if (window.isNonameServer) {
				lib.configOL.gameStarted = false;
				game.saveConfig('pagecfg' + window.isNonameServer, [lib.configOL, game.roomId, _status.onlinenickname, _status.onlineavatar]);
				game.reload();
			}
		},
		loop: function () {
			var event = _status.event;
			var step = event.step;
			var source = event.source;
			var player = event.player;
			var target = event.target;
			var targets = event.targets;
			var card = event.card;
			var cards = event.cards;
			var skill = event.skill;
			var forced = event.forced;
			var num = event.num;
			var trigger = event._trigger;
			var result = event._result;
			if (_status.paused2 || _status.imchoosing) {
				if (!lib.status.dateDelaying) {
					lib.status.dateDelaying = new Date();
				}
			}
			if (_status.paused || _status.paused2 || _status.over) {
				return;
			}
			if (_status.paused3) {
				_status.paused3 = 'paused';
				return;
			}
			if (lib.status.dateDelaying) {
				lib.status.dateDelayed += lib.getUTC(new Date()) - lib.getUTC(lib.status.dateDelaying);
				delete lib.status.dateDelaying;
			}
			if (event.next.length > 0) {
				var next = event.next.shift();
				if (next.player && next.player.skipList.contains(next.name)) {
					event.trigger(next.name + 'Skipped');
					next.player.skipList.remove(next.name);
					if (lib.phaseName.contains(next.name)) next.player.getHistory('skipped').add(next.name);
				}
				else {
					next.parent = event;
					_status.event = next;
				}
			}
			else if (event.finished) {
				if (event._triggered == 1) {
					if (event.type == 'card') event.trigger('useCardToOmitted');
					event.trigger(event.name + 'Omitted');
					event._triggered = 4;
				}
				else if (event._triggered == 2) {
					if (event.type == 'card') event.trigger('useCardToEnd');
					event.trigger(event.name + 'End');
					event._triggered = 3;
				}
				else if (event._triggered == 3) {
					if (event.type == 'card') event.trigger('useCardToAfter');
					event.trigger(event.name + 'After');
					event._triggered++;
				}
				else if (event.after && event.after.length) {
					var next = event.after.shift();
					if (next.player && next.player.skipList.contains(next.name)) {
						event.trigger(next.name + 'Skipped');
						next.player.skipList.remove(next.name);
						if (lib.phaseName.contains(next.name)) next.player.getHistory('skipped').add(next.name)
					}
					else {
						next.parent = event;
						_status.event = next;
					}
				}
				else {
					if (event.parent) {
						if (event.result) {
							event.parent._result = event.result;
						}
						_status.event = event.parent;
					}
					else {
						return;
					}
				}
			}
			else {
				if (event._triggered == 0) {
					if (event.type == 'card') event.trigger('useCardToBefore');
					event.trigger(event.name + 'Before');
					event._triggered++;
				}
				else if (event._triggered == 1) {
					if (event.type == 'card') event.trigger('useCardToBegin');
					if (event.name == 'phase' && !event._begun) {
						var next = game.createEvent('phasing', false, event);
						next.player = event.player;
						next.skill = event.skill;
						next.setContent('phasing');
						event._begun = true;
					}
					else {
						event.trigger(event.name + 'Begin');
						event._triggered++;
					}
				}
				else {
					if (player && player.classList.contains('dead') && !event.forceDie && event.name != 'phaseLoop') {
						game.broadcastAll(function () {
							while (_status.dieClose.length) {
								_status.dieClose.shift().close();
							}
						});
						if (event._oncancel) {
							event._oncancel();
						}
						event.finish();
					}
					else if (player && player.removed && event.name != 'phaseLoop') {
						event.finish();
					}
					else if (player && player.isOut() && event.name != 'phaseLoop' && !event.includeOut) {
						if (event.name == 'phase' && player == _status.roundStart && !event.skill) {
							_status.roundSkipped = true;
						}
						event.finish();
					}
					else {
						if (_status.withError || lib.config.compatiblemode || (_status.connectMode && !lib.config.debug)) {
							try {
								event.content(event, step, source, player, target, targets,
									card, cards, skill, forced, num, trigger, result,
									_status, lib, game, ui, get, ai);
							}
							catch (e) {
								game.print('游戏出错：' + event.name);
								game.print(e.toString());
								console.log(e);
							}
						}
						else {
							event.content(event, step, source, player, target, targets,
								card, cards, skill, forced, num, trigger, result,
								_status, lib, game, ui, get, ai);
						}
					}
					event.step++;
				}
			}
			game.loop();
		},
		pause: function () {
			clearTimeout(_status.timeout);
			_status.paused = true;
		},
		pause2: function () {
			if (_status.connectMode) return;
			_status.paused2 = true;
		},
		resume: function () {
			if (_status.paused) {
				if (!_status.noclearcountdown) {
					game.stopCountChoose();
				}
				_status.paused = false;
				delete _status.waitingForTransition;
				game.loop();
			}
		},
		resume2: function () {
			if (_status.connectMode) return;
			if (_status.paused2) {
				_status.paused2 = false;
				game.loop();
			}
		},
		delay: function (time, time2) {
			if (_status.paused) return;
			game.pause();
			if (typeof time != 'number') time = 1;
			if (typeof time2 != 'number') time2 = 0;
			time = time * lib.config.duration + time2;
			if (lib.config.speed == 'vvfast') time /= 3;
			_status.timeout = setTimeout(game.resume, time);
		},
		delayx: function (time, time2) {
			if (typeof time != 'number') time = 1;
			switch (lib.config.game_speed) {
				case 'vslow': time *= 2.5; break;
				case 'slow': time *= 1.5; break;
				case 'fast': time *= 0.7; break;
				case 'vfast': time *= 0.4; break;
				case 'vvfast': time *= 0.2; break;
			}
			return game.delay(time, time2);
		},
		check: function (event) {
			var i, j, range;
			if (event == undefined) event = _status.event;
			var custom = event.custom || {};
			var ok = true, auto = true;
			var player = event.player;
			var auto_confirm = lib.config.auto_confirm;
			var players = game.players.slice(0);
			if (event.deadTarget) players.addArray(game.dead);
			if (!event.filterButton && !event.filterCard && !event.filterTarget && (!event.skill || !event._backup)) {
				if (event.choosing) {
					_status.imchoosing = true;
				}
				return;
			}
			player.node.equips.classList.remove('popequip');
			if (event.filterButton) {
				var dialog = event.dialog;
				range = get.select(event.selectButton);
				var selectableButtons = false;
				if (event.forceAuto && ui.selected.buttons.length == range[1]) auto = true;
				else if (range[0] != range[1] || range[0] > 1) auto = false;
				for (i = 0; i < dialog.buttons.length; i++) {
					if (dialog.buttons[i].classList.contains('unselectable')) continue;
					if (event.filterButton(dialog.buttons[i], player) && lib.filter.buttonIncluded(dialog.buttons[i])) {
						if (ui.selected.buttons.length < range[1]) {
							dialog.buttons[i].classList.add('selectable');
						}
						else if (range[1] == -1) {
							dialog.buttons[i].classList.add('selected');
							ui.selected.buttons.add(dialog.buttons[i]);
						}
						else {
							dialog.buttons[i].classList.remove('selectable');
						}
					}
					else {
						dialog.buttons[i].classList.remove('selectable');
						if (range[1] == -1) {
							dialog.buttons[i].classList.remove('selected');
							ui.selected.buttons.remove(dialog.buttons[i]);
						}
					}
					if (dialog.buttons[i].classList.contains('selected')) {
						dialog.buttons[i].classList.add('selectable');
					}
					else if (!selectableButtons && dialog.buttons[i].classList.contains('selectable')) {
						selectableButtons = true;
					}
				}
				if (ui.selected.buttons.length < range[0]) {
					if (!event.forced || selectableButtons) {
						ok = false;
					}
					if (event.complexSelect || event.getParent().name == 'chooseCharacter' || event.getParent().name == 'chooseButtonOL') {
						ok = false;
					}
				}
				if (custom.add.button) {
					custom.add.button();
				}
			}
			if (event.filterCard) {
				if (ok == false) {
					game.uncheck('card');
				}
				else {
					var cards = player.getCards(event.position);
					var firstCheck = false;
					range = get.select(event.selectCard);
					if (!event._cardChoice && typeof event.selectCard != 'function' &&
						!event.complexCard && range[1] != -1 && !lib.config.compatiblemode) {
						event._cardChoice = [];
						firstCheck = true;
					}
					if (event.isMine() && event.name == 'chooseToUse' && event.parent.name == 'phaseUse' && !event.skill &&
						!event._targetChoice && !firstCheck && window.Map && !lib.config.compatiblemode) {
						event._targetChoice = new Map();
						for (var i = 0; i < event._cardChoice.length; i++) {
							if (!lib.card[event._cardChoice[i].name].complexTarget) {
								var targets = [];
								for (var j = 0; j < players.length; j++) {
									if (event.filterTarget(event._cardChoice[i], player, players[j])) {
										targets.push(players[j]);
									}
								}
								event._targetChoice.set(event._cardChoice[i], targets);
							}
						}
					}
					var selectableCards = false;
					if (range[0] != range[1] || range[0] > 1) auto = false;
					for (i = 0; i < cards.length; i++) {
						if (lib.config.cardtempname != 'off') {
							var cardname = get.name(cards[i]);
							var cardnature = get.nature(cards[i]);
							if (cards[i].name != cardname || ((cardnature || cards[i].nature) && cards[i].nature != cardnature)) {
								if (!cards[i]._tempName) cards[i]._tempName = ui.create.div('.tempname', cards[i]);
								var tempname = get.translation(cardname);
								cards[i]._tempName.dataset.nature = 'fire';
								if (cardname == 'sha') {
									if (cardnature) tempname = get.translation(cardnature) + tempname;
									if (cardnature == 'thunder') cards[i]._tempName.dataset.nature = 'thunder';
									if (cardnature == 'kami') cards[i]._tempName.dataset.nature = 'kami';
								}
								cards[i]._tempName.innerHTML = lib.config.cardtempname == 'default' ? get.verticalStr(tempname) : tempname;
								cards[i]._tempName.tempname = tempname;
							}
						}
						var nochess = true;
						if (!lib.filter.cardAiIncluded(cards[i])) {
							nochess = false;
						}
						else if (event._cardChoice && !firstCheck) {
							if (!event._cardChoice.contains(cards[i])) {
								nochess = false;
							}
						}
						else {
							if (player.isOut() || !lib.filter.cardRespondable(cards[i], player) ||
								cards[i].classList.contains('uncheck') ||
								!event.filterCard(cards[i], player)) {
								nochess = false;
							}
						}
						if (nochess) {
							if (ui.selected.cards.length < range[1]) {
								cards[i].classList.add('selectable');
								if (event._cardChoice && firstCheck) {
									event._cardChoice.push(cards[i]);
								}
							}
							else if (range[1] == -1) {
								cards[i].classList.add('selected');
								cards[i].updateTransform(true);
								ui.selected.cards.add(cards[i]);
							}
							else {
								cards[i].classList.remove('selectable');
							}
						}
						else {
							cards[i].classList.remove('selectable');
							if (range[1] == -1) {
								cards[i].classList.remove('selected');
								cards[i].updateTransform();
								ui.selected.cards.remove(cards[i]);
							}
						}
						if (cards[i].classList.contains('selected')) {
							cards[i].classList.add('selectable');
						}
						else if (!selectableCards && cards[i].classList.contains('selectable')) {
							selectableCards = true;
						}
					}
					if (ui.selected.cards.length < range[0]) {
						if (!event.forced || selectableCards || event.complexSelect) {
							ok = false;
						}
					}

					if (lib.config.popequip && get.is.phoneLayout() &&
						typeof event.position == 'string' && event.position.indexOf('e') != -1 &&
						player.node.equips.querySelector('.card.selectable')) {
						player.node.equips.classList.add('popequip');
						auto_confirm = false;
					}
				}
				if (custom.add.card) {
					custom.add.card();
				}
			}
			if (event.filterTarget) {
				if (ok == false) {
					game.uncheck('target');
				}
				else {
					var card = get.card();
					var firstCheck = false;
					range = get.select(event.selectTarget);
					var selectableTargets = false;
					if (range[0] != range[1] || range[0] > 1) auto = false;
					for (i = 0; i < players.length; i++) {
						var nochess = true;
						if (game.chess && !event.chessForceAll && player && get.distance(player, players[i], 'pure') > 7) {
							nochess = false;
						}
						else if (players[i].isOut()) {
							nochess = false;
						}
						else if (event._targetChoice && event._targetChoice.has(card)) {
							var targetChoice = event._targetChoice.get(card);
							if (!Array.isArray(targetChoice) || !targetChoice.contains(players[i])) {
								nochess = false;
							}
						}
						else if (!event.filterTarget(card, player, players[i])) {
							nochess = false;
						}
						if (nochess) {
							if (ui.selected.targets.length < range[1]) {
								players[i].classList.add('selectable');
								if (Array.isArray(event._targetChoice)) {
									event._targetChoice.push(players[i]);
								}
							}
							else if (range[1] == -1) {
								players[i].classList.add('selected');
								ui.selected.targets.add(players[i]);
							}
							else {
								players[i].classList.remove('selectable');
							}
						}
						else {
							players[i].classList.remove('selectable');
							if (range[1] == -1) {
								players[i].classList.remove('selected');
								ui.selected.targets.remove(players[i]);
							}
						}
						if (players[i].classList.contains('selected')) {
							players[i].classList.add('selectable');
						}
						else if (!selectableTargets && players[i].classList.contains('selectable')) {
							selectableTargets = true;
						}
						if (players[i].instance) {
							if (players[i].classList.contains('selected')) {
								players[i].instance.classList.add('selected');
							}
							else {
								players[i].instance.classList.remove('selected');
							}
							if (players[i].classList.contains('selectable')) {
								players[i].instance.classList.add('selectable');
							}
							else {
								players[i].instance.classList.remove('selectable');
							}
						}
					}
					if (ui.selected.targets.length < range[0]) {
						if (!event.forced || selectableTargets || event.complexSelect) {
							ok = false;
						}
					}
					if (range[1] == -1 && ui.selected.targets.length == 0 && event.targetRequired) {
						ok = false;
					}
				}
				if (custom.add.target) {
					custom.add.target();
				}
			}
			if (!event.skill && get.noSelected() && !_status.noconfirm) {
				var skills = [], enable, info;
				var skills2;
				if (event._skillChoice) {
					skills2 = event._skillChoice;
					for (var i = 0; i < skills2.length; i++) {
						if (event.isMine() || !event._aiexclude.contains(skills2[i])) {
							skills.push(skills2[i]);
						}
					}
				}
				else {
					var skills2;
					if (get.mode() == 'guozhan' && player.hasSkillTag('nomingzhi', false, null, true)) {
						skills2 = player.getSkills(false, true, false);
					}
					else {
						skills2 = player.getSkills(true, true, false);
					}
					skills2 = game.filterSkills(skills2.concat(lib.skill.global), player);
					event._skillChoice = [];
					game.expandSkills(skills2);
					for (i = 0; i < skills2.length; i++) {
						info = get.info(skills2[i]);
						enable = false;
						if (typeof info.enable == 'function') enable = info.enable(event);
						else if (typeof info.enable == 'object') enable = info.enable.contains(event.name);
						else if (info.enable == 'phaseUse') enable = (event.type == 'phase');
						else if (typeof info.enable == 'string') enable = (info.enable == event.name);
						if (enable) {
							if (!game.expandSkills(player.getSkills().concat(lib.skill.global)).contains(skills2[i]) && (info.noHidden || player.hasSkillTag('nomingzhi', false, null, true))) enable = false;
							if (info.filter && !info.filter(event, player)) enable = false;
							if (info.viewAs && typeof info.viewAs != 'function' && event.filterCard && !event.filterCard(info.viewAs, player, event)) enable = false;
							if (info.viewAs && typeof info.viewAs != 'function' && info.viewAsFilter && info.viewAsFilter(player) == false) enable = false;
							if (info.usable && get.skillCount(skills2[i]) >= info.usable) enable = false;
							if (info.chooseButton && _status.event.noButton) enable = false;
							if (info.round && (info.round - (game.roundNumber - player.storage[skills2[i] + '_roundcount']) > 0)) enable = false;
						}
						if (enable) {
							if (event.isMine() || !event._aiexclude.contains(skills2[i])) {
								skills.add(skills2[i]);
							}
							event._skillChoice.add(skills2[i]);
						}
					}
				}

				var globalskills = [];
				var globallist = lib.skill.global.slice(0);
				game.expandSkills(globallist);
				for (var i = 0; i < skills.length; i++) {
					if (globallist.contains(skills[i])) {
						globalskills.push(skills.splice(i--, 1)[0]);
					}
				}
				var equipskills = [];
				var ownedskills = player.getSkills(true, false);
				game.expandSkills(ownedskills);
				for (var i = 0; i < skills.length; i++) {
					if (!ownedskills.contains(skills[i])) {
						equipskills.push(skills.splice(i--, 1)[0]);
					}
				}
				if (equipskills.length) {
					ui.create.skills3(equipskills);
				}
				else if (ui.skills3) {
					ui.skills3.close();
				}
				if (skills.length) {
					ui.create.skills(skills);
				}
				else if (ui.skills) {
					ui.skills.close();
				}
				if (globalskills.length) {
					ui.create.skills2(globalskills);
				}
				else if (ui.skills2) {
					ui.skills2.close();
				}
			}
			else {
				if (ui.skills) {
					ui.skills.close()
				}
				if (ui.skills2) {
					ui.skills2.close()
				}
				if (ui.skills3) {
					ui.skills3.close()
				}
			}
			_status.multitarget = false;
			var skillinfo = get.info(_status.event.skill);
			if (_status.event.name == 'chooseToUse') {
				if (skillinfo && skillinfo.multitarget && !skillinfo.multiline) {
					_status.multitarget = true;
				}
				if ((skillinfo && skillinfo.viewAs && typeof skillinfo.viewAs != 'function') || !_status.event.skill) {
					var cardinfo = get.info(get.card());
					if (cardinfo && cardinfo.multitarget && !cardinfo.multiline) {
						_status.multitarget = true;
					}
				}
			}
			else if (_status.event.multitarget) {
				_status.multitarget = true;
			}
			if (event.isMine()) {
				if (game.chess && game.me && get.config('show_distance')) {
					for (var i = 0; i < players.length; i++) {
						if (players[i] == game.me) {
							players[i].node.action.hide();
						}
						else {
							players[i].node.action.show();
							var dist = get.distance(game.me, players[i], 'pure');
							var dist2 = get.distance(game.me, players[i]);
							players[i].node.action.innerHTML = '距离：' + dist2 + '/' + dist;
							if (dist > 7) {
								players[i].node.action.classList.add('thunder');
							}
							else {
								players[i].node.action.classList.remove('thunder');
							}
						}
					}
				}
				if (ok && auto && (auto_confirm || (skillinfo && skillinfo.direct)) && (!_status.mousedragging || !_status.mouseleft) &&
					!_status.mousedown && !_status.touchnocheck) {
					if (ui.confirm) {
						if (!skillinfo || !skillinfo.preservecancel) {
							ui.confirm.close();
						}
					}
					if (skillinfo && skillinfo.preservecancel && !ui.confirm) {
						ui.create.confirm('c');
					}
					if (event.skillDialog == true) event.skillDialog = false;
					ui.click.ok();
					_status.mousedragging = null;
				}
				else {
					ui.arena.classList.add('selecting');
					if (event.filterTarget && (!event.filterCard || !event.position || (typeof event.position == 'string' && event.position.indexOf('e') == -1))) {
						ui.arena.classList.add('tempnoe');
					}
					game.countChoose();
					if (!_status.noconfirm && !_status.event.noconfirm) {
						if (!_status.mousedown || _status.mouseleft) {
							var str = '';
							if (ok) str += 'o';
							if (!event.forced && !event.fakeforce && get.noSelected()) str += 'c';
							ui.create.confirm(str);
						}
					}
				}
				if (ui.confirm && ui.confirm.lastChild.link == 'cancel') {
					if (_status.event.type == 'phase' && !_status.event.skill) {
						ui.confirm.lastChild.innerHTML = '结束';
					}
					else {
						ui.confirm.lastChild.innerHTML = '取消';
					}
				}
			}
			return ok;
		},
		uncheck: function () {
			var i, j;
			if (game.chess) {
				var shadows = ui.chessContainer.getElementsByClassName('playergrid temp');
				while (shadows.length) {
					shadows[0].remove();
				}
			}
			var argc = arguments.length;
			var args = new Array(argc);
			for (var i = 0; i < argc; i++) {
				args[i] = arguments[i];
			}
			if ((args.length == 0 || args.contains('card')) && _status.event.player) {
				var cards = _status.event.player.getCards('hej');
				for (j = 0; j < cards.length; j++) {
					cards[j].classList.remove('selected');
					cards[j].classList.remove('selectable');
					if (cards[j]._tempName) {
						cards[j]._tempName.delete();
						delete cards[j]._tempName;
					}
					cards[j].updateTransform();
				}
				ui.selected.cards.length = 0;
				_status.event.player.node.equips.classList.remove('popequip');
			}
			var players = game.players.slice(0);
			if (_status.event.deadTarget) players.addArray(game.dead);
			if ((args.length == 0 || args.contains('target'))) {
				for (j = 0; j < players.length; j++) {
					players[j].classList.remove('selected');
					players[j].classList.remove('selectable');
					if (players[j].instance) {
						players[j].instance.classList.remove('selected');
						players[j].instance.classList.remove('selectable');
					}
				}
				ui.selected.targets.length = 0;
			}
			if ((args.length == 0 || args.contains('button')) && _status.event.dialog && _status.event.dialog.buttons) {
				for (var j = 0; j < _status.event.dialog.buttons.length; j++) {
					_status.event.dialog.buttons[j].classList.remove('selectable');
					_status.event.dialog.buttons[j].classList.remove('selected');
				}
				ui.selected.buttons.length = 0;
			}
			if (args.length == 0) {
				ui.arena.classList.remove('selecting');
				ui.arena.classList.remove('tempnoe');
				_status.imchoosing = false;
				_status.lastdragchange.length = 0;
				_status.mousedragging = null;
				_status.mousedragorigin = null;

				while (ui.touchlines.length) {
					ui.touchlines.shift().delete();
				}
			}
			ui.canvas.width = ui.arena.offsetWidth;
			ui.canvas.height = ui.arena.offsetHeight;
			for (var i = 0; i < players.length; i++) {
				players[i].unprompt();
			}
			for (var i = 0; i < _status.dragline.length; i++) {
				if (_status.dragline[i]) _status.dragline[i].remove();
			}
			ui.arena.classList.remove('dragging');
			_status.dragline.length = 0;
		},
		swapSeat: function (player1, player2, prompt, behind, noanimate) {
			if (noanimate) {
				player1.style.transition = 'all 0s';
				player2.style.transition = 'all 0s';
				ui.refresh(player1);
				ui.refresh(player2);
			}
			if (behind) {
				var totalPopulation = game.players.length + game.dead.length + 1;
				for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
					if (player1.next != player2) {
						game.swapSeat(player1, player1.next, false, false);
					}
					else {
						break;
					}
				}
				if (prompt != false) {
					game.log(player1, '将座位移至', player2, '后');
				}
			}
			else {
				game.addVideo('swapSeat', null, [player1.dataset.position, player2.dataset.position]);
				var temp1, pos, i, num;
				temp1 = player1.dataset.position;
				player1.dataset.position = player2.dataset.position;
				player2.dataset.position = temp1;
				game.arrangePlayers();
				if (!game.chess) {
					if (player1.dataset.position == '0' || player2.dataset.position == '0') {
						pos = parseInt(player1.dataset.position);
						if (pos == 0) pos = parseInt(player2.dataset.position);
						num = game.players.length + game.dead.length;
						for (i = 0; i < game.players.length; i++) {
							temp1 = parseInt(game.players[i].dataset.position) - pos;
							if (temp1 < 0) temp1 += num;
							game.players[i].dataset.position = temp1;
						}
						for (i = 0; i < game.dead.length; i++) {
							temp1 = parseInt(game.dead[i].dataset.position) - pos;
							if (temp1 < 0) temp1 += num;
							game.dead[i].dataset.position = temp1;
						}
					}
				}
				if (prompt != false) {
					game.log(player1, '和', player2, '交换了座位');
				}
			}
			if (noanimate) {
				setTimeout(function () {
					player1.style.transition = '';
					player2.style.transition = '';
				}, 200);
			}
		},
		swapPlayer: function (player, player2) {
			if (player2) {
				if (player == game.me) game.swapPlayer(player2);
				else if (player2 == game.me) game.swapPlayer(player);
			}
			else {
				if (player == game.me) return;
				var players = game.players.concat(game.dead);
				for (var i = 0; i < players.length; i++) {
					players[i].style.transition = 'all 0s';
				}
				game.addVideo('swapPlayer', player, get.cardsInfo(player.getCards('h')));
				if (!game.chess) {
					var pos = parseInt(player.dataset.position);
					var num = game.players.length + game.dead.length;
					var players = game.players.concat(game.dead);
					var temp;
					for (var i = 0; i < players.length; i++) {
						temp = parseInt(players[i].dataset.position) - pos;
						if (temp < 0) temp += num;
						players[i].dataset.position = temp;
					}
				}
				game.me.node.handcards1.remove();
				game.me.node.handcards2.remove();
				var current = game.me;
				game.me = player;
				if (current.isDead()) {
					current.$die();
				}
				ui.handcards1 = player.node.handcards1.animate('start').fix();
				ui.handcards2 = player.node.handcards2.animate('start').fix();
				ui.handcards1Container.appendChild(ui.handcards1);
				ui.handcards2Container.appendChild(ui.handcards2);

				ui.updatehl();
			}
			if (game.me.isAlive()) {
				if (ui.auto) ui.auto.show();
				if (ui.wuxie) ui.wuxie.show();
				if (ui.revive) {
					ui.revive.close();
					delete ui.revive;
				}
				if (ui.swap) {
					ui.swap.close();
					delete ui.swap;
				}
				if (ui.restart) {
					ui.restart.close();
					delete ui.restart;
				}
				if (ui.continue_game) {
					ui.continue_game.close();
					delete ui.continue_game;
				}
			}
			if (lib.config.mode == 'identity') {
				game.me.setIdentity(game.me.identity);
			}
			setTimeout(function () {
				for (var i = 0; i < players.length; i++) {
					players[i].style.transition = '';
				}
			}, 100);
		},
		swapControl: function (player) {
			if (player == game.me) return;

			game.me.node.handcards1.remove();
			game.me.node.handcards2.remove();

			game.me = player;
			ui.handcards1 = player.node.handcards1.animate('start').fix();
			ui.handcards2 = player.node.handcards2.animate('start').fix();
			ui.handcards1Container.insertBefore(ui.handcards1, ui.handcards1Container.firstChild);
			ui.handcards2Container.insertBefore(ui.handcards2, ui.handcards2Container.firstChild);
			ui.updatehl();
			game.addVideo('swapControl', player, get.cardsInfo(player.getCards('h')));

			if (game.me.isAlive()) {
				if (ui.auto) ui.auto.show();
				if (ui.wuxie) ui.wuxie.show();
				if (ui.revive) {
					ui.revive.close();
					delete ui.revive;
				}
				if (ui.swap) {
					ui.swap.close();
					delete ui.swap;
				}
				if (ui.restart) {
					ui.restart.close();
					delete ui.restart;
				}
				if (ui.continue_game) {
					ui.continue_game.close();
					delete ui.continue_game;
				}
			}
		},
		swapPlayerAuto: function (player) {
			if (game.modeSwapPlayer) {
				game.modeSwapPlayer(player);
			}
			else {
				game.swapPlayer(player);
			}
		},
		findNext: function (player) {
			var players = get.players(lib.sort.position);
			var position = parseInt(player.dataset.position);
			for (var i = 0; i < players.length; i++) {
				if (parseInt(players[i].dataset.position) >= position) {
					return players[i];
				}
			}
			return players[0];
		},
		loadModeAsync: function (name, callback) {
			window.game = game;
			var script = lib.init.js(lib.assetURL + 'mode', name, function () {
				if (!lib.config.dev) delete window.game;
				script.remove();
				var content = lib.imported.mode[name];
				delete lib.imported.mode[name];
				if (get.is.empty(lib.imported.mode)) {
					delete lib.imported.mode;
				}
				callback(content);
			});
		},
		switchMode: function (name, configx) {
			if (!lib.layoutfixed.contains(name)) {
				if (lib.config.layout != game.layout) {
					lib.init.layout(lib.config.layout);
				}
				else if (lib.config.mode == 'brawl') {
					if (lib.config.player_border == 'normal' && (game.layout == 'long' || game.layout == 'long2')) {
						ui.arena.classList.add('lslim_player');
					}
				}
			}
			window.game = game;
			var script = lib.init.js(lib.assetURL + 'mode', name, function () {
				if (!lib.config.dev) delete window.game;
				script.remove();
				var mode = lib.imported.mode;
				_status.sourcemode = lib.config.mode;
				lib.config.mode = name;

				var i, j, k;
				for (i in mode[lib.config.mode].element) {
					if (!lib.element[i]) lib.element[i] = [];
					for (j in mode[lib.config.mode].element[i]) {
						if (j == 'init') {
							if (!lib.element[i].inits) lib.element[i].inits = [];
							lib.element[i].inits.push(mode[lib.config.mode].element[i][j]);
						}
						else {
							lib.element[i][j] = mode[lib.config.mode].element[i][j];
						}
					}
				}
				for (i in mode[lib.config.mode].ai) {
					if (typeof mode[lib.config.mode].ai[i] == 'object') {
						if (ai[i] == undefined) ai[i] = {};
						for (j in mode[lib.config.mode].ai[i]) {
							ai[i][j] = mode[lib.config.mode].ai[i][j];
						}
					}
					else {
						ai[i] = mode[lib.config.mode].ai[i];
					}
				}
				for (i in mode[lib.config.mode].ui) {
					if (typeof mode[lib.config.mode].ui[i] == 'object') {
						if (ui[i] == undefined) ui[i] = {};
						for (j in mode[lib.config.mode].ui[i]) {
							ui[i][j] = mode[lib.config.mode].ui[i][j];
						}
					}
					else {
						ui[i] = mode[lib.config.mode].ui[i];
					}
				}
				for (i in mode[lib.config.mode].game) {
					game[i] = mode[lib.config.mode].game[i];
				}
				for (i in mode[lib.config.mode].get) {
					get[i] = mode[lib.config.mode].get[i];
				}
				if (game.onwash) {
					lib.onwash.push(game.onwash);
					delete game.onwash;
				}
				if (game.onover) {
					lib.onover.push(game.onover);
					delete game.onover;
				}
				lib.config.banned = lib.config[lib.config.mode + '_banned'] || [];
				lib.config.bannedcards = lib.config[lib.config.mode + '_bannedcards'] || [];

				for (i in mode[lib.config.mode]) {
					if (i == 'element') continue;
					if (i == 'game') continue;
					if (i == 'ai') continue;
					if (i == 'ui') continue;
					if (i == 'get') continue;
					if (i == 'config') continue;
					if (i == 'start') continue;
					if (i == 'startBefore') continue;
					if (lib[i] == undefined) lib[i] = (Array.isArray(mode[lib.config.mode][i])) ? [] : {};
					for (j in mode[lib.config.mode][i]) {
						lib[i][j] = mode[lib.config.mode][i][j];
					}
				}

				// var pilecfg=lib.config.customcardpile[get.config('cardpilename')];
				// if(pilecfg){
				//     lib.config.bannedpile=pilecfg[0]||{};
				//     lib.config.addedpile=pilecfg[1]||{};
				// }

				_status.event = {
					finished: true,
					next: [],
					after: []
				};
				_status.paused = false;

				if (_status.connectMode && lib.mode[name].connect) {
					game.saveConfig('connect_mode', name);
					game.clearConnect();
					lib.configOL.mode = name;
					if (configx) {
						for (var i in configx) {
							lib.configOL[i] = configx[i];
						}
					}
					else {
						for (var i in lib.mode[name].connect) {
							if (i == 'update') continue;
							lib.configOL[i.slice(8)] = get.config(i);
						}
						lib.configOL.characterPack = lib.connectCharacterPack.slice(0);
						lib.configOL.cardPack = lib.connectCardPack.slice(0);
						for (var i = 0; i < lib.config.connect_characters.length; i++) {
							lib.configOL.characterPack.remove(lib.config.connect_characters[i]);
						}
						for (var i = 0; i < lib.config.connect_cards.length; i++) {
							lib.configOL.cardPack.remove(lib.config.connect_cards[i]);
						}
						lib.configOL.banned = lib.config['connect_' + name + '_banned'];
						lib.configOL.bannedcards = lib.config['connect_' + name + '_bannedcards'];
					}
					lib.configOL.version = lib.versionOL;
					for (var i in lib.cardPackList) {
						if (lib.configOL.cardPack.contains(i)) {
							lib.card.list = lib.card.list.concat(lib.cardPackList[i]);
						}
					}
					for (i = 0; i < lib.card.list.length; i++) {
						if (lib.card.list[i][2] == 'huosha') {
							lib.card.list[i] = lib.card.list[i].slice(0);
							lib.card.list[i][2] = 'sha';
							lib.card.list[i][3] = 'fire';
						}
						else if (lib.card.list[i][2] == 'leisha') {
							lib.card.list[i] = lib.card.list[i].slice(0);
							lib.card.list[i][2] = 'sha';
							lib.card.list[i][3] = 'thunder';
						}
						if (!lib.card[lib.card.list[i][2]]) {
							lib.card.list.splice(i, 1); i--;
						}
						else if (lib.card[lib.card.list[i][2]].mode &&
							lib.card[lib.card.list[i][2]].mode.contains(lib.config.mode) == false) {
							lib.card.list.splice(i, 1); i--;
						}
					}
				}

				if (!lib.config.show_playerids || !game.showIdentity) {
					ui.playerids.style.display = 'none';
				}
				else {
					ui.playerids.style.display = '';
				}

				game.createEvent('game', false).setContent(mode[lib.config.mode].start);
				if (lib.mode[lib.config.mode] && lib.mode[lib.config.mode].fromextension) {
					var startstr = mode[lib.config.mode].start.toString();
					if (startstr.indexOf('onfree') == -1) {
						setTimeout(lib.init.onfree, 500);
					}
				}
				delete lib.imported.mode[name];

				if (!lib.db) {
					try {
						lib.storage = JSON.parse(localStorage.getItem(lib.configprefix + lib.config.mode));
						if (typeof lib.storage != 'object') throw ('err');
						if (lib.storage == null) throw ('err');
					}
					catch (err) {
						lib.storage = {};
						localStorage.setItem(lib.configprefix + lib.config.mode, "{}");
					}
					game.loop();
				}
				else {
					game.getDB('data', lib.config.mode, function (obj) {
						lib.storage = obj || {};
						game.loop();
					});
				}
			});
		},
		loadMode: function (mode) {
			var next = game.createEvent('loadMode', false);
			next.mode = mode;
			next.setContent('loadMode');
		},
		loadPackage: function () {
			var next = game.createEvent('loadPackage');
			next.packages = [];
			for (var i = 0; i < arguments.length; i++) {
				if (typeof arguments[i] == 'string') {
					next.packages.push(arguments[i]);
				}
			}
			next.setContent('loadPackage');
		},
		phaseLoop: function (player) {
			var next = game.createEvent('phaseLoop');
			next.player = player;
			next.setContent('phaseLoop');
		},
		gameDraw: function (player, num) {
			var next = game.createEvent('gameDraw');
			next.player = player || game.me;
			if (num == undefined) next.num = 4;
			else next.num = num;
			next.setContent('gameDraw');
		},
		chooseCharacterDouble: function () {
			var next = game.createEvent('chooseCharacter', false);
			var config, width, num, ratio, func, update, list, first;
			for (var i = 0; i < arguments.length; i++) {
				if (typeof arguments[i] == 'number') {
					if (!width) {
						width = arguments[i];
					}
					else if (!num) {
						num = arguments[i];
					}
					else {
						ratio = arguments[i];
					}
				}
				else if (typeof arguments[i] == 'function') {
					if (!func) {
						func = arguments[i];
					}
					else {
						update = arguments[i];
					}
				}
				else if (Array.isArray(arguments[i])) {
					list = arguments[i];
				}
				else if (get.objtype(arguments[i]) == 'object') {
					config = arguments[i];
				}
			}
			if (!config) {
				list = config;
				config = {};
			}
			config.width = config.width || width || 8;
			config.height = 4;
			config.size = config.width * config.height;
			config.num = config.num || num || 3;
			config.ratio = config.ratio || ratio || 1.2;
			config.update = config.update || update;
			if (!config.hasOwnProperty('first')) {
				if (typeof first == 'boolean') {
					config.first = first;
				}
				else {
					config.first = 'rand';
				}
			}
			if (!list) {
				list = [];
				for (var i in lib.character) {
					if (typeof func == 'function') {
						if (!func(i)) continue;
					}
					else {
						if (lib.filter.characterDisabled(i)) continue;
					}
					list.push(i);
				}
			}
			next.config = config;
			next.list = list;
			next.setContent(function () {
				'step 0'
				event.nodes = [];
				event.avatars = [];
				event.friend = [];
				event.enemy = [];
				event.blank = [];
				for (var i = 0; i < event.config.size; i++) {
					event.nodes.push(ui.create.div('.shadowed.reduce_radius.choosedouble'));
				}
				event.moveAvatar = function (node, i) {
					if (!node.classList.contains('moved')) {
						event.blank.push(node.index);
					}
					event.nodes[node.index].style.display = '';
					event.nodes[node.index].show();
					clearTimeout(event.nodes[node.index].choosetimeout);
					event.moveNode(node, i);
					var nodex = event.nodes[node.index];
					nodex.choosetimeout = setTimeout(function () {
						nodex.hide();
						nodex.choosetimeout = setTimeout(function () {
							nodex.show();
							nodex.style.display = 'none';
						}, 300);
					}, 400);
				};
				event.aiMove = function (friend) {
					var list = [];
					for (var i = 0; i < event.avatars.length; i++) {
						if (!event.avatars[i].classList.contains('moved')) {
							list.push(event.avatars[i]);
						}
					}
					for (var i = 0; i < list.length; i++) {
						if (Math.random() < 0.7 || i == list.length - 1) {
							if (friend) {
								event.moveAvatar(list[i], event.friend.length + event.config.width * (event.config.height - 1));
								event.friend.push(list[i]);
							}
							else {
								event.moveAvatar(list[i], event.enemy.length);
								event.enemy.push(list[i]);
							}
							list[i].classList.add('moved');
							break;
						}
					}
				};
				event.promptbar = ui.create.div('.hidden', ui.window);
				event.promptbar.style.width = '100%';
				event.promptbar.style.left = 0;
				if (get.is.phoneLayout()) {
					event.promptbar.style.top = '20px';
				}
				else {
					event.promptbar.style.top = '58px';
				}
				event.promptbar.style.pointerEvents = 'none';
				event.promptbar.style.textAlign = 'center';
				event.promptbar.style.zIndex = '2';
				ui.create.div('.shadowed.reduce_radius', event.promptbar);
				event.promptbar.firstChild.style.fontSize = '18px';
				event.promptbar.firstChild.style.padding = '6px 10px';
				event.promptbar.firstChild.style.position = 'relative';
				event.prompt = function (str) {
					event.promptbar.firstChild.innerHTML = str;
					event.promptbar.show();
				};
				event.moveNode = function (node, i) {
					var width = event.width, height = event.height, margin = event.margin;
					var left = -(width + 10) * event.config.width / 2 + 5 + (i % event.config.width) * (width + 10);
					var top = -(height + 10) * event.config.height / 2 + 5 + Math.floor(i / event.config.width) * (height + 10) + margin / 2;
					node.style.transform = 'translate(' + left + 'px,' + top + 'px)';
					node.index = i;
				};
				event.resize = function () {
					var margin = 0;
					if (!get.is.phoneLayout()) {
						margin = 38;
					}
					var height = (ui.window.offsetHeight - 10 * (event.config.height + 1) - margin) / event.config.height;
					var width = (ui.window.offsetWidth - 10 * (event.config.width + 1)) / event.config.width;
					if (width * event.config.ratio < height) {
						height = width * event.config.ratio;
					}
					else {
						width = height / event.config.ratio;
					}
					event.width = width;
					event.height = height;
					event.margin = margin;
					for (var i = 0; i < event.config.size; i++) {
						event.moveNode(event.nodes[i], i);
						event.nodes[i].style.width = width + 'px';
						event.nodes[i].style.height = height + 'px';
						if (event.avatars[i]) {
							event.moveNode(event.avatars[i], event.avatars[i].index);
							event.avatars[i].style.width = width + 'px';
							event.avatars[i].style.height = height + 'px';
							event.avatars[i].nodename.style.fontSize = Math.max(14, Math.round(width / 5.6)) + 'px';
						}
					}
					if (event.deciding) {
						var str = 'px,' + (event.margin / 2 - event.height * 0.5) + 'px)';
						for (var i = 0; i < event.friendlist.length; i++) {
							event.friendlist[i].style.transform = 'scale(1.2) translate(' + (-(event.width + 14) * event.friendlist.length / 2 + 7 + i * (event.width + 14)) + str;
						}
					}
				};
				lib.onresize.push(event.resize);
				event.clickAvatar = function () {
					if (event.deciding) {
						if (this.index < event.config.width) return;
						if (event.friendlist.contains(this)) {
							event.friendlist.remove(this);
							event.moveNode(this, this.index);
							this.nodename.innerHTML = get.slimName(this.link);
						}
						else {
							event.friendlist.push(this);
						}
						if (event.friendlist.length == event.config.num) {
							event.deciding = false;
							event.prompt('比赛即将开始');
							setTimeout(game.resume, 1000);
						}
						if (event.config.update) {
							for (var i = 0; i < event.friendlist.length; i++) {
								event.friendlist[i].nodename.innerHTML = event.config.update(i, event.friendlist.length) || event.friendlist[i].nodename.innerHTML;
							}
						}
						var str = 'px,' + (event.margin / 2 - event.height * 0.5) + 'px)';
						for (var i = 0; i < event.friendlist.length; i++) {
							event.friendlist[i].style.transform = 'scale(1.2) translate(' + (-(event.width + 14) * event.friendlist.length / 2 + 7 + i * (event.width + 14)) + str;
						}
					}
					else {
						if (!event.imchoosing) return;
						if (event.replacing) {
							this.link = event.replacing;
							this.setBackground(event.replacing, 'character');

							this.nodename.innerHTML = get.slimName(event.replacing);
							this.nodename.dataset.nature = get.groupnature(lib.character[event.replacing][1]);

							delete event.replacing;
							if (this.classList.contains('moved')) {
								event.custom.add.window();
							}
						}
						if (this.classList.contains('moved')) return;
						event.moveAvatar(this, event.friend.length + event.config.width * (event.config.height - 1));
						event.friend.push(this.link);
						this.classList.add('moved');
						game.resume();
					}
				};
				event.skipnode = ui.create.system('跳过', function () {
					this.remove();
					event._skiprest = true;
					if (event.imchoosing) {
						game.resume();
					}
				});
				if (get.config('change_choice')) {
					event.replacenode = ui.create.system('换将', function () {
						event.promptbar.hide();
						while (event.avatars.length) {
							event.avatars.shift().remove();
						}
						for (var i = 0; i < event.config.size; i++) {
							event.nodes[i].show();
							event.nodes[i].style.display = '';
							clearTimeout(event.nodes[i].choosetimeout);
						}
						delete event.list2;
						event.friend.length = 0;
						event.enemy.length = 0;
						event.blank.length = 0;
						event.redoing = true;
						if (event.imchoosing) {
							game.resume();
						}
					}, true);
				}
				if (get.config('change_choice')) {
					event.reselectnode = ui.create.system('重选', function () {
						event.promptbar.hide();
						event.list2 = event.list2.concat(event.friend).concat(event.enemy);
						event.friend.length = 0;
						event.enemy.length = 0;
						for (var i = 0; i < event.avatars.length; i++) {
							if (event.avatars[i].classList.contains('moved')) {
								event.moveAvatar(event.avatars[i], event.blank.randomRemove());
								event.avatars[i].classList.remove('moved');
							}
						}
						event.redoing = true;
						if (event.imchoosing) {
							game.resume();
						}
					}, true);
				}
				if (get.config('free_choose')) {
					var createCharacterDialog = function () {
						event.freechoosedialog = ui.create.characterDialog();
						event.freechoosedialog.style.height = '80%';
						event.freechoosedialog.style.top = '10%';
						event.freechoosedialog.style.transform = 'scale(0.8)';
						event.freechoosedialog.style.transition = 'all 0.3s';
						event.freechoosedialog.listen(function (e) {
							if (!event.replacing) {
								event.dialoglayer.clicked = true;
							}
						});
						event.freechoosedialog.classList.add('pointerdialog');
						event.dialoglayer = ui.create.div('.popup-container.hidden', function (e) {
							if (this.classList.contains('removing')) return;
							if (this.clicked) {
								this.clicked = false;
								return;
							}
							ui.window.classList.remove('modepaused');
							this.delete();
							e.stopPropagation();
							event.freechoosedialog.style.transform = 'scale(0.8)';
							if (event.replacing) {
								event.prompt('用' + get.translation(event.replacing) + '替换一名武将');
							}
							else {
								if (event.side == 0) {
									event.prompt('请选择两名武将');
								}
								else {
									event.prompt('请选择一名武将');
								}
							}
						});
						event.dialoglayer.classList.add('modenopause');
						event.dialoglayer.appendChild(event.freechoosedialog);
						event.freechoosenode.classList.remove('hidden');
					}

					event.custom.replace.button = function (button) {
						event.replacing = button.link;
					};
					event.custom.add.window = function () {
						if (event.replacing) {
							delete event.replacing;
							if (event.side == 0) {
								event.prompt('请选择两名武将');
							}
							else {
								event.prompt('请选择一名武将');
							}
						}
					};
					event.freechoosenode = ui.create.system('自由选将', function () {
						if (this.classList.contains('hidden')) return;
						if (!event.imchoosing) {
							event.prompt('请等待敌方选将');
							return;
						}
						delete event.replacing;
						ui.window.classList.add('modepaused');
						ui.window.appendChild(event.dialoglayer);
						ui.refresh(event.dialoglayer);
						event.dialoglayer.show();
						event.freechoosedialog.style.transform = 'scale(1)';
						event.promptbar.hide();
					}, true);
					if (lib.onfree) {
						event.freechoosenode.classList.add('hidden');
						lib.onfree.push(createCharacterDialog);
					}
					else {
						createCharacterDialog();
					}
				}
				event.checkredo = function () {
					if (event.redoing) {
						event.goto(1);
						delete event.redoing;
						return true;
					}
				};
				// if(ui.cardPileButton) ui.cardPileButton.style.display='none';
				ui.auto.hide();
				ui.wuxie.hide();
				event.resize();
				for (var i = 0; i < event.config.size; i++) {
					ui.window.appendChild(event.nodes[i]);
				}
				'step 1'
				var rand = event.config.first;
				if (rand == 'rand') {
					rand = (Math.random() < 0.5);
				}
				if (rand) {
					_status.color = true;
					event.side = 1;
				}
				else {
					_status.color = false;
					event.side = 3;
				}
				if (!event.list2) {
					event.list2 = event.list.randomGets(event.config.width * 2);
					for (var i = 0; i < event.config.width * 2; i++) {
						event.avatars.push(ui.create.div('.shadowed.shadowed2.reduce_radius.character.choosedouble', event.clickAvatar));
						var name = event.list2[i];
						event.avatars[i].setBackground(name, 'character');
						event.avatars[i].link = name;
						event.avatars[i].nodename = ui.create.div('.name', event.avatars[i], get.slimName(name));
						event.avatars[i].nodename.style.fontFamily = lib.config.name_font;
						event.avatars[i].index = i + event.config.width;
						event.avatars[i].animate('start');
						event.nodes[event.avatars[i].index].style.display = 'none';
						event.avatars[i].nodename.dataset.nature = get.groupnature(lib.character[name][1]);
						lib.setIntro(event.avatars[i]);
					}
					event.resize();
					for (var i = 0; i < event.avatars.length; i++) {
						ui.window.appendChild(event.avatars[i]);
					}
					event.avatars.sort(function (a, b) {
						return get.rank(b.link, true) - get.rank(a.link, true);
					})
				}
				game.delay();
				lib.init.onfree();
				'step 2'
				if (event.checkredo()) return;
				if (event._skiprest) return;
				if (event.side < 2) {
					event.imchoosing = true;
					if (event.side == 0) {
						event.prompt('请选择两名武将');
					}
					else {
						event.prompt('请选择一名武将');
						event.fast = get.time();
					}
					game.pause();
				}
				else {
					event.aiMove();
					game.delay();
				}
				'step 3'
				if (typeof event.fast == 'number' && get.time() - event.fast <= 1000) {
					event.fast = true;
				}
				else {
					event.fast = false;
				}
				delete event.imchoosing;
				if (event.checkredo()) return;
				if (event._skiprest) {
					while (event.enemy.length < event.config.width) {
						event.aiMove();
					}
					while (event.friend.length < event.config.width) {
						event.aiMove(true);
					}
				}
				else if (event.friend.length + event.enemy.length < event.config.width * 2 - 1) {
					if (event.side == 1) {
						game.delay(event.fast ? 1 : 2);
						event.promptbar.hide();
					}
					event.side++;
					if (event.side > 3) {
						event.side = 0;
					}
					event.goto(2);
				}
				else {
					event.promptbar.hide();
					event.side++;
					if (event.side > 3) {
						event.side = 0;
					}
					if (event.side >= 2) {
						game.delay()
					}
				}
				'step 4'
				if (event.checkredo()) return;
				if (event.skipnode) event.skipnode.delete();
				if (event.replacenode) event.replacenode.delete();
				if (event.reselectnode) event.reselectnode.delete();
				if (event.freechoosenode) event.freechoosenode.delete();
				for (var i = 0; i < event.avatars.length; i++) {
					if (!event.avatars[i].classList.contains('moved')) {
						if (event.side < 2) {
							event.moveAvatar(event.avatars[i], event.friend.length + event.config.width * (event.config.height - 1));
							event.friend.push(event.avatars[i]);
						}
						else {
							event.moveAvatar(event.avatars[i], event.enemy.length);
							event.enemy.push(event.avatars[i]);
						}
						event.avatars[i].classList.add('moved');
					}
				}
				game.delay();
				'step 5'
				event.prompt('选择' + get.cnNumber(event.config.num) + '名出场武将');
				event.enemylist = [];
				for (var i = 0; i < event.avatars.length; i++) {
					if (event.avatars[i].index > event.config.width) {
						event.avatars[i].classList.add('selecting');
					}
				}
				var rand = [];
				for (var i = 0; i < event.config.width; i++) {
					for (var j = 0; j < event.config.width - i; j++) {
						rand.push(i);
					}
				}
				for (var i = 0; i < event.config.num; i++) {
					var rand2 = rand.randomGet();
					for (var j = 0; j < rand.length; j++) {
						if (rand[j] == rand2) {
							rand.splice(j--, 1);
						}
					}
					event.enemylist.push(event.enemy[rand2]);
				}
				event.enemylist.randomSort();
				event.friendlist = [];
				event.deciding = true;
				for (var i = 0; i < event.config.size; i++) {
					event.nodes[i].hide();
				}
				game.pause();
				'step 6'
				event.promptbar.delete();
				if (ui.cardPileButton) ui.cardPileButton.style.display = '';
				lib.onresize.remove(event.resize);
				ui.wuxie.show();
				ui.auto.show();
				for (var i = 0; i < event.avatars.length; i++) {
					event.avatars[i].delete();
				}
				for (var i = 0; i < event.nodes.length; i++) {
					event.nodes[i].delete();
				}
				event.result = { friend: [], enemy: [] };
				for (var i = 0; i < event.config.num; i++) {
					event.result.friend[i] = event.friendlist[i].link;
					event.result.enemy[i] = event.enemylist[i].link;
				}
			});
		},
		updateRoundNumber: function () {
			game.broadcastAll(function (num1, num2, top) {
				if (ui.cardPileNumber) ui.cardPileNumber.innerHTML = num1 + '轮 剩余牌: ' + num2;
				_status.pileTop = top;
			}, game.roundNumber, ui.cardPile.childNodes.length, ui.cardPile.firstChild);
		},
		asyncDraw: function (players, num, drawDeck, bottom) {
			for (var i = 0; i < players.length; i++) {
				var num2 = 1;
				if (typeof num == 'number') {
					num2 = num;
				}
				else if (Array.isArray(num)) {
					num2 = num[i];
				}
				else if (typeof num == 'function') {
					num2 = num(players[i]);
				}
				if (drawDeck && drawDeck.drawDeck) {
					players[i].draw(num2, false, drawDeck);
				}
				else {
					if (bottom) players[i].draw(num2, 'nodelay', 'bottom');
					else players[i].draw(num2, 'nodelay');
				}
			}
		},
		asyncDrawAuto: function (players, num, drawDeck) {
			if (players.length == 1) {
				var num2 = 1;
				if (typeof num == 'number') {
					num2 = num;
				}
				else if (Array.isArray(num)) {
					num2 = num[0];
				}
				else if (typeof num == 'function') {
					num2 = num(players[0]);
				}
				if (drawDeck && drawDeck.drawDeck) {
					players[0].draw(num2, drawDeck);
				}
				else {
					players[0].draw(num2);
				}
			}
			else {
				game.asyncDraw.apply(this, arguments);
			}
		},
		finishSkill: function (i, sub) {
			var j;
			var mode = get.mode();
			var info = lib.skill[i];
			if (info.alter) {
				lib.translate[i + '_info_origin'] = lib.translate[i + '_info'];
				if (!lib.config.vintageSkills.contains(i)) {
					lib.translate[i + '_info'] = lib.translate[i + '_info_alter'];
				}
			}
			else if (lib.translate[i + '_info_' + mode]) {
				lib.translate[i + '_info'] = lib.translate[i + '_info_' + mode];
			}
			else if (lib.translate[i + '_info_zhu'] && (mode == 'identity' || (mode == 'guozhan' && _status.mode == 'four'))) {
				lib.translate[i + '_info'] = lib.translate[i + '_info_zhu'];
			}
			else if (lib.translate[i + '_info_combat'] && get.is.versus()) {
				lib.translate[i + '_info'] = lib.translate[i + '_info_combat'];
			}
			if (info.forbid && info.forbid.contains(mode)) {
				lib.skill[i] = {};
				if (lib.translate[i + '_info']) {
					lib.translate[i + '_info'] = '此模式下不可用';
				}
				return;
			}
			if (info.mode && info.mode.contains(mode) == false) {
				lib.skill[i] = {};
				if (lib.translate[i + '_info']) {
					lib.translate[i + '_info'] = '此模式下不可用';
				}
				return;
			}
			if (info.available && info.available(mode) == false) {
				lib.skill[i] = {};
				if (lib.translate[i + '_info']) {
					lib.translate[i + '_info'] = '此模式下不可用';
				}
				return;
			}
			if (info.viewAs && typeof info.viewAs != 'function') {
				if (typeof info.viewAs == 'string') {
					info.viewAs = { name: info.viewAs };
				}
				if (!lib.card[info.viewAs.name]) {
					lib.skill[i] = {};
					lib.translate[i + '_info'] = '技能不可用';
					return;
				}
				if (info.ai == undefined) info.ai = {};
				var skill = info.ai;
				var card = lib.card[info.viewAs.name].ai;
				for (j in card) {
					if (skill[j] == undefined) skill[j] = card[j];
					else if (typeof skill[j] == 'object') {
						for (var k in card[j]) {
							if (skill[j][k] == undefined) skill[j][k] = card[j][k];
						}
					}
				}
			}
			if (info.inherit) {
				var skill = lib.skill[info.inherit];
				for (j in skill) {
					if (info[j] == undefined) {
						if (j == 'audio' && (typeof info[j] == 'number' || typeof info[j] == 'boolean')) {
							info[j] = info.inherit;
						}
						else {
							info[j] = skill[j];
						}
					}
				}
				if (lib.translate[i] == undefined) {
					lib.translate[i] = lib.translate[info.inherit];
				}
				if (lib.translate[i + '_info'] == undefined) {
					lib.translate[i + '_info'] = lib.translate[info.inherit + '_info'];
				}
			}
			if (info.limited) {
				if (info.mark === undefined) info.mark = true;
				if (!info.intro) info.intro = {};
				if (info.intro.content === undefined) info.intro.content = 'limited';
				if (info.skillAnimation === undefined) info.skillAnimation = true;
				if (info.init === undefined) info.init = function (player, skill) {
					player.storage[skill] = false;
				}
			}
			if (info.subSkill && !sub) {
				for (var j in info.subSkill) {
					lib.skill[i + '_' + j] = info.subSkill[j];
					lib.skill[i + '_' + j].sub = true;
					if (info.subSkill[j].name) {
						lib.translate[i + '_' + j] = info.subSkill[j].name;
					}
					else {
						lib.translate[i + '_' + j] = lib.translate[i + '_' + j] || lib.translate[i];
					}
					if (info.subSkill[j].description) {
						lib.translate[i + '_' + j + '_info'] = info.subSkill[j].description;
					}
					if (info.subSkill[j].marktext) {
						lib.translate[i + '_' + j + '_bg'] = info.subSkill[j].marktext;
					}
					game.finishSkill(i + '_' + j, true);
				}
			}
			if (info.round) {
				var k = i + '_roundcount';
				if (typeof info.group == 'string') {
					info.group = [info.group, k];
				}
				else if (Array.isArray(info.group)) {
					info.group.add(k);
				}
				else {
					info.group = [k];
				}
				lib.skill[k] = (function (round, name) {
					return {
						init: function (player) {
							if (typeof player.storage[name] !== 'number') player.storage[name] = 1 - round;
						},
						intro: {
							content: function (storage, player) {
								var str = '';
								var info = get.info(name.slice(0, name.indexOf('_roundcount')));
								if (info && info.addintro) {
									str += info.addintro(storage, player);
								}
								var num = round - (game.roundNumber - storage);
								if (num > 0) {
									str += get.cnNumber(num) + '轮后' + (info.roundtext || '技能重置');
								}
								else {
									str += '技能可发动';
								}
								return str;
							},
							markcount: function (storage, player) {
								var num = round - (game.roundNumber - storage);
								if (num > 0) {
									return num;
								}
								return 0;
							}
						},
						trigger: { global: 'roundStart' },
						forced: true,
						popup: false,
						silent: true,
						content: function () {
							var skill = event.name.slice(0, event.name.indexOf('_roundcount'));
							if (lib.skill[skill].round - (game.roundNumber - player.storage[event.name]) > 0) {
								player.updateMarks();
							}
							else {
								player.unmarkSkill(event.name);
							}
						}
					};
				}(info.round, k));
				lib.translate[k] = lib.translate[i] || '';
				lib.translate[k + '_bg'] = lib.translate[i + '_bg'] || lib.translate[k][0];
			}
			if (info.marktext) {
				lib.translate[i + '_bg'] = info.marktext;
			}
			if (info.silent) {
				if (!info.hasOwnProperty('forced')) info.forced = true;
				if (!info.hasOwnProperty('popup')) info.popup = false;
			}
			if (i[0] == '_') {
				game.addGlobalSkill(i);
			}
		},
		finishCards: function () {
			_status.cardsFinished = true;
			var i, j, k;
			var mode = get.mode();
			for (i in lib.card) {
				if (lib.translate[i + '_info_' + mode]) {
					lib.translate[i + '_info'] = lib.translate[i + '_info_' + mode];
				}
				else if (lib.translate[i + '_info_zhu'] && (mode == 'identity' || (mode == 'guozhan' && _status.mode == 'four'))) {
					lib.translate[i + '_info'] = lib.translate[i + '_info_zhu'];
				}
				else if (lib.translate[i + '_info_combat'] && get.is.versus()) {
					lib.translate[i + '_info'] = lib.translate[i + '_info_combat'];
				}
				var card = lib.card[i];
				if (card.filterTarget && card.selectTarget == undefined) {
					card.selectTarget = 1;
				}
				if (card.autoViewAs) {
					if (!card.ai) {
						card.ai = {};
					}
					if (!card.ai.order) {
						card.ai.order = lib.card[card.autoViewAs].ai.order;
						if (!card.ai.order && lib.card[card.autoViewAs].ai.basic) {
							card.ai.order = lib.card[card.autoViewAs].ai.basic.order;
						}
					}
				}
				if (card.type == 'equip') {
					if (card.enable == undefined) card.enable = true;
					if (card.selectTarget == undefined) card.selectTarget = -1;
					if (card.filterTarget == undefined) card.filterTarget = function (card, player, target) {
						return target == player;
					};
					if (card.modTarget == undefined) card.modTarget = true;
					if (card.allowMultiple == undefined) card.allowMultiple = false;
					if (card.content == undefined) card.content = lib.element.content.equipCard;
					if (card.toself == undefined) card.toself = true;
					if (card.ai == undefined) card.ai = { basic: {} };
					if (card.ai.basic == undefined) card.ai.basic = {};
					if (card.ai.result == undefined) card.ai.result = { target: 1.5 };
					if (card.ai.basic.order == undefined) card.ai.basic.order = function (card, player) {
						if (player && player.hasSkillTag('reverseEquip')) {
							return 8.5 - get.equipValue(card, player) / 20;
						}
						else {
							return 8 + get.equipValue(card, player) / 20;
						}
					};
					if (card.ai.basic.useful == undefined) card.ai.basic.useful = 2;
					if (card.subtype == 'equip3') {
						if (card.ai.basic.equipValue == undefined) card.ai.basic.equipValue = 7;
					}
					else if (card.subtype == 'equip4') {
						if (card.ai.basic.equipValue == undefined) card.ai.basic.equipValue = 4;
					}
					else {
						if (card.ai.basic.equipValue == undefined) card.ai.basic.equipValue = 1;
					}
					if (card.ai.basic.value == undefined) card.ai.basic.value = function (card, player, index, method) {
						if (player.isDisabled(get.subtype(card))) return 0.01;
						var value = 0;
						var info = get.info(card);
						var current = player.getEquip(info.subtype);
						if (current && card != current) {
							value = get.value(current, player);
						}
						var equipValue = info.ai.equipValue;
						if (equipValue == undefined) {
							equipValue = info.ai.basic.equipValue;
						}
						if (typeof equipValue == 'function') {
							if (method == 'raw') return equipValue(card, player);
							if (method == 'raw2') return equipValue(card, player) - value;
							return Math.max(0.1, equipValue(card, player) - value);
						}
						if (typeof equipValue != 'number') equipValue = 0;
						if (method == 'raw') return equipValue;
						if (method == 'raw2') return equipValue - value;
						return Math.max(0.1, equipValue - value);
					}
					if (!card.ai.result.keepAI) card.ai.result.target = function (player, target, card) {
						return get.equipResult(player, target, card.name);
					};
				}
				else if (card.type == 'delay') {
					if (card.enable == undefined) card.enable = true;
					if (card.filterTarget == undefined) card.filterTarget = lib.filter.judge;
					if (card.content == undefined) card.content = lib.element.content.addJudgeCard;
					if (card.allowMultiple == undefined) card.allowMultiple = false;
				}
			}
			for (i in lib.skill) {
				game.finishSkill(i);
			}
		},
		checkMod: function () {
			var name = arguments[arguments.length - 2];
			var skills = arguments[arguments.length - 1];
			if (skills.getSkills) {
				if (name != 'cardname') skills = skills.getSkills();
				else skills = skills.getSkills(null, false);
			}
			skills = skills.concat(lib.skill.global);
			game.expandSkills(skills);
			var arg = [], i, info;
			for (i = 0; i < arguments.length - 2; i++) {
				arg.push(arguments[i]);
			}
			for (i = 0; i < skills.length; i++) {
				info = get.info(skills[i]);
				if (info && info.mod && info.mod[name]) {
					var result = info.mod[name].apply(this, arg);
					if (typeof arg[arg.length - 1] != 'object' && result != undefined) arg[arg.length - 1] = result;
				}
			}
			return arg[arg.length - 1];
		},
		prepareArena: function (num) {
			_status.prepareArena = true;
			game.showHistory(false);
			ui.create.players(num);
			ui.create.me();
			ui.create.cardsAsync();
			game.finishCards();
		},
		clearArena: function () {
			ui.control.innerHTML = '';
			ui.arenalog.innerHTML = '';
			var nodes = [];
			for (var i = 0; i < ui.arena.childNodes.length; i++) {
				nodes.push(ui.arena.childNodes[i]);
			}
			for (var i = 0; i < nodes.length; i++) {
				if (nodes[i] == ui.canvas) continue;
				if (nodes[i] == ui.control) continue;
				if (nodes[i] == ui.arenalog) continue;
				if (nodes[i] == ui.roundmenu) continue;
				if (nodes[i] == ui.timer) continue;
				if (nodes[i] == ui.autonode) continue;
				nodes[i].remove();
			}
			ui.sidebar.innerHTML = '';
			ui.cardPile.innerHTML = '';
			ui.discardPile.innerHTML = '';
			ui.special.innerHTML = '';
			ui.ordering.innerHTML = '';
			ui.playerids.remove();
			game.players.length = 0;
			game.dead.length = 0;
			game.me = null;
		},
		clearConnect: function () {
			if (ui.ipnode) {
				ui.ipnode.remove();
				delete ui.ipnode;
			}
			if (ui.iptext) {
				ui.iptext.remove();
				delete ui.iptext;
			}
			if (ui.ipbutton) {
				ui.ipbutton.remove();
				delete ui.ipbutton;
			}
			if (ui.recentIP) {
				ui.recentIP.remove();
				delete ui.recentIP;
			}
			if (ui.hall_button) {
				ui.hall_button.remove();
				delete ui.hall_button;
			}
			if (ui.startServer) {
				ui.startServer.remove();
				delete ui.startServer;
			}
			if (ui.rooms) {
				for (var i = 0; i < ui.rooms.length; i++) {
					ui.rooms[i].remove();
				}
				delete ui.rooms;
			}
			if (ui.connectEvents) {
				ui.connectRoom.remove();
				ui.connectEvents.remove();
				ui.connectEventsCount.remove();
				ui.connectClients.remove();
				ui.connectClientsCount.remove();
				delete ui.connectRoom;
				delete ui.connectEvents;
				delete ui.connectEventsCount;
				delete ui.connectClients;
				delete ui.connectClientsCount;
			}
		},
		log: function () {
			var str = '', str2 = '', logvid = null;
			for (var i = 0; i < arguments.length; i++) {
				var itemtype = get.itemtype(arguments[i]);
				if (itemtype == 'player' || itemtype == 'players') {
					str += '<span class="bluetext">' + get.translation(arguments[i]) + '</span>';
					str2 += get.translation(arguments[i]);
				}
				else if (itemtype == 'cards' || itemtype == 'card' || (typeof arguments[i] == 'object' && arguments[i] && arguments[i].name)) {
					str += '<span class="yellowtext">' + get.translation(arguments[i]) + '</span>';
					str2 += get.translation(arguments[i]);
				}
				else if (typeof arguments[i] == 'object') {
					if (arguments[i]) {
						if (arguments[i].parentNode == ui.historybar) {
							logvid = arguments[i].logvid;
						}
						else {
							str += get.translation(arguments[i]);
							str2 += get.translation(arguments[i]);
						}
					}
				}
				else if (typeof arguments[i] == 'string') {
					if (arguments[i][0] == '【' && arguments[i][arguments[i].length - 1] == '】') {
						str += '<span class="greentext">' + get.translation(arguments[i]) + '</span>';
						str2 += get.translation(arguments[i]);
					}
					else if (arguments[i][0] == '#') {
						var color = '';
						switch (arguments[i][1]) {
							case 'b': color = 'blue'; break;
							case 'y': color = 'yellow'; break;
							case 'g': color = 'green'; break;
						}
						str += '<span class="' + color + 'text">' + get.translation(arguments[i].slice(2)) + '</span>';
						str2 += get.translation(arguments[i].slice(2));
					}
					else {
						str += get.translation(arguments[i]);
						str2 += get.translation(arguments[i]);
					}
				}
				else {
					str += arguments[i];
					str2 += arguments[i];
				}

			}
			var node = ui.create.div();
			node.innerHTML = lib.config.log_highlight ? str : str2;
			ui.sidebar.insertBefore(node, ui.sidebar.firstChild);
			game.addVideo('log', null, lib.config.log_highlight ? str : str2);
			game.broadcast(function (str, str2) {
				game.log(lib.config.log_highlight ? str : str2);
			}, str, str2);
			if (!_status.video && !game.online) {
				if (!logvid) {
					logvid = _status.event.getLogv();
				}
				if (logvid) {
					game.logv(logvid, '<div class="text center">' + lib.config.log_highlight ? str : str2 + '</div>');
				}
			}
			// if(lib.config.title) document.title=lib.config.log_highlight?str:str2;
			if (lib.config.show_log != 'off' && !game.chess) {
				var nodeentry = node.cloneNode(true);
				ui.arenalog.insertBefore(nodeentry, ui.arenalog.firstChild);
				if (!lib.config.clear_log) {
					while (ui.arenalog.childNodes.length && ui.arenalog.scrollHeight > ui.arenalog.offsetHeight) {
						ui.arenalog.lastChild.remove();
					}
				}
				if (!lib.config.low_performance) {
					nodeentry.style.transition = 'all 0s';
					nodeentry.style.marginBottom = (-nodeentry.offsetHeight) + 'px';
					ui.refresh(nodeentry);
					nodeentry.style.transition = '';
					nodeentry.style.marginBottom = '';
				}
				if (lib.config.clear_log) {
					nodeentry.timeout = setTimeout(function () {
						nodeentry.delete();
					}, 1000);
					for (var i = 0; i < ui.arenalog.childElementCount; i++) {
						if (!ui.arenalog.childNodes[i].timeout) {
							ui.arenalog.childNodes[i].remove();
						}
					}
				}
			}
		},
		logv: function (player, card, targets, event, forced, logvid) {
			var node = ui.create.div('.hidden');
			node.node = {};
			logvid = logvid || get.id();
			if (!player) {
				player = _status.event.getParent().logvid;
				if (!player) return;
			}
			game.broadcast(function (player, card, targets, event, forced, logvid) {
				game.logv(player, card, targets, event, forced, logvid);
			}, player, card, targets, event, forced, logvid);
			if (typeof player == 'string') {
				for (var i = 0; i < ui.historybar.childElementCount; i++) {
					if (ui.historybar.childNodes[i].logvid == player) {
						ui.historybar.childNodes[i].added.push(card); break;
					}
				}
				return;
			}
			if (typeof card == 'string') {
				if (card != 'die') {
					if (lib.skill[card] && lib.skill[card].logv === false && !forced) return;
					if (!lib.translate[card]) return;
				}
				var avatar;
				if (!player.isUnseen(0)) {
					avatar = player.node.avatar.cloneNode();
				}
				else if (!player.isUnseen(1)) {
					avatar = player.node.avatar2.cloneNode();
				}
				else {
					return;
				}
				node.node.avatar = avatar;
				avatar.style.transform = '';
				avatar.className = 'avatar';
				if (card == 'die') {
					node.dead = true;
					node.player = player;
					var avatar2 = avatar.cloneNode();
					avatar2.className = 'avatarbg grayscale1';
					avatar.appendChild(avatar2);
					avatar.style.opacity = 0.6;
				}
				else {
					node.node.text = ui.create.div('', get.translation(card, 'skill'), avatar);
					node.node.text.dataset.nature = 'water';
					node.skill = card;
				}
				node.appendChild(avatar);
				if (card == 'die' && targets && targets != player) {
					node.source = targets;
					var avatar;
					player = targets;
					if (!player.isUnseen(0)) {
						avatar = player.node.avatar.cloneNode();
					}
					else if (!player.isUnseen(1)) {
						avatar = player.node.avatar2.cloneNode();
					}
					else if (get.mode() == 'guozhan' && player.node && player.node.name_seat) {
						avatar = ui.create.div('.avatar.cardbg');
						avatar.innerHTML = player.node.name_seat.innerHTML[0];
					}
					else {
						return;
					}
					avatar.style.transform = '';
					node.node.avatar2 = avatar;
					avatar.classList.add('avatar2');
					node.appendChild(avatar);
				}
			}
			else if (Array.isArray(card)) {
				node.cards = card[1];
				card = card[0];
				var info = [card.suit || '', card.number || '', card.name || '', card.nature || ''];
				if (!Array.isArray(node.cards) || !node.cards.length) {
					node.cards = [ui.create.card(node, 'noclick', true).init(info)];
				}
				if (card.name == 'wuxie') {
					if (ui.historybar.firstChild && ui.historybar.firstChild.type == 'wuxie') {
						ui.historybar.firstChild.players.push(player);
						ui.historybar.firstChild.cards.addArray(node.cards);
						return;
					}
					else {
						node.type = 'wuxie';
						node.players = [player];
					}
				}
				if (card.copy) {
					card.copy(node, false);
				}
				else {
					card = ui.create.card(node, 'noclick', true);
					card.init(info);
				}
				var avatar;
				if (!player.isUnseen(0)) {
					avatar = player.node.avatar.cloneNode();
				}
				else if (!player.isUnseen(1)) {
					avatar = player.node.avatar2.cloneNode();
				}
				else if (get.mode() == 'guozhan' && player.node && player.node.name_seat) {
					avatar = ui.create.div('.avatar.cardbg');
					avatar.innerHTML = player.node.name_seat.innerHTML[0];
				}
				else {
					return;
				}
				node.node.avatar = avatar;
				avatar.style.transform = '';
				avatar.classList.add('avatar2');
				node.appendChild(avatar);

				if (targets && targets.length == 1 && targets[0] != player && get.itemtype(targets[0]) == 'player') {
					(function () {
						var avatar2;
						var target = targets[0];
						if (!target.isUnseen(0)) {
							avatar2 = target.node.avatar.cloneNode();
						}
						else if (!player.isUnseen(1)) {
							avatar2 = target.node.avatar2.cloneNode();
						}
						else if (get.mode() == 'guozhan' && target.node && target.node.name_seat) {
							avatar2 = ui.create.div('.avatar.cardbg');
							avatar2.innerHTML = target.node.name_seat.innerHTML[0];
						}
						else {
							return;
						}
						node.node.avatar2 = avatar2;
						avatar2.style.transform = '';
						avatar2.classList.add('avatar2');
						avatar2.classList.add('avatar3');
						node.insertBefore(avatar2, avatar);
					}());
				}
			}
			if (targets && targets.length) {
				if (targets.length == 1 && targets[0] == player) {
					node.targets = [];
				}
				else {
					node.targets = targets;
				}
			}
			var fullheight = ui.historybar.offsetHeight;
			var num = Math.round((fullheight - 8) / 50);
			var margin = (fullheight - 42 * num) / (num + 1);
			node.style.transform = 'scale(0.8)';
			ui.historybar.insertBefore(node, ui.historybar.firstChild);
			ui.refresh(node);
			node.classList.remove('hidden');
			for (var i = 0; i < ui.historybar.childElementCount; i++) {
				var current = ui.historybar.childNodes[i];
				if (i < num) {
					current.style.transform = 'scale(1) translateY(' + (margin + i * (42 + margin) - 4) + 'px)';
				}
				else {
					if (!current.removetimeout) {
						current.style.opacity = 0;
						current.style.transform = 'scale(1) translateY(' + fullheight + 'px)';
						current.removetimeout = setTimeout((function (current) {
							return function () {
								current.remove();
							};
						}(current)), 500);
					}
				}
			}
			if (lib.config.touchscreen) {
				node.addEventListener('touchstart', ui.click.intro);
			}
			else {
				// node.addEventListener('mouseenter',ui.click.intro);
				node.addEventListener(lib.config.pop_logv ? 'mousemove' : 'click', ui.click.logv);
				node.addEventListener('mouseleave', ui.click.logvleave);
			}
			node.logvid = logvid;
			node.added = [];
			if (!game.online) {
				event = event || _status.event;
				event.logvid = node.logvid;
			}
			return node;
		},
		putDB: function (type, id, item, callback) {
			if (!lib.db) return item;
			if (lib.status.reload) {
				lib[_status.dburgent ? 'ondb2' : 'ondb'].push(['putDB', Array.from(arguments)]);
				return;
			}
			lib.status.reload++;
			var put = lib.db.transaction([type], 'readwrite').objectStore(type).put(item, id);
			put.onsuccess = function () {
				if (callback) {
					_status.dburgent = true;
					callback.apply(this, arguments);
					delete _status.dburgent;
				}
				game.reload2();
			};
		},
		getDB: function (type, id, callback) {
			if (!lib.db) {
				callback(null);
				return;
			}
			if (!callback) return;
			if (lib.status.reload) {
				lib[_status.dburgent ? 'ondb2' : 'ondb'].push(['getDB', Array.from(arguments)]);
				return;
			}
			lib.status.reload++;
			var store = lib.db.transaction([type], 'readwrite').objectStore(type);
			if (id) {
				store.get(id).onsuccess = function (e) {
					_status.dburgent = true;
					callback(e.target.result);
					delete _status.dburgent;
					game.reload2();
				};
			}
			else {
				var obj = {};
				store.openCursor().onsuccess = function (e) {
					var cursor = e.target.result;
					if (cursor) {
						obj[cursor.key] = cursor.value;
						cursor.continue();
					}
					else {
						_status.dburgent = true;
						callback(obj);
						delete _status.dburgent;
						game.reload2();
					}
				}
			}
		},
		deleteDB: function (type, id, callback) {
			if (!lib.db) {
				callback(false);
				return;
			}
			if (lib.status.reload) {
				lib[_status.dburgent ? 'ondb2' : 'ondb'].push(['deleteDB', Array.from(arguments)]);
				return;
			}
			if (arguments.length == 1) {
				game.getDB(type, null, function (obj) {
					var store = lib.db.transaction([type], 'readwrite').objectStore(type);
					for (var id in obj) {
						lib.status.reload++;
					}
					for (var id in obj) {
						store.delete(id).onsuccess = game.reload2;
					}
					game.reload2();
				});
			}
			else {
				lib.status.reload++;
				var store = lib.db.transaction([type], 'readwrite').objectStore(type);
				store.delete(id).onsuccess = function () {
					if (callback) {
						callback.apply(this, arguments);
					}
					game.reload2();
				};
			}
		},
		save: function (key, value, mode) {
			if (_status.reloading) return;
			mode = mode || lib.config.mode;
			if (!lib.db) {
				var config = {};
				if (key) {
					try {
						config = JSON.parse(localStorage.getItem(lib.configprefix + mode));
						if (typeof config != 'object') throw 'err';
					}
					catch (err) {
						config = {};
					}
					if (value == undefined) {
						delete config[key];
						if (mode == lib.config.mode) delete lib.storage[key];
					}
					else {
						config[key] = value;
						if (mode == lib.config.mode) lib.storage[key] = value;
					}
					config.version = lib.version;
					localStorage.setItem(lib.configprefix + mode, JSON.stringify(config));
				}
				else {
					localStorage.setItem(lib.configprefix + mode, JSON.stringify(lib.storage));
				}
			}
			else {
				if (key) {
					if (mode == lib.config.mode) {
						if (value == undefined) {
							delete lib.storage[key];
						}
						else {
							lib.storage[key] = value;
						}
						lib.storage.version = lib.version;
						game.putDB('data', mode, lib.storage);
					}
					else {
						game.getDB('data', mode, function (config) {
							if (!config) config = {};
							if (value == undefined) {
								delete config[key];
							}
							else {
								config[key] = value;
							}
							config.version = lib.version;
							game.putDB('data', mode, config);
						});
					}
				}
				else {
					game.putDB('data', mode, get.copy(lib.storage));
				}
			}
		},
		showChangeLog: function () {
			if (lib.version != lib.config.version || _status.extensionChangeLog) {
				var ul = document.createElement('ul');
				ul.style.textAlign = 'left';
				var caption;
				var players = null, cards = null;
				if (lib.version != lib.config.version) {
					for (var i = 0; i < lib.changeLog.length; i++) {
						if (lib.changeLog[i].indexOf('players://') == 0) {
							try {
								players = JSON.parse(lib.changeLog[i].slice(10));
							}
							catch (e) {
								players = null;
							}
						}
						else if (lib.changeLog[i].indexOf('cards://') == 0) {
							try {
								cards = JSON.parse(lib.changeLog[i].slice(8));
							}
							catch (e) {
								cards = null;
							}
						}
						else {
							var li = document.createElement('li');
							li.innerHTML = lib.changeLog[i];
							ul.appendChild(li);
						}
					}
					caption = lib.version + '更新内容';
				}
				else {
					caption = '扩展更新';
				}
				game.saveConfig('version', lib.version);
				for (var i in _status.extensionChangeLog) {
					var li = document.createElement('li');
					li.innerHTML = i + '：' + _status.extensionChangeLog[i];
					ul.appendChild(li);
				}
				var dialog = ui.create.dialog(caption, 'hidden');
				var lic = ui.create.div(dialog.content);
				lic.style.display = 'block';
				ul.style.display = 'inline-block';
				ul.style.marginLeft = '-40px';
				lic.appendChild(ul);
				if (players) {
					for (var i = 0; i < players.length; i++) {
						if (!lib.character[players[i]]) {
							players.splice(i--, 1);
						}
					}
					if (players.length) {
						dialog.addSmall([players, 'character']);
						dialog.classList.add('forcebutton');
						dialog.classList.add('withbg');
					}
				}
				if (cards) {
					for (var i = 0; i < cards.length; i++) {
						if (!lib.card[cards[i]]) {
							cards.splice(i--, 1);
						}
					}
					if (cards.length) {
						for (var i = 0; i < cards.length; i++) {
							cards[i] = [get.translation(get.type(cards[i])), '', cards[i]]
						}
						dialog.addSmall([cards, 'vcard']);
						dialog.classList.add('forcebutton');
						dialog.classList.add('withbg');
					}
				}
				dialog.open();
				var hidden = false;
				if (!ui.auto.classList.contains('hidden')) {
					ui.auto.hide();
					hidden = true;
				}
				game.pause();
				var control = ui.create.control('确定', function () {
					dialog.close();
					control.close();
					if (hidden) ui.auto.show();
					game.resume();
				});
				lib.init.onfree();
			}
		},
		showExtensionChangeLog: function (str, extname) {
			extname = extname || _status.extension;
			var cfg = 'extension_' + extname + '_changelog';
			if (lib.extensionPack[extname] && lib.extensionPack[extname].version != lib.config[cfg]) {
				game.saveConfig(cfg, lib.extensionPack[extname].version);
				if (!_status.extensionChangeLog) {
					_status.extensionChangeLog = {};
					_status.extensionChangeLog[extname] = str;
				}
			}
		},
		saveConfig: function (key, value, local, callback) {
			if (_status.reloading) return;
			if (local) {
				var localmode;
				if (typeof local == 'string') {
					localmode = local;
				}
				else {
					localmode = lib.config.mode;
				}
				if (!lib.config.mode_config[localmode]) {
					lib.config.mode_config[localmode] = {};
				}
				if (value == undefined) {
					delete lib.config.mode_config[localmode][key];
				}
				else {
					lib.config.mode_config[localmode][key] = value;
				}
				key += '_mode_config_' + localmode;
			}
			else {
				if (value == undefined) {
					delete lib.config[key];
				}
				else {
					lib.config[key] = value;
				}
			}
			if (!lib.db) {
				var config;
				try {
					config = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
					if (!config || typeof config != 'object') throw 'err'
				}
				catch (err) {
					config = {};
				}
				if (value === undefined) {
					delete config[key];
				}
				else {
					config[key] = value;
				}
				localStorage.setItem(lib.configprefix + 'config', JSON.stringify(config));
				if (callback) {
					callback();
				}
			}
			else {
				if (value == undefined) {
					game.deleteDB('config', key, callback);
				}
				else {
					game.putDB('config', key, value, callback);
				}
			}
		},
		saveConfigValue: function (key) {
			game.saveConfig(key, lib.config[key]);
		},
		saveExtensionConfig: function (extension, key, value) {
			return game.saveConfig('extension_' + extension + '_' + key, value);
		},
		getExtensionConfig: function (extension, key) {
			return lib.config['extension_' + extension + '_' + key];
		},
		clearModeConfig: function (mode) {
			if (_status.reloading) return;
			if (!lib.db) {
				var config;
				try {
					config = JSON.parse(localStorage.getItem(lib.configprefix + 'config'));
					if (!config || typeof config != 'object') throw 'err'
				}
				catch (err) {
					config = {};
				}
				for (var i in config) {
					if (i.substr(i.indexOf('_mode_config') + 13) == mode) {
						delete config[i];
					}
				}
				localStorage.setItem(lib.configprefix + 'config', JSON.stringify(config));
				localStorage.removeItem(lib.configprefix + mode);
			}
			else {
				game.getDB('config', null, function (config) {
					for (var i in config) {
						if (i.substr(i.indexOf('_mode_config') + 13) == mode) {
							game.saveConfig(i);
						}
					}
				});
			}
		},
		addPlayer: function (position, character, character2) {
			if (position < 0 || position > game.players.length + game.dead.length || position == undefined) {
				position = Math.ceil(Math.random() * (game.players.length + game.dead.length));
			}
			var players = game.players.concat(game.dead);
			ui.arena.setNumber(players.length + 1);
			for (var i = 0; i < players.length; i++) {
				if (parseInt(players[i].dataset.position) >= position) {
					players[i].dataset.position = parseInt(players[i].dataset.position) + 1;
				}
			}
			var player = ui.create.player(ui.arena).animate('start');
			if (character) player.init(character, character2);
			game.players.push(player);
			player.dataset.position = position;
			game.arrangePlayers();
			return player;
		},
		addFellow: function (position, character, animation) {
			game.addVideo('addFellow', null, [position, character, animation]);
			var player = ui.create.player(ui.arena).animate(animation || 'start');
			player.dataset.position = position || game.players.length + game.dead.length;
			player.getId();
			if (character) player.init(character);
			game.players.push(player); game.arrangePlayers();
			return player;
		},
		triggerEnter: function (player) {
			var next = game.createEvent('enterGame', false);
			next.player = player;
			next.setContent(function () {
				event.trigger('enterGame');
			});
		},
		restorePlayer: function (player) {
			if (game.players.contains(player) || game.dead.contains(player)) return;
			var position = parseInt(player.dataset.position);
			if (position < 0 || position > game.players.length + game.dead.length || position == undefined) {
				position = Math.ceil(Math.random() * (game.players.length + game.dead.length));
			}
			var players = game.players.concat(game.dead);
			ui.arena.setNumber(players.length + 1);
			for (var i = 0; i < players.length; i++) {
				if (parseInt(players[i].dataset.position) >= position) {
					players[i].dataset.position = parseInt(players[i].dataset.position) + 1;
				}
			}
			game.players.push(player);
			delete player.removed;
			player.removeAttribute('style');
			player.animate('start');
			ui.arena.appendChild(player);
			game.arrangePlayers();
			return player;
		},
		removePlayer: function (player) {
			if (_status.roundStart == player) {
				_status.roundStart = player.next || player.getNext() || game.players[0];
			}
			var players = game.players.concat(game.dead);
			player.style.left = player.getLeft() + 'px';
			player.style.top = player.getTop() + 'px';
			if (player == undefined) player = game.dead[0] || game.me.next;
			var position = parseInt(player.dataset.position);
			for (var i = 0; i < players.length; i++) {
				if (parseInt(players[i].dataset.position) > position) {
					players[i].dataset.position = parseInt(players[i].dataset.position) - 1;
				}
			}
			if (player.isAlive()) {
				player.next.previous = player.previous;
				player.previous.next = player.next;
			}
			player.nextSeat.previousSeat = player.previousSeat;
			player.previousSeat.nextSeat = player.nextSeat;
			player.delete();
			game.players.remove(player);
			game.dead.remove(player);
			ui.arena.setNumber(players.length - 1);
			player.removed = true;
			if (player == game.me) {
				ui.me.hide();
				ui.auto.hide();
				ui.wuxie.hide();
			}
			setTimeout(function () {
				player.removeAttribute('style');
			}, 500);
			return player;
		},
		replacePlayer: function (player, character, character2) {
			player.removed = true;
			var position = parseInt(player.dataset.position);
			game.players.remove(player);
			game.dead.remove(player);
			player.delete();
			var player2 = ui.create.player(ui.arena).animate('start');
			if (character) player2.init(character, character2);
			game.players.push(player2);
			player2.dataset.position = position;
			player2.nextSeat = player.nextSeat;
			player2.previousSeat = player.previousSeat;
			player2.nextSeat.previousSeat = player2;
			player2.previousSeat.nextSeat = player2;
			var player3 = player2.nextSeat;
			while (player3.isDead()) player3 = player3.nextSeat;
			player3.previous = player2;
			player2.next = player3;
			var player4 = player2.previousSeat;
			while (player4.isDead()) player4 = player4.previousSeat;
			player4.next = player2;
			player2.previous = player4;
			if (_status.roundStart == player) {
				_status.roundStart = player2;
			}
			return player2;
		},
		arrangePlayers: function () {
			if (game.chess && game.me) {
				var friendCount = 0;
				var enemyCount = 0;
				var rand = Math.random() < 0.5;
				for (var i = 0; i < game.players.length; i++) {
					if (game.players[i].side == game.me.side) {
						if (rand) {
							if (game.players[i] == game.friendZhu) {
								game.players[i]._sortCount = -2;
							}
							else {
								game.players[i]._sortCount = 2 * friendCount;
							}
						}
						else {
							if (game.players[i] == game.friendZhu) {
								game.players[i]._sortCount = -1;
							}
							else {
								game.players[i]._sortCount = 2 * friendCount + 1;
							}
						}
						friendCount++;
					}
					else {
						if (rand) {
							if (game.players[i] == game.enemyZhu) {
								game.players[i]._sortCount = -1;
							}
							else {
								game.players[i]._sortCount = 2 * enemyCount + 1;
							}
						}
						else {
							if (game.players[i] == game.enemyZhu) {
								game.players[i]._sortCount = -2;
							}
							else {
								game.players[i]._sortCount = 2 * enemyCount;
							}
						}
						enemyCount++;
					}
				}
				game.players.sort(function (a, b) {
					return a._sortCount - b._sortCount;
				});
				for (var i = 0; i < game.players.length; i++) {
					delete game.players[i]._sortCount;
				}
			}
			else {
				game.players.sort(lib.sort.position);
			}
			var players = game.players.concat(game.dead);
			players.sort(lib.sort.position);
			for (var i = 0; i < players.length; i++) {
				if (i == 0) {
					players[i].previousSeat = players[players.length - 1];
				}
				else {
					players[i].previousSeat = players[i - 1];
				}
				if (i == players.length - 1) {
					players[i].nextSeat = players[0];
				}
				else {
					players[i].nextSeat = players[i + 1];
				}
			}
			for (var i = 0; i < game.players.length; i++) {
				if (i == 0) {
					game.players[i].previous = game.players[game.players.length - 1];
				}
				else {
					game.players[i].previous = game.players[i - 1];
				}
				if (i == game.players.length - 1) {
					game.players[i].next = game.players[0];
				}
				else {
					game.players[i].next = game.players[i + 1];
				}
			}
		},
		filterSkills: function (skills, player) {
			var out = skills.slice(0);
			for (var i in player.disabledSkills) {
				out.remove(i);
			}
			return out;
		},
		expandSkills: function (skills) {
			var skills2 = [];
			for (var i = 0; i < skills.length; i++) {
				var info = get.info(skills[i]);
				if (info) {
					if (info.group) skills2 = skills2.concat(info.group);
				}
				else {
					console.log(skills[i]);
				}
			}
			for (var i = 0; i < skills2.length; i++) {
				skills.add(skills2[i]);
			}
			return skills;
		},
		css: function (style) {
			for (var i in style) {
				if (ui.style[i]) ui.style[i].innerHTML = i + JSON.stringify(style[i]).replace(/"/g, "");
				else {
					ui.style[i] = document.createElement('style');
					ui.style[i].innerHTML = i + JSON.stringify(style[i]).replace(/"/g, "");
					document.head.appendChild(ui.style[i]);
				}
			}
		},
		hasPlayer: function (func) {
			for (var i = 0; i < game.players.length; i++) {
				if (game.players[i].isOut()) continue;
				if (func(game.players[i])) return true;
			}
			return false;
		},
		hasPlayer2: function (func) {
			var players = game.players.slice(0).concat(game.dead);
			for (var i = 0; i < players.length; i++) {
				if (players[i].isOut()) continue;
				if (func(players[i])) return true;
			}
			return false;
		},
		countPlayer: function (func) {
			var num = 0;
			if (typeof func != 'function') {
				func = lib.filter.all;
			}
			for (var i = 0; i < game.players.length; i++) {
				if (game.players[i].isOut()) continue;
				var result = func(game.players[i]);
				if (typeof result == 'number') {
					num += result;
				}
				else if (result) {
					num++;
				}
			}
			return num;
		},
		countPlayer2: function (func) {
			var num = 0;
			if (typeof func != 'function') {
				func = lib.filter.all;
			}
			var players = game.players.slice(0).concat(game.dead);
			for (var i = 0; i < players.length; i++) {
				if (players[i].isOut()) continue;
				var result = func(players[i]);
				if (typeof result == 'number') {
					num += result;
				}
				else if (result) {
					num++;
				}
			}
			return num;
		},
		filterPlayer: function (func, list) {
			if (!Array.isArray(list)) {
				list = [];
			}
			if (typeof func != 'function') {
				func = lib.filter.all;
			}
			for (var i = 0; i < game.players.length; i++) {
				if (game.players[i].isOut()) continue;
				if (func(game.players[i])) {
					list.add(game.players[i]);
				}
			}
			return list;
		},
		filterPlayer2: function (func, list) {
			if (!Array.isArray(list)) {
				list = [];
			}
			if (typeof func != 'function') {
				func = lib.filter.all;
			}
			var players = game.players.slice(0).concat(game.dead);
			for (var i = 0; i < game.players.length; i++) {
				if (players[i].isOut()) continue;
				if (func(players[i])) {
					list.add(players[i]);
				}
			}
			return list;
		},
		findPlayer: function (func) {
			for (var i = 0; i < game.players.length; i++) {
				if (game.players[i].isOut()) continue;
				if (func(game.players[i])) {
					return game.players[i];
				}
			}
			return null;
		},
		findPlayer2: function (func) {
			var players = game.players.slice(0).concat(game.dead);
			for (var i = 0; i < players.length; i++) {
				if (players[i].isOut()) continue;
				if (func(players[i])) {
					return players[i];
				}
			}
			return null;
		},
		findCards: function (func, all) {
			var cards = [];
			for (var i in lib.card) {
				if (!lib.translate[i + '_info']) continue;
				if (lib.card[i].mode && lib.card[i].mode.contains(lib.config.mode) == false) continue;
				if (!all && !lib.inpile.contains(i)) continue;
				if (func(i, lib.card[i])) {
					cards.push(i);
				}
			}
			return cards;
		},
		countGroup: function () {
			var list = lib.group.slice(0);
			return game.countPlayer(function (current) {
				if (list.contains(current.group)) {
					list.remove(current.group);
					return true;
				}
			});
		},
		players: [],
		dead: [],
		imported: [],
		playerMap: {},
		phaseNumber: 0,
		roundNumber: 0,
		shuffleNumber: 0,
	};
	var ui = {
		updates: [],
		thrown: [],
		touchlines: [],
		todiscard: {},
		refresh: function (node) {
			void window.getComputedStyle(node, null).getPropertyValue("opacity");
		},
		create: {
			div: function () {
				var str, innerHTML, position, position2, style, divposition, listen;
				for (var i = 0; i < arguments.length; i++) {
					if (typeof arguments[i] == 'string') {
						if (typeof str == 'string') {
							innerHTML = arguments[i];
						}
						else {
							str = arguments[i];
						}
					}
					else if (get.objtype(arguments[i]) == 'div' ||
						get.objtype(arguments[i]) == 'table' ||
						get.objtype(arguments[i]) == 'tr' ||
						get.objtype(arguments[i]) == 'td' ||
						get.objtype(arguments[i]) == 'body') position = arguments[i];
					else if (typeof arguments[i] == 'number') position2 = arguments[i];
					else if (get.itemtype(arguments[i]) == 'divposition') divposition = arguments[i];
					else if (typeof arguments[i] == 'object') style = arguments[i];
					else if (typeof arguments[i] == 'function') listen = arguments[i];
				}
				if (str == undefined) str = '';
				var node = document.createElement('div');
				for (var i = 0; i < str.length; i++) {
					if (str[i] == '.') {
						if (node.className.length != 0) {
							node.className += ' ';
						}
						while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
							node.className += str[i + 1];
							i++;
						}
					}
					else if (str[i] == '#') {
						while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
							node.id += str[i + 1];
							i++;
						}
					}
				}
				if (position) {
					if (typeof position2 == 'number' && position.childNodes.length > position2) {
						position.insertBefore(node, position.childNodes[position2]);
					}
					else {
						position.appendChild(node);
					}
				}
				if (style) node.css(style);
				if (divposition) node.setPosition(divposition);
				if (innerHTML) node.innerHTML = innerHTML;
				if (listen) node.listen(listen);
				return node;
			},
			filediv: function () {
				var args = Array.from(arguments);
				var func = null;
				for (var i = 0; i < args.length; i++) {
					if (typeof args[i] == 'function') {
						func = args[i];
						args.splice(i, 1);
						break;
					}
				}
				var div = ui.create.div.apply(this, args);
				var input = ui.create.node('input.fileinput');
				input.type = 'file';
				input.onchange = function (e) {
					func.call(this, this.files[0], e);
				};
				div.appendChild(input);
				div.inputNode = input;
				return div;
			},
			node: function () {
				var tagName, str, innerHTML, position, position2, style, divposition, listen;
				for (var i = 0; i < arguments.length; i++) {
					if (typeof arguments[i] == 'string') {
						if (typeof tagName == 'string') {
							innerHTML = arguments[i];
						}
						else {
							tagName = arguments[i];
						}
					}
					else if (get.objtype(arguments[i]) == 'div' ||
						get.objtype(arguments[i]) == 'table' ||
						get.objtype(arguments[i]) == 'tr' ||
						get.objtype(arguments[i]) == 'td' ||
						get.objtype(arguments[i]) == 'body') position = arguments[i];
					else if (typeof arguments[i] == 'number') position2 = arguments[i];
					else if (get.itemtype(arguments[i]) == 'divposition') divposition = arguments[i];
					else if (typeof arguments[i] == 'object') style = arguments[i];
					else if (typeof arguments[i] == 'function') listen = arguments[i];
				}
				if (tagName == undefined) {
					tagName = 'div';
				}
				else {
					var i1 = tagName.indexOf('.');
					var i2 = tagName.indexOf('#');
					if (i1 != -1 || i2 != -1) {
						if (i2 != -1 && i2 < i1) {
							i1 = i2;
						}
						str = tagName.slice(i1);
						tagName = tagName.slice(0, i1);
					}
				}
				var node = document.createElement(tagName);
				if (str) {
					for (var i = 0; i < str.length; i++) {
						if (str[i] == '.') {
							if (node.className.length != 0) {
								node.className += ' ';
							}
							while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
								node.className += str[i + 1];
								i++;
							}
						}
						else if (str[i] == '#') {
							while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
								node.id += str[i + 1];
								i++;
							}
						}
					}
				}
				if (position) {
					if (typeof position2 == 'number' && position.childNodes.length > position2) {
						position.insertBefore(node, position.childNodes[position2]);
					}
					else {
						position.appendChild(node);
					}
				}
				if (style) HTMLDivElement.prototype.css.call(node, style);
				if (divposition) HTMLDivElement.prototype.setPosition.call(node, divposition);
				if (innerHTML) node.innerHTML = innerHTML;
				if (listen) node.onclick = listen;
				return node;
			},
			iframe: function (src) {
				var layer = document.createElement('div');
				layer.classList.add('poplayer');
				layer.style.zIndex = '100';
				layer.listen(function () {
					this.remove();
				});
				layer.style.background = 'white';

				var webview = document.createElement('iframe');
				webview.src = src;
				webview.style.width = '100%';
				webview.style.height = '100%';
				webview.style.left = '0px';
				webview.style.top = '0px';
				webview.style.position = 'absolute';
				webview.style.border = 'none';
				layer.appendChild(webview);

				var backbutton = ui.create.div('.menubutton.round', '返', layer, function () {
					layer.remove();
				});
				backbutton.style.bottom = '10px';
				backbutton.style.right = '10px';
				backbutton.style.background = 'rgba(0,0,0,0.4)';
				backbutton.style.color = 'white';
				backbutton.style.textShadow = 'rgba(0,0,0,0.5) 0px 0px 2px';
				backbutton.style.boxShadow = 'rgba(0, 0, 0, 0.3) 0 0 0 1px, rgba(0, 0, 0, 0.3) 0 3px 10px';
				backbutton.style.position = 'fixed';

				ui.window.appendChild(layer);
			},
			identitycircle: function (list, target) {
				var container = ui.create.div('.identitycircle.menubg', target);
				var circle = ui.create.div(container);
				container.dataset.num = list.length;
				for (var i = 0; i < list.length; i++) {
					var sec1 = ui.create.div(circle);
					sec1.dataset.color = list[i];
					var sec2 = ui.create.div(circle);
					sec2.dataset.color = list[i];
					var deg1 = 360 / list.length * i;
					var deg2 = 0;
					if (list.length == 2) {
						deg2 = 90;
					}
					else if (list.length == 3) {
						deg2 = 30;
					}
					sec1.style.transform = 'rotate(' + deg1 + 'deg)';
					sec2.style.transform = 'rotate(' + (deg1 + deg2) + 'deg)';
				}
			},
			chat: function () {
				var chat = ui.create.system('聊天', null, true);
				ui.chatButton = chat;
				lib.setPopped(chat, ui.click.chat, 220);
			},
			exit: function () {
				if (!ui.exit) {
					ui.exit = ui.create.control('退出房间', ui.click.exit);
				}
			},
			connecting: function (bool) {
				if (bool) {
					ui.window.classList.remove('connecting');
					if (ui.connecting) {
						ui.connecting.delete();
						delete ui.connecting;
					}
				}
				else {
					ui.window.classList.add('connecting');
					ui.connecting = ui.create.div('.fullsize.connectlayer');
					document.body.appendChild(ui.connecting);
					ui.create.div('', '正在重连...', ui.connecting);
					ui.connecting.splashtimeout = setTimeout(function () {
						if (ui.connecting) {
							delete ui.connecting.splashtimeout;
						}
					}, 300);
					// setTimeout(function(){
					// 	if(ui.connecting){
					// 		ui.connecting.firstChild.show();
					// 	}
					// },1000);
				}
			},
			roomInfo: function () {
				var chat = ui.create.system(game.online ? '房间信息' : '房间设置', function () {
					if (!game.online || game.onlinezhu) {
						ui.click.connectMenu();
					}
				}, true);
				ui.roomInfo = chat;
				lib.setPopped(chat, function () {
					if (game.getRoomInfo) {
						var uiintro = ui.create.dialog('hidden');
						game.getRoomInfo(uiintro);
						return uiintro;
					}
				}, 180);
			},
			templayer: function (time) {
				if (typeof time != 'number' || isNaN(time) || time == Infinity) {
					time = 500;
				}
				var templayer = ui.create.div('.popup-container', ui.window);
				setTimeout(function () {
					templayer.remove();
				}, time);
			},
			selectlist: function (list, init, position, onchange) {
				var select = document.createElement('select');
				for (var i = 0; i < list.length; i++) {
					var option = document.createElement('option');
					if (Array.isArray(list[i])) {
						option.value = list[i][0];
						option.innerHTML = list[i][1];
					}
					else {
						option.value = list[i];
						option.innerHTML = list[i];
					}
					if (init == option.value) {
						option.selected = 'selected';
					}
					select.appendChild(option);
				}
				if (position) {
					position.appendChild(select);
				}
				if (onchange) {
					select.onchange = onchange;
				}
				return select;
			},
			menu: function (connectMenu) {
				var menuTimeout = null;
				if (!connectMenu && !game.syncMenu) {
					menuTimeout = setTimeout(lib.init.reset, 1000);
				}
				var menu, menuContainer;
				var startButton;
				var popupContainer;
				var closeMenu = function () {
					if (popupContainer.noclose) {
						popupContainer.noclose = false;
						return;
					}
					popupContainer.classList.add('hidden');
					if (popupContainer.onclose) {
						popupContainer.onclose();
					}
				};
				popupContainer = ui.create.div('.popup-container.hidden', ui.window, closeMenu);

				var openMenu = function (node, e, onclose) {
					popupContainer.innerHTML = '';
					var left = Math.round(e.clientX / game.documentZoom);
					var zoom = get.is.phoneLayout ? 1.3 : 1;
					popupContainer.appendChild(node);
					// var rect=node.getBoundingClientRect();
					if (node.classList.contains('visual')) {
						// var num=node.querySelectorAll('.menu.visual>div').length;
						// node.style.top=(e.y-node.offsetHeight/2+30)+'px';
						for (var i = 0; i < node.childElementCount; i++) {
							if (node.childNodes[i].update) {
								node.childNodes[i].update();
							}
						}
						// if(node.offsetTop<10){
						// 	node.style.top='10px';
						// }
					}
					// else if(get.is.phoneLayout()&&rect.top*1.3+rect.height*1.3+20>ui.window.offsetHeight){
					// 	node.style.top=(ui.winheightdow.offsetHeight-20-rect.height*1.3)/1.3+'px';
					// }
					// if(e){
					var height = node.offsetHeight;
					var idealtop = e.clientY / game.documentZoom;
					if (idealtop < 10) {
						idealtop = 10;
					}
					else if ((idealtop + height) * zoom + 10 > ui.window.offsetHeight) {
						idealtop = (ui.window.offsetHeight - 10) / zoom - height;
					}
					node.style.top = idealtop + 'px';
					node.style.left = left + 'px';
					// }

					popupContainer.classList.remove('hidden');
					popupContainer.onclose = onclose;
				};
				var clickToggle = function () {
					if (this.classList.contains('disabled')) return;
					this.classList.toggle('on');
					var config = this._link.config;
					if (config.onclick) {
						if (config.onclick.call(this, this.classList.contains('on')) === false) {
							this.classList.toggle('on');
						}
					}
					if (config.update) {
						config.update();
					}
				};
				var clickSwitcher = function () {
					if (this.classList.contains('disabled')) return;
					var node = this;
					this.classList.add('on');
					if (this._link.menu) {
						var pos1 = this.lastChild.getBoundingClientRect();
						var pos2 = ui.window.getBoundingClientRect();
						if (this._link.menu.classList.contains('visual')) {
							openMenu(this._link.menu, {
								clientX: pos1.left + pos1.width + 5 - pos2.left,
								clientY: pos1.top - pos2.top
							}, function () {
								node.classList.remove('on');
							});
						}
						else if (this._link.menu.childElementCount > 10) {
							openMenu(this._link.menu, {
								clientX: pos1.left + pos1.width + 5 - pos2.left,
								clientY: Math.min((ui.window.offsetHeight - 400) / 2, pos1.top - pos2.top)
							}, function () {
								node.classList.remove('on');
							});
							lib.setScroll(this._link.menu);
						}
						else {
							openMenu(this._link.menu, {
								clientX: pos1.left + pos1.width + 5 - pos2.left,
								clientY: pos1.top - pos2.top
							}, function () {
								node.classList.remove('on');
							});
						}
					}
				};
				var clickContainer = function () {
					menuContainer.classList.add('hidden');
					if (connectMenu) {
						if (_status.enteringroom) {
							_status.enteringroom = false;
						}
						ui.window.classList.remove('shortcutpaused');
					}
					else {
						game.resume2();
						if (game.onresume2) {
							game.onresume2();
						}
						ui.arena.classList.remove('menupaused');
						ui.historybar.classList.remove('menupaused');
						ui.window.classList.remove('touchinfohidden');
						ui.config2.classList.remove('pressdown2');
					}
				};
				var clickMenuItem = function () {
					var node = this.parentNode._link;
					var config = node._link.config;
					node._link.current = this.link;
					var tmpName = node.lastChild.innerHTML;
					node.lastChild.innerHTML = config.item[this._link];
					if (config.onclick) {
						if (config.onclick.call(node, this._link, this) === false) {
							node.lastChild.innerHTML = tmpName;
						}
					}
					if (config.update) {
						config.update();
					}
				};
				var createMenu = function (tabs, config) {
					var createPage = function (position) {
						var node = ui.create.div(position);
						lib.setScroll(ui.create.div('.left.pane', node));
						lib.setScroll(ui.create.div('.right.pane', node));
						return node;
					};
					var menu = ui.create.div('.main.menu.dialog.popped.static', config.position, function (e) {
						e.stopPropagation();
					});
					if (connectMenu) {
						menu.classList.add('center');
						menuContainer.classList.add('centermenu');
					}
					var menuTab = ui.create.div('.menu-tab', menu);
					var menuTabBar = ui.create.div('.menu-tab-bar', menu);
					menuTabBar.style.left = (config.bar || 0) + 'px';
					if (Math.round(2 * game.documentZoom) < 2) {
						menuTabBar.style.height = '3px';
					}
					var menuContent = ui.create.div('.menu-content', menu);
					var clickTab = function () {
						if (this.classList.contains('disabled')) return;
						var active = this.parentNode.querySelector('.active');
						if (active) {
							active.classList.remove('active');
							active._link.remove();
						}
						this.classList.add('active');
						menuTabBar.style.transform = 'translateX(' + (this.getBoundingClientRect().left - this.parentNode.firstChild.getBoundingClientRect().left) / game.documentZoom + 'px)';
						menuContent.appendChild(this._link);
					};
					ui.click.menuTab = function (tab) {
						for (var i = 0; i < menuTab.childNodes.length; i++) {
							if (menuTab.childNodes[i].innerHTML == tab) {
								clickTab.call(menuTab.childNodes[i]);
								return;
							}
						}
					};
					var pages = [];
					for (var i = 0; i < tabs.length; i++) {
						var active = (i === (config.init || 0));
						pages[i] = createPage(active ? menuContent : null);
						ui.create.div(active ? '.active' : '', tabs[i], menuTab, clickTab)._link = pages[i];
					}
					return {
						menu: menu,
						pages: pages
					};
				};
				var createConfig = function (config, position) {
					var node = ui.create.div('.config', config.name);
					node._link = { config: config };
					if (!config.clear) {
						if (config.name != '开启') {
							if (config.name == '屏蔽弱将') {
								config.intro = '强度过低的武将（孙策除外）不会出现在选将框，也不会被AI选择'
							}
							else if (config.name == '屏蔽强将') {
								config.intro = '强度过高的武将不会出现在选将框，也不会被AI选择'
							}
							else if (!config.intro) {
								config.intro = '设置' + config.name;
							}
							lib.setIntro(node, function (uiintro) {
								if (lib.config.touchscreen) _status.dragged = true;
								uiintro.style.width = '170px';
								var str = config.intro;
								if (typeof str == 'function') {
									str = str();
								}
								uiintro._place_text = uiintro.add('<div class="text" style="display:inline">' + str + '</div>');
							});
						}
					}
					else {
						node.innerHTML = '<span>' + config.name + '</span>';
						if (!config.nopointer) {
							node.classList.add('pointerspan');
						}
					}
					if (config.item) {
						if (typeof config.item == 'function') {
							config.item = config.item();
						}
						if (Array.isArray(config.init)) {

						}
						else {
							node.classList.add('switcher');
							node.listen(clickSwitcher);
							ui.create.div('', config.item[config.init], node);
							node._link.menu = ui.create.div('.menu');
							if (config.visualMenu) {
								node._link.menu.classList.add('visual');
								var updateVisual = function () {
									config.visualMenu(this, this._link, config.item[this._link], config);
								};
								var createNode = function (i, before) {
									var visualMenu = ui.create.div();
									if (config.visualBar) {
										if (before) {
											node._link.menu.insertBefore(visualMenu, before);
										}
										else {
											node._link.menu.insertBefore(visualMenu, node._link.menu.lastChild);
										}
									}
									else {
										node._link.menu.appendChild(visualMenu);
									}
									ui.create.div('.name', get.verticalStr(config.item[i]), visualMenu);
									visualMenu._link = i;
									if (config.visualMenu(visualMenu, i, config.item[i], config) !== false) {
										visualMenu.listen(clickMenuItem);
									}
									visualMenu.update = updateVisual;
								};
								if (config.visualBar) {
									var visualBar = ui.create.div(node._link.menu, function () {
										this.parentNode.parentNode.noclose = true;
									});
									node._link.menu.classList.add('withbar');
									config.visualBar(visualBar, config.item, createNode, node);
									visualBar.update = function () {
										config.visualBar(visualBar, config.item, createNode, node);
									}
								}
								for (var i in config.item) {
									createNode(i);
								}
								lib.setScroll(node._link.menu);
								node._link.menu.updateBr = function () {
									var br = Array.from(this.querySelectorAll('.menu.visual>br'));
									while (br.length) {
										br.shift().remove();
									}
									var split = [];
									for (var i = 1; i < this.childElementCount; i++) {
										if (i % 3 == 0) {
											split.push(this.childNodes[i]);
										}
									}
									for (var i = 0; i < split.length; i++) {
										this.insertBefore(ui.create.node('br'), split[i]);
									}
								}
								node._link.menu.updateBr();
							}
							else {
								for (var i in config.item) {
									var textMenu = ui.create.div('', config.item[i], node._link.menu, clickMenuItem);
									textMenu._link = i;
									if (config.textMenu) {
										config.textMenu(textMenu, i, config.item[i], config)
									}
								}
							}
							node._link.menu._link = node;
							node._link.current = config.init;
						}
					}
					else if (config.range) {

					}
					else if (config.clear) {
						if (node.innerHTML.length >= 15) node.style.height = 'auto';
						node.listen(clickToggle);
					}
					else if (config.input) {
						node.classList.add('switcher');
						var input = ui.create.div(node);
						if (!config.fixed) {
							input.contentEditable = true;
							input.style.webkitUserSelect = 'text';
						}
						input.style.minWidth = '10px';
						input.onkeydown = function (e) {
							if (e.keyCode == 13) {
								e.preventDefault();
								e.stopPropagation();
								input.blur();
							}
						};
						if (config.name == '联机昵称') {
							input.innerHTML = config.init || '无名玩家';
							input.onblur = function () {
								input.innerHTML = input.innerHTML.replace(/<br>/g, '');
								if (!input.innerHTML) {
									input.innerHTML = '无名玩家';
								}
								game.saveConfig('connect_nickname', input.innerHTML);
								game.saveConfig('connect_nickname', input.innerHTML, 'connect');
							}
						}
						else if (config.name == '联机大厅') {
							input.innerHTML = config.init || lib.hallURL;
							input.onblur = function () {
								if (!input.innerHTML) {
									input.innerHTML = lib.hallURL;
								}
								input.innerHTML = input.innerHTML.replace(/<br>/g, '');
								game.saveConfig('hall_ip', input.innerHTML, 'connect');
							}
						}
						else {
							input.innerHTML = config.init;
							input.onblur = config.onblur;
						}
					}
					else {
						node.classList.add('toggle');
						node.listen(clickToggle);
						ui.create.div(ui.create.div(node));
						if (config.init == true) {
							node.classList.add('on');
						}
					}
					if (position) {
						position.appendChild(node);
					}
					return node;
				};
				var updateActive, updateActiveCard;
				var menuUpdates = [];
				menuContainer = ui.create.div('.menu-container.hidden', ui.window, clickContainer);
				var menux;
				if (!connectMenu) {
					ui.menuContainer = menuContainer;
					ui.click.configMenu = function () {
						ui.click.shortcut(false)
						if (menuContainer.classList.contains('hidden')) {
							ui.config2.classList.add('pressdown2');
							ui.arena.classList.add('menupaused');
							ui.historybar.classList.add('menupaused');
							ui.window.classList.add('touchinfohidden');
							menuContainer.classList.remove('hidden');
							for (var i = 0; i < menuUpdates.length; i++) {
								menuUpdates[i]();
							}
						}
						else {
							clickContainer.call(menuContainer);
						}
					}
					menux = createMenu(['开始', '选项', '武将', '卡牌', '扩展', '其它'], {
						position: menuContainer, bar: 40
					});
				}
				else {
					ui.connectMenuContainer = menuContainer;
					ui.click.connectMenu = function () {
						if (menuContainer.classList.contains('hidden')) {
							if (_status.waitingForPlayer) {
								startButton.innerHTML = '设';
								var start = menux.pages[0].firstChild;
								for (var i = 0; i < start.childNodes.length; i++) {
									if (start.childNodes[i].mode != lib.configOL.mode) {
										start.childNodes[i].classList.add('unselectable');
										start.childNodes[i].classList.remove('active');
										start.childNodes[i].link.remove();
									}
									else {
										start.childNodes[i].classList.add('active');
										start.nextSibling.appendChild(start.childNodes[i].link);
									}
								}
							}
							ui.window.classList.add('shortcutpaused');
							menuContainer.classList.remove('hidden');
							for (var i = 0; i < menuUpdates.length; i++) {
								menuUpdates[i]();
							}
						}
						else {
							clickContainer.call(menuContainer);
						}
					}

					menux = createMenu(['模式', '武将', '卡牌'], {
						position: menuContainer, bar: 123
					});
					menu = menux.menu;
				}
				var menuxpages = menux.pages.slice(0);

				var copyObj = get.copy;

				(function () {
					var start = menuxpages.shift();
					var rightPane = start.lastChild;

					startButton = ui.create.div('.menubutton.round.highlight', '启', start, function () {
						if (this.animating || this.classList.contains('dim')) {
							return;
						}
						var active = this.parentNode.querySelector('.active');
						if (active) {
							if (connectMenu) {
								if (_status.waitingForPlayer) {
									var config = {};
									for (var i in lib.mode[lib.configOL.mode].connect) {
										if (i == 'update') continue;
										config[i.slice(8)] = get.config(i, lib.configOL.mode);
									}
									if (game.online) {
										if (game.onlinezhu) {
											game.send('changeRoomConfig', config);
										}
									}
									else {
										game.broadcastAll(function (config) {
											for (var i in config) {
												lib.configOL[i] = config[i];
											}
										}, config);
										if (lib.configOL.mode == 'identity' && lib.configOL.identity_mode == 'zhong' && game.connectPlayers) {
											for (var i = 0; i < game.connectPlayers.length; i++) {
												game.connectPlayers[i].classList.remove('unselectable2');
											}
											lib.configOL.number = 8;
											game.updateWaiting();
										}
										if (game.onlineroom) {
											game.send('server', 'config', lib.configOL);
										}
										game.connectPlayers[0].chat('房间设置已更改');
									}
								}
								else if (_status.enteringroom) {
									lib.configOL.mode = active.mode;
									if (_status.enteringroomserver) {
										game.saveConfig('connect_mode', lib.configOL.mode);

										var config = {};
										for (var i in lib.mode[lib.configOL.mode].connect) {
											if (i == 'update') continue;
											config[i.slice(8)] = get.config(i, lib.configOL.mode);
										}

										config.characterPack = lib.connectCharacterPack.slice(0);
										config.cardPack = lib.connectCardPack.slice(0);
										for (var i = 0; i < lib.config.connect_characters.length; i++) {
											config.characterPack.remove(lib.config.connect_characters[i]);
										}
										for (var i = 0; i < lib.config.connect_cards.length; i++) {
											config.cardPack.remove(lib.config.connect_cards[i]);
										}
										config.banned = lib.config['connect_' + active.mode + '_banned'];
										config.bannedcards = lib.config['connect_' + active.mode + '_bannedcards'];
										game.send('server', 'enter', _status.roomindex, lib.config.connect_nickname, lib.config.connect_avatar, config, active.mode);
									}
									else {
										game.send('server', 'enter', _status.roomindex, lib.config.connect_nickname, lib.config.connect_avatar);
									}
								}
								else {
									localStorage.setItem(lib.configprefix + 'directstart', true);
									game.saveConfig('directstartmode', active.mode);
									game.saveConfig('mode', 'connect');
									ui.exitroom = ui.create.system('退出房间', function () {
										game.saveConfig('directstartmode');
										game.reload();
									}, true);
									game.switchMode(active.mode);
								}
								clickContainer.call(menuContainer);
							}
							else {
								game.saveConfig('mode', active.mode);
								localStorage.setItem(lib.configprefix + 'directstart', true);
								game.reload();
							}
						}
					});

					var clickMode = function () {
						if (this.classList.contains('unselectable')) return;
						var active = this.parentNode.querySelector('.active');
						if (active === this) {
							return;
						}
						active.classList.remove('active');
						active.link.remove();
						active = this;
						this.classList.add('active');
						rightPane.appendChild(this.link);
						if (connectMenu) {
							if (updateActive) updateActive();
							if (updateActiveCard) updateActiveCard();
						}
					};

					var createModeConfig = function (mode, position) {
						var info = lib.mode[mode];
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', info.name, position, clickMode);
						node.link = page;
						node.mode = mode;
						if (connectMenu) {
							if (mode == lib.config.connect_mode) {
								node.classList.add('active');
							}
						}
						else {
							if (mode == lib.config.mode) {
								node.classList.add('active');
							}
						}
						var map = {};
						var infoconfig = connectMenu ? info.connect : info.config;
						if (infoconfig) {
							var hiddenNodes = [];
							var config = lib.config.mode_config[mode] || {};
							if (connectMenu) {
								infoconfig.connect_choose_timeout = {
									name: '出牌时限',
									init: '30',
									item: {
										'10': '10秒',
										'15': '15秒',
										'30': '30秒',
										'60': '60秒',
										'90': '90秒',
									},
									connect: true,
									frequent: true
								};
								infoconfig.connect_observe = {
									name: '允许旁观',
									init: true,
									connect: true
								};
								infoconfig.connect_observe_handcard = {
									name: '允许观看手牌',
									init: false,
									connect: true
								};
							}
							for (var j in infoconfig) {
								if (j === 'update') {
									continue;
								}
								var cfg = copyObj(infoconfig[j]);
								cfg._name = j;
								cfg.mode = mode;
								if (!config.hasOwnProperty(j)) {
									game.saveConfig(j, cfg.init, mode);
								}
								else {
									cfg.init = config[j];
								}
								if (!cfg.onclick) {
									cfg.onclick = function (result) {
										var cfg = this._link.config;
										game.saveConfig(cfg._name, result, mode);
										if (cfg.onsave) {
											cfg.onsave.call(this, result);
										}
										if (!_status.connectMode || game.online) {
											if (typeof cfg.restart == 'function') {
												if (cfg.restart()) {
													startButton.classList.add('glowing');
												}
											}
											else if (cfg.restart) {
												startButton.classList.add('glowing');
											}
										}
									};
								}
								if (infoconfig.update) {
									cfg.update = function () {
										infoconfig.update(config, map);
									};
								}
								var cfgnode = createConfig(cfg);
								map[j] = cfgnode;
								if (cfg.frequent) {
									page.appendChild(cfgnode);
								}
								else {
									cfgnode.classList.add('auto-hide');
									hiddenNodes.push(cfgnode);
								}
							}
							if (!connectMenu) {
								var move = ui.create.div('.auto-hide.config', '<div style="margin-right:10px" class="pointerdiv">上移↑</div><div class="pointerdiv">下移↓</div>');
								move.firstChild.listen(function () {
									if (node.previousSibling) {
										node.parentNode.insertBefore(node, node.previousSibling);
										var order = [];
										for (var i = 0; i < node.parentNode.childNodes.length; i++) {
											order.push(node.parentNode.childNodes[i].mode);
										}
										game.saveConfig('modeorder', order);
									}
								});
								move.lastChild.listen(function () {
									if (node.nextSibling) {
										if (node.nextSibling.nextSibling) {
											node.parentNode.insertBefore(node, node.nextSibling.nextSibling);
										}
										else {
											node.parentNode.insertBefore(node.nextSibling, node);
										}
										var order = [];
										for (var i = 0; i < node.parentNode.childNodes.length; i++) {
											order.push(node.parentNode.childNodes[i].mode);
										}
										game.saveConfig('modeorder', order);
									}
								});
								hiddenNodes.push(move);
							}
							var expanded = false;
							var hasexpand = true;
							if (hiddenNodes.length) {
								if (lib.config.fold_mode) {
									var clickmore = function (type) {
										if (type === 'expand' && expanded) return;
										if (type === 'unexpand' && !expanded) return;
										if (expanded) {
											this.classList.remove('on');
											this.parentNode.classList.remove('expanded');
										}
										else {
											this.classList.add('on');
											this.parentNode.classList.add('expanded');
										}
										expanded = !expanded;
									};
									var morenodes = ui.create.div('.config.more', '更多 <div>&gt;</div>', page);
									morenodes.listen(clickmore);
									morenodes._onclick = clickmore;
									page.morenodes = morenodes;
								}
								else {
									page.classList.add('expanded');
									if (!connectMenu) {
										page.classList.add('expanded2');
									}
								}
								for (var k = 0; k < hiddenNodes.length; k++) {
									page.appendChild(hiddenNodes[k]);
								}
							}
							else {
								hasexpand = false;
							}
							if (!connectMenu) {
								var hidemode = ui.create.div('.config.pointerspan', '<span>隐藏此模式</span>', page, function () {
									if (this.firstChild.innerHTML == '隐藏此模式') {
										this.firstChild.innerHTML = '此模式将在重启后隐藏';
										lib.config.hiddenModePack.add(mode);
										if (!lib.config.prompt_hidepack) {
											alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
											game.saveConfig('prompt_hidepack', true);
										}
									}
									else {
										this.firstChild.innerHTML = '隐藏此模式';
										lib.config.hiddenModePack.remove(mode);
									}
									game.saveConfig('hiddenModePack', lib.config.hiddenModePack);
								});
								if (hasexpand) {
									hidemode.classList.add('auto-hide');
								}
							}
							if (infoconfig.update) {
								infoconfig.update(config, map);
								node.update = function () {
									infoconfig.update(config, map);
								}
							}
						}
						if (connectMenu) {
							menuUpdates.push(function () {
								if (_status.waitingForPlayer) {
									if (map.connect_player_number) {
										map.connect_player_number.style.display = 'none';
									}
									if (map.connect_versus_mode) {
										map.connect_versus_mode.style.display = 'none';
									}
								}
							})
						}
						return node;
					};
					var modeorder = lib.config.modeorder || [];
					for (var i in lib.mode) {
						modeorder.add(i);
					}
					for (var i = 0; i < modeorder.length; i++) {
						if (connectMenu) {
							if (!lib.mode[modeorder[i]].connect) continue;
							if (!lib.config['connect_' + modeorder[i] + '_banned']) {
								lib.config['connect_' + modeorder[i] + '_banned'] = [];
							}
							if (!lib.config['connect_' + modeorder[i] + '_bannedcards']) {
								lib.config['connect_' + modeorder[i] + '_bannedcards'] = [];
							}
						}
						if (lib.config.all.mode.contains(modeorder[i])) {
							createModeConfig(modeorder[i], start.firstChild);
						}
					}
					var active = start.firstChild.querySelector('.active');
					if (!active) {
						active = start.firstChild.firstChild;
						active.classList.add('active');
					}
					rightPane.appendChild(active.link);
					if (lib.config.fold_mode) {
						rightPane.addEventListener('mousewheel', function (e) {
							var morenodes = this.firstChild.morenodes;
							if (morenodes) {
								if (e.wheelDelta < 0) {
									morenodes._onclick.call(morenodes, 'expand');
								}
								else if (this.scrollTop == 0) {
									morenodes._onclick.call(morenodes, 'unexpand');
								}
							}
						}, { passive: true });
					}
				}());

				(function () {
					if (connectMenu) return;
					var start = menuxpages.shift();
					var rightPane = start.lastChild;

					var clickMode = function () {
						var active = this.parentNode.querySelector('.active');
						if (active === this) {
							return;
						}
						active.classList.remove('active');
						active.link.remove();
						active = this;
						this.classList.add('active');
						rightPane.appendChild(this.link);
					};

					var clickAutoSkill = function (bool) {
						var name = this._link.config._name;
						var list = lib.config.autoskilllist;
						if (bool) {
							list.remove(name);
						}
						else {
							list.add(name);
						}
						game.saveConfig('autoskilllist', list);
					};
					var skilllistexpanded = game.expandSkills(lib.skilllist);
					for (var i in lib.skill) {
						if (!skilllistexpanded.contains(i)) continue;
						if (lib.skill[i].frequent && lib.translate[i]) {
							lib.configMenu.skill.config[i] = {
								name: lib.translate[i + '_noconf'] || lib.translate[i],
								init: true,
								type: 'autoskill',
								onclick: clickAutoSkill,
								intro: lib.translate[i + '_info']
							}
						}
					}
					var clickBanSkill = function (bool) {
						var name = this._link.config._name;
						var list = lib.config.forbidlist;
						if (bool) {
							list.remove(name);
						}
						else {
							list.add(name);
						}
						game.saveConfig('forbidlist', list);
					};
					var forbid = lib.config.forbid;
					if (!lib.config.forbidlist) {
						game.saveConfig('forbidlist', []);
					}
					for (var i = 0; i < forbid.length; i++) {
						var skip = false;
						var str = '';
						var str2 = '';
						var str3 = '';
						for (var j = 0; j < forbid[i].length; j++) {
							if (!lib.skilllist.contains(forbid[i][j])) {
								skip = true;
								break;
							}
							str += get.translation(forbid[i][j]) + '+';
							str2 += forbid[i][j] + '+';
							str3 += get.translation(forbid[i][j]) + '：' + lib.translate[forbid[i][j] + '_info'];
							if (j < forbid[i].length - 1) {
								str3 += '<div class="placeholder slim" style="display:block;height:8px"></div>';
							}
						}
						if (skip) continue;
						str = str.slice(0, str.length - 1);
						str2 = str2.slice(0, str2.length - 1);

						lib.configMenu.skill.config[str2] = {
							name: str,
							init: true,
							type: 'banskill',
							onclick: clickBanSkill,
							intro: str3
						}
					}

					var updateView = null;
					var updateAppearence = null;
					var createModeConfig = function (mode, position) {
						var info = lib.configMenu[mode];
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', info.name, position, clickMode);
						node.link = page;
						node.mode = mode;
						var map = {};
						if (info.config) {
							var hiddenNodes = [];
							var autoskillNodes = [];
							var banskillNodes = [];
							var custombanskillNodes = [];
							var banskill;

							if (mode == 'skill') {
								var autoskillexpanded = false;
								var banskillexpanded = false;
								ui.create.div('.config.more', '自动发动 <div>&gt;</div>', page, function () {
									if (autoskillexpanded) {
										this.classList.remove('on');
										for (var k = 0; k < autoskillNodes.length; k++) {
											autoskillNodes[k].style.display = 'none';
										}
									}
									else {
										this.classList.add('on');
										for (var k = 0; k < autoskillNodes.length; k++) {
											autoskillNodes[k].style.display = '';
										}
									}
									autoskillexpanded = !autoskillexpanded;
								});
								banskill = ui.create.div('.config.more', '双将禁配 <div>&gt;</div>', page, function () {
									if (banskillexpanded) {
										this.classList.remove('on');
										for (var k = 0; k < banskillNodes.length; k++) {
											banskillNodes[k].style.display = 'none';
										}
									}
									else {
										this.classList.add('on');
										for (var k = 0; k < banskillNodes.length; k++) {
											banskillNodes[k].style.display = '';
										}
									}
									banskillexpanded = !banskillexpanded;
								});

								var banskilladd = ui.create.div('.config.indent', '<span class="pointerdiv">添加...</span>', page, function () {
									this.nextSibling.classList.toggle('hidden');
								});
								banskilladd.style.display = 'none';
								banskillNodes.push(banskilladd);

								var banskilladdNode = ui.create.div('.config.indent.hidden.banskilladd', page);
								banskilladdNode.style.display = 'none';
								banskillNodes.push(banskilladdNode);

								var matchBanSkill = function (skills1, skills2) {
									if (skills1.length != skills2.length) return false;
									for (var i = 0; i < skills1.length; i++) {
										if (!skills2.contains(skills1[i])) return false;
									}
									return true;
								}
								var deleteCustomBanSkill = function () {
									for (var i = 0; i < lib.config.customforbid.length; i++) {
										if (matchBanSkill(lib.config.customforbid[i], this.parentNode.link)) {
											lib.config.customforbid.splice(i--, 1);
											break;
										}
									}
									game.saveConfig('customforbid', lib.config.customforbid);
									this.parentNode.remove();
								}
								var createCustomBanSkill = function (skills) {
									var node = ui.create.div('.config.indent.toggle');
									node.style.display = 'none';
									node.link = skills;
									banskillNodes.push(node);
									custombanskillNodes.push(node);
									var str = get.translation(skills[0]);
									for (var i = 1; i < skills.length; i++) {
										str += '+' + get.translation(skills[i]);
									}
									node.innerHTML = str;
									var span = document.createElement('span');
									span.classList.add('cardpiledelete');
									span.innerHTML = '删除';
									span.onclick = deleteCustomBanSkill;
									node.appendChild(span);
									page.insertBefore(node, banskilladdNode.nextSibling);
									return node;
								};
								for (var i = 0; i < lib.config.customforbid.length; i++) {
									createCustomBanSkill(lib.config.customforbid[i]);
								}
								(function () {
									var list = [];
									for (var i in lib.character) {
										if (lib.character[i][3].length)
											list.push([i, lib.translate[i]]);
									}

									list.sort(function (a, b) {
										a = a[0]; b = b[0];
										var aa = a, bb = b;
										if (aa.indexOf('_') != -1) {
											aa = aa.slice(aa.indexOf('_') + 1);
										}
										if (bb.indexOf('_') != -1) {
											bb = bb.slice(bb.indexOf('_') + 1);
										}
										if (aa != bb) {
											return aa > bb ? 1 : -1;
										}
										return a > b ? 1 : -1;
									});

									var list2 = [];
									var skills = lib.character[list[0][0]][3];
									for (var i = 0; i < skills.length; i++) {
										list2.push([skills[i], lib.translate[skills[i]]]);
									}

									var selectname = ui.create.selectlist(list, list[0], banskilladdNode);
									selectname.onchange = function () {
										var skills = lib.character[this.value][3];
										skillopt.innerHTML = '';
										for (var i = 0; i < skills.length; i++) {
											var option = document.createElement('option');
											option.value = skills[i];
											option.innerHTML = lib.translate[skills[i]];
											skillopt.appendChild(option);
										}
									};
									selectname.style.maxWidth = '85px';
									var skillopt = ui.create.selectlist(list2, list2[0], banskilladdNode);

									var span = document.createElement('span');
									span.innerHTML = '＋';
									banskilladdNode.appendChild(span);
									var br = document.createElement('br');
									banskilladdNode.appendChild(br);

									var selectname2 = ui.create.selectlist(list, list[0], banskilladdNode);
									selectname2.onchange = function () {
										var skills = lib.character[this.value][3];
										skillopt2.innerHTML = '';
										for (var i = 0; i < skills.length; i++) {
											var option = document.createElement('option');
											option.value = skills[i];
											option.innerHTML = lib.translate[skills[i]];
											skillopt2.appendChild(option);
										}
									};
									selectname2.style.maxWidth = '85px';
									var skillopt2 = ui.create.selectlist(list2, list2[0], banskilladdNode);
									var confirmbutton = document.createElement('button');
									confirmbutton.innerHTML = '确定';
									banskilladdNode.appendChild(confirmbutton);

									confirmbutton.onclick = function () {
										var skills = [skillopt.value, skillopt2.value];
										if (skills[0] == skills[1]) {
											skills.shift();
										}
										if (!lib.config.customforbid) return;
										for (var i = 0; i < lib.config.customforbid.length; i++) {
											if (matchBanSkill(lib.config.customforbid[i], skills)) return;
										}
										lib.config.customforbid.push(skills);
										game.saveConfig('customforbid', lib.config.customforbid);
										createCustomBanSkill(skills).style.display = '';
									}
								}());
								page.style.paddingBottom = '10px';
							}
							var config = lib.config;
							if (mode == 'appearence') {
								updateAppearence = function () {
									info.config.update(config, map);
								};
							}
							else if (mode == 'view') {
								updateView = function () {
									info.config.update(config, map);
								};
							}
							for (var j in info.config) {
								if (j === 'update') {
									continue;
								}
								var cfg = copyObj(info.config[j]);
								cfg._name = j;
								if (!config.hasOwnProperty(j)) {
									if (cfg.type != 'autoskill' && cfg.type != 'banskill') {
										game.saveConfig(j, cfg.init);
									}
								}
								else {
									cfg.init = config[j];
								}
								if (!cfg.onclick) {
									cfg.onclick = function (result) {
										var cfg = this._link.config;
										game.saveConfig(cfg._name, result);
										if (cfg.onsave) {
											cfg.onsave.call(this, result);
										}
									};
								}
								if (info.config.update) {
									if (mode == 'appearence' || mode == 'view') {
										cfg.update = function () {
											if (updateAppearence) {
												updateAppearence();
											}
											if (updateView) {
												updateView();
											}
										};
									}
									else {
										cfg.update = function () {
											info.config.update(config, map);
										};
									}
								}
								var cfgnode = createConfig(cfg);
								if (cfg.type == 'autoskill') {
									autoskillNodes.push(cfgnode);
									// cfgnode.style.transition='all 0s';
									cfgnode.classList.add('indent');
									// cfgnode.hide();
									cfgnode.style.display = 'none';
								}
								else if (cfg.type == 'banskill') {
									banskillNodes.push(cfgnode);
									// cfgnode.style.transition='all 0s';
									cfgnode.classList.add('indent');
									// cfgnode.hide();
									cfgnode.style.display = 'none';
								}
								if (j == 'import_data_button') {
									ui.import_data_button = cfgnode;
									cfgnode.hide();
									cfgnode.querySelector('button').onclick = function () {
										var fileToLoad = this.previousSibling.files[0];
										if (fileToLoad) {
											var fileReader = new FileReader();
											fileReader.onload = function (fileLoadedEvent) {
												var data = fileLoadedEvent.target.result;
												if (!data) return;
												try {
													data = JSON.parse(lib.init.decode(data));
													if (!data || typeof data != 'object') {
														throw ('err');
													}
													if (lib.db && (!data.config || !data.data)) {
														throw ('err');
													}
												}
												catch (e) {
													console.log(e);
													alert('导入失败');
													return;
												}
												alert('导入成功');
												if (!lib.db) {
													var noname_inited = localStorage.getItem('noname_inited');
													var onlineKey = localStorage.getItem(lib.configprefix + 'key');
													localStorage.clear();
													if (noname_inited) {
														localStorage.setItem('noname_inited', noname_inited);
													}
													if (onlineKey) {
														localStorage.setItem(lib.configprefix + 'key', onlineKey);
													}
													for (var i in data) {
														localStorage.setItem(i, data[i]);
													}
												}
												else {
													for (var i in data.config) {
														game.putDB('config', i, data.config[i]);
														lib.config[i] = data.config[i];
													}
													for (var i in data.data) {
														game.putDB('data', i, data.data[i]);
													}
												}
												lib.init.background();
												game.reload();
											};
											fileReader.readAsText(fileToLoad, "UTF-8");
										}
									}
								}
								else if (j == 'import_music') {
									cfgnode.querySelector('button').onclick = function () {
										if (_status.music_importing) return;
										_status.music_importing = true;
										var fileToLoad = this.previousSibling.files[0];
										if (fileToLoad) {
											if (!lib.config.customBackgroundMusic) lib.config.customBackgroundMusic = {};
											var name = fileToLoad.name;
											if (name.indexOf('.') != -1) {
												name = name.slice(0, name.indexOf('.'));
											}
											var link = (game.writeFile ? 'cdv_' : 'custom_') + name;
											if (lib.config.customBackgroundMusic[link]) {
												if (!confirm('已经存在文件名称相同的背景音乐，是否仍然要继续导入？')) { _status.music_importing = false; return };
												for (var i = 1; i < 1000; i++) {
													if (!lib.config.customBackgroundMusic[link + '_' + i]) {
														link = link + '_' + i; break;
													}
												}
											}
											var callback = function () {
												var nodexx = ui.background_music_setting;
												var nodeyy = nodexx._link.menu;
												var nodezz = nodexx._link.config;
												var musicname = link.slice(link.indexOf('_') + 1);
												game.prompt('###请输入音乐的名称###' + musicname, true, function (str) {
													if (str) musicname = str;
													lib.config.customBackgroundMusic[link] = musicname;
													lib.config.background_music = link;
													lib.config.all.background_music.add(link);
													game.saveConfig('background_music', link);
													game.saveConfig('customBackgroundMusic', lib.config.customBackgroundMusic);
													nodezz.item[link] = lib.config.customBackgroundMusic[link];
													var textMenu = ui.create.div('', lib.config.customBackgroundMusic[link], nodeyy, clickMenuItem);
													textMenu._link = link;
													nodezz.updatex.call(nodexx, []);
													_status.music_importing = false;
													if (!_status._aozhan) game.playBackgroundMusic();
												});
											};
											if (game.writeFile) {
												game.writeFile(fileToLoad, 'audio/background', link + '.mp3', callback);
											}
											else {
												game.putDB('audio', link, fileToLoad, callback);
											}
										}
									}
								}
								map[j] = cfgnode;
								if (!cfg.unfrequent) {
									if (cfg.type == 'autoskill') {
										page.insertBefore(cfgnode, banskill);
									}
									else {
										page.appendChild(cfgnode);
									}
								}
								else {
									// cfgnode.classList.add('auto-hide');
									hiddenNodes.push(cfgnode);
								}
							}
							var expanded = false;
							if (hiddenNodes.length) {
								// ui.create.div('.config.more','更多 <div>&gt;</div>',page,function(){
								//     if(expanded){
								//      			this.classList.remove('on');
								//      			this.parentNode.classList.remove('expanded');
								//     }
								//     else{
								//      			this.classList.add('on');
								//      			this.parentNode.classList.add('expanded');
								//     }
								//     expanded=!expanded;
								// });
								page.classList.add('morenodes');
								for (var k = 0; k < hiddenNodes.length; k++) {
									page.appendChild(hiddenNodes[k]);
								}
							}
							if (info.config.update) {
								info.config.update(config, map);
							}
						}
						return node;
					};

					for (var i in lib.configMenu) {
						if (i != 'others') createModeConfig(i, start.firstChild);
					}
					(function () {
						if (!game.download && !lib.device) return;
						var page = ui.create.div('#create-extension');
						var node = ui.create.div('.menubutton.large', '文件', start.firstChild, clickMode);
						node.link = page;
						node.mode = 'create';
						var pageboard = ui.create.div(page);

						var importextensionexpanded = false;
						var importExtension;
						var extensionnode = ui.create.div('.config.more', '导入素材包 <div>&gt;</div>', pageboard, function () {
							if (importextensionexpanded) {
								this.classList.remove('on');
								importExtension.style.display = 'none';
							}
							else {
								this.classList.add('on');
								importExtension.style.display = '';
							}
							importextensionexpanded = !importextensionexpanded;
						});
						extensionnode.style.padding = '13px 33px 4px';
						extensionnode.style.left = '0px';
						importExtension = ui.create.div('.new_character.export.import', pageboard);
						importExtension.style.padding = '0px 33px 10px';
						importExtension.style.display = 'none';
						importExtension.style.width = '100%';
						importExtension.style.textAlign = 'left';
						ui.create.div('', '<input type="file" accept="application/zip" style="width:153px"><button>确定</button>', importExtension);
						var promptnode = ui.create.div('', '<div style="width:153px;font-size:small;margin-top:8px">', importExtension);
						promptnode.style.display = 'none';
						importExtension.firstChild.lastChild.onclick = function () {
							if (promptnode.style.display != 'none') return;
							var fileToLoad = this.previousSibling.files[0];
							if (fileToLoad) {
								promptnode.style.display = '';
								promptnode.firstChild.innerHTML = '正在解压...';
								var fileReader = new FileReader();
								fileReader.onload = function (fileLoadedEvent) {
									var data = fileLoadedEvent.target.result;
									var loadData = function () {
										var zip = new JSZip();
										zip.load(data);
										var images = [], audios = [], fonts = [], directories = {}, directorylist = [];
										for (var i in zip.files) {
											var ext = i.slice(i.lastIndexOf('.') + 1);
											if (i.indexOf('audio/') == 0 && (ext == 'mp3' || ext == 'ogg')) {
												audios.push(i);
											}
											else if (i.indexOf('font/') == 0 && ext == 'ttf') {
												fonts.push(i);
											}
											else if (i.indexOf('image/') == 0 && (ext == 'jpg' || ext == 'png')) {
												images.push(i);
											}
											else {
												continue;
											}
											var index = i.lastIndexOf('/');
											var str = i.slice(0, index);
											if (!directories[str]) {
												directories[str] = [];
												directorylist.push(str);
											}
											directories[str].push(i.slice(index + 1));
										}
										if (audios.length || fonts.length || images.length) {
											var str = '';
											if (audios.length) {
												str += audios.length + '个音频文件';
											}
											if (fonts.length) {
												if (str.length) str += '、'
												str += fonts.length + '个字体文件';
											}
											if (images.length) {
												if (str.length) str += '、'
												str += images.length + '个图片文件';
											}
											var filelist = audios.concat(fonts).concat(images);
											if (filelist.length > 200) {
												str += '，导入时间可能较长';
											}
											var assetLoaded = function () {
												promptnode.firstChild.innerHTML = '导入成功。<span class="hrefnode">重新启动</span><span class="closenode">×</span>';
												promptnode.firstChild.querySelectorAll('span')[0].onclick = game.reload;
												promptnode.firstChild.querySelectorAll('span')[1].onclick = function () {
													promptnode.style.display = 'none';
												}
											};
											if (confirm('本次将导入' + str + '，是否继续？')) {
												promptnode.firstChild.innerHTML = '正在导入... <span class="hrefnode">详细信息</span>';
												promptnode.firstChild.querySelector('span.hrefnode').onclick = ui.click.consoleMenu;
												if (lib.node && lib.node.fs) {
													var writeFile = function () {
														if (filelist.length) {
															var str = filelist.shift();
															game.print(str.slice(str.lastIndexOf('/') + 1));
															lib.node.fs.writeFile(__dirname + '/' + str, zip.files[str].asNodeBuffer(), null, writeFile);
														}
														else {
															assetLoaded();
														}
													};
													game.ensureDirectory(directorylist, writeFile);

												}
												else {
													var getDirectory = function () {
														if (directorylist.length) {
															var dir = directorylist.shift();
															var filelist = directories[dir];
															window.resolveLocalFileSystemURL(lib.assetURL + dir, function (entry) {
																var writeFile = function () {
																	if (filelist.length) {
																		var filename = filelist.shift();
																		game.print(filename);
																		entry.getFile(filename, { create: true }, function (fileEntry) {
																			fileEntry.createWriter(function (fileWriter) {
																				fileWriter.onwriteend = writeFile;
																				fileWriter.onerror = function (e) {
																					game.print('Write failed: ' + e.toString());
																				};
																				fileWriter.write(zip.files[dir + '/' + filename].asArrayBuffer());
																			});
																		});
																	}
																	else {
																		getDirectory();
																	}
																};
																writeFile();
															});
														}
														else {
															assetLoaded();
														}
													};
													game.ensureDirectory(directorylist, getDirectory);
												}
											}
											else {
												promptnode.style.display = 'none';
											}
										}
										else {
											alert('没有检测到素材');
										}
									}
									if (!window.JSZip) {
										lib.init.js(lib.assetURL + 'game', 'jszip', loadData);
									}
									else {
										loadData();
									}
								};
								fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
							}
						}

						var dashboard = ui.create.div(pageboard);
						var clickDash = function () {
							ui.create.templayer();
							pageboard.hide();
							this.link.show();
							if (this.link.init) {
								this.link.init();
							}
						};
						var createDash = function (str1, str2, node) {
							var dash = ui.create.div('.menubutton.large.dashboard');
							dashboard.appendChild(dash);
							page.appendChild(node);
							dash.link = node;
							node.link = dash;
							dash.listen(clickDash);
							lib.setScroll(node);
							ui.create.div('', str1, dash);
							ui.create.div('', str2, dash);
						};
						var createDash2 = function (str1, str2, path, page) {
							var dash = ui.create.div('.menubutton.large.dashboard.dashboard2');
							page.appendChild(dash);
							dash.listen(function () {
								page.path = path;
								enterDirectory(page, path);
							});
							ui.create.div('', str1, dash);
							ui.create.div('', str2, dash);
						};
						var removeFile = function (selected, page) {
							if (lib.node && lib.node.fs) {
								var unlink = function () {
									if (selected.length) {
										lib.node.fs.unlink(__dirname + '/' + selected.shift().path, unlink);
									}
									else {
										enterDirectory(page, page.currentpath);
									}
								}
								unlink();
							}
							else {
								window.resolveLocalFileSystemURL(lib.assetURL + page.currentpath, function (entry) {
									var unlink = function () {
										if (selected.length) {
											entry.getFile(selected.shift().filename, { create: false }, function (fileEntry) {
												fileEntry.remove(unlink);
											});
										}
										else {
											enterDirectory(page, page.currentpath);
										}
									}
									unlink();
								});
							}
						};
						var clickDirectory = function () {
							if (_status.dragged) return;
							var page = this.parentNode.parentNode.parentNode;
							if (page.deletebutton.classList.contains('active')) {
								if (confirm('确认删除' + this.innerHTML + '文件夹？（此操作不可撤销）')) {
									if (lib.node && lib.node.fs) {
										try {
											var removeDirectory = function (path, callback) {
												lib.node.fs.readdir(__dirname + '/' + path, function (err, list) {
													if (err) {
														console.log(err);
														return;
													}
													var removeFile = function () {
														if (list.length) {
															var filename = list.shift();
															var url = __dirname + '/' + path + '/' + filename;
															if (lib.node.fs.statSync(url).isDirectory()) {
																removeDirectory(path + '/' + filename, removeFile);
															}
															else {
																lib.node.fs.unlink(url, removeFile);
															}
														}
														else {
															lib.node.fs.rmdir(__dirname + '/' + path, callback);
														}
													}
													removeFile();
												});
											};
											removeDirectory(this.path, function () {
												enterDirectory(page, page.currentpath);
											});
										}
										catch (e) {
											console.log(e);
										}
									}
									else {
										window.resolveLocalFileSystemURL(lib.assetURL + this.path, function (entry) {
											entry.removeRecursively(function () {
												enterDirectory(page, page.currentpath);
											});
										});
									}
								}
								return;
							}
							enterDirectory(page, this.path);
						};
						var clickFile = function () {
							if (_status.dragged) return;
							var page = this.parentNode.parentNode.parentNode;
							if (page.deletebutton.classList.contains('active')) {
								if (confirm('确认删除' + this.innerHTML + '？（此操作不可撤销）')) {
									removeFile([this], page);
								}
								return;
							}
							this.classList.toggle('thundertext');
							page.clicked = true;
							if (this.ext == 'jpg' || this.ext == 'png') {
								if (this.classList.contains('thundertext')) {
									if (!this.previewnode) {
										this.previewnode = document.createElement('img');
										this.previewnode.src = lib.assetURL + this.path;
										this.previewnode.width = '60';
										this.previewnode.style.maxHeight = '120px';
										this.parentNode.appendChild(this.previewnode);
									}
								}
								else {
									if (this.previewnode) {
										this.previewnode.remove();
										delete this.previewnode;
									}
								}
							}
							else if (this.ext == 'mp3' || this.ext == 'ogg') {
								if (this.classList.contains('thundertext')) {
									if (!this.previewnode) {
										this.previewnode = game.playAudio(this.path.slice(6));
									}
								}
								else {
									if (this.previewnode) {
										this.previewnode.remove();
										delete this.previewnode;
									}
								}
							}
						};
						var clickFileList = function () {
							if (!this.parentNode) return;
							if (this.parentNode.clicked) {
								this.parentNode.clicked = false;
							}
							else {
								var selected = Array.from(this.querySelectorAll('span.thundertext'));
								for (var i = 0; i < selected.length; i++) {
									selected[i].classList.remove('thundertext');
									if (selected[i].previewnode) {
										selected[i].previewnode.remove();
										delete selected[i].previewnode;
									}
								}
							}
						};
						var enterDirectory = function (page, path) {
							page.innerHTML = '';
							page.currentpath = path;
							var backbutton = ui.create.div('.menubutton.round', '返', page, function () {
								page.clicked = false;
								clickFileList.call(filelist);
								if (page.path == path) {
									page.reset();
								}
								else {
									if (path.indexOf('/') == -1) {
										enterDirectory(page, '');
									}
									else {
										enterDirectory(page, path.slice(0, path.lastIndexOf('/')));
									}
								}
							});
							backbutton.style.zIndex = 1;
							backbutton.style.right = '10px';
							backbutton.style.bottom = '15px';


							var refresh = function () {
								enterDirectory(page, path);
							};
							var addbutton = ui.create.div('.menubutton.round', '添', page, function () {
								var pos1 = this.getBoundingClientRect();
								var pos2 = ui.window.getBoundingClientRect();
								openMenu(this.menu, {
									clientX: pos1.left + pos1.width + 5 - pos2.left,
									clientY: pos1.top - pos2.top
								});
							});
							addbutton.menu = ui.create.div('.menu');
							ui.create.div('', '添加文件', addbutton.menu, function () {
								popupContainer.noclose = true;
							});
							var createDir = function (str) {
								if (lib.node && lib.node.fs) {
									lib.node.fs.mkdir(__dirname + '/' + path + '/' + str, refresh);
								}
								else {
									window.resolveLocalFileSystemURL(lib.assetURL + path, function (entry) {
										entry.getDirectory(str, { create: true }, refresh);
									});
								}
							};
							ui.create.div('', '添加目录', addbutton.menu, function () {
								ui.create.templayer();
								game.prompt('输入目录名称', function (str) {
									if (str) {
										createDir(str);
									}
								});
							});
							var input = document.createElement('input');
							input.className = 'fileinput';
							input.type = 'file';
							input.onchange = function () {
								var fileToLoad = input.files[0];
								game.print(fileToLoad.name);
								if (fileToLoad) {
									var fileReader = new FileReader();
									fileReader.onload = function (e) {
										game.writeFile(e.target.result, path, fileToLoad.name, refresh);
									};
									fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
								}
							};
							addbutton.menu.firstChild.appendChild(input);
							addbutton.style.zIndex = 1;
							addbutton.style.right = '10px';
							addbutton.style.bottom = '80px';

							var deletebutton = ui.create.div('.menubutton.round', '删', page, function () {
								if (!this.parentNode) return;
								if (!this.classList.contains('active')) {
									var selected = Array.from(filelist.querySelectorAll('span.thundertext'));
									if (selected.length) {
										if (confirm('一共要删除' + selected.length + '个文件，此操作不可撤销，是否确定？')) {
											removeFile(selected, page);
										}
									}
									else {
										this.classList.add('active');
									}
								}
								else {
									this.classList.remove('active');
								}
							});
							deletebutton.style.zIndex = 1;
							deletebutton.style.right = '10px';
							deletebutton.style.bottom = '145px';

							page.backbutton = backbutton;
							page.addbutton = addbutton;
							page.deletebutton = deletebutton;
							var filelist = ui.create.div(page);
							filelist.classList.add('file-container');
							filelist.listen(clickFileList);
							lib.setScroll(filelist);
							game.getFileList(path, function (folders, files) {
								var sort = function (a, b) {
									if (a > b) return 1;
									if (a < b) return -1;
									return 0;
								}
								folders.sort(sort);
								files.sort(sort);
								var parent = path;
								if (parent) {
									parent += '/';
								}
								for (var i = 0; i < folders.length; i++) {
									if (!page.path && folders[i] == 'app') continue;
									var entry = ui.create.div('', '<span>' + folders[i], filelist);
									entry.firstChild.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickDirectory);
									entry.firstChild.path = parent + folders[i]
								}
								for (var i = 0; i < files.length; i++) {
									if (!page.path) {
										if (files[i] == 'app.html') continue;
										if (files[i] == 'main.js') continue;
										if (files[i] == 'package.json') continue;
									}
									var entry = ui.create.div('', '<span>' + files[i], filelist);
									entry.firstChild.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickFile);
									entry.firstChild.ext = files[i].slice(files[i].lastIndexOf('.') + 1);
									entry.firstChild.path = parent + files[i];
									entry.firstChild.filename = files[i];
								}
							});
						};
						var dash1 = (function () {
							var page = ui.create.div('.hidden.menu-buttons');
							page.reset = function () {
								page.innerHTML = '';
								var backbutton = ui.create.div('.menubutton.round', '返', page, function () {
									ui.create.templayer();
									page.hide();
									pageboard.show();
								});
								backbutton.style.zIndex = 1;
								backbutton.style.right = '10px';
								backbutton.style.bottom = '15px';
								var placeholder = ui.create.div('.placeholder', page);
								placeholder.style.position = 'relative';
								placeholder.style.display = 'block';
								placeholder.style.width = '100%';
								placeholder.style.height = '14px';
								createDash2('将', '武将图片', 'image/character', page);
								createDash2('肤', '皮肤图片', 'image/skin', page);
								createDash2('卡', '卡牌图片', 'image/card', page);
								createDash2('模', '模式图片', 'image/mode', page);
								createDash2('始', '开始图片', 'image/splash', page);
								createDash2('景', '背景图片', 'image/background', page);
							};
							page.reset();
							return page;
						}());
						var dash2 = (function () {
							var page = ui.create.div('.hidden.menu-buttons');
							page.reset = function () {
								page.innerHTML = '';
								var backbutton = ui.create.div('.menubutton.round', '返', page, function () {
									ui.create.templayer();
									page.hide();
									pageboard.show();
								});
								backbutton.style.zIndex = 1;
								backbutton.style.right = '10px';
								backbutton.style.bottom = '15px';
								var placeholder = ui.create.div('.placeholder', page);
								placeholder.style.position = 'relative';
								placeholder.style.display = 'block';
								placeholder.style.width = '100%';
								placeholder.style.height = '14px';
								createDash2('技', '技能配音', 'audio/skill', page);
								createDash2('卡', '男性卡牌', 'audio/card/male', page);
								createDash2('牌', '女性卡牌', 'audio/card/female', page);
								createDash2('亡', '阵亡配音', 'audio/die', page);
								createDash2('效', '游戏音效', 'audio/effect', page);
								createDash2('景', '背景音乐', 'audio/background', page);
							};
							page.reset();
							return page;
						}());
						var dash3 = (function () {
							var page = ui.create.div('.hidden.menu-buttons');
							page.path = 'font';
							page.reset = function () {
								ui.create.templayer();
								page.hide();
								pageboard.show();
							};
							page.init = function () {
								enterDirectory(page, 'font');
							};
							return page;
						}());
						var dash4 = (function () {
							var page = ui.create.div('.hidden.menu-buttons');
							page.path = '';
							page.reset = function () {
								ui.create.templayer();
								page.hide();
								pageboard.show();
							};
							page.init = function () {
								enterDirectory(page, '');
							};
							return page;
						}());
						createDash('图', '图片文件', dash1);
						createDash('音', '音频文件', dash2);
						createDash('字', '字体文件', dash3);
						createDash('全', '全部文件', dash4);
					}());
					createModeConfig('others', start.firstChild);

					var active = start.firstChild.querySelector('.active');
					if (!active) {
						active = start.firstChild.firstChild;
						active.classList.add('active');
					}
					rightPane.appendChild(active.link);
				}());

				(function () {
					var start = menuxpages.shift();
					var rightPane = start.lastChild;

					var clickMode = function () {
						var active = this.parentNode.querySelector('.active');
						if (active) {
							if (active === this) {
								return;
							}
							active.classList.remove('active');
							active.link.remove();
						}
						this.classList.add('active');
						updateActive(this);
						rightPane.appendChild(this.link);
					};
					updateActive = function (node) {
						if (!node) {
							node = start.firstChild.querySelector('.active');
							if (!node) {
								return;
							}
						}
						for (var i = 0; i < node.link.childElementCount; i++) {
							if (node.link.childNodes[i].updateBanned) {
								node.link.childNodes[i].updateBanned();
							}
						}
					};
					var updateNodes = function () {
						for (var i = 0; i < start.firstChild.childNodes.length; i++) {
							var node = start.firstChild.childNodes[i];
							if (node.link) {
								if (node.mode.indexOf('mode_') == 0) continue;
								if (node.mode == 'custom') continue;
								if (connectMenu) {
									if (!lib.config.connect_characters.contains(node.mode)) {
										node.classList.remove('off');
										node.link.firstChild.classList.add('on');
									}
									else {
										node.classList.add('off');
										node.link.firstChild.classList.remove('on');
									}
								}
								else {
									if (lib.config.characters.contains(node.mode)) {
										node.classList.remove('off');
										node.link.firstChild.classList.add('on');
									}
									else {
										node.classList.add('off');
										node.link.firstChild.classList.remove('on');
									}
								}
							}
						}
					}
					var togglePack = function (bool) {
						var name = this._link.config._name;
						if (connectMenu) {
							if (!bool) {
								lib.config.connect_characters.add(name);
							}
							else {
								lib.config.connect_characters.remove(name);
							}
							game.saveConfig('connect_characters', lib.config.connect_characters);
						}
						else {
							if (bool) {
								lib.config.characters.add(name);
							}
							else {
								lib.config.characters.remove(name);
							}
							game.saveConfig('characters', lib.config.characters);
						}
						updateNodes();
					};

					var createModeConfig = function (mode, position, position2) {
						var info = lib.characterPack[mode];
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', lib.translate[mode + '_character_config'], position, clickMode);
						if (node.innerHTML.length >= 5) {
							node.classList.add('smallfont');
						}
						if (position2) {
							position.insertBefore(node, position2);
						}
						node.link = page;
						node.mode = mode;
						page.node = node;
						var list = [];
						var boolAI = true;
						var alterableSkills = [];
						var alterableCharacters = [];
						var charactersToAlter = [];
						for (var i in info) {
							if (info[i][4] && info[i][4].contains('unseen')) continue;
							if (connectMenu && lib.connectBanned.contains(i)) continue;
							list.push(i);
							if (boolAI && !lib.config.forbidai_user.contains(i)) boolAI = false;
							for (var j = 0; j < info[i][3].length; j++) {
								if (!lib.skill[info[i][3][j]]) {
									continue;
								}
								if (lib.skill[info[i][3][j]].alter) {
									alterableSkills.add(info[i][3][j]);
									alterableCharacters.add(i);
									if (lib.config.vintageSkills.contains(info[i][3][j])) {
										charactersToAlter.add(i);
									}
								}
							}
						}
						alterableCharacters.sort();
						var groupSort = function (name) {
							if (info[name][1] == 'shen') return -1;
							if (info[name][1] == 'wei') return 0;
							if (info[name][1] == 'shu') return 1;
							if (info[name][1] == 'wu') return 2;
							if (info[name][1] == 'qun') return 3;
							if (info[name][1] == 'western') return 4;
							if (info[name][1] == 'key') return 5;
							return 6;
						}
						list.sort(function (a, b) {
							var del = groupSort(a) - groupSort(b);
							if (del != 0) return del;
							var aa = a, bb = b;
							if (a.indexOf('_') != -1) {
								a = a.slice(a.lastIndexOf('_') + 1);
							}
							if (b.indexOf('_') != -1) {
								b = b.slice(b.lastIndexOf('_') + 1);
							}
							if (a != b) {
								return a > b ? 1 : -1;
							}
							return aa > bb ? 1 : -1;
						});
						var list2 = list.slice(0);
						var cfgnode = createConfig({
							name: '开启',
							_name: mode,
							init: lib.config.characters.contains(mode),
							onclick: togglePack
						});
						var cfgnodeAI = createConfig({
							name: 'AI禁选',
							_name: mode,
							init: boolAI,
							intro: '将该武将包内的武将全部设置为AI禁选',
							onclick: function (bool) {
								if (bool) {
									for (var i = 0; i < list.length; i++) {
										lib.config.forbidai_user.add(list[i]);
									}
								}
								else {
									for (var i = 0; i < list.length; i++) {
										lib.config.forbidai_user.remove(list[i]);
									}
								}
								game.saveConfig('forbidai_user', lib.config.forbidai_user);
							},
						});
						if (mode.indexOf('mode_') != 0) {
							cfgnodeAI.style.marginTop = '0px';
							page.appendChild(cfgnode);
							page.appendChild(cfgnodeAI);
							if (alterableCharacters.length) {
								var cfgnode2 = createConfig({
									name: '新版替换',
									_name: mode,
									init: charactersToAlter.length == 0,
									intro: '以下武将将被修改：' + get.translation(alterableCharacters),
									onclick: function (bool) {
										if (bool) {
											for (var i = 0; i < alterableSkills.length; i++) {
												lib.config.vintageSkills.remove(alterableSkills[i]);
												lib.translate[alterableSkills[i] + '_info'] = lib.translate[alterableSkills[i] + '_info_alter'];
											}
										}
										else {
											for (var i = 0; i < alterableSkills.length; i++) {
												lib.config.vintageSkills.add(alterableSkills[i]);
												lib.translate[alterableSkills[i] + '_info'] = lib.translate[alterableSkills[i] + '_info_origin'];
											}
										}
										game.saveConfig('vintageSkills', lib.config.vintageSkills);
									}
								});
								cfgnode2.style.marginTop = '0px';
								page.appendChild(cfgnode2);
							}
						}
						else if (mode.indexOf('mode_extension') == 0) {
							page.appendChild(cfgnodeAI);
						}
						else {
							page.style.paddingTop = '8px';
						}
						var banCharacter = function (e) {
							if (_status.clicked) {
								_status.clicked = false;
								return;
							}
							if (mode.indexOf('mode_') == 0 && mode.indexOf('mode_extension_') != 0 &&
								mode != 'mode_favourite' && mode != 'mode_banned') {
								if (!connectMenu && lib.config.show_charactercard) {
									ui.click.charactercard(this.link, this, mode == 'mode_guozhan' ? 'guozhan' : true);
								}
								return;
							}
							ui.click.touchpop();
							this._banning = connectMenu ? 'online' : 'offline';
							if (!connectMenu && lib.config.show_charactercard) {
								ui.click.charactercard(this.link, this);
							}
							else {
								ui.click.intro.call(this, e);
							}
							_status.clicked = false;
							delete this._banning;
						};
						var updateBanned = function () {
							var list;
							if (connectMenu) {
								var mode = menux.pages[0].firstChild.querySelector('.active');
								if (mode && mode.mode) {
									list = lib.config['connect_' + mode.mode + '_banned'];
								}
							}
							else {
								list = lib.config[get.mode() + '_banned'];
							}
							if (list && list.contains(this.link)) {
								this.classList.add('banned');
							}
							else {
								this.classList.remove('banned');
							}
						};
						if (lib.characterSort[mode]) {
							var listb = [];
							if (!connectMenu) {
								listb = lib.config[get.mode() + '_banned'] || [];
							}
							else {
								var modex = menux.pages[0].firstChild.querySelector('.active');
								if (modex && modex.mode) {
									listb = lib.config['connect_' + modex.mode + '_banned'];
								}
							}
							for (var pak in lib.characterSort[mode]) {
								var info = lib.characterSort[mode][pak];
								var listx = [];
								var boolx = false;
								for (var ii = 0; ii < list2.length; ii++) {
									if (info.contains(list2[ii])) {
										listx.add(list2[ii]);
										if (!listb.contains(list2[ii])) boolx = true;
										list2.splice(ii--, 1);
									}
								}
								if (listx.length) {
									var cfgnodeX = createConfig({
										name: lib.translate[pak],
										_name: pak,
										init: boolx,
										onclick: function (bool) {
											var banned = [];
											if (connectMenu) {
												var modex = menux.pages[0].firstChild.querySelector('.active');
												if (modex && modex.mode) {
													banned = lib.config['connect_' + modex.mode + '_banned'];
												}
											}
											else if (_status.connectMode) return;
											else banned = lib.config[get.mode() + '_banned'] || [];
											var listx = lib.characterSort[mode][this._link.config._name];
											if (bool) {
												for (var i = 0; i < listx.length; i++) {
													banned.remove(listx[i]);
												}
											}
											else {
												for (var i = 0; i < listx.length; i++) {
													banned.add(listx[i]);
												}
											}
											game.saveConfig(connectMenu ? ('connect_' + modex.mode + '_banned') : (get.mode() + '_banned'), banned);
											updateActive();
										},
									});
									page.appendChild(cfgnodeX);
									var buttons = ui.create.buttons(listx, 'character', page);
									for (var i = 0; i < buttons.length; i++) {
										buttons[i].classList.add('noclick');
										buttons[i].listen(banCharacter);
										buttons[i].node.hp.style.transition = 'all 0s';
										buttons[i].node.hp._innerHTML = buttons[i].node.hp.innerHTML;
										if (mode != 'mode_banned') {
											buttons[i].updateBanned = updateBanned;
										}
									}
								}
							}
							if (list2.length) {
								var cfgnodeX = createConfig({
									name: '其他',
									_name: 'others',
									clear: true,
								});
								page.appendChild(cfgnodeX);
								var buttons = ui.create.buttons(list2, 'character', page);
								for (var i = 0; i < buttons.length; i++) {
									buttons[i].classList.add('noclick');
									buttons[i].listen(banCharacter);
									buttons[i].node.hp.style.transition = 'all 0s';
									buttons[i].node.hp._innerHTML = buttons[i].node.hp.innerHTML;
									if (mode != 'mode_banned') {
										buttons[i].updateBanned = updateBanned;
									}
								}
							}
						}
						else {
							var buttons = ui.create.buttons(list, 'character', page);
							for (var i = 0; i < buttons.length; i++) {
								buttons[i].classList.add('noclick');
								buttons[i].listen(banCharacter);
								buttons[i].node.hp.style.transition = 'all 0s';
								buttons[i].node.hp._innerHTML = buttons[i].node.hp.innerHTML;
								if (mode != 'mode_banned') {
									buttons[i].updateBanned = updateBanned;
								}
							}
						}
						page.classList.add('menu-buttons');
						page.classList.add('leftbutton');
						if (!connectMenu) {
							if (mode.indexOf('mode_') != 0) {
								ui.create.div('.config.pointerspan', '<span>隐藏武将包</span>', page, function () {
									if (this.firstChild.innerHTML == '隐藏武将包') {
										this.firstChild.innerHTML = '武将包将在重启后隐藏';
										lib.config.hiddenCharacterPack.add(mode);
										if (!lib.config.prompt_hidepack) {
											alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
											game.saveConfig('prompt_hidepack', true);
										}
									}
									else {
										this.firstChild.innerHTML = '隐藏武将包';
										lib.config.hiddenCharacterPack.remove(mode);
									}
									game.saveConfig('hiddenCharacterPack', lib.config.hiddenCharacterPack);
								});
							}
						}
						return node;
					};
					if (lib.config.show_favourite_menu && !connectMenu && Array.isArray(lib.config.favouriteCharacter)) {
						lib.characterPack.mode_favourite = {};
						for (var i = 0; i < lib.config.favouriteCharacter.length; i++) {
							var favname = lib.config.favouriteCharacter[i];
							if (lib.character[favname]) {
								lib.characterPack.mode_favourite[favname] = lib.character[favname];
							}
						}
						ui.favouriteCharacter = createModeConfig('mode_favourite', start.firstChild).link;
						if (get.is.empty(lib.characterPack.mode_favourite)) {
							ui.favouriteCharacter.node.style.display = 'none';
						}
						delete lib.characterPack.mode_favourite;
					}
					if (!connectMenu && lib.config.show_ban_menu) {
						lib.characterPack.mode_banned = {};
						for (var i = 0; i < lib.config.all.mode.length; i++) {
							var banned = lib.config[lib.config.all.mode[i] + '_banned'];
							if (banned) {
								for (var j = 0; j < banned.length; j++) {
									if (lib.character[banned[j]]) {
										lib.characterPack.mode_banned[banned[j]] = lib.character[banned[j]];
									}
								}
							}
						}
						var bannednode = createModeConfig('mode_banned', start.firstChild);
						if (get.is.empty(lib.characterPack.mode_banned)) {
							bannednode.style.display = 'none';
						}
						delete lib.characterPack.mode_banned;
					}
					var characterlist = connectMenu ? lib.connectCharacterPack : lib.config.all.characters;
					for (var i = 0; i < characterlist.length; i++) {
						createModeConfig(characterlist[i], start.firstChild);
					}
					if (!connectMenu) {
						for (var i in lib.characterPack) {
							if (i.indexOf('mode_') == 0) {
								createModeConfig(i, start.firstChild);
							}
						}
					}
					var active = start.firstChild.querySelector('.active');
					if (!active) {
						active = start.firstChild.firstChild;
						if (active.style.display == 'none') {
							active = active.nextSibling;
							if (active.style.display == 'none') {
								active = active.nextSibling;
							}
						}
						active.classList.add('active');
						updateActive(active);
					}
					rightPane.appendChild(active.link);

					if (!connectMenu) {
						var node1 = ui.create.div('.lefttext', '全部开启', start.firstChild, function () {
							game.saveConfig('characters', lib.config.all.characters);
							updateNodes();
						});
						var node2 = ui.create.div('.lefttext', '恢复默认', start.firstChild, function () {
							game.saveConfig('characters', lib.config.defaultcharacters);
							updateNodes();
						});
						node1.style.marginTop = '12px';
						node2.style.marginTop = '7px';
					}

					updateNodes();
				}());

				(function () {
					var start = menuxpages.shift();
					var rightPane = start.lastChild;
					var pileCreated = false;
					var recreatePile = function () {
						lib.config.customcardpile['当前牌堆'] = [lib.config.bannedpile, lib.config.addedpile];
						game.saveConfig('customcardpile', lib.config.customcardpile);
						game.saveConfig('cardpilename', '当前牌堆', true);
						pileCreated = false;
					};

					var clickMode = function () {
						var active = this.parentNode.querySelector('.active');
						if (active === this) {
							return;
						}
						active.classList.remove('active');
						active.link.remove();
						active = this;
						this.classList.add('active');
						updateActiveCard(this);
						if (this.mode == 'cardpile') {
							this.create();
						}
						rightPane.appendChild(this.link);
					};
					updateActiveCard = function (node) {
						if (!node) {
							node = start.firstChild.querySelector('.active');
							if (!node) {
								return;
							}
						}
						for (var i = 0; i < node.link.childElementCount; i++) {
							if (node.link.childNodes[i].updateBanned) {
								node.link.childNodes[i].updateBanned();
							}
						}
					};
					var updateNodes = function () {
						for (var i = 0; i < start.firstChild.childNodes.length; i++) {
							var node = start.firstChild.childNodes[i];
							if (node.link) {
								if (node.mode.indexOf('mode_') == 0) continue;
								if (node.mode == 'custom') continue;
								if (node.mode == 'cardpile') continue;
								if (connectMenu) {
									if (!lib.config.connect_cards.contains(node.mode)) {
										node.classList.remove('off');
										node.link.firstChild.classList.add('on');
									}
									else {
										node.classList.add('off');
										node.link.firstChild.classList.remove('on');
									}
								}
								else {
									if (lib.config.cards.contains(node.mode)) {
										node.classList.remove('off');
										node.link.firstChild.classList.add('on');
									}
									else {
										node.classList.add('off');
										node.link.firstChild.classList.remove('on');
									}
								}
							}
						}
					}
					var togglePack = function (bool) {
						var name = this._link.config._name;
						if (connectMenu) {
							if (!bool) {
								lib.config.connect_cards.add(name);
							}
							else {
								lib.config.connect_cards.remove(name);
							}
							game.saveConfig('connect_cards', lib.config.connect_cards);
						}
						else {
							if (bool) {
								lib.config.cards.add(name);
							}
							else {
								lib.config.cards.remove(name);
							}
							game.saveConfig('cards', lib.config.cards);
						}
						updateNodes();
					};
					var toggleCardPile = function (bool) {
						var name = this._link.config._name;
						var number = this._link.config._number;
						if (!lib.config.bannedpile[name]) {
							lib.config.bannedpile[name] = [];
						}
						if (bool) {
							lib.config.bannedpile[name].remove(number);
						}
						else {
							lib.config.bannedpile[name].add(number);
						}
						recreatePile();
					}

					var createModeConfig = function (mode, position) {
						var info = lib.cardPack[mode];
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', lib.translate[mode + '_card_config'], position, clickMode);
						if (node.innerHTML.length >= 5) {
							node.classList.add('smallfont');
						}
						node.link = page;
						node.mode = mode;
						var list = [];
						for (var i = 0; i < info.length; i++) {
							if (!lib.card[info[i]] || (lib.card[info[i]].derivation && mode != 'mode_derivation')) continue;
							list.push(['', get.translation(get.type(info[i], 'trick')), info[i]]);
						}
						var sortCard = function (card) {
							var type = lib.card[card[2]].type;
							var subtype = lib.card[card[2]].subtype;
							if (lib.cardType[subtype]) {
								return lib.cardType[subtype];
							}
							if (lib.cardType[type]) {
								return lib.cardType[type];
							}
							switch (type) {
								case 'basic': return 0;
								case 'chess': return 1.5;
								case 'trick': return 2;
								case 'delay': return 3;
								case 'equip': {
									switch (lib.card[card[2]].subtype) {
										case 'equip1': return 4.1;
										case 'equip2': return 4.2;
										case 'equip3': return 4.3;
										case 'equip4': return 4.4;
										case 'equip5': return 4.5;
										default: return 4;
									}
								}
								case 'zhenfa': return 5;
								default: return 6;
							}
						}
						list.sort(function (a, b) {
							var sort1 = sortCard(a);
							var sort2 = sortCard(b);
							if (sort1 == sort2) {
								return (b[2] < a[2]) ? 1 : -1;
							}
							else if (sort1 > sort2) {
								return 1;
							}
							else {
								return -1;
							}
						});
						var cfgnode = createConfig({
							name: '开启',
							_name: mode,
							init: lib.config.cards.contains(mode),
							onclick: togglePack
						});
						if (mode.indexOf('mode_') != 0) {
							page.appendChild(cfgnode);
						}
						else {
							page.style.paddingTop = '8px';
						}
						var banCard = function (e) {
							if (_status.clicked) {
								_status.clicked = false;
								return;
							}
							if (mode.indexOf('mode_') == 0 && mode.indexOf('mode_extension_') != 0 && mode != 'mode_banned') {
								return;
							}
							ui.click.touchpop();
							this._banning = connectMenu ? 'online' : 'offline';
							ui.click.intro.call(this, e);
							_status.clicked = false;
							delete this._banning;
						};
						var updateBanned = function () {
							var list;
							if (connectMenu) {
								var mode = menux.pages[0].firstChild.querySelector('.active');
								if (mode && mode.mode) {
									list = lib.config['connect_' + mode.mode + '_bannedcards'];
								}
							}
							else {
								list = lib.config[get.mode() + '_bannedcards'];
							}
							if (list && list.contains(this.link[2])) {
								this.classList.add('banned');
							}
							else {
								this.classList.remove('banned');
							}
						};
						var buttons = ui.create.buttons(list, 'vcard', page);
						for (var i = 0; i < buttons.length; i++) {
							buttons[i].classList.add('noclick');
							buttons[i].listen(banCard);
							if (mode != 'mode_banned') {
								buttons[i].updateBanned = updateBanned;
							}
						}
						page.classList.add('menu-buttons');
						page.classList.add('leftbutton');
						if (!connectMenu && mode.indexOf('mode_') != 0) {
							ui.create.div('.config.pointerspan', '<span>隐藏卡牌包</span>', page, function () {
								if (this.firstChild.innerHTML == '隐藏卡牌包') {
									this.firstChild.innerHTML = '卡牌包将在重启后隐藏';
									lib.config.hiddenCardPack.add(mode);
									if (!lib.config.prompt_hidepack) {
										alert('隐藏的扩展包可通过选项-其它-重置隐藏内容恢复');
										game.saveConfig('prompt_hidepack', true);
									}
								}
								else {
									this.firstChild.innerHTML = '隐藏卡牌包';
									lib.config.hiddenCardPack.remove(mode);
								}
								game.saveConfig('hiddenCardPack', lib.config.hiddenCardPack);
							});
						}
						if (mode.indexOf('mode_') != 0 && lib.cardPile[mode]) {
							var cardpileNodes = [];
							var cardpileexpanded = false;
							if (!lib.config.bannedpile[mode]) {
								lib.config.bannedpile[mode] = [];
							}
							if (!lib.config.addedpile[mode]) {
								lib.config.addedpile[mode] = [];
							}
							ui.create.div('.config.more.pile', '编辑牌堆 <div>&gt;</div>', page, function () {
								if (cardpileexpanded) {
									this.classList.remove('on');
									for (var k = 0; k < cardpileNodes.length; k++) {
										cardpileNodes[k].style.display = 'none';
									}
								}
								else {
									this.classList.add('on');
									for (var k = 0; k < cardpileNodes.length; k++) {
										cardpileNodes[k].style.display = '';
									}
								}
								cardpileexpanded = !cardpileexpanded;
							});
							var cfgnode = ui.create.div(page, '.config.pointerspan.cardpilecfg.toggle');
							var cfgaddcard = ui.create.node('button', '', '添加卡牌', cfgnode, function () {
								this.parentNode.nextSibling.classList.toggle('hidden');
							});
							var cfgbancard = ui.create.node('button', '', '全部关闭', cfgnode, function () {
								for (var i = 0; i < cardpileNodes.length; i++) {
									if (cardpileNodes[i].type == 'defaultcards' && cardpileNodes[i].classList.contains('on')) {
										clickToggle.call(cardpileNodes[i]);
									}
								}
							});
							var cfgenablecard = ui.create.node('button', '', '全部开启', cfgnode, function () {
								for (var i = 0; i < cardpileNodes.length; i++) {
									if (cardpileNodes[i].type == 'defaultcards' && !cardpileNodes[i].classList.contains('on')) {
										clickToggle.call(cardpileNodes[i]);
									}
								}
							});
							cfgbancard.style.marginLeft = '5px';
							cfgenablecard.style.marginLeft = '5px';
							cardpileNodes.push(cfgnode);
							cfgnode.style.display = 'none';
							cfgnode.classList.add('cardpilecfg');
							cfgnode.classList.add('toggle');
							cfgnode.style.marginTop = '5px';
							page.appendChild(cfgnode);

							var cardpileadd = ui.create.div('.config.toggle.hidden.cardpilecfg.cardpilecfgadd', page);
							var pileaddlist = [];
							for (var i = 0; i < lib.config.cards.length; i++) {
								if (!lib.cardPack[lib.config.cards[i]]) continue;
								for (var j = 0; j < lib.cardPack[lib.config.cards[i]].length; j++) {
									var cname = lib.cardPack[lib.config.cards[i]][j];
									pileaddlist.push([cname, get.translation(cname)]);
									if (cname == 'sha') {
										pileaddlist.push(['huosha', '火杀']);
										pileaddlist.push(['leisha', '雷杀']);
									}
								}
							}
							var cardpileaddname = ui.create.selectlist(pileaddlist, null, cardpileadd);
							cardpileaddname.style.width = '75px';
							cardpileaddname.style.marginRight = '2px';
							cardpileaddname.style.marginLeft = '-1px';
							var cardpileaddsuit = ui.create.selectlist([
								['heart', '红桃'],
								['diamond', '方片'],
								['club', '梅花'],
								['spade', '黑桃'],
							], null, cardpileadd);
							cardpileaddsuit.style.width = '53px';
							cardpileaddsuit.style.marginRight = '2px';
							var cardpileaddnumber = ui.create.selectlist([
								1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
							], null, cardpileadd);
							cardpileaddnumber.style.width = '43px';
							cardpileaddnumber.style.marginRight = '2px';
							var button = document.createElement('button');
							button.innerHTML = '确定';
							button.style.width = '40px';
							var deletecard = function () {
								this.parentNode.remove();
								var info = this.parentNode._info;
								var list = lib.config.addedpile[mode];
								for (var i = 0; i < list.length; i++) {
									if (list[i][0] == info[0] && list[i][1] == info[1] && list[i][2] == info[2]) {
										list.splice(i, 1); break;
									}
								}
								recreatePile();
							};
							button.onclick = function () {
								var card = [
									cardpileaddsuit.value,
									cardpileaddnumber.value,
									cardpileaddname.value,
								];
								lib.config.addedpile[mode].push(card);
								recreatePile();
								var cfgnode = ui.create.div('.config.toggle.cardpilecfg');
								cfgnode._info = card;
								cfgnode.innerHTML = get.translation(card[2]) + ' ' + get.translation(card[0]) + card[1];
								var cfgnodedelete = document.createElement('span');
								cfgnodedelete.classList.add('cardpiledelete');
								cfgnodedelete.innerHTML = '删除';
								cfgnodedelete.onclick = deletecard;
								cfgnode.appendChild(cfgnodedelete);
								page.insertBefore(cfgnode, cardpileadd.nextSibling);
							};
							cardpileadd.appendChild(button);
							cardpileadd.style.whiteSpace = 'nowrap';
							cardpileNodes.push(cardpileadd);

							for (var i = 0; i < lib.config.addedpile[mode].length; i++) {
								var card = lib.config.addedpile[mode][i];
								var cfgnode = ui.create.div('.config.toggle.cardpilecfg');
								cfgnode._info = card;
								cfgnode.innerHTML = get.translation(card[2]) + ' ' + get.translation(card[0]) + card[1];
								var cfgnodedelete = document.createElement('span');
								cfgnodedelete.classList.add('cardpiledelete');
								cfgnodedelete.innerHTML = '删除';
								cfgnodedelete.onclick = deletecard;
								cfgnode.appendChild(cfgnodedelete);
								cfgnode.style.display = 'none';
								cardpileNodes.push(cfgnode);
								page.appendChild(cfgnode);
							}

							for (var i = 0; i < lib.cardPile[mode].length; i++) {
								var card = lib.cardPile[mode][i];
								var cfgnode = createConfig({
									name: get.translation(card[2]) + ' ' + get.translation(card[0]) + card[1],
									_number: i,
									_name: mode,
									init: !lib.config.bannedpile[mode].contains(i),
									onclick: toggleCardPile
								});
								cfgnode.type = 'defaultcards';
								cardpileNodes.push(cfgnode);
								cfgnode.style.display = 'none';
								cfgnode.classList.add('cardpilecfg');
								page.appendChild(cfgnode);
							}
							ui.create.div('.menuplaceholder', page);
						}
						return node;
					};
					if (!connectMenu && lib.config.show_ban_menu) {
						lib.cardPack.mode_banned = [];
						for (var i = 0; i < lib.config.all.mode.length; i++) {
							var banned = lib.config[lib.config.all.mode[i] + '_bannedcards'];
							if (banned) {
								for (var j = 0; j < banned.length; j++) {
									lib.cardPack.mode_banned.add(banned[j]);
								}
							}
						}
						var bannednode = createModeConfig('mode_banned', start.firstChild);
						if (lib.cardPack.mode_banned.length == 0) {
							bannednode.style.display = 'none';
						}
						delete lib.cardPack.mode_banned;
					}
					for (var i = 0; i < lib.config.all.cards.length; i++) {
						if (connectMenu && !lib.connectCardPack.contains(lib.config.all.cards[i])) continue;
						createModeConfig(lib.config.all.cards[i], start.firstChild);
					}
					if (!connectMenu) {
						for (var i in lib.cardPack) {
							if (i.indexOf('mode_') == 0) {
								createModeConfig(i, start.firstChild);
							}
						}
					}
					var active = start.firstChild.querySelector('.active');
					if (!active) {
						active = start.firstChild.firstChild;
						if (active.style.display == 'none') {
							active = active.nextSibling;
						}
						active.classList.add('active');
						updateActiveCard(active);
					}
					rightPane.appendChild(active.link);

					(function () {
						if (connectMenu) return;
						var page = ui.create.div('.menu-buttons');
						var node = ui.create.div('.menubutton.large', '牌堆', clickMode);
						start.firstChild.insertBefore(node, start.firstChild.querySelector('.lefttext'));
						node.link = page;
						node.mode = 'cardpile';
						node.create = function () {
							if (pileCreated) return;
							pileCreated = true;
							page.innerHTML = '';

							var pileList = null;
							var createList = function () {
								if (pileList) {
									pileList.remove();
								}
								var list = ['默认牌堆'];
								if (lib.config.customcardpile['当前牌堆']) {
									list.push('当前牌堆');
								}
								for (var i in lib.config.customcardpile) {
									list.add(i);
								}
								var currentpile = get.config('cardpilename');
								if (!currentpile) {
									if (list.contains('当前牌堆')) {
										currentpile = '当前牌堆';
									}
									else {
										currentpile = '默认牌堆';
									}
								}
								pileList = ui.create.selectlist(list, currentpile, pileChoose, function (e) {
									game.saveConfig('cardpilename', this.value, true);
									restart.style.display = '';
								});
								pileList.style.float = 'right';
							}
							var pileChoose = ui.create.div('.config.toggle.cardpilecfg.nomarginleft', '选择牌堆', page);
							createList();

							var pileDel = function () {
								delete lib.config.customcardpile[this.parentNode.link];
								this.parentNode.remove();
								game.saveConfig('customcardpile', lib.config.customcardpile);
								for (var i in lib.config.mode_config) {
									if (i == 'global') continue;
									if (lib.config.mode_config[i].cardpilename == this.parentNode.link) {
										game.saveConfig('cardpilename', null, i);
									}
								}
								createList();
							};

							var restart = ui.create.div('.config.more', '重新启动', game.reload, page);
							restart.style.display = 'none';
							var createPileNode = function (name) {
								var node = ui.create.div('.config.toggle.cardpilecfg.nomarginleft', name);
								node.link = name;
								var del = document.createElement('span');
								del.innerHTML = '删除';
								del.classList.add('cardpiledelete');
								del.onclick = pileDel;
								node.appendChild(del);
								if (name == '当前牌堆') {
									page.insertBefore(node, pileChoose.nextSibling);
								}
								else {
									page.insertBefore(node, restart);
								}
							};
							for (var i in lib.config.customcardpile) {
								createPileNode(i);
							}
							var exportCardPile;
							ui.create.div('.config.more', '保存当前牌堆 <div>&gt;</div>', page, function () {
								this.classList.toggle('on');
								if (this.classList.contains('on')) {
									exportCardPile.classList.remove('hidden');
								}
								else {
									exportCardPile.classList.add('hidden');
								}
							});
							exportCardPile = ui.create.div('.config.cardpileadd.indent', page);
							exportCardPile.classList.add('hidden');
							ui.create.div('', '名称：<input type="text"><button>确定</button>', exportCardPile);
							var input = exportCardPile.firstChild.lastChild.previousSibling;
							input.value = '自定义牌堆';
							input.style.marginRight = '3px';
							input.style.width = '120px';
							exportCardPile.firstChild.lastChild.onclick = function () {
								var name = input.value;
								var ok = true;
								if (lib.config.customcardpile[name] || name == '默认牌堆' || name == '当前牌堆') {
									for (var i = 1; i <= 1000; i++) {
										if (!lib.config.customcardpile[name + '(' + i + ')']) {
											name = name + '(' + i + ')';
											break;
										}
									}
								}
								lib.config.customcardpile[name] = [lib.config.bannedpile, lib.config.addedpile];
								delete lib.config.customcardpile['当前牌堆'];
								for (var i in lib.mode) {
									if (lib.config.mode_config[i] &&
										(lib.config.mode_config[i].cardpilename == '当前牌堆' || !lib.config.mode_config[i].cardpilename)) {
										game.saveConfig('cardpilename', name, i);
									}
								}
								for (var i = 0; i < page.childElementCount; i++) {
									if (page.childNodes[i].link == '当前牌堆') {
										page.childNodes[i].remove();
										break;
									}
								}
								game.saveConfig('customcardpile', lib.config.customcardpile);
								createPileNode(name);
								createList();
							};
						}
					}());

					if (!connectMenu) {
						var node1 = ui.create.div('.lefttext', '全部开启', start.firstChild, function () {
							game.saveConfig('cards', lib.config.all.cards);
							updateNodes();
						});
						var node2 = ui.create.div('.lefttext', '恢复默认', start.firstChild, function () {
							game.saveConfig('cards', lib.config.defaultcards);
							updateNodes();
						});
						node1.style.marginTop = '12px';
						node2.style.marginTop = '7px';
					}

					updateNodes();
				}());

				(function () {
					if (connectMenu) return;
					var start = menuxpages.shift();
					var rightPane = start.lastChild;

					var clickMode = function () {
						if (this.mode == 'get') {
							this.update();
						}
						var active = this.parentNode.querySelector('.active');
						if (active === this) {
							return;
						}
						active.classList.remove('active');
						active.link.remove();
						active = this;
						this.classList.add('active');
						rightPane.appendChild(this.link);
					};
					ui.click.extensionTab = function (name) {
						ui.click.menuTab('扩展');
						for (var i = 0; i < start.firstChild.childElementCount; i++) {
							if (start.firstChild.childNodes[i].innerHTML == name) {
								clickMode.call(start.firstChild.childNodes[i]);
								break;
							}
						}
					}
					var updateNodes = function () {
						for (var i = 0; i < start.firstChild.childNodes.length; i++) {
							var node = start.firstChild.childNodes[i];
							if (node.link) {
								if (node.mode == 'get') continue;
								if (node.mode == 'create') continue;
								if (node.mode.indexOf('extension_') == 0) {
									if (lib.config[node.mode + '_enable']) {
										node.classList.remove('off');
										node.link.firstChild.classList.add('on');
									}
									else {
										node.classList.add('off');
										node.link.firstChild.classList.remove('on');
									}
								}
								else {
									if (lib.config.plays.contains(node.mode)) {
										node.classList.remove('off');
										node.link.firstChild.classList.add('on');
									}
									else {
										node.classList.add('off');
										node.link.firstChild.classList.remove('on');
									}
								}
							}
						}
					}
					var togglePack = function (bool) {
						var name = this._link.config._name;
						if (name.indexOf('extension_') == 0) {
							if (bool) {
								game.saveConfig(name, true);
							}
							else {
								game.saveConfig(name, false);
							}
						}
						else {
							name = name.slice(0, name.indexOf('_enable_playpackconfig'));
							if (bool) {
								lib.config.plays.add(name);
							}
							else {
								lib.config.plays.remove(name);
							}
							game.saveConfig('plays', lib.config.plays);
						}
						if (this.onswitch) {
							this.onswitch(bool);
						}
						updateNodes();
					};

					var createModeConfig = function (mode, position) {
						var page = ui.create.div('');
						page.style.paddingBottom = '10px';
						var node;
						if (mode.indexOf('extension_') == 0) {
							node = ui.create.div('.menubutton.large', mode.slice(10), position, clickMode);
						}
						else {
							node = ui.create.div('.menubutton.large', lib.translate[mode + '_play_config'], position, clickMode);
						}
						if (node.innerHTML.length >= 5) {
							node.classList.add('smallfont');
						}
						node.link = page;
						node.mode = mode;
						for (var i in lib.extensionMenu[mode]) {
							if (i == 'game') continue;
							var cfg = copyObj(lib.extensionMenu[mode][i]);
							var j;
							if (mode.indexOf('extension_') == 0) {
								j = mode + '_' + i;
							}
							else {
								j = mode + '_' + i + '_playpackconfig';
							}
							cfg._name = j;
							if (!lib.config.hasOwnProperty(j)) {
								game.saveConfig(j, cfg.init);
							}
							else {
								cfg.init = lib.config[j];
							}

							if (i == 'enable') {
								cfg.onclick = togglePack;
							}
							else if (!lib.extensionMenu[mode][i].onclick) {
								cfg.onclick = function (result) {
									var cfg = this._link.config;
									game.saveConfig(cfg._name, result);
								};
							}
							var cfgnode = createConfig(cfg);
							if (cfg.onswitch) {
								cfgnode.onswitch = cfg.onswitch;
							}
							page.appendChild(cfgnode);
						}
						return node;
					};
					for (var i in lib.extensionMenu) {
						if (lib.config.all.stockextension.contains(i) && !lib.config.all.plays.contains(i)) continue;
						if (lib.config.hiddenPlayPack.contains(i)) continue;
						createModeConfig(i, start.firstChild);
					}
					(function () {
						if (!lib.device && !lib.db) return;
						if (lib.config.show_extensionmaker == false) return;
						var page = ui.create.div('#create-extension');
						var node = ui.create.div('.menubutton.large', '制作扩展', start.firstChild, clickMode);
						node.link = page;
						node.mode = 'create';
						var pageboard = ui.create.div(page);
						var inputExtLine = ui.create.div(pageboard);
						inputExtLine.style.transition = 'all 0s';
						inputExtLine.style.padding = '10px';
						inputExtLine.style.height = '22px';
						inputExtLine.style.lineHeight = '22px';
						inputExtLine.style.whiteSpace = 'nowrap';
						inputExtLine.style.overflow = 'visible';
						var inputExtSpan = document.createElement('span');
						inputExtSpan.innerHTML = '扩展名：';
						inputExtLine.appendChild(inputExtSpan);
						var inputExtName = document.createElement('input');
						inputExtName.type = 'text';
						inputExtName.value = '无名扩展';
						inputExtName.style.width = '80px';
						inputExtName.style.textAlign = 'center';
						inputExtLine.appendChild(inputExtName);

						var buttonConfirmOnclick = function () {
							buttonConfirm.style.display = 'none';
							inputExtSpan.style.display = 'none';
							inputExtName.style.display = 'none';
							authorExtLine.style.display = 'none';
							introExtLine.style.display = 'none';
							forumExtLine.style.display = 'none';
							diskExtLine.style.display = 'none';
							versionExtLine.style.display = 'none';
							okExtLine.style.display = 'none';
							inputExtLine.style.padding = '10px';
							buttonRename.style.display = '';
							buttonSave.style.display = '';
							buttonReset.style.display = '';
							buttonExport.style.display = '';
							inputExtSpan.innerHTML = '扩展名称：';
							inputExtName.style.width = '100px';
							inputExtName.style.textAlign = '';

							dashboard.style.display = '';
						};
						var createExtLine = function (str, str2) {
							var infoExtLine = ui.create.div(pageboard);
							infoExtLine.style.display = 'none';
							infoExtLine.style.padding = '0 10px 10px 10px';
							infoExtLine.style.height = '22px';
							infoExtLine.style.lineHeight = '22px';
							infoExtLine.style.whiteSpace = 'nowrap';
							infoExtLine.style.overflow = 'visible';
							if (typeof str == 'boolean') {
								var inputConfirm = document.createElement('button');
								inputConfirm.innerHTML = '确定';
								inputConfirm.onclick = buttonConfirmOnclick;
								infoExtLine.appendChild(inputConfirm);
								return infoExtLine;
							}
							var infoExtSpan = document.createElement('span');
							infoExtSpan.innerHTML = str + '：';
							infoExtLine.appendChild(infoExtSpan);
							var infoExtName = document.createElement('input');
							infoExtName.type = 'text';
							infoExtName.style.width = '100px';
							infoExtName.value = str2 || '';
							infoExtLine.appendChild(infoExtName);
							return infoExtLine;
						};
						var authorExtLine = createExtLine('扩展作者', lib.config.connect_nickname);
						var introExtLine = createExtLine('扩展描述');
						var versionExtLine = createExtLine('扩展版本', '1.0');
						var diskExtLine = createExtLine('网盘地址');
						var forumExtLine = createExtLine('讨论地址');
						var okExtLine = createExtLine(true);

						game.editExtension = function (name) {
							page.currentExtension = name || '无名扩展';
							inputExtName.value = page.currentExtension;
							if (name && lib.extensionPack[name]) {
								authorExtLine.querySelector('input').value = lib.extensionPack[name].author || '';
								introExtLine.querySelector('input').value = lib.extensionPack[name].intro || '';
								diskExtLine.querySelector('input').value = lib.extensionPack[name].diskURL || '';
								forumExtLine.querySelector('input').value = lib.extensionPack[name].forumURL || '';
								versionExtLine.querySelector('input').value = lib.extensionPack[name].version || '';
							}
							else {
								authorExtLine.querySelector('input').value = lib.config.connect_nickname || '';
								introExtLine.querySelector('input').value = '';
								diskExtLine.querySelector('input').value = '';
								forumExtLine.querySelector('input').value = '';
								versionExtLine.querySelector('input').value = '1.0';
							}
							if (name) {
								inputExtName.disabled = true;
								buttonConfirm.style.display = 'none';
								inputExtSpan.style.display = 'none';
								inputExtName.style.display = 'none';
								buttonRename.style.display = '';
								buttonSave.style.display = '';
								buttonReset.style.display = '';
								buttonExport.style.display = '';
							}
							else {
								inputExtName.disabled = false;
								buttonConfirm.style.display = '';
								inputExtSpan.innerHTML = '扩展名：';
								inputExtName.style.width = '80px';
								inputExtName.style.textAlign = 'center';
								inputExtSpan.style.display = '';
								inputExtName.style.display = '';
								buttonRename.style.display = 'none';
								buttonSave.style.display = 'none';
								buttonReset.style.display = 'none';
								buttonExport.style.display = 'none';
							}

							dashboard.style.display = '';

							exportExtLine.style.display = 'none';
							shareExtLine.style.display = 'none';
							authorExtLine.style.display = 'none';
							introExtLine.style.display = 'none';
							forumExtLine.style.display = 'none';
							diskExtLine.style.display = 'none';
							versionExtLine.style.display = 'none';
							okExtLine.style.display = 'none';
							inputExtLine.style.padding = '10px';
							dash1.reset(name);
							dash2.reset(name);
							dash3.reset(name);
							dash4.reset(name);
							dash1.link.classList.remove('active');
							dash2.link.classList.remove('active');
							dash3.link.classList.remove('active');
							dash4.link.classList.remove('active');
							var active = node.parentNode.querySelector('.active');
							if (active === node) {
								return;
							}
							active.classList.remove('active');
							active.link.remove();
							node.classList.add('active');
							rightPane.appendChild(node.link);
						}
						var processExtension = function (exportext) {
							if (page.currentExtension) {
								if (page.currentExtension != inputExtName.value && !exportext) {
									game.removeExtension(page.currentExtension);
								}
							}
							inputExtName.disabled = true;
							setTimeout(function () {
								var ext = {};
								var config = null, help = null;
								for (var i in dash4.content) {
									try {
										if (i == 'content' || i == 'precontent') {
											eval('ext[i]=' + dash4.content[i]);
											if (typeof ext[i] != 'function') {
												throw ('err');
											}
											else {
												ext[i] = ext[i].toString();
											}
										}
										else {
											eval(dash4.content[i]);
											eval('ext[i]=' + i);
											if (ext[i] == null || typeof ext[i] != 'object') {
												throw ('err');
											}
											else {
												ext[i] = JSON.stringify(ext[i]);
											}
										}
									}
									catch (e) {
										console.log(e);
										delete ext[i];
									}
								}
								page.currentExtension = inputExtName.value || '无名扩展';
								var str = '{name:"' + page.currentExtension + '"';
								for (var i in ext) {
									str += ',' + i + ':' + ext[i];
								}
								dash2.content.pack.list = [];
								for (var i = 0; i < dash2.pile.childNodes.length; i++) {
									dash2.content.pack.list.push(dash2.pile.childNodes[i].link);
								}
								str += ',package:' + get.stringify({
									character: dash1.content.pack,
									card: dash2.content.pack,
									skill: dash3.content.pack,
									intro: introExtLine.querySelector('input').value || '',
									author: authorExtLine.querySelector('input').value || '',
									diskURL: diskExtLine.querySelector('input').value || '',
									forumURL: forumExtLine.querySelector('input').value || '',
									version: versionExtLine.querySelector('input').value || '',
								});
								var files = { character: [], card: [], skill: [] };
								for (var i in dash1.content.image) {
									files.character.push(i);
								}
								for (var i in dash2.content.image) {
									files.card.push(i);
								}
								for (var i in dash3.content.audio) {
									files.skill.push(i);
								}
								str += ',files:' + JSON.stringify(files);
								str += '}';
								var extension = { 'extension.js': 'game.import("extension",function(lib,game,ui,get,ai,_status){return ' + str + '})' };
								for (var i in dash1.content.image) {
									extension[i] = dash1.content.image[i];
								}
								for (var i in dash2.content.image) {
									extension[i] = dash2.content.image[i];
								}
								if (exportext) {
									var proexport = function () {
										game.importExtension(extension, null, page.currentExtension, {
											intro: introExtLine.querySelector('input').value || '',
											author: authorExtLine.querySelector('input').value || '',
											netdisk: diskExtLine.querySelector('input').value || '',
											forum: forumExtLine.querySelector('input').value || '',
											version: versionExtLine.querySelector('input').value || '',
										});
									};
									if (game.getFileList) {
										game.getFileList('extension/' + page.currentExtension, function (folders, files) {
											extension._filelist = files;
											proexport();
										});
									}
									else {
										proexport();
									}
								}
								else {
									game.importExtension(extension, function () {
										exportExtLine.style.display = '';
									});
								}
							}, 500);
						};
						var buttonConfirm = document.createElement('button');
						buttonConfirm.innerHTML = '确定';
						buttonConfirm.style.marginLeft = '5px';
						buttonConfirm.onclick = buttonConfirmOnclick;
						inputExtLine.appendChild(buttonConfirm);
						var buttonRename = document.createElement('button');
						buttonRename.innerHTML = '选项';
						buttonRename.style.marginLeft = '2px';
						buttonRename.style.marginRight = '2px';
						buttonRename.style.display = 'none';
						buttonRename.onclick = function () {
							inputExtSpan.style.display = '';
							inputExtName.style.display = '';
							authorExtLine.style.display = '';
							introExtLine.style.display = '';
							forumExtLine.style.display = '';
							diskExtLine.style.display = '';
							versionExtLine.style.display = '';
							okExtLine.style.display = 'block';
							inputExtLine.style.padding = '20px 10px 10px 10px';
							inputExtName.disabled = false;
							buttonRename.style.display = 'none';
							buttonSave.style.display = 'none';
							buttonReset.style.display = 'none';
							buttonExport.style.display = 'none';
							inputExtSpan.innerHTML = '扩展名称：';
							inputExtName.style.width = '100px';
							inputExtName.style.textAlign = '';

							dashboard.style.display = 'none';
						};
						inputExtLine.appendChild(buttonRename);
						var buttonReset = document.createElement('button');
						buttonReset.innerHTML = '重置';
						buttonReset.style.marginLeft = '2px';
						buttonReset.style.marginRight = '2px';
						buttonReset.style.display = 'none';
						buttonReset.onclick = function () {
							if (confirm('当前扩展将被清除，是否确定？')) {
								game.editExtension();
							}
						};
						inputExtLine.appendChild(buttonReset);
						var buttonSave = document.createElement('button');
						buttonSave.innerHTML = '保存';
						buttonSave.style.marginLeft = '2px';
						buttonSave.style.marginRight = '2px';
						buttonSave.style.display = 'none';
						buttonSave.onclick = function () {
							dash1.link.classList.remove('active');
							dash2.link.classList.remove('active');
							dash3.link.classList.remove('active');
							dash4.link.classList.remove('active');
							processExtension();
						};
						inputExtLine.appendChild(buttonSave);
						var buttonExport = document.createElement('button');
						buttonExport.innerHTML = '导出';
						buttonExport.style.marginLeft = '2px';
						buttonExport.style.marginRight = '2px';
						buttonExport.style.display = 'none';
						buttonExport.onclick = function () {
							processExtension(true);
							if (lib.config.show_extensionshare) {
								shareExtLine.style.display = '';
							}
						};
						inputExtLine.appendChild(buttonExport);
						var exportExtLine = ui.create.div(pageboard);
						exportExtLine.style.display = 'none';
						exportExtLine.style.width = 'calc(100% - 40px)';
						exportExtLine.style.textAlign = 'left';
						exportExtLine.style.marginBottom = '5px';
						if (lib.device == 'ios') {
							exportExtLine.innerHTML = '已保存。退出游戏并重新打开后生效<span class="closenode">×</span>';
							exportExtLine.querySelectorAll('span')[0].onclick = function () {
								exportExtLine.style.display = 'none';
							};
						}
						else {
							exportExtLine.innerHTML = '重启后生效。<span class="hrefnode">立即重启</span><span class="closenode">×</span>';
							exportExtLine.querySelectorAll('span')[0].onclick = game.reload;
							exportExtLine.querySelectorAll('span')[1].onclick = function () {
								exportExtLine.style.display = 'none';
							};
						}


						var shareExtLine = ui.create.div(pageboard);
						shareExtLine.style.display = 'none';
						shareExtLine.style.width = 'calc(100% - 40px)';
						shareExtLine.style.textAlign = 'left';
						shareExtLine.style.marginBottom = '5px';
						shareExtLine.innerHTML = '已导出扩展。<span class="hrefnode">分享扩展</span><span class="closenode">×</span>';
						shareExtLine.querySelectorAll('span')[0].onclick = function () {
							game.open('https://tieba.baidu.com/p/5439380222');
						};
						shareExtLine.querySelectorAll('span')[1].onclick = function () {
							shareExtLine.style.display = 'none';
						};

						var dashboard = ui.create.div(pageboard);
						var clickDash = function () {
							ui.create.templayer();
							pageboard.hide();
							this.link.show();
							if (this.link.init) {
								this.link.init();
							}
						};
						var createDash = function (str1, str2, node) {
							var dash = ui.create.div('.menubutton.large.dashboard');
							dashboard.appendChild(dash);
							page.appendChild(node);
							dash.link = node;
							node.link = dash;
							dash.listen(clickDash);
							lib.setScroll(node);
							ui.create.div('', str1, dash);
							ui.create.div('', str2, dash);
						};
						var dash1 = (function () {
							var page = ui.create.div('.hidden.menu-buttons');
							var currentButton = null;
							page.init = function () {
								if (!page.querySelector('.button.character')) {
									toggle.classList.add('on');
									newCharacter.style.display = '';
								}
							};
							var updateButton = function () {
								var name = page.querySelector('input.new_name').value;
								if (!name) {
									editnode.classList.add('disabled');
									return;
								}
								name = name.split('|');
								name = name[0];
								if (currentButton) {
									if (currentButton.link != name) {
										if (lib.character[name] || page.content.pack.character[name]) {
											editnode.classList.add('disabled');
											return;
										}
									}
								}
								else {
									if (lib.character[name] || page.content.pack.character[name]) {
										editnode.classList.add('disabled');
										return;
									}
								}
								if (!fakeme.image) {
									if (!page.content.image[name + '.jpg']) {
										editnode.classList.add('disabled');
										return;
									}
								}
								editnode.classList.remove('disabled');
							};
							var clickButton = function () {
								if (currentButton == this) {
									resetEditor();
									return;
								}
								resetEditor();
								currentButton = this;
								toggle.classList.add('on');
								newCharacter.style.display = '';
								fakeme.classList.add('inited');
								fakeme.style.backgroundImage = this.style.backgroundImage;
								if (page.content.pack.translate[this.link] != this.link) {
									newCharacter.querySelector('.new_name').value = this.link + '|' + page.content.pack.translate[this.link];
								}
								else {
									newCharacter.querySelector('.new_name').value = this.link;
								}
								var info = page.content.pack.character[this.link];
								newCharacter.querySelector('.new_hp').value = info[2];
								sexes.value = info[0];
								groups.value = info[1];
								if (info[4]) {
									for (var i = 0; i < options.childNodes.length - 1; i++) {
										if (info[4].contains(options.childNodes[i].lastChild.name)) {
											options.childNodes[i].lastChild.checked = true;
										}
										else {
											options.childNodes[i].lastChild.checked = false;
										}
									}
									for (var i = 0; i < info[4].length; i++) {
										if (info[4][i].indexOf('des:') == 0) {
											newCharacter.querySelector('.new_des').value = info[4][i].slice(4);
										}
									}
								}

								var skills = info[3];
								for (var i = 0; i < skills.length; i++) {
									var node = document.createElement('button');
									node.skill = skills[i];
									node.onclick = deletenode;
									node.innerHTML = lib.translate[skills[i]];
									skillList.firstChild.appendChild(node);
								}

								toggle.innerHTML = '编辑武将 <div>&gt;</div>';
								editnode.innerHTML = '编辑武将';
								editnode.classList.remove('disabled');
								delnode.innerHTML = '删除';
								delnode.button = this;
							}
							var createButton = function (name, image) {
								var button = ui.create.div('.button.character');
								button.link = name;
								button.image = image;
								button.style.backgroundImage = 'url(' + image + ')';
								button.style.backgroundSize = 'cover';
								button.listen(clickButton);
								button.classList.add('noclick');
								button.nodename = ui.create.div(button, '.name', get.verticalStr(page.content.pack.translate[name]));
								button.nodename.style.top = '8px';
								page.insertBefore(button, page.childNodes[1]);
							}
							page.reset = function (name) {
								resetEditor();
								var buttons = page.querySelectorAll('.button.character');
								var list = [];
								for (var i = 0; i < buttons.length; i++) {
									list.push(buttons[i]);
								}
								for (var i = 0; i < list.length; i++) {
									list[i].remove();
								}
								if (lib.extensionPack[name]) {
									page.content.pack = lib.extensionPack[name].character || {
										character: {},
										translate: {}
									};
									page.content.image = {};
									for (var i in page.content.pack.character) {
										var file = i + '.jpg';
										var loadImage = function (file, data) {
											var img = new Image();
											img.crossOrigin = 'Anonymous';
											img.onload = function () {
												var canvas = document.createElement('CANVAS');
												var ctx = canvas.getContext('2d');
												var dataURL;
												canvas.height = this.height;
												canvas.width = this.width;
												ctx.drawImage(this, 0, 0);
												canvas.toBlob(function (blob) {
													var fileReader = new FileReader();
													fileReader.onload = function (e) {
														page.content.image[file] = e.target.result;
													};
													fileReader.readAsArrayBuffer(blob, "UTF-8");
												});
											};
											img.src = data;
										}
										if (game.download) {
											var url = lib.assetURL + 'extension/' + name + '/' + file;
											createButton(i, url);
											if (lib.device == 'ios' || lib.device == 'android') {
												window.resolveLocalFileSystemURL(lib.assetURL + 'extension/' + name, function (entry) {
													entry.getFile(file, {}, function (fileEntry) {
														fileEntry.file(function (fileToLoad) {
															var fileReader = new FileReader();
															fileReader.onload = function (e) {
																page.content.image[file] = e.target.result;
															};
															fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
														});
													});
												});
											}
											else {
												loadImage(file, url);
											}
										}
										else {
											game.getDB('image', 'extension-' + name + ':' + file, (function (file, name) {
												return function (data) {
													createButton(name, data);
													loadImage(file, data);
												};
											}(file, i)))
										}
									}
								}
								else {
									page.content = {
										pack: {
											character: {},
											translate: {}
										},
										image: {}
									};
									toggle.classList.add('on');
									newCharacter.style.display = '';
								}
							};
							ui.create.div('.config.more', '<div style="transform:none;margin-right:3px">←</div>返回', page, function () {
								ui.create.templayer();
								page.hide();
								pageboard.show();
							});
							page.content = {
								pack: {
									character: {},
									translate: {}
								},
								image: {}
							};
							var newCharacter;
							var toggle = ui.create.div('.config.more.on', '创建武将 <div>&gt;</div>', page, function () {
								this.classList.toggle('on');
								if (this.classList.contains('on')) {
									newCharacter.style.display = '';
								}
								else {
									newCharacter.style.display = 'none';
								}
							});
							var resetEditor = function () {
								currentButton = null;
								toggle.classList.remove('on');
								newCharacter.style.display = 'none';
								fakeme.classList.remove('inited');
								delete fakeme.image;
								delete fakeme.image64;
								fakeme.style.backgroundImage = '';
								var inputs = newCharacter.querySelectorAll('input');
								for (var i = 0; i < inputs.length; i++) {
									inputs[i].value = '';
								}
								inputs = newCharacter.querySelectorAll('textarea');
								for (var i = 0; i < inputs.length; i++) {
									inputs[i].value = '';
								}
								skillList.firstChild.innerHTML = '';
								toggle.innerHTML = '创建武将 <div>&gt;</div>';
								editnode.innerHTML = '创建武将';
								editnode.classList.add('disabled');
								delnode.innerHTML = '取消';
								delete delnode.button;
							}

							newCharacter = ui.create.div('.new_character', page);
							var fakeme = ui.create.div('.avatar', newCharacter);

							var input = document.createElement('input');
							input.type = 'file';
							input.accept = 'image/*';
							input.className = 'fileinput';
							input.onchange = function () {
								var fileToLoad = input.files[0];
								if (fileToLoad) {
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										fakeme.style.backgroundImage = 'url(' + data + ')';
										fakeme.image64 = data;
										fakeme.classList.add('inited');
										var fileReader = new FileReader();
										fileReader.onload = function (fileLoadedEvent) {
											fakeme.image = fileLoadedEvent.target.result;
											updateButton();
										};
										fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								}
							}
							fakeme.appendChild(input);

							ui.create.div('.select_avatar', '选择头像', fakeme);

							ui.create.div('.indent', '姓名：<input class="new_name" type="text">', newCharacter).style.paddingTop = '8px';
							ui.create.div('.indent', '介绍：<input class="new_des" type="text">', newCharacter).style.paddingTop = '8px';
							ui.create.div('.indent', '体力：<input class="new_hp" type="text">', newCharacter).style.paddingTop = '8px';
							newCharacter.querySelector('input.new_name').onblur = updateButton;
							var sexes = ui.create.selectlist([
								['male', '男'],
								['female', '女'],
								['none', '无'],
							], null, ui.create.div('.indent', '性别：', newCharacter));
							var grouplist = [];
							for (var i = 0; i < lib.group.length; i++) {
								grouplist.push([lib.group[i], get.translation(lib.group[i])]);
							};
							var groups = ui.create.selectlist(grouplist, null, ui.create.div('.indent', '势力：', newCharacter));
							var options = ui.create.div('.add_skill.options', '<span>主公<input type="checkbox" name="zhu"></span><span>BOSS<input type="checkbox" name="boss"></span><span>AI禁选<input type="checkbox" name="forbidai"></span><br>', newCharacter);
							var addSkill = ui.create.div('.add_skill', '添加技能<br>', newCharacter);
							var list = [];
							for (var i in lib.character) {
								if (lib.character[i][3].length) {
									list.push([i, lib.translate[i]]);
								}
							}
							list.sort(function (a, b) {
								a = a[0]; b = b[0];
								var aa = a, bb = b;
								if (aa.indexOf('_') != -1) {
									aa = aa.slice(aa.indexOf('_') + 1);
								}
								if (bb.indexOf('_') != -1) {
									bb = bb.slice(bb.indexOf('_') + 1);
								}
								if (aa != bb) {
									return aa > bb ? 1 : -1;
								}
								return a > b ? 1 : -1;
							});
							var list2 = [];
							var skills = lib.character[list[0][0]][3];
							for (var i = 0; i < skills.length; i++) {
								list2.push([skills[i], lib.translate[skills[i]]]);
							}
							list.unshift(['current_extension', '此扩展']);

							var selectname = ui.create.selectlist(list, list[1], addSkill);
							page.selectname = selectname;
							selectname.onchange = function () {
								skillopt.innerHTML = '';
								if (this.value == 'current_extension') {
									for (var i in dash3.content.pack.skill) {
										var option = document.createElement('option');
										option.value = i;
										option.innerHTML = dash3.content.pack.translate[i];
										skillopt.appendChild(option);
									}
								}
								else {
									var skills = lib.character[this.value][3];
									for (var i = 0; i < skills.length; i++) {
										var option = document.createElement('option');
										option.value = skills[i];
										option.innerHTML = lib.translate[skills[i]];
										skillopt.appendChild(option);
									}
								}
							};
							selectname.style.maxWidth = '85px';
							var skillopt = ui.create.selectlist(list2, list2[0], addSkill);
							skillopt.style.maxWidth = '60px';
							page.skillopt = skillopt;
							var addSkillButton = document.createElement('button');
							addSkillButton.innerHTML = '添加';
							addSkill.appendChild(addSkillButton);
							page.addSkillButton = addSkillButton;
							var deletenode = function () {
								this.remove();
							}
							addSkillButton.onclick = function () {
								for (var i = 0; i < skillList.firstChild.childNodes.length; i++) {
									if (skillList.firstChild.childNodes[i].skill == skillopt.value) return;
								}
								var node = document.createElement('button');
								node.skill = skillopt.value;
								node.onclick = deletenode;
								for (var i = 0; i < skillopt.childElementCount; i++) {
									if (skillopt.childNodes[i].value == skillopt.value) {
										node.innerHTML = skillopt.childNodes[i].innerHTML; break;
									}
								}
								skillList.firstChild.appendChild(node);
							};
							var createSkillButton = document.createElement('button');
							createSkillButton.innerHTML = '创建';
							createSkillButton.style.marginLeft = '3px';
							addSkill.appendChild(createSkillButton);
							createSkillButton.onclick = function () {
								ui.create.templayer();
								page.hide();
								dash3.show();
								dash3.fromchar = 'add';
								dash3.toggle.classList.add('on');
								dash3.newSkill.style.display = '';
							};
							page.updateSkill = function () {
								for (var i = 0; i < skillList.firstChild.childNodes.length; i++) {
									var node = skillList.firstChild.childNodes[i];
									var skill = skillList.firstChild.childNodes[i].skill;
									if (dash3.content.pack.skill[skill]) {
										node.innerHTML = dash3.content.pack.translate[skill];
									}
									else if (lib.skill[skill]) {
										node.innerHTML = lib.translate[skill];
									}
									else {
										node.remove(); i--;
									}
								}
							};
							var skillList = ui.create.div('.skill_list', newCharacter);
							ui.create.div(skillList);
							var editnode = ui.create.div('.menubutton.large.disabled', '创建武将', ui.create.div(skillList), function () {
								var name = page.querySelector('input.new_name').value;
								if (!name) {
									alert('请填写武将名\n提示：武将名格式为id+|+中文名，其中id必须惟一');
									return;
								}
								name = name.split('|');
								var translate = name[1] || name[0];
								name = name[0];
								if (currentButton) {
									if (currentButton.link != name) {
										if (lib.character[name] || page.content.pack.character[name]) {
											alert('武将名与现有武将重复，请更改\n提示：武将名格式为id+|+中文名，其中id必须惟一');
											return;
										}
										page.content.image[name + '.jpg'] = page.content.image[currentButton.link + '.jpg'];
										delete page.content.image[currentButton.link + '.jpg'];
										delete page.content.pack.character[currentButton.link];
										delete page.content.pack.translate[currentButton.link];
										currentButton.link = name;
									}
								}
								else {
									if (lib.character[name] || page.content.pack.character[name]) {
										alert('武将名与现有武将重复，请更改\n提示：武将名格式为id+|+中文名，其中id必须惟一');
										return;
									}
								}
								if (fakeme.image) {
									page.content.image[name + '.jpg'] = fakeme.image;
								}
								else {
									if (!page.content.image[name + '.jpg']) {
										alert('请选择武将头像');
										return;
									}
								}
								var hp = page.querySelector('input.new_hp').value;
								if (hp == 'Infinity') hp = Infinity;
								else if (hp.indexOf('/') == -1) hp = parseInt(hp) || 1;
								var skills = [];
								for (var i = 0; i < skillList.firstChild.childNodes.length; i++) {
									skills.add(skillList.firstChild.childNodes[i].skill);
								}
								var tags = [];
								for (var i = 0; i < options.childNodes.length - 1; i++) {
									if (options.childNodes[i].lastChild.checked) {
										tags.push(options.childNodes[i].lastChild.name);
									}
								}
								if (tags.contains('boss')) {
									tags.add('bossallowed');
								}
								var des = page.querySelector('input.new_des').value;
								if (des) {
									tags.add('des:' + des);
								}

								page.content.pack.translate[name] = translate;
								page.content.pack.character[name] = [sexes.value, groups.value, hp, skills, tags];
								if (this.innerHTML == '创建武将') {
									createButton(name, fakeme.image64);
								}
								else if (currentButton) {
									if (fakeme.image64) {
										currentButton.image = fakeme.image64;
										currentButton.style.backgroundImage = 'url(' + fakeme.image64 + ')';
									}
									currentButton.nodename.innerHTML = get.verticalStr(translate);
								}
								resetEditor();
								dash1.link.classList.add('active');
							});
							var delnode = ui.create.div('.menubutton.large', '取消', editnode.parentNode, function () {
								if (this.innerHTML == '删除') {
									this.button.remove();
									var name = this.button.link;
									delete dash1.content.pack.character[name];
									delete dash1.content.pack.translate[name];
									delete dash1.content.image[name];
									dash1.link.classList.add('active');
								}
								resetEditor();
							});
							delnode.style.marginLeft = '13px';

							return page;
						}());
						var dash2 = (function () {
							var page = ui.create.div('.hidden.menu-buttons');
							var currentButton = null;
							page.init = function () {
								if (!page.querySelector('.button.card')) {
									toggle.classList.add('on');
									newCard.style.display = '';
								}
							};
							var updateButton = function () {
								var name = page.querySelector('input.new_name').value;
								if (!name) {
									editnode.classList.add('disabled');
									return;
								}
								name = name.split('|');
								name = name[0];
								if (currentButton) {
									if (currentButton.link != name) {
										if (lib.card[name] || page.content.pack.card[name]) {
											editnode.classList.add('disabled');
											return;
										}
									}
								}
								else {
									if (lib.card[name] || page.content.pack.card[name]) {
										editnode.classList.add('disabled');
										return;
									}
								}
								if (!fakeme.image && !fakeme.classList.contains('inited')) {
									editnode.classList.add('disabled');
									return;
								}
								editnode.classList.remove('disabled');
							};
							var clickButton = function () {
								if (currentButton == this) {
									resetEditor();
									return;
								}
								resetEditor();
								currentButton = this;
								toggle.classList.add('on');
								newCard.style.display = '';
								fakeme.classList.add('inited');
								delete fakeme.image;
								delete fakeme.image64;
								if (this.classList.contains('fullskin')) {
									fakeme.imagenode.style.backgroundImage = this.imagenode.style.backgroundImage;
									fakeme.classList.add('fullskin');
								}
								else {
									fakeme.style.backgroundImage = this.style.backgroundImage;
									fakeme.classList.remove('fullskin');
								}
								if (page.content.pack.translate[this.link] != this.link) {
									newCard.querySelector('.new_name').value = this.link + '|' + page.content.pack.translate[this.link];
								}
								else {
									newCard.querySelector('.new_name').value = this.link;
								}
								newCard.querySelector('.new_description').value = page.content.pack.translate[this.link + '_info'];
								var info = page.content.pack.card[this.link];
								container.code = 'card=' + get.stringify(info);

								toggle.innerHTML = '编辑卡牌 <div>&gt;</div>';
								editnode.innerHTML = '编辑卡牌';
								editnode.classList.remove('disabled');
								delnode.innerHTML = '删除';
								delnode.button = this;
							}
							var createButton = function (name, image, fullskin) {
								var button = ui.create.div('.button.card');
								button.link = name;
								button.image = image;
								button.imagenode = ui.create.div('.image', button);
								if (image) {
									if (fullskin) {
										button.imagenode.style.backgroundImage = 'url(' + image + ')';
										button.style.backgroundImage = '';
										button.style.backgroundSize = '';
										button.classList.add('fullskin');
									}
									else {
										button.style.color = 'white';
										button.style.textShadow = 'black 0 0 2px';
										button.imagenode.style.backgroundImage = '';
										button.style.backgroundImage = 'url(' + image + ')';
										button.style.backgroundSize = 'cover';
									}
								}
								button.listen(clickButton);
								button.classList.add('noclick');
								button.nodename = ui.create.div(button, '.name', get.verticalStr(page.content.pack.translate[name]));
								page.insertBefore(button, page.childNodes[1]);
							}
							page.reset = function (name) {
								resetEditor();
								var buttons = page.querySelectorAll('.button.card');
								var list = [];
								for (var i = 0; i < buttons.length; i++) {
									list.push(buttons[i]);
								}
								for (var i = 0; i < list.length; i++) {
									list[i].remove();
								}
								if (lib.extensionPack[name]) {
									page.content.pack = lib.extensionPack[name].card || {
										card: {},
										translate: {}
									};
									page.content.image = {};
									if (Array.isArray(page.content.pack.list)) {
										for (var i = 0; i < page.content.pack.list.length; i++) {
											var card = page.content.pack.list[i];
											var node = document.createElement('button');
											node.innerHTML = page.content.pack.translate[card[2]] + ' ' + lib.translate[card[0]] + card[1];
											node.name = card[2];
											node.link = card;
											pile.appendChild(node);
											node.onclick = function () {
												this.remove();
											}
										}
									}
									for (var i in page.content.pack.card) {
										var file;
										var fullskin = page.content.pack.card[i].fullskin ? true : false;
										if (fullskin) {
											file = i + '.png';
										}
										else {
											file = i + '.jpg';
										}
										var loadImage = function (file, data) {
											var img = new Image();
											img.crossOrigin = 'Anonymous';
											img.onload = function () {
												var canvas = document.createElement('CANVAS');
												var ctx = canvas.getContext('2d');
												var dataURL;
												canvas.height = this.height;
												canvas.width = this.width;
												ctx.drawImage(this, 0, 0);
												canvas.toBlob(function (blob) {
													var fileReader = new FileReader();
													fileReader.onload = function (e) {
														page.content.image[file] = e.target.result;
													};
													fileReader.readAsArrayBuffer(blob, "UTF-8");
												});
											};
											img.src = data;
										}
										if (game.download) {
											var url = lib.assetURL + 'extension/' + name + '/' + file;
											createButton(i, url, fullskin);
											if (lib.device == 'ios' || lib.device == 'android') {
												window.resolveLocalFileSystemURL(lib.assetURL + 'extension/' + name, function (entry) {
													entry.getFile(file, {}, function (fileEntry) {
														fileEntry.file(function (fileToLoad) {
															var fileReader = new FileReader();
															fileReader.onload = function (e) {
																page.content.image[file] = e.target.result;
															};
															fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
														});
													});
												});
											}
											else {
												loadImage(file, url);
											}
										}
										else {
											game.getDB('image', 'extension-' + name + ':' + file, (function (file, name, fullskin) {
												return function (data) {
													createButton(name, data, fullskin);
													loadImage(file, data);
												};
											}(file, i, fullskin)))
										}
									}
								}
								else {
									page.content = {
										pack: {
											card: {},
											translate: {}
										},
										image: {}
									};
									toggle.classList.add('on');
									newCard.style.display = '';
								}
								updatePile();
							};
							ui.create.div('.config.more.margin-bottom', '<div style="transform:none;margin-right:3px">←</div>返回', page, function () {
								ui.create.templayer();
								page.hide();
								pageboard.show();
							});
							page.content = {
								pack: {
									card: {},
									translate: {},
									list: []
								},
								image: {}
							};
							var newCard;
							var toggle = ui.create.div('.config.more.on', '创建卡牌 <div>&gt;</div>', page, function () {
								this.classList.toggle('on');
								if (this.classList.contains('on')) {
									newCard.style.display = '';
								}
								else {
									newCard.style.display = 'none';
								}
							});
							var resetEditor = function () {
								currentButton = null;
								toggle.classList.remove('on');
								newCard.style.display = 'none';
								fakeme.classList.remove('inited');
								fakeme.classList.add('fullskin');
								delete fakeme.image;
								delete fakeme.image64;
								fakeme.style.backgroundImage = '';
								fakeme.imagenode.style.backgroundImage = '';
								var inputs = newCard.querySelectorAll('input');
								for (var i = 0; i < inputs.length; i++) {
									inputs[i].value = '';
								}
								toggle.innerHTML = '创建卡牌 <div>&gt;</div>';
								editnode.innerHTML = '创建卡牌';
								editnode.classList.add('disabled');
								delnode.innerHTML = '取消';
								delete delnode.button;
								container.code = 'card={\n			 \n}\n\n\/*\n示例：\ncard={\n			 type:"basic",\n    enable:true,\n			 filterTarget:true,\n    content:function(){\n        target.draw()\n    },\n    ai:{\n        order:1,\n        result:{\n            target:1\n        }\n    }\n}\n此例的效果为目标摸一张牌\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';
							}

							newCard = ui.create.div('.new_character', page);
							newCard.style.height = '173px';
							var fakeme = ui.create.div('.card.fullskin', newCard);

							var input = document.createElement('input');
							input.type = 'file';
							input.accept = 'image/*';
							input.className = 'fileinput';
							input.onchange = function () {
								var fileToLoad = input.files[0];
								if (fileToLoad) {
									var fileReader = new FileReader();
									var fullimage = (fileToLoad.name.indexOf('.jpg') != -1);
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										if (fullimage) {
											fakeme.imagenode.style.backgroundImage = '';
											fakeme.style.backgroundImage = 'url(' + data + ')';
											fakeme.classList.remove('fullskin');
										}
										else {
											fakeme.style.backgroundImage = '';
											fakeme.imagenode.style.backgroundImage = 'url(' + data + ')';
											fakeme.classList.add('fullskin');
										}
										fakeme.image64 = data;
										fakeme.classList.add('inited');
										var fileReader = new FileReader();
										fileReader.onload = function (fileLoadedEvent) {
											fakeme.image = fileLoadedEvent.target.result;
											updateButton();
										};
										fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
									};
									fileReader.readAsDataURL(fileToLoad, "UTF-8");
								}
							}
							fakeme.appendChild(input);

							fakeme.imagenode = ui.create.div('.image', fakeme);
							ui.create.div('.name', '选<br>择<br>背<br>景', fakeme);

							ui.create.div('.indent', '名称：<input class="new_name" type="text">', newCard).style.paddingTop = '8px';
							ui.create.div('.indent', '描述：<input class="new_description" type="text">', newCard).style.paddingTop = '6px';
							newCard.querySelector('input.new_name').onblur = updateButton;
							var codeButton = document.createElement('button');
							newCard.appendChild(codeButton);
							codeButton.innerHTML = '编辑代码';
							codeButton.style.left = '123px';
							codeButton.style.top = '66px';
							codeButton.style.position = 'absolute';

							var citeButton = document.createElement('button');
							newCard.appendChild(citeButton);
							citeButton.innerHTML = '引用代码';
							citeButton.style.left = '123px';
							citeButton.style.top = '90px';
							citeButton.style.position = 'absolute';
							citeButton.onclick = function () {
								codeButton.style.display = 'none';
								citeButton.style.display = 'none';
								selectname.style.display = '';
								confirmcontainer.style.display = '';
							}

							var list = [];
							for (var i in lib.card) {
								if (lib.translate[i]) {
									list.push([i, lib.translate[i]]);
								}
							}
							list.sort(function (a, b) {
								a = a[0]; b = b[0];
								var aa = a, bb = b;
								if (aa.indexOf('_') != -1) {
									aa = aa.slice(aa.indexOf('_') + 1);
								}
								if (bb.indexOf('_') != -1) {
									bb = bb.slice(bb.indexOf('_') + 1);
								}
								if (aa != bb) {
									return aa > bb ? 1 : -1;
								}
								return a > b ? 1 : -1;
							});
							var selectname = ui.create.selectlist(list, list[0], newCard);
							selectname.style.left = '123px';
							selectname.style.top = '66px';
							selectname.style.position = 'absolute';
							selectname.style.display = 'none';

							var confirmcontainer = ui.create.div(newCard);
							confirmcontainer.style.left = '123px';
							confirmcontainer.style.top = '90px';
							confirmcontainer.style.position = 'absolute';
							confirmcontainer.style.display = 'none';

							var citeconfirm = document.createElement('button');
							citeconfirm.innerHTML = '引用';
							confirmcontainer.appendChild(citeconfirm);
							citeconfirm.onclick = function () {
								codeButton.style.display = '';
								citeButton.style.display = '';
								selectname.style.display = 'none';
								confirmcontainer.style.display = 'none';
								container.code = 'card=' + get.stringify(lib.card[selectname.value]);
								codeButton.onclick.call(codeButton);
								if (lib.translate[selectname.value + '_info']) {
									newCard.querySelector('input.new_description').value = lib.translate[selectname.value + '_info'];
								}
							}

							var citecancel = document.createElement('button');
							citecancel.innerHTML = '取消';
							citecancel.style.marginLeft = '3px';
							confirmcontainer.appendChild(citecancel);
							citecancel.onclick = function () {
								codeButton.style.display = '';
								citeButton.style.display = '';
								selectname.style.display = 'none';
								confirmcontainer.style.display = 'none';
							}

							codeButton.onclick = function () {
								var node = container;
								ui.window.classList.add('shortcutpaused');
								ui.window.classList.add('systempaused');
								window.saveNonameInput = saveInput;
								if (node.aced) {
									ui.window.appendChild(node);
									node.editor.setValue(node.code, 1);
								}
								else if (lib.device == 'ios') {
									ui.window.appendChild(node);
									if (!node.textarea) {
										var textarea = document.createElement('textarea');
										editor.appendChild(textarea);
										node.textarea = textarea;
										lib.setScroll(textarea);
									}
									node.textarea.value = node.code;
								}
								else {
									var aceReady = function () {
										ui.window.appendChild(node);
										var mirror = window.CodeMirror(editor, {
											value: node.code,
											mode: "javascript",
											lineWrapping: !lib.config.touchscreen && lib.config.mousewheel,
											lineNumbers: true,
											indentUnit: 4,
											autoCloseBrackets: true,
											theme: 'mdn-like'
										});
										lib.setScroll(editor.querySelector('.CodeMirror-scroll'));
										node.aced = true;
										node.editor = mirror;
									}
									if (!window.CodeMirror) {
										lib.init.js(lib.assetURL + 'game', 'codemirror', aceReady);
										lib.init.css(lib.assetURL + 'layout/default', 'codemirror');
									}
									else {
										aceReady();
									}
								}
							}

							var container = ui.create.div('.popup-container.editor');
							var editorpage = ui.create.div(container);
							var discardConfig = ui.create.div('.editbutton', '取消', editorpage, function () {
								ui.window.classList.remove('shortcutpaused');
								ui.window.classList.remove('systempaused');
								container.delete(null);
								delete window.saveNonameInput;
							});
							var saveInput = function () {
								var code;
								if (container.editor) {
									code = container.editor.getValue();
								}
								else if (container.textarea) {
									code = container.textarea.value;
								}
								try {
									var card = null;
									eval(code);
									if (card == null || typeof card != 'object') {
										throw ('err');
									}
								}
								catch (e) {
									if (e == 'err') {
										alert('代码格式有错误，请对比示例代码仔细检查');
									}
									else {
										alert('代码语法有错误，请仔细检查（' + e + '）')
									}
									return;
								}
								dash2.link.classList.add('active');
								ui.window.classList.remove('shortcutpaused');
								ui.window.classList.remove('systempaused');
								container.delete();
								container.code = code;
								delete window.saveNonameInput;
							};
							var saveConfig = ui.create.div('.editbutton', '保存', editorpage, saveInput);
							var editor = ui.create.div(editorpage);
							container.code = 'card={\n			 \n}\n\n\/*\n示例：\ncard={\n			 type:"basic",\n    enable:true,\n			 filterTarget:true,\n    content:function(){\n        target.draw()\n    },\n    ai:{\n        order:1,\n        result:{\n            target:1\n        }\n    }\n}\n此例的效果为目标摸一张牌\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';

							var editnode = ui.create.div('.menubutton.large.new_card.disabled', '创建卡牌', newCard, function () {
								var name = page.querySelector('input.new_name').value;
								if (!name) {
									alert('请填写卡牌名\n提示：卡牌名格式为id+|+中文名，其中id必须惟一');
									return;
								}
								name = name.split('|');
								var translate = name[1] || name[0];
								var info = page.querySelector('input.new_description').value;
								name = name[0];
								if (currentButton) {
									if (currentButton.link != name) {
										if (lib.card[name] || page.content.pack.card[name]) {
											alert('卡牌名与现有卡牌重复，请更改\n提示：卡牌名格式为id+|+中文名，其中id必须惟一');
											return;
										}
										var extname;
										if (currentButton.classList.contains('fullskin')) {
											extname = '.png';
										}
										else {
											extname = '.jpg';
										}
										page.content.image[name + extname] = page.content.image[currentButton.link + extname];
										delete page.content.image[currentButton.link + extname];
										delete page.content.pack.card[currentButton.link];
										delete page.content.pack.translate[currentButton.link];
										delete page.content.pack.translate[currentButton.link + '_info'];
										currentButton.link = name;
									}
								}
								else {
									if (lib.card[name] || page.content.pack.card[name]) {
										alert('卡牌名与现有卡牌重复，请更改\n提示：卡牌名格式为id+|+中文名，其中id必须惟一');
										return;
									}
								}
								if (fakeme.image) {
									if (fakeme.classList.contains('fullskin')) {
										page.content.image[name + '.png'] = fakeme.image;
										delete page.content.image[name + '.jpg'];
									}
									else {
										page.content.image[name + '.jpg'] = fakeme.image;
										delete page.content.image[name + '.png'];
									}
								}
								else if (!fakeme.classList.contains('inited')) {
									alert('请选择一个卡牌背景');
									return;
								}
								page.content.pack.translate[name] = translate;
								page.content.pack.translate[name + '_info'] = info;
								try {
									var card = null;
									eval(container.code);
									if (card == null || typeof card != 'object') {
										throw ('err');
									}
									page.content.pack.card[name] = card;
								}
								catch (e) {
									page.content.pack.card[name] = {};
								}
								if (fakeme.classList.contains('inited')) {
									if (fakeme.classList.contains('fullskin')) {
										page.content.pack.card[name].fullskin = true;
										delete page.content.pack.card[name].fullimage;
									}
									else {
										page.content.pack.card[name].fullimage = true;
										delete page.content.pack.card[name].fullskin;
									}
								}
								if (this.innerHTML == '创建卡牌') {
									createButton(name, fakeme.image64, fakeme.classList.contains('fullskin'));
								}
								else if (currentButton) {
									if (fakeme.image64) {
										if (fakeme.classList.contains('fullskin')) {
											currentButton.style.color = '';
											currentButton.style.textShadow = '';
											currentButton.imagenode.style.backgroundImage = 'url(' + fakeme.image64 + ')';
											currentButton.style.backgroundImage = '';
											currentButton.style.backgroundSize = '';
											currentButton.classList.add('fullskin');
										}
										else {
											currentButton.style.color = 'white';
											currentButton.style.textShadow = 'black 0 0 2px';
											currentButton.imagenode.style.backgroundImage = '';
											currentButton.style.backgroundImage = 'url(' + fakeme.image64 + ')';
											currentButton.style.backgroundSize = 'cover';
											currentButton.classList.remove('fullskin');
										}
									}
									currentButton.nodename.innerHTML = get.verticalStr(translate);
								}
								resetEditor();
								updatePile();
								dash2.link.classList.add('active');
							});
							var delnode = ui.create.div('.menubutton.large.new_card_delete', '取消', editnode.parentNode, function () {
								if (this.innerHTML == '删除') {
									this.button.remove();
									var name = this.button.link;
									delete dash2.content.pack.card[name];
									delete dash2.content.pack.translate[name];
									delete dash2.content.pack.translate[name + '_info'];
									delete dash2.content.image[name];
									updatePile();
									dash2.link.classList.add('active');
								}
								resetEditor();
							});

							var editPile;
							var toggle2 = ui.create.div('.config.more', '编辑牌堆 <div>&gt;</div>', page, function () {
								this.classList.toggle('on');
								if (this.classList.contains('on')) {
									editPile.style.display = '';
								}
								else {
									editPile.style.display = 'none';
								}
							});

							editPile = ui.create.div('.edit_pile', page);
							editPile.style.display = 'none';


							var cardpileadd = ui.create.div('.config.toggle.cardpilecfg.cardpilecfgadd', editPile);
							var pile = ui.create.div(editPile);
							page.pile = pile;
							var cardpileaddname = document.createElement('select');
							var updatePile = function () {
								cardpileaddname.innerHTML = '';
								var list = [];
								var list2 = [];
								for (var i in page.content.pack.card) {
									list.push([i, page.content.pack.translate[i]]);
									list2.push(i);
								}
								if (list.length) {
									toggle2.style.display = '';
									if (toggle2.classList.contains('on')) {
										editPile.style.display = '';
									}
									else {
										editPile.style.display = 'none';
									}
									for (var i = 0; i < list.length; i++) {
										var option = document.createElement('option');
										option.value = list[i][0];
										option.innerHTML = list[i][1];
										cardpileaddname.appendChild(option);
									}
									for (var i = 0; i < pile.childNodes.length; i++) {
										if (!list2.contains(pile.childNodes[i].name)) {
											pile.childNodes[i].remove(); i--;
										}
									}
								}
								else {
									toggle2.style.display = 'none';
									editPile.style.display = 'none';
									pile.innerHTML = '';
								}
							};
							updatePile();
							cardpileadd.appendChild(cardpileaddname);
							cardpileaddname.style.width = '75px';
							cardpileaddname.style.marginRight = '2px';
							cardpileaddname.style.marginLeft = '-1px';
							var cardpileaddsuit = ui.create.selectlist([
								['heart', '红桃'],
								['diamond', '方片'],
								['club', '梅花'],
								['spade', '黑桃'],
							], null, cardpileadd);
							cardpileaddsuit.style.width = '53px';
							cardpileaddsuit.style.marginRight = '2px';
							var cardpileaddnumber = ui.create.selectlist([
								1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
							], null, cardpileadd);
							cardpileaddnumber.style.width = '43px';
							cardpileaddnumber.style.marginRight = '2px';
							var button = document.createElement('button');
							button.innerHTML = '确定';
							button.style.width = '40px';
							button.onclick = function () {
								var card = [
									cardpileaddsuit.value,
									cardpileaddnumber.value,
									cardpileaddname.value,
								];
								var node = document.createElement('button');
								node.innerHTML = page.content.pack.translate[card[2]] + ' ' + lib.translate[card[0]] + card[1];
								node.name = card[2];
								node.link = card;
								pile.appendChild(node);
								node.onclick = function () {
									this.remove();
								}
							};
							cardpileadd.appendChild(button);
							cardpileadd.style.whiteSpace = 'nowrap';
							cardpileadd.style.position = 'relative';
							cardpileadd.style.right = '-4px';

							return page;
						}());
						var dash3 = (function () {
							var page = ui.create.div('.hidden.menu-buttons.new_skill');
							var updateButton = function () {
								var name = page.querySelector('input.new_name').value;
								if (!name) {
									editnode.classList.add('disabled');
									return;
								}
								name = name.split('|');
								name = name[0];
								if (currentButton) {
									if (currentButton.link != name) {
										if (lib.skill[name] || page.content.pack.skill[name]) {
											editnode.classList.add('disabled');
											return;
										}
									}
								}
								else {
									if (lib.skill[name] || page.content.pack.skill[name]) {
										editnode.classList.add('disabled');
										return;
									}
								}
								editnode.classList.remove('disabled');
							};
							page.init = function () {
								if (!page.querySelector('.menubutton:not(.large)')) {
									toggle.classList.add('on');
									newSkill.style.display = '';
								}
							};
							page.reset = function (name) {
								resetEditor();
								var buttons = page.querySelectorAll('.menubutton:not(.large)');
								var list = [];
								for (var i = 0; i < buttons.length; i++) {
									list.push(buttons[i]);
								}
								for (var i = 0; i < list.length; i++) {
									list[i].remove();
								}
								if (lib.extensionPack[name]) {
									page.content.pack = lib.extensionPack[name].skill || {
										skill: {},
										translate: {}
									};
									page.content.audio = {};
									for (var i in page.content.pack.skill) {
										createButton(i);
									}
									dash1.updateSkill();
								}
								else {
									page.content = {
										pack: {
											skill: {},
											translate: {}
										},
										audio: {}
									};
									toggle.classList.add('on');
									newSkill.style.display = '';
								}
							};
							ui.create.div('.config.more.margin-bottom', '<div style="transform:none;margin-right:3px">←</div>返回', page, function () {
								ui.create.templayer();
								page.hide();
								if (page.fromchar) {
									dash1.show();
									delete page.fromchar;
								}
								else {
									pageboard.show();
								}
							});
							var currentButton = null;
							var clickButton = function () {
								if (currentButton == this) {
									resetEditor();
									return;
								}
								resetEditor();
								currentButton = this;
								toggle.classList.add('on');
								newSkill.style.display = '';
								if (page.content.pack.translate[this.link] != this.link) {
									newSkill.querySelector('.new_name').value = this.link + '|' + page.content.pack.translate[this.link];
								}
								else {
									newSkill.querySelector('.new_name').value = this.link;
								}
								newSkill.querySelector('.new_description').value = page.content.pack.translate[this.link + '_info'];
								var info = page.content.pack.skill[this.link];
								container.code = 'skill=' + get.stringify(info);

								toggle.innerHTML = '编辑技能 <div>&gt;</div>';
								editnode.innerHTML = '编辑技能';
								editnode.classList.remove('disabled');
								delnode.button = this;
								delnode.innerHTML = '删除';
							}
							var createButton = function (name) {
								var button = ui.create.div('.menubutton');
								button.link = name;
								button.innerHTML = page.content.pack.translate[name];
								button.listen(clickButton);
								page.insertBefore(button, page.childNodes[1]);
							}
							var newSkill;
							var toggle = ui.create.div('.config.more.on', '创建技能 <div>&gt;</div>', page, function () {
								this.classList.toggle('on');
								if (this.classList.contains('on')) {
									newSkill.style.display = '';
								}
								else {
									newSkill.style.display = 'none';
								}
							});
							page.toggle = toggle;
							var resetEditor = function () {
								currentButton = null;
								toggle.classList.remove('on');
								newSkill.style.display = 'none';
								var inputs = newSkill.querySelectorAll('input');
								for (var i = 0; i < inputs.length; i++) {
									inputs[i].value = '';
								}
								var inputs = newSkill.querySelectorAll('textarea');
								for (var i = 0; i < inputs.length; i++) {
									inputs[i].value = '';
								}
								toggle.innerHTML = '创建技能 <div>&gt;</div>';
								editnode.innerHTML = '创建技能';
								editnode.classList.add('disabled');
								delnode.innerHTML = '取消';
								delete delnode.button;
								container.code = 'skill={\n    \n}\n\n\/*\n示例：\nskill={\n    trigger:{player:"phaseJieshuBegin"},\n    frequent:true,\n    content:function(){\n        player.draw()\n    }\n}\n此例为闭月代码\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';
								if (page.fromchar == 'add') {
									page.fromchar = true;
								}
							}

							newSkill = ui.create.div('.new_character.new_skill', page);
							page.newSkill = newSkill;
							var namenode = ui.create.div('.config', '名称：<input class="new_name" type="text" style="width:120px"></input>', newSkill);
							var descnode = ui.create.div('.config', '描述：<input class="new_description" type="text" style="width:120px"></input>', newSkill);
							namenode.querySelector('input.new_name').onblur = updateButton;
							var commandline = ui.create.div('.config', newSkill);
							var editbutton = document.createElement('button');
							editbutton.innerHTML = '编辑代码';
							commandline.appendChild(editbutton);
							editbutton.onclick = function () {
								var node = container;
								ui.window.classList.add('shortcutpaused');
								ui.window.classList.add('systempaused');
								window.saveNonameInput = saveInput;
								if (node.aced) {
									ui.window.appendChild(node);
									node.editor.setValue(node.code, 1);
								}
								else if (lib.device == 'ios') {
									ui.window.appendChild(node);
									if (!node.textarea) {
										var textarea = document.createElement('textarea');
										editor.appendChild(textarea);
										node.textarea = textarea;
										lib.setScroll(textarea);
									}
									node.textarea.value = node.code;
								}
								else {
									var aceReady = function () {
										ui.window.appendChild(node);
										var mirror = window.CodeMirror(editor, {
											value: node.code,
											mode: "javascript",
											lineWrapping: !lib.config.touchscreen && lib.config.mousewheel,
											lineNumbers: true,
											indentUnit: 4,
											autoCloseBrackets: true,
											theme: 'mdn-like'
										});
										lib.setScroll(editor.querySelector('.CodeMirror-scroll'));
										node.aced = true;
										node.editor = mirror;
									}
									if (!window.ace) {
										lib.init.js(lib.assetURL + 'game', 'codemirror', aceReady);
										lib.init.css(lib.assetURL + 'layout/default', 'codemirror');
									}
									else {
										aceReady();
									}
								}
							}

							var container = ui.create.div('.popup-container.editor');
							var editorpage = ui.create.div(container);
							var discardConfig = ui.create.div('.editbutton', '取消', editorpage, function () {
								ui.window.classList.remove('shortcutpaused');
								ui.window.classList.remove('systempaused');
								container.delete(null);
								delete window.saveNonameInput;
							});
							var saveInput = function () {
								var code;
								if (container.editor) {
									code = container.editor.getValue();
								}
								else if (container.textarea) {
									code = container.textarea.value;
								}
								try {
									var skill = null;
									eval(code);
									if (skill == null || typeof skill != 'object') {
										throw ('err');
									}
								}
								catch (e) {
									if (e == 'err') {
										alert('代码格式有错误，请对比示例代码仔细检查');
									}
									else {
										alert('代码语法有错误，请仔细检查（' + e + '）')
									}
									return;
								}
								dash3.link.classList.add('active');
								ui.window.classList.remove('shortcutpaused');
								ui.window.classList.remove('systempaused');
								container.delete();
								container.code = code;
								delete window.saveNonameInput;
							};
							var saveConfig = ui.create.div('.editbutton', '保存', editorpage, saveInput);
							var editor = ui.create.div(editorpage);
							container.code = 'skill={\n    \n}\n\n\/*\n示例：\nskill={\n    trigger:{player:"phaseJieshuBegin"},\n    frequent:true,\n    content:function(){\n        player.draw()\n    }\n}\n此例为闭月代码\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';

							var citebutton = document.createElement('button');
							citebutton.innerHTML = '引用代码';
							commandline.appendChild(citebutton);
							citebutton.onclick = function () {
								editbutton.style.display = 'none';
								citebutton.style.display = 'none';
								selectname.style.display = '';
								skillopt.style.display = '';
								addSkillButton.style.display = '';
								cancelSkillButton.style.display = '';
							}

							var list = [];
							for (var i in lib.character) {
								if (lib.character[i][3].length) {
									list.push([i, lib.translate[i]]);
								}
							}
							list.sort(function (a, b) {
								a = a[0]; b = b[0];
								var aa = a, bb = b;
								if (aa.indexOf('_') != -1) {
									aa = aa.slice(aa.indexOf('_') + 1);
								}
								if (bb.indexOf('_') != -1) {
									bb = bb.slice(bb.indexOf('_') + 1);
								}
								if (aa != bb) {
									return aa > bb ? 1 : -1;
								}
								return a > b ? 1 : -1;
							});
							list.push(['others', '其它']);
							var list2 = [];
							var skills = lib.character[list[0][0]][3];
							for (var i = 0; i < skills.length; i++) {
								list2.push([skills[i], lib.translate[skills[i]]]);
							}
							var selectname = ui.create.selectlist(list, list[0], commandline);
							var list3 = [];
							for (var i in lib.skill) {
								if (i != 'global' && !get.is.empty(lib.skill[i]) && !lib.skilllist.contains(i)) {
									list3.push(i);
								}
							}
							list3.sort(function (a, b) {
								return a > b ? 1 : -1;
							});
							selectname.onchange = function () {
								var skills;
								skillopt.innerHTML = '';
								if (this.value == 'others') {
									skills = list3;
									for (var i = 0; i < skills.length; i++) {
										var option = document.createElement('option');
										option.value = skills[i];
										option.innerHTML = skills[i];
										skillopt.appendChild(option);
									}
								}
								else {
									skills = lib.character[this.value][3];
									for (var i = 0; i < skills.length; i++) {
										var option = document.createElement('option');
										option.value = skills[i];
										option.innerHTML = lib.translate[skills[i]];
										skillopt.appendChild(option);
									}
								}
							};
							selectname.style.display = 'none';
							selectname.style.maxWidth = '80px';
							var skillopt = ui.create.selectlist(list2, list2[0], commandline);
							skillopt.style.display = 'none';
							skillopt.style.maxWidth = '60px';
							var addSkillButton = document.createElement('button');
							addSkillButton.style.display = 'none';
							addSkillButton.innerHTML = '引用';
							commandline.appendChild(addSkillButton);
							addSkillButton.onclick = function () {
								editbutton.style.display = '';
								citebutton.style.display = '';
								selectname.style.display = 'none';
								skillopt.style.display = 'none';
								addSkillButton.style.display = 'none';
								cancelSkillButton.style.display = 'none';
								container.code = 'skill=' + get.stringify(lib.skill[skillopt.value]);
								editbutton.onclick.call(editbutton);
								if (lib.translate[skillopt.value + '_info']) {
									newSkill.querySelector('input.new_description').value = lib.translate[skillopt.value + '_info'];
								}
							}
							var cancelSkillButton = document.createElement('button');
							cancelSkillButton.style.display = 'none';
							cancelSkillButton.innerHTML = '取消';
							commandline.appendChild(cancelSkillButton);
							cancelSkillButton.onclick = function () {
								editbutton.style.display = '';
								citebutton.style.display = '';
								selectname.style.display = 'none';
								skillopt.style.display = 'none';
								addSkillButton.style.display = 'none';
								cancelSkillButton.style.display = 'none';
							}

							var editnode = ui.create.div('.menubutton.large.new_skill.disabled', '创建技能', function () {
								var name = page.querySelector('input.new_name').value;
								if (!name) {
									alert('请填写技能名\n提示：技能名格式为id+|+中文名，其中id必须惟一');
									return;
								}
								name = name.split('|');
								var translate = name[1] || name[0];
								var info = page.querySelector('input.new_description').value;
								name = name[0];
								if (currentButton) {
									if (currentButton.link != name) {
										if (lib.skill[name] || page.content.pack.skill[name]) {
											alert('技能名与现有技能重复，请更改\n提示：技能名格式为id+|+中文名，其中id必须惟一');
											return;
										}
										delete page.content.pack.skill[currentButton.link];
										delete page.content.pack.translate[currentButton.link];
										delete page.content.pack.translate[currentButton.link + '_info'];
										currentButton.link = name;
									}
								}
								else {
									if (lib.skill[name] || page.content.pack.skill[name]) {
										alert('技能名与现有技能重复，请更改\n提示：技能名格式为id+|+中文名，其中id必须惟一');
										return;
									}
								}
								page.content.pack.translate[name] = translate;
								page.content.pack.translate[name + '_info'] = info;
								try {
									var skill = null;
									eval(container.code);
									if (skill == null || typeof skill != 'object') {
										throw ('err');
									}
									page.content.pack.skill[name] = skill;
								}
								catch (e) {
									page.content.pack.skill[name] = {};
								}
								dash1.selectname.value = 'current_extension';
								dash1.selectname.onchange.call(dash1.selectname);
								if (this.innerHTML == '创建技能') {
									createButton(name);
									if (page.fromchar == 'add') {
										ui.create.templayer();
										page.hide();
										dash1.show();
										dash1.skillopt.value = name;
										dash1.addSkillButton.onclick();
										delete page.fromchar;
									}
								}
								else if (currentButton) {
									currentButton.innerHTML = translate;
								}
								resetEditor();
								dash3.link.classList.add('active');
								dash1.updateSkill();
							}, newSkill);
							var delnode = ui.create.div('.menubutton.large.new_card_delete', '取消', editnode.parentNode, function () {
								if (this.innerHTML == '删除') {
									this.button.remove();
									var name = this.button.link;
									delete dash3.content.pack.skill[name];
									delete dash3.content.pack.translate[name];
									delete dash3.content.pack.translate[name + '_info'];
									dash3.link.classList.add('active');
									if (get.is.empty(dash3.content.pack.skill)) {
										dash1.selectname.value = dash1.selectname.childNodes[1].value;
									}
									dash1.selectname.onchange.call(dash1.selectname);
									dash1.updateSkill();
									resetEditor();
								}
								else if (page.fromchar == 'add') {
									ui.create.templayer();
									page.hide();
									dash1.show();
									delete page.fromchar;
									setTimeout(resetEditor, 600);
								}
								else {
									resetEditor();
								}
							});

							page.content = {
								pack: {
									skill: {},
									translate: {}
								},
								audio: {}
							};
							return page;
						}());
						var dash4 = (function () {
							var page = ui.create.div('.hidden.menu-buttons');
							ui.create.div('.config.more.margin-bottom', '<div style="transform:none;margin-right:3px">←</div>返回', page, function () {
								ui.create.templayer();
								page.hide();
								pageboard.show();
							});
							page.reset = function (name) {
								page.content = {};
								if (lib.extensionPack[name]) {
									for (var i in dashes) {
										dashes[i].node.code = '';
									}
									for (var i in lib.extensionPack[name].code) {
										switch (typeof lib.extensionPack[name].code[i]) {
											case 'function': page.content[i] = lib.extensionPack[name].code[i].toString(); break;
											case 'object': page.content[i] = i + '=' + get.stringify(lib.extensionPack[name].code[i]); break;
										}
									}
									for (var i in page.content) {
										dashes[i].node.code = page.content[i] || '';
									}
								}
								else {
									dashes.content.node.code = 'function(config,pack){\n    \n}\n\n\/*\n函数执行时机为游戏数据加载之后、界面加载之前\n参数1扩展选项（见选项代码）；参数2为扩展定义的武将、卡牌和技能等（可在此函数中修改）\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';
									dashes.precontent.node.code = 'function(){\n    \n}\n\n\/*\n函数执行时机为游戏数据加载之前，且不受禁用扩展的限制\n除添加模式外请慎用\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';
									dashes.config.node.code = 'config={\n			 \n}\n\n\/*\n示例：\nconfig={\n			 switcher_example:{\n    name:"示例列表选项",\n        init:"3",\n        item:{"1":"一","2":"二","3":"三"}\n    },\n			 toggle_example:{\n        name:"示例开关选项",\n        init:true\n    }\n}\n此例中传入的主代码函数的默认参数为{switcher_example:"3",toggle_example:true}\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';
									dashes.help.node.code = 'help={\n			 \n}\n\n\/*\n示例：\nhelp={\n    "帮助条目":"<ul><li>列表1-条目1<li>列表1-条目2</ul><ol><li>列表2-条目1<li>列表2-条目2</ul>"\n}\n帮助内容将显示在菜单－选项－帮助中\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/';
								}
							};
							var dashes = {};
							var createCode = function (str1, str2, sub, func, link, str) {
								var dash = ui.create.div('.menubutton.large.dashboard');
								dashes[link] = dash;
								sub.appendChild(dash);
								dash.listen(func);
								dash.link = link;
								ui.create.div('', str1, dash);
								ui.create.div('', str2, dash);
								var container = ui.create.div('.popup-container.editor');
								var editorpage = ui.create.div(container);
								var discardConfig = ui.create.div('.editbutton', '取消', editorpage, function () {
									ui.window.classList.remove('shortcutpaused');
									ui.window.classList.remove('systempaused');
									container.delete(null);
									delete window.saveNonameInput;
								});
								var saveInput = function () {
									var code;
									if (container.editor) {
										code = container.editor.getValue();
									}
									else if (container.textarea) {
										code = container.textarea.value;
									}
									try {
										if (link == 'content' || link == 'precontent') {
											var func = null;
											eval('func=' + code);
											if (typeof func != 'function') {
												throw ('err');
											}
										}
										else if (link == 'config') {
											var config = null;
											eval(code);
											if (config == null || typeof config != 'object') {
												throw ('err');
											}
										}
										else if (link == 'help') {
											var help = null;
											eval(code);
											if (help == null || typeof help != 'object') {
												throw ('err');
											}
										}
									}
									catch (e) {
										if (e == 'err') {
											alert('代码格式有错误，请对比示例代码仔细检查');
										}
										else {
											alert('代码语法有错误，请仔细检查（' + e + '）')
										}
										return;
									}
									dash4.link.classList.add('active');
									ui.window.classList.remove('shortcutpaused');
									ui.window.classList.remove('systempaused');
									container.delete();
									container.code = code;
									page.content[link] = code;
									delete window.saveNonameInput;
								};
								var saveConfig = ui.create.div('.editbutton', '保存', editorpage, saveInput);
								var editor = ui.create.div(editorpage);
								container.code = str;
								dash.editor = editor;
								dash.node = container;
								dash.saveInput = saveInput;
								page.content[link] = str;
							};
							var clickCode = function () {
								var node = this.node;
								ui.window.classList.add('shortcutpaused');
								ui.window.classList.add('systempaused');
								window.saveNonameInput = this.saveInput;
								if (node.aced) {
									ui.window.appendChild(node);
									node.editor.setValue(node.code, 1);
								}
								else if (lib.device == 'ios') {
									ui.window.appendChild(node);
									if (!node.textarea) {
										var textarea = document.createElement('textarea');
										this.editor.appendChild(textarea);
										node.textarea = textarea;
										lib.setScroll(textarea);
									}
									node.textarea.value = node.code;
								}
								else {
									var editor = this.editor;
									var aceReady = function () {
										ui.window.appendChild(node);
										var mirror = window.CodeMirror(editor, {
											value: node.code,
											mode: "javascript",
											lineWrapping: !lib.config.touchscreen && lib.config.mousewheel,
											lineNumbers: true,
											indentUnit: 4,
											autoCloseBrackets: true,
											theme: 'mdn-like'
										});
										lib.setScroll(editor.querySelector('.CodeMirror-scroll'));
										node.aced = true;
										node.editor = mirror;
									}
									if (!window.ace) {
										lib.init.js(lib.assetURL + 'game', 'codemirror', aceReady);
										lib.init.css(lib.assetURL + 'layout/default', 'codemirror');
									}
									else {
										aceReady();
									}
								}
							};
							page.content = {}
							createCode('主', '主代码', page, clickCode, 'content', 'function(config,pack){\n    \n}\n\n\/*\n函数执行时机为游戏数据加载之后、界面加载之前\n参数1扩展选项（见选项代码）；参数2为扩展定义的武将、卡牌和技能等（可在此函数中修改）\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/');
							createCode('启', '启动代码', page, clickCode, 'precontent', 'function(){\n			 \n}\n\n\/*\n函数执行时机为游戏数据加载之前，且不受禁用扩展的限制\n除添加模式外请慎用\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/');
							createCode('选', '选项代码', page, clickCode, 'config', 'config={\n    \n}\n\n\/*\n示例：\nconfig={\n    switcher_example:{\n        name:"示例列表选项",\n        init:"3",\n						  item:{"1":"一","2":"二","3":"三"}\n    },\n			 toggle_example:{\n        name:"示例开关选项",\n        init:true\n    }\n}\n此例中传入的主代码函数的默认参数为{switcher_example:"3",toggle_example:true}\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/');
							createCode('帮', '帮助代码', page, clickCode, 'help', 'help={\n    \n}\n\n\/*\n示例：\nhelp={\n    "帮助条目":"<ul><li>列表1-条目1<li>列表1-条目2</ul><ol><li>列表2-条目1<li>列表2-条目2</ul>"\n}\n帮助内容将显示在菜单－选项－帮助中\n导出时本段代码中的换行、缩进以及注释将被清除\n*\/');

							return page;
						}());
						createDash('将', '编辑武将', dash1);
						createDash('卡', '编辑卡牌', dash2);
						createDash('技', '编辑技能', dash3);
						createDash('码', '编辑代码', dash4);
					}());
					(function () {
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', '获取扩展', start.firstChild, clickMode);
						node.link = page;
						node.mode = 'get';
						page.listen(function () {
							if (!page.currenttimeout) {
								var active = page.querySelector('.videonode.current');
								if (active) {
									active.classList.remove('current');
								}
							}
						});
						var importextensionexpanded = false;
						page.style.paddingBottom = '10px';
						var importExtension;
						var extensionnode = ui.create.div('.config.more', '导入扩展 <div>&gt;</div>', page, function () {
							if (importextensionexpanded) {
								this.classList.remove('on');
								importExtension.style.display = 'none';
							}
							else {
								this.classList.add('on');
								importExtension.style.display = '';
							}
							importextensionexpanded = !importextensionexpanded;
						});
						importExtension = ui.create.div('.new_character.export.import', page);
						importExtension.style.marginLeft = '5px';
						importExtension.style.marginTop = '5px';
						importExtension.style.marginBottom = '5px';
						importExtension.style.display = 'none';
						importExtension.style.width = '100%';
						importExtension.style.textAlign = 'left';
						ui.create.div('', '<input type="file" accept="application/zip" style="width:153px"><button>确定</button>', importExtension);

						var extensionURL = lib.updateURL.replace(/noname/g, 'noname-extension') + '/master/';

						var reloadnode = ui.create.div('.config.toggle.pointerdiv', '重新启动', page, game.reload);
						reloadnode.style.display = 'none';
						var placeholder = ui.create.div('.config.toggle', page);
						placeholder.style.height = 0;
						placeholder.style.marginTop = '5px';

						importExtension.firstChild.lastChild.onclick = function () {
							var fileToLoad = this.previousSibling.files[0];
							if (fileToLoad) {
								var fileReader = new FileReader();
								fileReader.onload = function (fileLoadedEvent) {
									var finishLoad = function () {
										extensionnode.innerHTML = '导入成功，3秒后将重启';
										setTimeout(function () {
											extensionnode.innerHTML = '导入成功，2秒后将重启';
											setTimeout(function () {
												extensionnode.innerHTML = '导入成功，1秒后将重启';
												setTimeout(game.reload, 1000);
											}, 1000);
										}, 1000);
									};
									var data = fileLoadedEvent.target.result;
									if (game.importExtension(data, finishLoad) !== false) {
										importExtension.style.display = 'none';
									}
								};
								fileReader.readAsArrayBuffer(fileToLoad, "UTF-8");
							}
						}

						var clickExtension = function () {
							var active = this.parentNode.querySelector('.videonode.current');
							if (active && active != this) {
								active.classList.remove('current');
							}
							this.classList.add('current');
							clearTimeout(page.currenttimeout);
							page.currenttimeout = setTimeout(function () {
								delete page.currenttimeout;
							}, 200);
						};
						var downloadExtension = function (e) {
							if ((this.innerHTML != '下载扩展' && this.innerHTML != '更新扩展') || !window.JSZip) return;
							this.classList.remove('update');
							if (e) {
								e.stopPropagation();
							}
							node.updated = true;
							var that = this;
							var list = [];
							var size = parseFloat(this.info.size) || 0;
							if (size) {
								if (this.info.size.indexOf('MB') != -1) {
									size *= 1024 * 1024;
								}
								else if (this.info.size.indexOf('KB') != -1) {
									size *= 1024;
								}
							}

							this.innerHTML = '<span>正在下载</span><div>正在下载</div>';
							this.classList.add('nopointer');
							this.classList.add('button-downloading');
							var progress = ui.create.div('.button-progress', this);
							ui.create.div(progress);
							var url = extensionURL + this.info.name + '.zip';
							var onprogress = function (byte, total) {
								if (total) {
									size = total;
								}
								if (byte == -1) {
									byte = size;
								}
								progress.firstChild.style.width = Math.round(100 * byte / size) + '%';
							};
							var files = this.info.files || [];
							for (var i = 0; i < files.length; i++) {
								files[i] = 'extension/' + that.info.name + '/' + files[i];
							}
							game.checkFileList(files, function () {
								files.unshift('extension/' + that.info.name + '/extension.js');
								for (var i = 0; i < files.length; i++) {
									files[i] = extensionURL + that.info.name + '/' + files[i].slice(10 + that.info.name.length + 1);
								}
								var n1 = 0, n2 = files.length;
								game.multiDownload(files, function () {
									n1++;
									onprogress(n1, n2);
								}, function (e) {
									game.print('下载失败：' + e.source);
								}, function () {
									onprogress(-1);
									_status.importingExtension = true;
									window.game = game;
									lib.init.js(lib.assetURL + 'extension/' + that.info.name, 'extension', function () {
										if (!lib.config.dev) delete window.game;
										if (game.importedPack) {
											var extname = game.importedPack.name;
											if (lib.config.extensions.contains(extname)) {
												game.removeExtension(extname, true);
											}
											lib.config.extensions.add(extname);
											game.saveConfig('extensions', lib.config.extensions);
											game.saveConfig('extension_' + extname + '_enable', true);
											game.saveConfig('extension_' + extname + '_version', that.info.version);
											for (var i in game.importedPack.config) {
												if (game.importedPack.config[i] && game.importedPack.config[i].hasOwnProperty('init')) {
													game.saveConfig('extension_' + extname + '_' + i, game.importedPack.config[i].init);
												}
											}
											reloadnode.style.display = '';
											that.childNodes[0].innerHTML = '安装成功';
											that.childNodes[1].innerHTML = '安装成功';
											that.classList.remove('active');
											that.classList.remove('highlight');
											delete game.importedPack;
										}
										else {
											that.innerHTML = '安装失败';
											that.classList.add('nopointer');
										}
										_status.importingExtension = false;
									}, function () {
										that.innerHTML = '下载失败';
										that.classList.add('nopointer');
										_status.importingExtension = false;
									});
								}, function (current) {
									return 'extension/' + current.slice(extensionURL.length);
								});
							});
						};

						node.update = function () {
							if (this.updated) return;
							if (!window.JSZip) {
								lib.init.js(lib.assetURL + 'game', 'jszip');
							}
							var toremove = [];
							for (var i = 0; i < page.childElementCount; i++) {
								if (page.childNodes[i].classList.contains('menubutton') || page.childNodes[i].classList.contains('loading')) {
									toremove.push(page.childNodes[i]);
								}
							}
							for (var i = 0; i < toremove.length; i++) {
								toremove[i].remove();
							}

							var loading = ui.create.div('.loading.config.toggle', '载入中...', page);
							var loaded = function (list) {
								var list = [];
								var extension = window.extension;
								for (var i in extension) {
									extension[i].name = i;
									list.push(extension[i]);
								}
								list.randomSort();
								delete window.extension;
								loading.style.display = 'none';
								for (var i = 0; i < list.length; i++) {
									var node = ui.create.div('.videonode.menubutton.extension.large', page, clickExtension);
									ui.create.div('.caption', list[i].name, node);
									ui.create.div('.text.author', '作者：' + list[i].author + '<span>(' + list[i].size + ')</span>', node);
									ui.create.div('.text', list[i].intro, node);
									var download = ui.create.div('.menubutton.text.active', '下载扩展', node.firstChild);
									if (game.download) {
										if (list[i].netdisk) {
											var linknode = ui.create.div('.text', node);
											ui.create.node('span.hrefnode', '网盘链接', function () {
												game.open(this.link);
											}, linknode).link = list[i].netdisk;
											if (list[i].forum) {
												ui.create.node('span', linknode).style.marginRight = '10px';
												ui.create.node('span.hrefnode', '参与讨论', function () {
													game.open(this.link);
												}, linknode).link = list[i].forum;
											}
										}
										else if (list[i].forum) {
											var linknode = ui.create.div('.text', node);
											ui.create.node('span.hrefnode', '参与讨论', function () {
												game.open(this.link);
											}, linknode).link = list[i].forum;
										}
										download.listen(downloadExtension);
										if (lib.config.extensions.contains(list[i].name)) {
											download.classList.remove('active');
											if (lib.extensionPack[list[i].name] && lib.extensionPack[list[i].name].version == list[i].version) {
												download.classList.add('transparent2');
												download.classList.remove('active');
												download.innerHTML = '已安装';
											}
											else if (lib.config['extension_' + list[i].name + '_version'] != list[i].version) {
												download.innerHTML = '更新扩展';
												download.classList.add('highlight');
												download.classList.add('update');
											}
											else {
												download.classList.add('transparent2');
												download.classList.remove('active');
												download.innerHTML = '已安装';
											}
										}
										download.info = list[i];
									}
									else {
										if (list[i].forum) {
											var linknode = ui.create.div('.text', node);
											ui.create.node('span', linknode);
											ui.create.node('span.hrefnode', '参与讨论', function () {
												game.open(this.link);
											}, linknode).link = list[i].forum;
										}
										download.listen(function () {
											game.open(this.link);
										});
										download.link = list[i].netdisk;
									}
								}
							};
							window.extension = {};
							if (game.download) {
								lib.init.req(extensionURL + 'catalog.js', function () {
									try {
										eval(this.responseText);
										// if(!window.noname_extension_list){
										// 	throw('err');
										// }
									}
									catch (e) {
										delete window.extension;
										loading.innerHTML = '连接失败';
										return;
									}
									loaded();
								}, function () {
									delete window.extension;
									loading.innerHTML = '连接失败';
								});
							}
							else {
								lib.init.js(extensionURL.replace(/raw\.githubusercontent\.com/, 'rawgit.com') + 'catalog.js', null, loaded, function () {
									delete window.extension;
									loading.innerHTML = '连接失败';
								});
							}
						};
					}());
					var active = start.firstChild.querySelector('.active');
					if (!active) {
						active = start.firstChild.firstChild;
						active.classList.add('active');
					}
					rightPane.appendChild(active.link);
					updateNodes();
				}());

				(function () {
					if (connectMenu) return;
					var start = menuxpages.shift();
					var rightPane = start.lastChild;
					var cheatButton = ui.create.div('.menubutton.round.highlight', '作', start);
					cheatButton.style.display = 'none';
					var runButton = ui.create.div('.menubutton.round.highlight', '执', start);
					runButton.style.display = 'none';
					var clearButton = ui.create.div('.menubutton.round.highlight', '清', start);
					clearButton.style.display = 'none';
					clearButton.style.left = '275px';
					var playButton = ui.create.div('.menubutton.round.highlight.hidden', '播', start);
					playButton.style.display = 'none';
					playButton.style.left = '215px';
					playButton.style.transition = 'opacity 0.3s';
					var deleteButton = ui.create.div('.menubutton.round.highlight.hidden', '删', start);
					deleteButton.style.display = 'none';
					deleteButton.style.left = '275px';
					deleteButton.style.transition = 'opacity 0.3s';
					var saveButton = ui.create.div('.menubutton.round.highlight.hidden', '存', start);
					saveButton.style.display = 'none';
					saveButton.style.transition = 'opacity 0.3s';


					var clickMode = function () {
						if (this.classList.contains('off')) return;
						var active = this.parentNode.querySelector('.active');
						if (active === this) {
							return;
						}
						if (active) {
							active.classList.remove('active');
							active.link.remove();
						}
						active = this;
						this.classList.add('active');
						rightPane.appendChild(this.link);
						if (this.type == 'cheat') {
							cheatButton.style.display = '';
						}
						else {
							cheatButton.style.display = 'none';
						}
						if (this.type == 'cmd') {
							runButton.style.display = '';
							clearButton.style.display = '';
						}
						else {
							runButton.style.display = 'none';
							clearButton.style.display = 'none';
						}
						if (this.type == 'video') {
							playButton.style.display = '';
							saveButton.style.display = '';
							deleteButton.style.display = '';
						}
						else {
							playButton.style.display = 'none';
							saveButton.style.display = 'none';
							deleteButton.style.display = 'none';
						}
					};

					ui.click.consoleMenu = function () {
						ui.click.menuTab('其它');
						clickMode.call(ui.commandnode);
					};
					(function () {
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', '更新', start.firstChild, clickMode);
						node.link = page;
						page.classList.add('menu-help');
						var ul = document.createElement('ul');
						var li1 = document.createElement('li');
						var li2 = document.createElement('li');
						var li3 = document.createElement('li');
						var trimurl = function (str) {
							if (str == lib.updateURLS.github) {
								return 'GitHub';
							}
							if (str == lib.updateURLS.coding) {
								return 'Coding';
							}
							var index;
							index = str.indexOf('://');
							if (index != -1) {
								str = str.slice(index + 3);
							}
							index = str.indexOf('/');
							if (index != -1) {
								str = str.slice(0, index);
							}
							if (str.length > 15) {
								var list = str.split('.');
								if (list.length > 1) {
									list.shift();
								}
								str = list[0];
								for (var i = 1; i < list.length; i++) {
									str += '.' + list[i];
								}
							}
							if (str.length > 15) {
								var list = str.split('.');
								if (list.length > 1) {
									list.pop();
								}
								str = list[0];
								for (var i = 1; i < list.length; i++) {
									str += '.' + list[i];
								}
							}
							return str;
						}
						li1.innerHTML = '游戏版本：' + lib.version + '<p style="margin-top:8px;white-space:nowrap"></p>';
						li2.innerHTML = '素材版本：' + (lib.config.asset_version || '无') + '<p style="margin-top:8px"></p>';
						li3.innerHTML = '更新地址：<span>' + trimurl(lib.config.updateURL || lib.updateURL) + '</span><p style="margin-top:8px"></p>';
						li3.style.whiteSpace = 'nowrap';
						li3.style.display = 'none';// coding

						var button1, button2, button3, button4, button5;

						game.checkForUpdate = function (forcecheck, dev) {
							if (!dev && button1.disabled) {
								return;
							}
							else if (dev && button3.disabled) {
								return;
							}
							else if (!game.download) {
								alert('此版本不支持游戏内更新，请手动更新');
								return;
							}
							else {
								if (dev) {
									button3.innerHTML = '正在检查更新';
								}
								else {
									button1.innerHTML = '正在检查更新';
								}
								button3.disabled = true;
								button1.disabled = true;

								var goupdate = function (files, update) {
									lib.version = update.version;
									if (update.dev && !lib.config.debug) {
										dev = 'nodev';
									}
									lib.init.req('game/source.js', function () {
										try {
											eval(this.responseText);
											if (!window.noname_source_list) {
												throw ('err');
											}
										}
										catch (e) {
											alert('更新地址有误');
											console.log(e);
											return;
										}

										var updates = window.noname_source_list;
										delete window.noname_source_list;
										if (Array.isArray(files)) {
											files.add('game/update.js');
											var files2 = [];
											for (var i = 0; i < files.length; i++) {
												var str = files[i].indexOf('*');
												if (str != -1) {
													str = files[i].slice(0, str);
													files.splice(i--, 1);
													for (var j = 0; j < updates.length; j++) {
														if (updates[j].indexOf(str) == 0) {
															files2.push(updates[j]);
														}
													}
												}
											}
											updates = files.concat(files2);
										}
										for (var i = 0; i < updates.length; i++) {
											if (updates[i].indexOf('theme/') == 0 && updates[i].indexOf('.css') == -1) {
												updates.splice(i--, 1);
											}
											else if (updates[i].indexOf('node_modules/') == 0 && !update.node) {
												updates.splice(i--, 1);
											}
										}

										if (!ui.arena.classList.contains('menupaused')) {
											ui.click.configMenu();
											ui.click.menuTab('其它');
										}
										var p = button1.parentNode;
										button1.remove();
										button3.remove();
										var span = document.createElement('span');
										var n1 = 0;
										var n2 = updates.length;
										span.innerHTML = '正在下载文件（' + n1 + '/' + n2 + '）';
										p.appendChild(span);
										var finish = function () {
											span.innerHTML = '游戏更新完毕（' + n1 + '/' + n2 + '）';
											p.appendChild(document.createElement('br'));
											var button = document.createElement('button');
											button.innerHTML = '重新启动';
											button.onclick = game.reload;
											button.style.marginTop = '8px';
											p.appendChild(button);
										}
										game.multiDownload(updates, function () {
											n1++;
											span.innerHTML = '正在下载文件（' + n1 + '/' + n2 + '）';
										}, function (e) {
											game.print('下载失败：' + e.source);
										}, function () {
											setTimeout(finish, 500);
										}, null, dev);
									}, function () {
										alert('更新地址有误');
									}, true);
								};

								lib.init.req('game/update.js', function () {
									try {
										eval(this.responseText);
										if (!window.noname_update) {
											throw ('err');
										}
									}
									catch (e) {
										alert('更新地址有误');
										console.log(e);
										return;
									}

									var update = window.noname_update;
									delete window.noname_update;
									if (forcecheck === false) {
										if (update.version == lib.config.check_version) {
											return;
										}
									}
									game.saveConfig('check_version', update.version);
									var goon = true;
									if (!dev) {
										if (update.version.indexOf('beta') != -1 || update.version == lib.version) {
											goon = false;
										}
									}
									if (goon) {
										var files = null;
										var version = lib.version;
										if (Array.isArray(update.dev) && dev) {
											files = update.dev;
										}
										else if (Array.isArray(update.files) && update.update && !dev) {
											var version1 = version.split('.');
											var version2 = update.update.split('.');
											for (var i = 0; i < version1.length && i < version2.length; i++) {
												if (version2[i] > version1[i]) {
													files = false; break;
												}
												else if (version1[i] > version2[i]) {
													files = update.files.slice(0); break;
												}
											}
											if (files === null) {
												if (version1.length >= version2.length) {
													files = update.files.slice(0);
												}
											}
										}
										var str;
										if (dev) {
											str = '开发版仅供测试使用，可能存在风险，是否确定更新？'
										}
										else {
											str = '有新版本' + update.version + '可用，是否下载？';
										}
										if (navigator.notification && navigator.notification.confirm) {
											var str2;
											if (dev) {
												str2 = str;
												str = '更新到开发版';
											}
											else {
												str2 = update.changeLog[0];
												for (var i = 1; i < update.changeLog.length; i++) {
													if (update.changeLog[i].indexOf('://') == -1) {
														str2 += '；' + update.changeLog[i];
													}
												}
											}
											navigator.notification.confirm(
												str2,
												function (index) {
													if (index == 1) {
														goupdate(files, update);
													}
													else {
														button1.disabled = false;
														button1.innerHTML = '检查游戏更新';
														button3.disabled = false;
														button3.innerHTML = '更新到开发版';
													}
												},
												str,
												['确定', '取消']
											);
										}
										else {
											if (confirm(str)) {
												goupdate(files, update);
											}
											else {
												button1.disabled = false;
												button1.innerHTML = '检查游戏更新';
												button3.disabled = false;
												button3.innerHTML = '更新到开发版';
											}
										}
									}
									else {
										alert('当前版本已是最新');
										button1.disabled = false;
										button1.innerHTML = '检查游戏更新';
										button3.disabled = false;
										button3.innerHTML = '更新到开发版';
									}
								}, function () {
									if (forcecheck === false) {
										return;
									}
									alert('连接失败');
									button1.disabled = false;
									button1.innerHTML = '检查游戏更新';
									button3.disabled = false;
									button3.innerHTML = '更新到开发版';
								}, true);
							}
						};
						game.checkForAssetUpdate = function (type) {
							if (button2.disabled) {
								return;
							}
							else if (game.download) {
								button2.innerHTML = '正在检查更新';
								button2.disabled = true;
								lib.init.req('game/asset.js', function () {
									try {
										eval(this.responseText);
										if (!window.noname_asset_list || !window.noname_skin_list) {
											throw ('err');
										}
									}
									catch (e) {
										alert('更新地址有误');
										console.log(e);
										return;
									}

									var updates = window.noname_asset_list;
									delete window.noname_asset_list;
									var skins = window.noname_skin_list;
									delete window.noname_skin_list;
									var asset_version = updates.shift();

									var skipcharacter = [], skipcard = ['tiesuo_mark'];
									if (!lib.config.asset_full) {
										for (var i = 0; i < lib.config.all.sgscharacters.length; i++) {
											var pack = lib.characterPack[lib.config.all.sgscharacters[i]];
											for (var j in pack) {
												skipcharacter.add(j);
											}
										}
										for (var i = 0; i < lib.config.all.sgscards.length; i++) {
											var pack = lib.cardPack[lib.config.all.sgscards[i]];
											if (pack) {
												skipcard = skipcard.concat(pack);
											}
										}
									}
									for (var i = 0; i < updates.length; i++) {
										switch (updates[i].slice(0, 5)) {
											case 'image': {
												if (!lib.config.asset_full) {
													if (!lib.config.asset_image) {
														updates.splice(i--, 1);
													}
													else {
														if (updates[i].indexOf('image/character') == 0) {
															if (updates[i].indexOf('jun_') != 16 && updates[i].indexOf('gz_') != 16 && !skipcharacter.contains(updates[i].slice(16, updates[i].lastIndexOf('.')))) {
																updates.splice(i--, 1);
															}
														}
														else if (updates[i].indexOf('image/card') == 0) {
															if (updates[i].indexOf('qiaosi_card') != 11 && !skipcard.contains(updates[i].slice(11, updates[i].lastIndexOf('.')))) {
																updates.splice(i--, 1);
															}
														}
														else if (updates[i].indexOf('image/mode/stone') == 0) {
															updates.splice(i--, 1);
														}
													}
												}
												break;
											}
											case 'audio': {
												if (!lib.config.asset_audio) {
													updates.splice(i--, 1);
												}
												break;
											}
											case 'font/': {
												if (!lib.config.asset_font) {
													updates.splice(i--, 1);
												}
											}
										}
									}
									if (lib.config.asset_skin) {
										for (var i in skins) {
											for (var j = 1; j <= skins[i]; j++) {
												updates.push('image/skin/' + i + '/' + j + '.jpg');
											}
										}
									}
									if (!ui.arena.classList.contains('menupaused')) {
										ui.click.configMenu();
										ui.click.menuTab('其它');
									}

									var proceed = function () {
										if (updates.length == 0) {
											game.print(updates);
											game.saveConfig('asset_version', asset_version);
											alert('素材已是最新');
											button2.disabled = false;
											button2.innerHTML = '检查素材更新';
											return;
										}
										var p = button2.parentNode;
										button2.remove();
										var span = document.createElement('span');
										span.style.whiteSpace = 'nowrap';
										var n1 = 0;
										var n2 = updates.length;
										span.innerHTML = '正在下载素材（' + n1 + '/' + n2 + '）';
										span1.remove();
										span2.remove();
										span2_check.remove();
										span3.remove();
										span3_check.remove();
										span4.remove();
										span4_check.remove();
										span5.remove();
										span5_check.remove();
										span6.remove();
										span6_check.remove();
										span2_br.remove();
										span3_br.remove();
										span4_br.remove();
										span5_br.remove();
										span6_br.remove();
										p.appendChild(span);

										var br6 = ui.create.node('br');
										var span7 = ui.create.div('.hrefnode', '详细信息');
										span7.style.marginTop = '6px';
										span7.listen(ui.click.consoleMenu);
										p.appendChild(br6);
										p.appendChild(span7);

										var finish = function () {
											if (n1 == n2) {
												game.saveConfig('asset_version', asset_version);
											}
											span.innerHTML = '素材更新完毕（' + n1 + '/' + n2 + '）';
											p.appendChild(document.createElement('br'));
											var button = document.createElement('button');
											button.innerHTML = '重新启动';
											button.onclick = game.reload;
											button.style.marginTop = '8px';
											p.appendChild(button);
										}
										game.multiDownload(updates, function () {
											n1++;
											span.innerHTML = '正在下载素材（' + n1 + '/' + n2 + '）';
										}, function (e) {
											game.print('下载失败：' + e.source);
										}, function () {
											setTimeout(finish, 500);
										});
									};
									game.checkFileList(updates, proceed);
								}, function () {
									alert('连接失败');
									button2.disabled = false;
									button2.innerHTML = '检查素材更新';
								}, true);
							}
							else {
								alert('此版本不支持游戏内更新素材，请手动更新');
							}
						};

						button1 = document.createElement('button');
						button1.innerHTML = '检查游戏更新';
						button1.onclick = game.checkForUpdate;
						li1.lastChild.appendChild(button1);

						button3 = document.createElement('button');
						button3.innerHTML = '更新到开发版';
						button3.style.marginLeft = '5px';
						button3.onclick = function () {
							game.checkForUpdate(null, true);
						};
						// if(lib.config.dev){
						//     li1.lastChild.appendChild(button3);
						// }

						(function () {
							var updatep1 = li1.querySelector('p');
							var updatep2 = li2;
							var updatep3 = li3;
							var updatep4 = node;
							var updatepx = ui.create.node('p');
							li1.appendChild(updatepx);
							updatepx.style.display = 'none';
							updatepx.style.whiteSpace = 'nowrap';
							updatepx.style.marginTop = '8px';
							var buttonx = ui.create.node('button', '访问项目主页', function () {
								window.open('https://github.com/libccy/noname');
							});
							updatepx.appendChild(buttonx);
							ui.updateUpdate = function () {
								if (!game.download) {
									updatep1.style.display = 'none';
									updatep2.style.display = 'none';
									updatep3.style.display = 'none';
									updatepx.style.display = '';
									updatep4.innerHTML = '关于';
								}
								else {
									updatep1.style.display = '';
									updatep2.style.display = '';
									updatep3.style.display = 'none'; // coding
									updatepx.style.display = 'none';
									updatep4.innerHTML = '更新';
								}
							}
							ui.updateUpdate();
						}());

						button4 = document.createElement('button');
						button4.innerHTML = '设置更新地址';
						button4.onclick = function () {
							game.prompt('设置更新地址', function (str) {
								if (str) {
									game.saveConfig('updateURL', str);
									li3.querySelector('span').innerHTML = trimurl(str);
									button5.style.display = '';
									button6.style.display = 'none';
								}
							});
						};
						// li3.lastChild.appendChild(button4);

						var button6 = document.createElement('button');
						button6.innerHTML = '设为备用镜像';
						button6.style.display = 'none';// coding
						// button6.style.marginLeft='5px';
						button6.onclick = function () {
							game.saveConfig('updateURL', lib.mirrorURL);
							button5.style.display = '';
							button6.style.display = 'none';
							li3.querySelector('span').innerHTML = trimurl(lib.mirrorURL);
						};
						li3.lastChild.appendChild(button6);

						button5 = document.createElement('button');
						button5.innerHTML = '设为默认镜像';
						// button5.style.marginLeft='5px';
						button5.onclick = function () {
							game.saveConfig('updateURL');
							button5.style.display = 'none';
							button6.style.display = '';
							li3.querySelector('span').innerHTML = trimurl(lib.updateURL);
						};
						li3.lastChild.appendChild(button5);
						if (!lib.config.updateURL) {
							button5.style.display = 'none';
						}
						else {
							button6.style.display = 'none';
						}

						button2 = document.createElement('button');
						button2.innerHTML = '检查素材更新';
						button2.onclick = game.checkForAssetUpdate;
						li2.lastChild.appendChild(button2);

						var span1 = ui.create.div('.config.more', '选项 <div>&gt;</div>');
						span1.style.fontSize = 'small';
						span1.style.display = 'inline';
						span1.toggle = function () {
							if (!this.classList.toggle('on')) {
								game.saveConfig('asset_toggle_off', true);
								span2.style.display = 'none';
								span2_br.style.display = 'none';
								span2_check.style.display = 'none';
								span3.style.display = 'none';
								span3_br.style.display = 'none';
								span3_check.style.display = 'none';
								span4.style.display = 'none';
								span4_br.style.display = 'none';
								span4_check.style.display = 'none';
								span5.style.display = 'none';
								span5_br.style.display = 'none';
								span5_check.style.display = 'none';
								span6.style.display = 'none';
								span6_br.style.display = 'none';
								span6_check.style.display = 'none';
							}
							else {
								game.saveConfig('asset_toggle_off');
								span2.style.display = '';
								span2_br.style.display = '';
								span2_check.style.display = '';
								span3.style.display = '';
								span3_br.style.display = '';
								span3_check.style.display = '';
								span4.style.display = '';
								span4_br.style.display = '';
								span4_check.style.display = '';
								span5.style.display = '';
								span5_br.style.display = '';
								span5_check.style.display = '';
								span6.style.display = '';
								span6_br.style.display = '';
								span6_check.style.display = '';
							}
						};
						span1.listen(span1.toggle);
						li2.lastChild.appendChild(span1);

						var span6_br = ui.create.node('br');
						li2.lastChild.appendChild(span6_br);

						var span5 = ui.create.div('', '图片素材（精简，126MB）');
						span5.style.fontSize = 'small';
						span5.style.lineHeight = '16px';
						var span5_check = document.createElement('input');
						span5_check.type = 'checkbox';
						span5_check.style.marginLeft = '5px';
						if (lib.config.asset_image) {
							span5_check.checked = true;
						}
						span5_check.onchange = function () {
							game.saveConfig('asset_image', this.checked);
						}
						var span2_br = ui.create.node('br');

						var span4 = ui.create.div('', '字体素材（48MB）');
						span4.style.fontSize = 'small';
						span4.style.lineHeight = '16px';
						li2.lastChild.appendChild(span4);
						var span4_check = document.createElement('input');
						span4_check.type = 'checkbox';
						span4_check.style.marginLeft = '5px';
						if (lib.config.asset_font) {
							span4_check.checked = true;
						}
						span4_check.onchange = function () {
							game.saveConfig('asset_font', this.checked);
						}
						li2.lastChild.appendChild(span4_check);
						var span3_br = ui.create.node('br');
						li2.lastChild.appendChild(span3_br);

						var span3 = ui.create.div('', '音效素材（125MB）');
						span3.style.fontSize = 'small';
						span3.style.lineHeight = '16px';
						li2.lastChild.appendChild(span3);
						var span3_check = document.createElement('input');
						span3_check.type = 'checkbox';
						span3_check.style.marginLeft = '5px';
						if (lib.config.asset_audio) {
							span3_check.checked = true;
						}
						span3_check.onchange = function () {
							game.saveConfig('asset_audio', this.checked);
						}
						li2.lastChild.appendChild(span3_check);
						var span4_br = ui.create.node('br');
						li2.lastChild.appendChild(span4_br);

						var span2 = ui.create.div('', '皮肤素材（351MB）');
						span2.style.fontSize = 'small';
						span2.style.lineHeight = '16px';
						li2.lastChild.appendChild(span2);
						var span2_check = document.createElement('input');
						span2_check.type = 'checkbox';
						span2_check.style.marginLeft = '5px';
						if (lib.config.asset_skin) {
							span2_check.checked = true;
						}
						span2_check.onchange = function () {
							game.saveConfig('asset_skin', this.checked);
						}
						li2.lastChild.appendChild(span2_check);
						var span5_br = ui.create.node('br');
						li2.lastChild.appendChild(span5_br);


						li2.lastChild.appendChild(span5);
						li2.lastChild.appendChild(span5_check);
						li2.lastChild.appendChild(span2_br);

						var span6 = ui.create.div('', '图片素材（完整，203MB）');
						span6.style.fontSize = 'small';
						span6.style.lineHeight = '16px';
						li2.lastChild.appendChild(span6);
						var span6_check = document.createElement('input');
						span6_check.type = 'checkbox';
						span6_check.style.marginLeft = '5px';
						if (lib.config.asset_full) {
							span6_check.checked = true;
						}
						span6_check.onchange = function () {
							game.saveConfig('asset_full', this.checked);
						}
						li2.lastChild.appendChild(span6_check);

						span2.style.display = 'none';
						span2_br.style.display = 'none';
						span2_check.style.display = 'none';
						span3.style.display = 'none';
						span3_br.style.display = 'none';
						span3_check.style.display = 'none';
						span4.style.display = 'none';
						span4_br.style.display = 'none';
						span4_check.style.display = 'none';
						span5.style.display = 'none';
						span5_br.style.display = 'none';
						span5_check.style.display = 'none';
						span6.style.display = 'none';
						span6_br.style.display = 'none';
						span6_check.style.display = 'none';

						ul.appendChild(li1);
						ul.appendChild(li2);
						ul.appendChild(li3);
						page.appendChild(ul);


						if (!lib.config.asset_toggle_off) {
							span1.toggle();
						}
					}());
					(function () {
						var norow2 = function () {
							var node = currentrow1;
							if (!node) return false;
							return node.innerHTML == '横置' || node.innerHTML == '翻面' || node.innerHTML == '换人' || node.innerHTML == '复活';
						};
						var checkCheat = function () {
							if (norow2()) {
								for (var i = 0; i < row2.childElementCount; i++) {
									row2.childNodes[i].classList.remove('selectedx');
									row2.childNodes[i].classList.add('unselectable');
								}
							}
							else {
								for (var i = 0; i < row2.childElementCount; i++) {
									row2.childNodes[i].classList.remove('unselectable');
								}
							}
							if (currentrow1 && currentrow1.innerHTML == '复活') {
								for (var i = 0; i < row3.childNodes.length; i++) {
									if (row3.childNodes[i].dead) {
										row3.childNodes[i].style.display = '';
									}
									else {
										row3.childNodes[i].style.display = 'none';
										row3.childNodes[i].classList.remove('glow');
									}
									row3.childNodes[i].classList.remove('unselectable');
								}
							}
							else {
								for (var i = 0; i < row3.childElementCount; i++) {
									if (currentrow1 && currentrow1.innerHTML == '换人' && row3.childNodes[i].link == game.me) {
										row3.childNodes[i].classList.add('unselectable');
									}
									else {
										row3.childNodes[i].classList.remove('unselectable');
									}
									if (!row3.childNodes[i].dead) {
										row3.childNodes[i].style.display = '';
									}
									else {
										row3.childNodes[i].style.display = 'none';
										row3.childNodes[i].classList.remove('glow');
									}
								}
							}
							if (currentrow1 && (currentrow2 || norow2()) && row3.querySelector('.glow')) {
								cheatButton.classList.add('glowing');
								return true;
							}
							else {
								cheatButton.classList.remove('glowing');
								return false;
							}
						}
						cheatButton.listen(function () {
							if (checkCheat()) {
								var num;
								if (currentrow2) {
									switch (currentrow2.innerHTML) {
										case '一': num = 1; break;
										case '二': num = 2; break;
										case '三': num = 3; break;
										case '四': num = 4; break;
										case '五': num = 5; break;
									}
								}
								var targets = [];
								var buttons = row3.querySelectorAll('.glow');
								for (var i = 0; i < buttons.length; i++) {
									targets.push(buttons[i].link);
								}
								while (targets.length) {
									var target = targets.shift();
									switch (currentrow1.innerHTML) {
										case '伤害': target.damage(num, 'nosource'); break;
										case '回复': target.recover(num, 'nosource'); break;
										case '摸牌': target.draw(num); break;
										case '弃牌': target.discard(target.getCards('he').randomGets(num)); break;
										case '横置': target.link(); break;
										case '翻面': target.turnOver(); break;
										case '复活': target.revive(target.maxHp); break;
										case '换人': {
											if (_status.event.isMine()) {
												if (!ui.auto.classList.contains('hidden')) {
													setTimeout(function () {
														ui.click.auto();
														setTimeout(function () {
															ui.click.auto();
															game.swapPlayer(target);
														}, 500);
													});
												}
											}
											else {
												game.swapPlayer(target);
											}
											break;
										}
									}
								}
								if (ui.coin) {
									game.changeCoin(-20);
								}
								clickContainer.call(menuContainer);
							}
						});

						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', '控制', start.firstChild, clickMode);
						node.link = page;
						node.type = 'cheat';
						page.classList.add('menu-sym');

						var currentrow1 = null;
						var row1 = ui.create.div('.menu-cheat', page);
						var clickrow1 = function () {
							if (this.classList.contains('unselectable')) return;
							if (currentrow1 == this) {
								this.classList.remove('selectedx');
								currentrow1 = null;
							}
							else {
								this.classList.add('selectedx');
								if (currentrow1) {
									currentrow1.classList.remove('selectedx');
								}
								currentrow1 = this;
								if (this.innerHTML == '换人') {
									for (var i = 0; i < row3.childNodes.length; i++) {
										row3.childNodes[i].classList.remove('glow');
									}
								}
							}
							checkCheat();
						};
						var nodedamage = ui.create.div('.menubutton', '伤害', row1, clickrow1);
						var noderecover = ui.create.div('.menubutton', '回复', row1, clickrow1);
						var nodedraw = ui.create.div('.menubutton', '摸牌', row1, clickrow1);
						var nodediscard = ui.create.div('.menubutton', '弃牌', row1, clickrow1);
						var nodelink = ui.create.div('.menubutton', '横置', row1, clickrow1);
						var nodeturnover = ui.create.div('.menubutton', '翻面', row1, clickrow1);
						var noderevive = ui.create.div('.menubutton', '复活', row1, clickrow1);
						var nodereplace = ui.create.div('.menubutton', '换人', row1, clickrow1);
						if (lib.config.mode != 'identity' && lib.config.mode != 'guozhan' && lib.config.mode != 'doudizhu') {
							nodereplace.classList.add('unselectable');
						}

						var currentrow2 = null;
						var row2 = ui.create.div('.menu-cheat', page);
						var clickrow2 = function () {
							if (this.classList.contains('unselectable')) return;
							if (currentrow2 == this) {
								this.classList.remove('selectedx');
								currentrow2 = null;
							}
							else {
								this.classList.add('selectedx');
								if (currentrow2) {
									currentrow2.classList.remove('selectedx');
								}
								currentrow2 = this;
							}
							checkCheat();
						};
						var nodex1 = ui.create.div('.menubutton', '一', row2, clickrow2);
						var nodex2 = ui.create.div('.menubutton', '二', row2, clickrow2);
						var nodex3 = ui.create.div('.menubutton', '三', row2, clickrow2);
						var nodex4 = ui.create.div('.menubutton', '四', row2, clickrow2);
						var nodex5 = ui.create.div('.menubutton', '五', row2, clickrow2);

						var row3 = ui.create.div('.menu-buttons.leftbutton.commandbutton', page);
						row3.style.marginTop = '3px';
						var clickrow3 = function () {
							if (this.classList.contains('unselectable')) return;
							this.classList.toggle('glow');
							if (currentrow1 && currentrow1.innerHTML == '换人' && this.classList.contains('glow')) {
								if (this.link == game.me) {
									this.classList.remove('glow');
								}
								for (var i = 0; i < row3.childElementCount; i++) {
									if (row3.childNodes[i] != this) {
										row3.childNodes[i].classList.remove('glow');
									}
								}
							}
							checkCheat();
						};
						menuUpdates.push(function () {
							if (_status.video || _status.connectMode) {
								node.classList.add('off');
								if (node.classList.contains('active')) {
									node.classList.remove('active');
									node.link.remove();
									active = start.firstChild.firstChild;
									active.classList.add('active');
									rightPane.appendChild(active.link);
								}

								page.remove();
								cheatButton.remove();
								if (_status.video) node.remove();
								return;
							}
							var list = [];
							for (var i = 0; i < game.players.length; i++) {
								if (lib.character[game.players[i].name] || game.players[i].name1) {
									list.push(game.players[i]);
								}
							}
							for (var i = 0; i < game.dead.length; i++) {
								if (lib.character[game.dead[i].name] || game.dead[i].name1) {
									list.push(game.dead[i]);
								}
							}
							if (list.length) {
								row1.show();
								row2.show();
								row3.innerHTML = '';
								var buttons = ui.create.buttons(list, 'player', row3, true);
								for (var i = 0; i < buttons.length; i++) {
									buttons[i].listen(clickrow3);
									if (game.dead.contains(buttons[i].link)) {
										buttons[i].dead = true;
									}
								}
								checkCheat();
							}
							else {
								row1.hide();
								row2.hide();
							}
							if (lib.config.mode == 'identity' || lib.config.mode == 'guozhan' || lib.config.mode == 'doudizhu') {
								if (game.notMe || (game.me && (game.me._trueMe || game.hasPlayer(function (current) {
									return current._trueMe == game.me;
								}))) || !game.phaseNumber || _status.qianlidanji) {
									nodereplace.classList.add('unselectable');
								}
								else if (_status.event.isMine() && ui.auto.classList.contains('hidden')) {
									nodereplace.classList.add('unselectable');
								}
								else {
									nodereplace.classList.remove('unselectable');
								}
							}
							if (game.dead.length == 0) {
								noderevive.classList.add('unselectable');
							}
							else {
								noderevive.classList.remove('unselectable');
							}
							checkCheat();
						});
					}());
					(function () {
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', '命令', start.firstChild, clickMode);
						ui.commandnode = node;
						node.type = 'cmd';
						node.link = page;
						page.classList.add('menu-sym');
						menuUpdates.push(function () {
							if (_status.connectMode) {
								node.classList.add('off');
								if (node.classList.contains('active')) {
									node.classList.remove('active');
									node.link.remove();
									active = start.firstChild.firstChild;
									active.classList.add('active');
									rightPane.appendChild(active.link);
								}
							}
						});
						var text = document.createElement('div');
						text.style.width = '194px';
						text.style.height = '124px';
						text.style.padding = '3px';
						text.style.borderRadius = '2px';
						text.style.boxShadow = 'rgba(0, 0, 0, 0.2) 0 0 0 1px';
						text.style.textAlign = 'left';
						text.style.webkitUserSelect = 'initial';
						text.style.overflow = 'scroll';
						text.style.position = 'absolute';
						text.style.left = '30px';
						text.style.top = '50px';
						text.style.wordBreak = 'break-all';
						var pre = ui.create.node('pre.fullsize', text);
						pre.style.margin = 0;
						pre.style.padding = 0;
						pre.style.position = 'relative';
						lib.setScroll(pre);
						page.appendChild(text);

						// var caption=ui.create.div('','输入命令',page);
						// caption.style.margin='6px';
						// caption.style.position='absolute';
						// caption.style.width='120px';
						// caption.style.top='129px';
						// caption.style.left='64px';
						var text2 = document.createElement('input');
						text2.style.width = '200px';
						text2.style.height = '20px';
						text2.style.padding = '0';
						text2.style.position = 'absolute';
						text2.style.top = '15px';
						text2.style.left = '30px';
						text2.style.resize = 'none';
						text2.style.border = 'none';
						text2.style.borderRadius = '2px';
						text2.style.boxShadow = 'rgba(0, 0, 0, 0.2) 0 0 0 1px';
						var g = {};
						var logs = [];
						var logindex = -1;
						var cheat = lib.cheat;
						var runCommand = function (e) {
							if (text2.value && !['up', 'down'].contains(text2.value)) {
								logindex = -1;
								logs.unshift(text2.value);
							}
							if (text2.value == 'cls') {
								pre.innerHTML = '';
								text2.value = '';
							}
							else if (text2.value == 'up') {
								if (logindex + 1 < logs.length) {
									text2.value = logs[++logindex];
								}
								else {
									text2.value = '';
								}
							}
							else if (text2.value == 'down') {
								if (logindex >= 0) {
									logindex--;
									if (logindex < 0) {
										text2.value = '';
									}
									else {
										text2.value = logs[logindex];
									}
								}
								else {
									text2.value = '';
								}
							}
							else if (text2.value.indexOf('无天使') != -1 && (text2.value.indexOf('无神佛') != -1 || text2.value.indexOf('无神') != -1 && text2.value.indexOf('无佛') != -1)) {
								game.print('密码正确！欢迎来到死后世界战线！');
								_status.keyVerified = true;
								text2.value = '';
							}
							else {
								if (!game.observe && !game.online) {
									try {
										var result = eval(text2.value);
										game.print(result);
									}
									catch (e) {
										game.print(e);
									}
								}
								text2.value = '';
							}
						}
						text2.addEventListener('keydown', function (e) {
							if (e.keyCode == 13) {
								runCommand();
							}
							else if (e.keyCode == 38) {
								if (logindex + 1 < logs.length) {
									text2.value = logs[++logindex];
								}
							}
							else if (e.keyCode == 40) {
								if (logindex >= 0) {
									logindex--;
									if (logindex < 0) {
										text2.value = '';
									}
									else {
										text2.value = logs[logindex];
									}
								}
							}
						});
						page.appendChild(text2);
						game.print = function () {
							var textstr = '';
							for (var i = 0; i < arguments.length; i++) {
								if (get.is.object(arguments[i])) {
									var argi = get.stringify(arguments[i]);
									if (argi && argi.length < 5000) {
										textstr += argi;
									}
									else {
										textstr += arguments[i].toString();
									}
								}
								else {
									textstr += arguments[i];
								}
								if (i < arguments.length - 1) {
									textstr += ' ';
								}
							}
							textstr += '<br>';
							pre.innerHTML += textstr;
							text.scrollTop = text.scrollHeight;
						}
						if (_status.toprint) {
							for (var i = 0; i < _status.toprint.length; i++) {
								game.print.apply(this, _status.toprint[i]);
							}
							delete _status.toprint;
						}
						runButton.listen(runCommand);
						clearButton.listen(function () {
							pre.innerHTML = '';
						});
					}());
					(function () {
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', '战绩', start.firstChild, clickMode);
						node.type = 'rec';
						node.link = page;
						page.style.paddingBottom = '10px';
						var reset = function () {
							if (this.innerHTML == '重置') {
								this.innerHTML = '确定';
								var that = this;
								setTimeout(function () {
									that.innerHTML = '重置';
								}, 1000);
							}
							else {
								this.parentNode.previousSibling.remove();
								this.parentNode.remove();
								lib.config.gameRecord[this.parentNode.link] = { data: {} };
								game.saveConfig('gameRecord', lib.config.gameRecord);
							}
						}
						for (var i = 0; i < lib.config.all.mode.length; i++) {
							if (!lib.config.gameRecord[lib.config.all.mode[i]]) continue;
							if (lib.config.gameRecord[lib.config.all.mode[i]].str) {
								ui.create.div('.config.indent', lib.translate[lib.config.all.mode[i]], page).style.marginBottom = '-5px';
								var item = ui.create.div('.config.indent', lib.config.gameRecord[lib.config.all.mode[i]].str + '<span>重置</span>', page);
								item.style.height = 'auto';
								item.lastChild.addEventListener('click', reset);
								item.lastChild.classList.add('pointerdiv');
								item.link = lib.config.all.mode[i];
							}
						}
					}());
					(function () {
						if (!window.indexedDB || window.nodb) return;
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', '录像', start.firstChild, clickMode);
						node.type = 'video';
						node.link = page;

						var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
						lib.videos = [];
						store.openCursor().onsuccess = function (e) {
							var cursor = e.target.result;
							if (cursor) {
								lib.videos.push(cursor.value);
								cursor.continue();
							}
							else {
								lib.videos.sort(function (a, b) {
									return parseInt(b.time) - parseInt(a.time);
								});
								var clickcapt = function () {
									var current = this.parentNode.querySelector('.videonode.active');
									if (current && current != this) {
										current.classList.remove('active');
									}
									if (this.classList.toggle('active')) {
										playButton.show();
										deleteButton.show();
										saveButton.show();
									}
									else {
										playButton.hide();
										deleteButton.hide();
										saveButton.hide();
									}
								};
								var staritem = function () {
									this.parentNode.classList.toggle('starred');
									var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
									if (this.parentNode.classList.contains('starred')) {
										this.parentNode.link.starred = true;
									}
									else {
										this.parentNode.link.starred = false;
									}
									store.put(this.parentNode.link);
								}
								var createNode = function (video, before) {
									var node = ui.create.div('.videonode.menubutton.large', clickcapt);
									node.link = video;
									var nodename1 = ui.create.div('.menubutton.videoavatar', node);
									nodename1.setBackground(video.name1, 'character');
									if (video.name2) {
										var nodename2 = ui.create.div('.menubutton.videoavatar2', node);
										nodename2.setBackground(video.name2, 'character');
									}
									var date = new Date(video.time);
									var str = date.getFullYear() + '.' + (date.getMonth() + 2) + '.' + (date.getDay() + 1) + ' ' +
										date.getHours() + ':';
									var minutes = date.getMinutes();
									if (minutes < 10) {
										str += '0';
									}
									str += minutes;
									ui.create.div('.caption', video.name[0], node);
									ui.create.div('.text', str + '<br>' + video.name[1], node);
									if (video.win) {
										ui.create.div('.victory', '胜', node);
									}

									if (before) {
										page.insertBefore(node, page.firstChild);
									}
									else {
										page.appendChild(node);
									}
									ui.create.div('.video_star', '★', node, staritem);
									if (video.starred) {
										node.classList.add('starred');
									}
								}
								for (var i = 0; i < lib.videos.length; i++) {
									createNode(lib.videos[i]);
								}
								ui.create.videoNode = createNode;
								var importVideoNode = ui.create.div('.config.switcher.pointerspan',
									'<span class="underlinenode slim ">导入录像...</span>', function () {
										this.nextSibling.classList.toggle('hidden');
									}, page);
								importVideoNode.style.marginLeft = '12px';
								importVideoNode.style.marginTop = '3px';
								var importVideo = ui.create.div('.config.hidden', page);
								importVideo.style.whiteSpace = 'nowrap';
								importVideo.style.marginBottom = '80px';
								importVideo.style.marginLeft = '13px';
								importVideo.style.width = 'calc(100% - 30px)';
								importVideo.innerHTML = '<input type="file" style="width:calc(100% - 40px)">' +
									'<button style="width:40px">确定</button>';
								importVideo.lastChild.onclick = function () {
									var fileToLoad = importVideo.firstChild.files[0];
									var fileReader = new FileReader();
									fileReader.onload = function (fileLoadedEvent) {
										var data = fileLoadedEvent.target.result;
										if (!data) return;
										try {
											data = JSON.parse(lib.init.decode(data));
										}
										catch (e) {
											console.log(e);
											alert('导入失败');
											return;
										}
										var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
										var videos = lib.videos.slice(0);
										for (var i = 0; i < videos.length; i++) {
											if (videos[i].starred) {
												videos.splice(i--, 1);
											}
										}
										for (var deletei = 0; deletei < 5; deletei++) {
											if (videos.length >= parseInt(lib.config.video) && videos.length) {
												var toremove = videos.pop();
												lib.videos.remove(toremove);
												store.delete(toremove.time);
												for (var i = 0; i < page.childNodes.length; i++) {
													if (page.childNodes[i].link == toremove) {
														page.childNodes[i].remove();
														break;
													}
												}
											}
											else {
												break;
											}
										}
										for (var i = 0; i < lib.videos.length; i++) {
											if (lib.videos[i].time == data.time) {
												alert('录像已存在');
												return;
											}
										}
										lib.videos.unshift(data);
										store.put(data);
										createNode(data, true);
									};
									fileReader.readAsText(fileToLoad, "UTF-8");
								}

								playButton.listen(function () {
									var current = this.parentNode.querySelector('.videonode.active');
									if (current) {
										game.playVideo(current.link.time, current.link.mode);
									}
								});
								deleteButton.listen(function () {
									var current = this.parentNode.querySelector('.videonode.active');
									if (current) {
										lib.videos.remove(current.link);
										var store = lib.db.transaction(['video'], 'readwrite').objectStore('video');
										store.delete(current.link.time);
										current.remove();
									}
								});
								saveButton.listen(function () {
									var current = this.parentNode.querySelector('.videonode.active');
									if (current) {
										game.export(lib.init.encode(JSON.stringify(current.link)),
											'无名杀 - 录像 - ' + current.link.name[0] + ' - ' + current.link.name[1]);
									}
								});

								ui.updateVideoMenu = function () {
									var active = start.firstChild.querySelector('.active');
									if (active) {
										active.classList.remove('active');
										active.link.remove();
									}
									node.classList.add('active');
									rightPane.appendChild(page);
									playButton.style.display = '';
									deleteButton.style.display = '';
									saveButton.style.display = '';
								}
							}
						};
					}());


					for (var i in lib.help) {
						var page = ui.create.div('');
						var node = ui.create.div('.menubutton.large', i, start.firstChild, clickMode);
						node.type = 'help';
						node.link = page;
						node.style.display = 'none';
						page.classList.add('menu-help');
						page.innerHTML = lib.help[i];
					}

					if (!connectMenu) {
						var node = ui.create.div('.menubutton.large', '帮助', start.firstChild, function () {
							var activex = start.firstChild.querySelector('.active');
							if (this.innerHTML == '帮助') {
								cheatButton.style.display = 'none';
								runButton.style.display = 'none';
								clearButton.style.display = 'none';
								playButton.style.display = 'none';
								saveButton.style.display = 'none';
								deleteButton.style.display = 'none';

								this.innerHTML = '返回';
								for (var i = 0; i < start.firstChild.childElementCount; i++) {
									var nodex = start.firstChild.childNodes[i];
									if (nodex == node) continue;
									if (nodex.type == 'help') {
										nodex.style.display = '';
										if (activex && activex.type != 'help') {
											activex.classList.remove('active');
											activex.link.remove();
											activex = null;
											nodex.classList.add('active');
											rightPane.appendChild(nodex.link);
										}
									}
									else {
										nodex.style.display = 'none';
									}
								}
							}
							else {
								this.innerHTML = '帮助';
								for (var i = 0; i < start.firstChild.childElementCount; i++) {
									var nodex = start.firstChild.childNodes[i];
									if (nodex == node) continue;
									if (nodex.type != 'help') {
										nodex.style.display = '';
										if (activex && activex.type == 'help') {
											activex.classList.remove('active');
											activex.link.remove();
											activex = null;
											clickMode.call(nodex);
										}
									}
									else {
										nodex.style.display = 'none';
									}
								}
							}
						});
					}

					var active = start.firstChild.querySelector('.active');
					if (!active) {
						active = start.firstChild.firstChild;
						active.classList.add('active');
					}
					rightPane.appendChild(active.link);
				}());

				if (menuTimeout) {
					clearTimeout(menuTimeout);
					delete window.resetExtension;
					localStorage.removeItem(lib.configprefix + 'disable_extension', true);
				}
			},
			table: function () {
				var str, row, col, position, position2, fixed, style, divposition;
				for (var i = 0; i < arguments.length; i++) {
					if (typeof arguments[i] == 'string') str = arguments[i];
					else if (typeof arguments[i] == 'number') {
						if (typeof row == 'number') {
							if (typeof col == 'number') position2 = arguments[i];
							else col = arguments[i];
						}
						else row = arguments[i];
					}
					else if (get.objtype(arguments[i]) == 'div' ||
						get.objtype(arguments[i]) == 'table' ||
						get.objtype(arguments[i]) == 'tr' ||
						get.objtype(arguments[i]) == 'td' ||
						get.objtype(arguments[i]) == 'body') position = arguments[i];
					else if (typeof arguments[i] == 'boolean') fixed = arguments[i];
					else if (get.itemtype(arguments[i]) == 'divposition') divposition = arguments[i];
					else if (typeof arguments[i] == 'object') style = arguments[i];
				}
				if (str == undefined) str = '';
				var node = document.createElement('table');
				for (var i = 0; i < str.length; i++) {
					if (str[i] == '.') {
						if (node.className.length != 0) {
							node.className += ' ';
						}
						while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
							node.className += str[i + 1];
							i++;
						}
					}
					else if (str[i] == '#') {
						while (str[i + 1] != '.' && str[i + 1] != '#' && i + 1 < str.length) {
							node.id += str[i + 1];
							i++;
						}
					}
				}
				var tr, td;
				for (var i = 0; i < row; i++) {
					tr = document.createElement('tr');
					if (fixed) tr.style.height = (100 / row) + '%';
					node.appendChild(tr);
					for (var j = 0; j < col; j++) {
						td = document.createElement('td');
						tr.appendChild(td);
					}
				}
				if (position) {
					if (typeof position2 == 'number' && position.childNodes.length > position2) {
						position.insertBefore(node, position.childNodes[position2]);
					}
					else {
						position.appendChild(node);
					}
				}
				return node;
			},
			giveup: function () {
				if (ui.giveup) return;
				if (!lib.config.show_giveup) return;
				ui.giveup = ui.create.system('投降', function () {
					var player = game.me;
					this.remove();
					if (game.online) {
						game.send('giveup', player);
					}
					else {
						_status.event.next.length = 0;
						game.createEvent('giveup', false).setContent(function () {
							game.log(player, '投降');
							player.popup('投降');
							player.die('nosource');
						}).player = player;
					}
					if (_status.paused && _status.imchoosing && !_status.auto) {
						ui.click.auto();
					}
				}, true);
			},
			groupControl: function (dialog) {
				return ui.create.control('wei', 'shu', 'wu', 'qun', 'western', 'key', function (link, node) {
					if (link == '全部') {
						dialog.currentcapt = '';
						dialog.currentgroup = '';
						for (var i = 0; i < dialog.buttons.length; i++) {
							dialog.buttons[i].style.display = '';
						}
					}
					else {
						if (node.classList.contains('thundertext')) {
							dialog.currentgroup = null;
							dialog.currentgroupnode = null;
							node.classList.remove('thundertext');
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
						else {
							if (dialog.currentgroupnode) {
								dialog.currentgroupnode.classList.remove('thundertext');
							}
							dialog.currentgroup = link;
							dialog.currentgroupnode = node;
							node.classList.add('thundertext');
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.buttons[i].group != link ||
									(dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt))) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
					}
				});
			},
			cardDialog: function () {
				var args = ['thisiscard'];
				for (var i = 0; i < arguments.length; i++) {
					args.push(arguments[i]);
				}
				return ui.create.characterDialog.apply(this, args);
			},
			characterDialog2: function (filter) {
				var list = [];
				for (var i in lib.character) {
					if (lib.character[i][4].contains('minskin')) continue;
					if (lib.character[i][4].contains('boss') || lib.character[i][4].contains('hiddenboss')) {
						if (lib.config.mode == 'boss') continue;
						if (!lib.character[i][4].contains('bossallowed')) continue;
					}

					if (lib.character[i][4].contains('stonehidden')) continue;
					if (lib.config.banned.contains(i)) continue;
					if (filter && filter(i)) continue;
					list.push(i);
				}
				var dialog = ui.create.dialog('hidden');
				dialog.classList.add('noupdate');
				dialog.classList.add('scroll1');
				dialog.classList.add('scroll2');
				dialog.classList.add('scroll3');
				list.sort(lib.sort.character);
				dialog.classList.add('character');
				dialog.classList.add('choose-character');
				var getPack = function (name) {
					for (var i in lib.characterPack) {
						if (lib.characterPack[i][name]) return i;
					}
					return null;
				}
				var packs = {};
				var packnode = ui.create.div('.packnode', dialog);
				lib.setScroll(packnode);
				var clickCapt = function () {
					var active = this.parentNode.querySelector('.active');
					if (active) {
						active.classList.remove('active');
					}
					this.classList.add('active');
					for (var i = 0; i < dialog.buttons.length; i++) {
						if (this.pack && !this.pack.contains(dialog.buttons[i].link)) {
							dialog.buttons[i].classList.add('nodisplay');
						}
						else {
							dialog.buttons[i].classList.remove('nodisplay');
						}
					}
				}
				var createNode = function (packname) {
					var translate;
					var pack = null;
					if (packname == '最近') {
						pack = get.config('recentCharacter') || [];
					}
					else if (packname == '收藏') {
						pack = lib.config.favouriteCharacter;
					}
					var node = ui.create.div('.dialogbutton.menubutton.large', packname, packnode, clickCapt);
					node.pack = pack;
					return node;
				}
				dialog.add([list, 'character']);
				var bool = true;
				var node;
				var recent = get.config('recentCharacter');
				if (recent && recent.length) {
					node = createNode('最近');
					if (lib.config.character_dialog_tool == '最近') {
						clickCapt.call(node);
						bool = false;
					}
				}
				if (lib.config.favouriteCharacter.length) {
					node = createNode('收藏');
					if (lib.config.character_dialog_tool == '收藏') {
						clickCapt.call(node);
						bool = false;
					}
				}
				var node = createNode('全部');
				if (lib.config.character_dialog_tool == 'all') {
					clickCapt.call(node);
					bool = false;
				}
				if (bool) {
					clickCapt.call(packnode.firstChild);
				}

				var node = ui.create.div('.dialogbutton.menubutton.large', '筛选', packnode);
				return dialog;
			},
			characterDialog: function () {
				// if(lib.config.character_dialog_style=='newstyle'){
				//     for(var i=0;i<arguments.length;i++){
				//      			if(arguments[i]=='thisiscard'){
				//      						 break;
				//      			}
				//     }
				//     if(i==arguments.length){
				//      			return ui.create.characterDialog2.apply(this,arguments);
				//     }
				// }
				var filter, str, noclick, thisiscard, seperate, expandall, onlypack, heightset, precharacter;
				for (var i = 0; i < arguments.length; i++) {
					if (arguments[i] === 'thisiscard') {
						thisiscard = true;
					}
					else if (arguments[i] === 'expandall') {
						expandall = true;
					}
					else if (arguments[i] === 'heightset') {
						heightset = true;
					}
					else if (arguments[i] == 'precharacter') {
						precharacter = true;
					}
					else if (typeof arguments[i] == 'string' && arguments[i].indexOf('onlypack:') == 0) {
						onlypack = arguments[i].slice(9);
					}
					else if (typeof arguments[i] == 'object' && typeof arguments[i].seperate == 'function') {
						seperate = arguments[i].seperate;
					}
					else if (typeof arguments[i] === 'string') {
						str = arguments[i];
					}
					else if (typeof arguments[i] === 'function') {
						filter = arguments[i];
					}
					else if (typeof arguments[i] == 'boolean') {
						noclick = arguments[i];
					}
				}
				var list = [];
				var dialog;
				var node = ui.create.div('.caption.pointerspan');
				if (get.is.phoneLayout()) {
					node.style.fontSize = '30px';
				}
				var namecapt = [];
				var getCapt = function (str) {
					var capt;
					//48成员特别筛选组
					if (str.includes('48')) {
						capt = str.substr(str.lastIndexOf('_') + 1, 5);
						return capt;
					} else if (str.includes('_SB')) {
						capt = '丝芭';
						return capt;
					} else if (str.indexOf('_') == -1) {
						capt = str[0];
					} else {
						capt = str[str.lastIndexOf('_') + 1];
					}
					capt = capt.toLowerCase();
					if (!/[a-z]/i.test(capt)) {
						capt = '自定义';
					}
					return capt;
				}
				if (thisiscard) {
					for (var i in lib.card) {
						if (!lib.translate[i + '_info']) continue;
						if (filter && filter(i)) continue;
						list.push(['', get.translation(lib.card[i].type), i]);
						if (namecapt.indexOf(getCapt(i)) == -1) {
							namecapt.push(getCapt(i));
						}
					}
				}
				else {
					for (var i in lib.character) {
						if (lib.character[i][4].contains('minskin')) continue;
						if (lib.character[i][4].contains('boss') || lib.character[i][4].contains('hiddenboss')) {
							if (lib.config.mode == 'boss') continue;
							if (!lib.character[i][4].contains('bossallowed')) continue;
						}

						if (lib.character[i][4].contains('stonehidden')) continue;
						if (lib.character[i][4].contains('unseen')) continue;
						if (lib.config.banned.contains(i)) continue;
						if (lib.characterFilter[i] && !lib.characterFilter[i](get.mode())) continue;
						if (filter && filter(i)) continue;
						list.push(i);
						if (namecapt.indexOf(getCapt(i)) == -1) {
							namecapt.push(getCapt(i));
						}
					}
				}
				namecapt.sort(function (a, b) {
					return a > b ? 1 : -1;
				});
				if (!thisiscard) {
					namecapt.remove('自定义');
					namecapt.push('newline');
					for (var i in lib.characterDialogGroup) {
						namecapt.push(i);
					}
				}
				var newlined = false;
				var newlined2;
				var packsource;
				var clickCapt = function (e) {
					if (_status.dragged) return;
					if (dialog.currentcapt2 == '最近' && dialog.currentcaptnode2 != this && !dialog.currentcaptnode2.inited) {
						dialog.currentcapt2 = null;
						dialog.currentcaptnode2.classList.remove('thundertext');
						dialog.currentcaptnode2.inited = true;
						dialog.currentcaptnode2 = null;
					}
					if (this.alphabet) {
						if (this.classList.contains('thundertext')) {
							dialog.currentcapt = null;
							dialog.currentcaptnode = null;
							this.classList.remove('thundertext');
							if (this.touchlink) {
								this.touchlink.classList.remove('active');
							}
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
						else {
							if (dialog.currentcaptnode) {
								dialog.currentcaptnode.classList.remove('thundertext');
								if (dialog.currentcaptnode.touchlink) {
									dialog.currentcaptnode.touchlink.classList.remove('active');
								}
							}
							dialog.currentcapt = this.link;
							dialog.currentcaptnode = this;
							this.classList.add('thundertext');
							if (this.touchlink) {
								this.touchlink.classList.add('active');
							}
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
					}
					else {
						if (newlined2) {
							newlined2.style.display = 'none';
							if (!packsource.onlypack) {
								packsource.classList.remove('thundertext');
								if (!get.is.phoneLayout() || !lib.config.filternode_button) {
									packsource.innerHTML = '武将包';
								}
							}
						}
						if (this.classList.contains('thundertext')) {
							dialog.currentcapt2 = null;
							dialog.currentcaptnode2 = null;
							this.classList.remove('thundertext');
							if (this.touchlink) {
								this.touchlink.classList.remove('active');
							}
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
						else {
							if (dialog.currentcaptnode2) {
								dialog.currentcaptnode2.classList.remove('thundertext');
								if (dialog.currentcaptnode2.touchlink) {
									dialog.currentcaptnode2.touchlink.classList.remove('active');
								}
							}
							dialog.currentcapt2 = this.link;
							dialog.currentcaptnode2 = this;
							this.classList.add('thundertext');
							if (this.touchlink) {
								this.touchlink.classList.add('active');
							}
							else if (this.parentNode == newlined2) {
								packsource.innerHTML = this.innerHTML;
								packsource.classList.add('thundertext');
							}
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.currentgroup && dialog.buttons[i].group != dialog.currentgroup) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									if (dialog.buttons[i].activate) {
										dialog.buttons[i].activate();
									}
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
					}
					if (dialog.seperate) {
						for (var i = 0; i < dialog.seperate.length; i++) {
							if (!dialog.seperate[i].nextSibling.querySelector('.button:not(.nodisplay)')) {
								dialog.seperate[i].style.display = 'none';
								dialog.seperate[i].nextSibling.style.display = 'none';
							}
							else {
								dialog.seperate[i].style.display = '';
								dialog.seperate[i].nextSibling.style.display = '';
							}
						}
					}
					if (filternode) {
						if (filternode.querySelector('.active')) {
							packsource.classList.add('thundertext');
						}
						else {
							packsource.classList.remove('thundertext');
						}
					}
					if (e) e.stopPropagation();
				};
				for (i = 0; i < namecapt.length; i++) {
					if (namecapt[i] == 'newline') {
						newlined = document.createElement('div');
						newlined.style.marginTop = '5px';
						newlined.style.display = 'block';
						// newlined.style.fontFamily='xinwei';
						if (get.is.phoneLayout()) {
							newlined.style.fontSize = '32px';
						}
						else {
							newlined.style.fontSize = '22px';
						}
						newlined.style.textAlign = 'center';
						node.appendChild(newlined);
					}
					else if (newlined) {
						var span = ui.create.div('.tdnode.pointerdiv.shadowed.reduce_radius');
						span.style.margin = '3px';
						span.style.width = 'auto';
						span.innerHTML = ' ' + namecapt[i].toUpperCase() + ' ';
						span.link = namecapt[i];
						span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
						newlined.appendChild(span);
						node[namecapt[i]] = span;
						if (namecapt[i] == '收藏') {
							span._nature = 'fire';
						}
						else {
							span._nature = 'wood';
						}
					}
					else {
						var span = document.createElement('span');
						span.innerHTML = ' ' + namecapt[i].toUpperCase() + ' ';
						span.link = namecapt[i];
						span.alphabet = true;
						span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
						node.appendChild(span);
					}
				}
				if (!thisiscard) {
					var groups = get.mode() == 'SNH48' ? ['S', 'N', 'H', 'X', 'B', 'E', 'J', 'G', 'N3', 'Z', 'C', 'K', 'guan'] : ['wei', 'shu', 'wu', 'qun'];
					var bool1 = false;
					var bool2 = false;
					var bool3 = (get.is.guozhanMode() && _status.forceKey != true && get.config('onlyguozhan'));
					for (var i in lib.character) {
						if (lib.character[i][1] == 'shen') {
							bool1 = true;
						}
						if (bool3 || lib.character[i][1] == 'key') {
							bool2 = true;
						}
						if (bool1 && bool2) break;
					}
					if (bool1) groups.add('shen');
					if (bool2 && !bool3) groups.add('key');
					var natures = ['water', 'soil', 'wood', 'metal'];
					var span = document.createElement('span');
					newlined.appendChild(span);
					span.style.margin = '8px';
					var clickGroup = function () {
						if (_status.dragged) return;
						if (dialog.currentcapt2 == '最近' && dialog.currentcaptnode2 != this && !dialog.currentcaptnode2.inited) {
							dialog.currentcapt2 = null;
							dialog.currentcaptnode2.classList.remove('thundertext');
							dialog.currentcaptnode2.inited = true;
							dialog.currentcaptnode2 = null;
						}
						var node = this, link = this.link;
						if (node.classList.contains('thundertext')) {
							dialog.currentgroup = null;
							dialog.currentgroupnode = null;
							node.classList.remove('thundertext');
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
						else {
							if (dialog.currentgroupnode) {
								dialog.currentgroupnode.classList.remove('thundertext');
							}
							dialog.currentgroup = link;
							dialog.currentgroupnode = node;
							node.classList.add('thundertext');
							for (var i = 0; i < dialog.buttons.length; i++) {
								if (dialog.currentcapt && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.currentcapt2 && dialog.buttons[i].capt != dialog.getCurrentCapt(dialog.buttons[i].link, dialog.buttons[i].capt, true)) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else if (dialog.buttons[i].group != dialog.currentgroup) {
									dialog.buttons[i].classList.add('nodisplay');
								}
								else {
									dialog.buttons[i].classList.remove('nodisplay');
								}
							}
						}
					};
					for (var i = 0; i < groups.length; i++) {
						var span = ui.create.div('.tdnode.pointerdiv.shadowed.reduce_radius.reduce_margin');
						span.style.margin = '3px';
						newlined.appendChild(span);
						span.innerHTML = get.translation(groups[i]);
						span.link = groups[i];
						span._nature = natures[i];
						span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickGroup);
					}

					var span = document.createElement('span');
					newlined.appendChild(span);
					span.style.margin = '8px';

					packsource = ui.create.div('.tdnode.pointerdiv.shadowed.reduce_radius.reduce_margin');
					packsource.style.margin = '3px';
					newlined.appendChild(packsource);
					var filternode = null;
					var clickCaptNode = function (e) {
						delete _status.filterCharacter;
						ui.window.classList.remove('shortcutpaused');
						filternode.delete();
						filternode.classList.remove('shown');
						clickCapt.call(this.link, e);
					};
					if (get.is.phoneLayout() && lib.config.filternode_button) {
						newlined.style.marginTop = '';
						packsource.innerHTML = '筛选';
						filternode = ui.create.div('.popup-container.filter-character.modenopause');
						ui.create.div(filternode);
						filternode.listen(function (e) {
							if (this.classList.contains('removing')) return;
							delete _status.filterCharacter;
							ui.window.classList.remove('shortcutpaused');
							this.delete();
							this.classList.remove('shown');
							e.stopPropagation();
						});
						for (var i = 0; i < node.childElementCount; i++) {
							if (node.childNodes[i].tagName.toLowerCase() == 'span') {
								node.childNodes[i].style.display = 'none';
								node.childNodes[i].touchlink = ui.create.div(filternode.firstChild, clickCaptNode, '.menubutton.large.capt', node.childNodes[i].innerHTML);
								node.childNodes[i].touchlink.link = node.childNodes[i];
							}
						}
						ui.create.node('br', filternode.firstChild);
					}
					else {
						if (onlypack) {
							packsource.onlypack = true;
							packsource.innerHTML = get.translation(onlypack + '_character_config');
							packsource.style.display = 'none';
							packsource.previousSibling.style.display = 'none';
						}
						else {
							packsource.innerHTML = '武将包';
						}
					}

					newlined2 = document.createElement('div');
					newlined2.style.marginTop = '5px';
					newlined2.style.display = 'none';
					newlined2.style.fontFamily = 'xinwei';
					newlined2.classList.add('pointernode');
					if (get.is.phoneLayout()) {
						newlined2.style.fontSize = '32px';
					}
					else {
						newlined2.style.fontSize = '22px';
					}
					newlined2.style.textAlign = 'center';
					node.appendChild(newlined2);

					packsource.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
						if (packsource.onlypack) return;
						if (_status.dragged) return;
						if (get.is.phoneLayout() && lib.config.filternode_button && filternode) {
							_status.filterCharacter = true;
							ui.window.classList.add('shortcutpaused');
							ui.window.appendChild(filternode);
							ui.refresh(filternode);
							filternode.classList.add('shown');
							var dh = filternode.offsetHeight - filternode.firstChild.offsetHeight;
							if (dh > 0) {
								filternode.firstChild.style.top = (dh / 2) + 'px';
							}
							else {
								filternode.firstChild.style.top = '';
							}
						}
						else {
							if (newlined2.style.display == 'none') {
								newlined2.style.display = 'block';
							}
							else {
								newlined2.style.display = 'none';
							}
						}
					});
					var packlist = [];
					for (var i = 0; i < lib.config.all.characters.length; i++) {
						if (!lib.config.characters.contains(lib.config.all.characters[i])) continue;
						packlist.push(lib.config.all.characters[i]);
					}
					for (var i in lib.characterPack) {
						if (!lib.config.all.characters.contains(i)) {
							packlist.push(i);
						}
					}
					for (var i = 0; i < packlist.length; i++) {
						var span = document.createElement('div');
						span.style.display = 'inline-block';
						span.style.width = 'auto';
						span.style.margin = '5px';
						if (get.is.phoneLayout()) {
							span.style.fontSize = '32px';
						}
						else {
							span.style.fontSize = '22px';
						}
						span.innerHTML = lib.translate[packlist[i] + '_character_config'];
						span.link = packlist[i];
						span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
						newlined2.appendChild(span);
						if (filternode && !onlypack) {
							span.touchlink = ui.create.div(filternode.firstChild, clickCaptNode, '.menubutton.large', span.innerHTML);
							span.touchlink.link = span;
						}
					}
				}

				var groupSort;
				if (thisiscard) {
					groupSort = function (name) {
						var type = lib.card[name[2]].type;
						if (lib.cardType[type]) {
							return lib.cardType[type];
						}
						switch (type) {
							case 'basic': return 0;
							case 'chess': return 1.5;
							case 'trick': return 2;
							case 'delay': return 3;
							case 'equip': return 4;
							case 'zhenfa': return 5;
							default: return 6;
						}
					};
				}
				else {
					groupSort = function (name) {
						if (lib.character[name][1] == 'shen') return -1;
						if (lib.character[name][1] == 'wei') return 0;
						if (lib.character[name][1] == 'shu') return 1;
						if (lib.character[name][1] == 'wu') return 2;
						if (lib.character[name][1] == 'qun') return 3;
						return 4
					}
				}
				list.sort(function (a, b) {
					var del = groupSort(a) - groupSort(b);
					if (del != 0) return del;
					var aa = a, bb = b;
					if (a.indexOf('_') != -1) {
						a = a.slice(a.lastIndexOf('_') + 1);
					}
					if (b.indexOf('_') != -1) {
						b = b.slice(b.lastIndexOf('_') + 1);
					}
					if (a != b) {
						return a > b ? 1 : -1;
					}
					return aa > bb ? 1 : -1;
				});
				dialog = ui.create.dialog('hidden');
				dialog.classList.add('noupdate');
				dialog.classList.add('scroll1');
				dialog.classList.add('scroll2');
				dialog.classList.add('scroll3');
				dialog.addEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', function () {
					_status.clicked2 = true;
				});
				if (heightset) {
					dialog.style.height = ((game.layout == 'long2' || game.layout == 'nova') ? 380 : 350) + 'px';
					dialog._scrollset = true;
				}
				dialog.getCurrentCapt = function (link, capt, noalph) {
					var currentcapt = noalph ? this.currentcapt2 : this.currentcapt;
					if (this.seperatelist && noalph) {
						if (this.seperatelist[currentcapt].contains(link)) return capt;
						return null;
					}
					if (lib.characterDialogGroup[currentcapt]) {
						return lib.characterDialogGroup[currentcapt](link, capt);
					}
					if (currentcapt && currentcapt.includes('48'))
						return this.currentcapt
					if (lib.characterPack[currentcapt]) {
						if (lib.characterPack[currentcapt][link]) {
							return capt;
						}
						return null;
					}
					return this.currentcapt;
				}
				if (str) {
					dialog.add(str);
				}
				dialog.add(node);
				if (thisiscard) {
					if (seperate) {
						seperate = seperate(list);
						dialog.seperate = [];
						dialog.seperatelist = seperate.list;
						if (dialog.seperatelist) {
							newlined = document.createElement('div');
							newlined.style.marginTop = '5px';
							newlined.style.display = 'block';
							newlined.style.fontFamily = 'xinwei';
							if (get.is.phoneLayout()) {
								newlined.style.fontSize = '32px';
							}
							else {
								newlined.style.fontSize = '22px';
							}
							newlined.style.textAlign = 'center';
							node.appendChild(newlined);
							for (var i in dialog.seperatelist) {
								var span = document.createElement('span');
								span.style.margin = '3px';
								span.innerHTML = i;
								span.link = i;
								span.seperate = true;
								span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clickCapt);
								newlined.appendChild(span);
							}
						}
						for (var i in seperate) {
							if (i == 'list') continue;
							var link = '';
							var linkcontent = seperate[i];
							if (i.indexOf('_link:') != -1) {
								link = i.slice(i.indexOf('_link:') + 6);
								i = i.slice(0, i.indexOf('_link:'));
							}
							var nodesep = dialog.add(i);
							nodesep.link = link;
							dialog.seperate.push(nodesep);
							dialog.add([linkcontent, 'vcard'], noclick);
						}
					}
					else {
						dialog.add([list, 'vcard'], noclick);
					}
				}
				else {
					if (precharacter) {
						dialog.add([list, 'precharacter'], noclick);
					}
					else {
						dialog.add([list, 'character'], noclick);
					}
				}
				dialog.add(ui.create.div('.placeholder'));
				for (i = 0; i < dialog.buttons.length; i++) {
					if (thisiscard) {
						dialog.buttons[i].capt = getCapt(dialog.buttons[i].link[2]);
					}
					else {
						dialog.buttons[i].group = lib.character[dialog.buttons[i].link][1];
						dialog.buttons[i].capt = getCapt(dialog.buttons[i].link);
					}
				}
				if (!expandall) {
					if (!thisiscard && (lib.characterDialogGroup[lib.config.character_dialog_tool] ||
						lib.config.character_dialog_tool == '自创')) {
						clickCapt.call(node[lib.config.character_dialog_tool]);
					}
				}
				return dialog;
			},
			dialog: function () {
				var i;
				var hidden = false;
				var notouchscroll = false;
				var forcebutton = false;
				var dialog = ui.create.div('.dialog');
				dialog.contentContainer = ui.create.div('.content-container', dialog);
				dialog.content = ui.create.div('.content', dialog.contentContainer);
				dialog.bar1 = ui.create.div('.bar.top', dialog);
				dialog.bar2 = ui.create.div('.bar.bottom', dialog);
				dialog.buttons = [];
				for (i in lib.element.dialog) {
					dialog[i] = lib.element.dialog[i];
				}
				for (i = 0; i < arguments.length; i++) {
					if (typeof arguments[i] == 'boolean') dialog.static = arguments[i];
					else if (arguments[i] == 'hidden') hidden = true;
					else if (arguments[i] == 'notouchscroll') notouchscroll = true;
					else if (arguments[i] == 'forcebutton') forcebutton = true;
					else dialog.add(arguments[i]);
				}
				if (!hidden) {
					dialog.open();
				}
				if (!lib.config.touchscreen) dialog.contentContainer.onscroll = ui.update;
				if (!notouchscroll) {
					dialog.contentContainer.ontouchstart = ui.click.dialogtouchStart;
					dialog.contentContainer.ontouchmove = ui.click.touchScroll;
					dialog.contentContainer.style.WebkitOverflowScrolling = 'touch';
					dialog.ontouchstart = ui.click.dragtouchdialog;
				}
				if (forcebutton) {
					dialog.forcebutton = true;
					dialog.classList.add('forcebutton');
				}
				return dialog;
			},
			line2: function () {
				var node = ui.create.line.apply(this, arguments);
				node.classList.add('line2');
				return node;
			},
			line: function () {
				var two = false, func;
				var node = ui.create.div('.config');
				for (var i = 0; i < arguments.length; i++) {
					if (typeof arguments[i] == 'string' || typeof arguments[i] == 'number') {
						if (two) ui.create.div('.toggle', node).innerHTML = arguments[i];
						else {
							ui.create.div(node).innerHTML = arguments[i];
							two = true;
						}
					}
					else if (typeof arguments[i] == 'function') func = arguments[i];
				}
				if (func) {
					for (var i = 0; i < node.childNodes.length; i++) node.childNodes[i].listen(func);
				}
				return node;
			},
			switcher: function (name, current, current2) {
				var func;
				var node = ui.create.div('.config');
				ui.create.div(node).innerHTML = get.translation(name + '_config');
				var switcher = ui.create.div('.toggle.pointerdiv', node);
				switcher.name = name;
				for (var i = 0; i < arguments.length; i++) {
					if (typeof arguments[i] == 'function') {
						func = arguments[i]; break;
					}
				}
				if (typeof current == 'string') {
					switcher.link = current;
					switcher.innerHTML = get.translation(current);
					switcher.contentEditable = true;
					switcher.style.webkitUserSelect = 'text';
					switcher.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.editor);
				}
				else if (typeof current == 'object') {
					switcher.link = current2 || current[0];
					switcher.innerHTML = get.translation(switcher.link);
					switcher.choice = current;
					switcher.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.switcher);
				}
				else {
					if (current) {
						switcher.classList.add('on');
					}
					switcher.classList.add('onoff');
					ui.create.div(ui.create.div(switcher));
					switcher.link = current ? true : false;
					switcher.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.toggle);
				}
				if (func) switcher.additionalCommand = func;
				return node;
			},
			caption: function (str, position) {
				var caption = ui.create.div('.caption', position);
				caption.innerHTML = str;
				return caption;
			},
			control: function () {
				var nc = !ui.control.querySelector('div:not(.removing):not(.stayleft)');
				// for(var i=0;i<ui.control.childNodes.length;i++){
				// 	if(ui.control.childNodes[i].classList.contains('removing')){
				// 		var that=ui.control.childNodes[i];
				// 		var width=that.offsetWidth;
				// 		that.style.marginLeft=(-width/2)+'px';
				// 		that.style.marginRight=(-width/2)+'px';
				// 		that.style.transitionDuration=0.8*parseFloat(getComputedStyle(that).opacity)+'s';
				// 	}
				// }
				var i, controls;
				var nozoom = false;
				if (Array.isArray(arguments[0])) controls = arguments[0];
				else controls = arguments;
				var control = ui.create.div('.control');
				ui.control.insertBefore(control, _status.createControl || ui.confirm);
				for (i in lib.element.control) {
					control[i] = lib.element.control[i];
				}
				for (i = 0; i < controls.length; i++) {
					if (typeof controls[i] == 'function') {
						control.custom = controls[i];
					}
					else if (controls[i] == 'nozoom') {
						nozoom = true;
					}
					else if (controls[i] == 'stayleft') {
						control.stayleft = true;
						control.classList.add('stayleft');
					}
					else {
						control.add(controls[i]);
					}
				}
				ui.controls.unshift(control);
				if (nc) {
					ui.control.animate('nozoom', 100);
				}
				// if(ui.control.classList.contains('nozoom')){
				// 	nozoom=true;
				// }
				// if(nozoom){
				// 	control.classList.add('nozoom');
				// }
				if (control.childNodes.length) {
					// if(nozoom||true){
					control.style.transition = 'opacity 0.5s';
					control.animate('controlpressdownx', 500);
					// }
					// else{
					// 	control.style.transition='';
					// 	control.style.transform='scale(0.8)';
					// }
					ui.refresh(control);
					if (!control.stayleft) {
						control.style.transform = 'translateX(-' + (control.offsetWidth / 2) + 'px)';
					}
					control.style.opacity = 1;
					ui.refresh(control);
					control.style.transition = '';
				}

				control.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.control2);

				if (lib.config.button_press) {
					control.addEventListener(lib.config.touchscreen ? 'touchstart' : 'mousedown', function () {
						if (this.classList.contains('disabled')) return;
						this.classList.add('controlpressdown');
						if (typeof this._offset == 'number') {
							this.style.transform = 'translateX(' + this._offset + 'px) scale(0.97)';
						}
					});
					control.addEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', function () {
						this.classList.remove('controlpressdown');
						if (typeof this._offset == 'number') {
							this.style.transform = 'translateX(' + this._offset + 'px)';
						}
					});
				}

				ui.updatec();
				return control;
			},
			confirm: function (str, func) {
				if (ui.confirm && ui.confirm.str == str) {
					return;
				}
				if (str == 'o') {
					if (ui.confirm) {
						ui.confirm.replace('ok');
					}
					else {
						ui.confirm = ui.create.control('ok');
					}
				}
				else if (str == 'oc' || str == 'co') {
					if (ui.confirm) {
						ui.confirm.replace('ok', 'cancel');
					}
					else {
						ui.confirm = ui.create.control('ok', 'cancel');
					}
				}
				else if (str == 'c') {
					if (ui.confirm) {
						ui.confirm.replace('cancel');
					}
					else {
						ui.confirm = ui.create.control('cancel');
					}
				}
				else if (ui.confirm) {
					ui.confirm.close();
					delete ui.confirm;
				}
				if (ui.confirm) {
					ui.confirm.str = str;
					if (func) ui.confirm.custom = func;
					else delete ui.confirm.custom;
				}
			},
			skills: function (skills) {
				var i, same;
				if (ui.skills) {
					if (ui.skills.skills.length == skills.length && ui.skills.style.display != 'none') {
						same = true;
						for (i = 0; i < skills.length; i++) {
							if (ui.skills.skills.contains(skills[i]) == false) {
								same = false;
								break;
							}
						}
					}
					if (same) return;
					ui.skills.close();
					delete ui.skills;
				}
				if (skills == undefined || skills.length == 0) return;
				if (!_status.event.isMine()) {
					_status.noupdatec = true;
				}
				ui.skills = ui.create.control(skills.concat([ui.click.skill]));
				for (var i = 0; i < ui.skills.childNodes.length; i++) {
					ui.skills.childNodes[i].innerHTML = get.skillTranslation(ui.skills.childNodes[i].link, _status.event.player);
				}
				if (!_status.event.isMine()) {
					ui.skills.style.display = 'none';
				}
				else {
					ui.updatec();
				}
				_status.noupdatec = false;
				ui.skills.skills = skills;
				return ui.skills;
			},
			skills2: function (skills) {
				var i, same;
				if (ui.skills2) {
					if (ui.skills2.skills.length == skills.length && ui.skills2.style.display != 'none') {
						same = true;
						for (i = 0; i < skills.length; i++) {
							if (ui.skills2.skills.contains(skills[i]) == false) {
								same = false;
								break;
							}
						}
					}
					if (same) return;
					ui.skills2.close();
					delete ui.skills2;
				}
				if (skills == undefined || skills.length == 0) return;
				if (!_status.event.isMine()) {
					_status.noupdatec = true;
				}
				ui.skills2 = ui.create.control(skills.concat([ui.click.skill]));
				for (var i = 0; i < ui.skills2.childNodes.length; i++) {
					ui.skills2.childNodes[i].innerHTML = get.skillTranslation(ui.skills2.childNodes[i].link, _status.event.player);
				}
				if (!_status.event.isMine()) {
					ui.skills2.style.display = 'none';
				}
				else {
					ui.updatec();
				}
				_status.noupdatec = false;
				ui.skills2.skills = skills;
				return ui.skills2;
			},
			skills3: function (skills) {
				var i, same;
				if (ui.skills3) {
					if (ui.skills3.skills.length == skills.length && ui.skills3.style.display != 'none') {
						same = true;
						for (i = 0; i < skills.length; i++) {
							if (ui.skills3.skills.contains(skills[i]) == false) {
								same = false;
								break;
							}
						}
					}
					if (same) return;
					ui.skills3.close();
					delete ui.skills3;
				}
				if (skills == undefined || skills.length == 0) return;
				if (!_status.event.isMine()) {
					_status.noupdatec = true;
				}
				ui.skills3 = ui.create.control(skills.concat([ui.click.skill]));
				for (var i = 0; i < ui.skills3.childNodes.length; i++) {
					ui.skills3.childNodes[i].innerHTML = get.skillTranslation(ui.skills3.childNodes[i].link, _status.event.player);
				}
				if (!_status.event.isMine()) {
					ui.skills3.style.display = 'none';
				}
				else {
					ui.updatec();
				}
				_status.noupdatec = false;
				ui.skills3.skills = skills;
				return ui.skills3;
			},
			arena: function () {
				var i, j;
				ui.window = ui.create.div('#window.hidden', document.body);
				ui.create.div('#statusbg', document.body);
				ui.refresh(ui.window);
				if (!localStorage.getItem(lib.configprefix + 'playback')) {
					ui.window.show();
				}
				else {
					setTimeout(function () {
						ui.window.show();
					}, 1000);
				}
				// lib.setPressure(ui.window,ui.click.pressurepause);
				if (window.isNonameServer) {
					ui.window.classList.add('server');
					var serverinfo = ui.create.div('.serverinfo', ui.window);
					ui.create.div('', '服务器正在运行', serverinfo);
					var serverinfotable = ui.create.table(2, 2, ui.create.div(serverinfo));
					serverinfotable.style.display = 'inline-block';
					serverinfotable.firstChild.firstChild.innerHTML = '房间人数：';
					serverinfotable.firstChild.lastChild.id = 'server_count';
					serverinfotable.firstChild.lastChild.innerHTML = '0';
					serverinfotable.lastChild.firstChild.innerHTML = '房间状态：';
					serverinfotable.lastChild.lastChild.id = 'server_status';
					serverinfotable.lastChild.lastChild.innerHTML = '空闲';
					ui.create.div('.menubutton.large', '关闭服务器', function () {
						if (_status.gameStarted && !confirm('关闭服务器当前进行的游戏将终止且不可恢复，是否确定关闭？')) {
							return;
						}
						localStorage.removeItem(lib.configprefix + 'asserver');
						game.reload();
					}, ui.create.div('', serverinfo));
				}

				ui.window.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.window);
				ui.system = ui.create.div("#system.", ui.window);
				ui.arena = ui.create.div('#arena.nome', ui.window);
				if (lib.device == 'ios' && !get.is.phoneLayout()) {
					ui.arena.classList.add('ipad');
				}
				ui.arena.setNumber = function (num) {
					this.dataset.number = num;
					// if(game.layout=='nova'&&parseInt(num)<7){
					// 	ui.arena.classList.add('player_autolong');
					// }
					// else if(lib.config.player_height_nova!='long'){
					// 	ui.arena.classList.remove('player_autolong');
					// }
					// if(game.layout=='long'&&parseInt(num)<parseInt(lib.config.fewplayer)){
					//     this.classList.add('fewplayer');
					// }
					// else{
					//     this.classList.remove('fewplayer');
					// }
				}

				if (lib.config.low_performance) {
					ui.window.classList.add('low_performance');
				}
				if (game.layout == 'mobile' || game.layout == 'long') {
					ui.arena.classList.add('mobile');
				}
				if (game.layout == 'long' || game.layout == 'long2') {
					ui.arena.classList.add('long');
				}
				if (game.layout == 'default') {
					ui.arena.classList.add('oldlayout');
				}
				if (lib.config.player_border != 'wide' || game.layout == 'long' || game.layout == 'long2') {
					ui.arena.classList.add('slim_player');
				}
				if (lib.config.player_border == 'slim') {
					ui.arena.classList.add('uslim_player');
				}
				if (lib.config.player_border == 'narrow') {
					ui.arena.classList.add('mslim_player');
				}
				if (lib.config.player_border == 'normal' && lib.config.mode != 'brawl' && (game.layout == 'long' || game.layout == 'long2')) {
					ui.arena.classList.add('lslim_player');
				}
				ui.window.dataset.player_border = lib.config.player_border;
				if (lib.config.compatiblemode) {
					ui.window.classList.add('compatiblemode');
				}
				ui.window.dataset.radius_size = lib.config.radius_size || 'default';
				if (game.layout == 'long' || game.layout == 'mobile') {
					if (lib.config.textequip == 'text') ui.arena.classList.add('textequip');
				}
				if (game.layout == 'long' || game.layout == 'long2' || game.layout == 'mobile' || game.layout == 'nova') {
					if (lib.config.cardshape == 'oblong') {
						ui.window.classList.add('oblongcard');
						ui.arena.classList.add('oblongcard');
					}
				}
				if (lib.config.blur_ui) {
					ui.window.classList.add('blur_ui');
				}
				if (lib.config.glass_ui) {
					ui.window.classList.add('glass_ui');
				}
				if (lib.config.custom_button) {
					lib.configMenu.appearence.config.custom_button.onclick('skip');
				}

				if (lib.config.show_statusbar_ios == 'overlay') {
					document.body.classList.add('statusbar');
				}
				if (lib.config.keep_awake) {
					if (window.plugins && window.plugins.insomnia) window.plugins.insomnia.keepAwake();
					else {
						lib.init.js(lib.assetURL + 'game', 'NoSleep', function () {
							var noSleep = new NoSleep();
							document.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function enableNoSleep() {
								document.removeEventListener(lib.config.touchscreen ? 'touchend' : 'click', enableNoSleep, false);
								noSleep.enable();
								window.noSleep = noSleep;
							}, false);
						});
					}
				}
				lib.init.js(lib.assetURL + 'game', 'keyWords', function () { });

				lib.updateURL = lib.updateURLS[lib.config.update_link] || lib.updateURLS.coding;

				lib.init.cssstyles();

				ui.arena.dataset.player_height = lib.config.player_height || 'default';
				ui.arena.dataset.player_height_nova = lib.config.player_height_nova || 'default';
				// if(lib.config.player_height_nova=='long') ui.arena.classList.add('player_autolong');
				ui.arena.dataset.target_shake = lib.config.target_shake || 'off';
				ui.backgroundMusic = document.createElement('audio');
				ui.backgroundMusic.volume = lib.config.volumn_background / 8;
				game.playBackgroundMusic();
				ui.backgroundMusic.autoplay = true;
				ui.backgroundMusic.addEventListener('ended', game.playBackgroundMusic);
				ui.window.appendChild(ui.backgroundMusic);
				if (lib.config.cursor_style == 'pointer') {
					ui.window.classList.add('nopointer');
				}
				if (lib.config.turned_style == false) {
					ui.arena.classList.add('hide_turned');
				}
				if (lib.config.link_style2 != 'chain') {
					ui.arena.classList.add('nolink');
				}
				if (lib.config.show_name == false) {
					ui.arena.classList.add('hide_name');
				}
				if (lib.config.change_skin_auto != 'off') {
					_status.skintimeout = setTimeout(ui.click.autoskin, parseInt(lib.config.change_skin_auto));
				}
				if (lib.config.border_style && lib.config.border_style.indexOf('dragon_') == 0) {
					ui.arena.dataset.framedecoration = lib.config.border_style.slice(7);
				}

				ui.gameinfo = ui.create.div('#time', ui.window);

				ui.arenalog = ui.create.div('#arenalog', ui.arena);
				if (lib.config.show_log == 'off') {
					ui.arenalog.style.display = 'none';
				}
				else {
					ui.arenalog.dataset.position = lib.config.show_log;
				}
				ui.historybar = ui.create.div('#historybar.shadowed', ui.window);
				lib.setScroll(ui.historybar);

				ui.roundmenu = ui.create.div('#roundmenu.roundarenabutton.menubutton.round', ui.arena);
				ui.roundmenu._position = [180, 210];
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);

				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);

				ui.create.div(ui.roundmenu);
				ui.create.div(ui.roundmenu);

				ui.create.div(ui.roundmenu);

				if (lib.config.show_time2) {
					ui.roundmenu.classList.add('clock');
				}
				ui.roundmenu.dataset.watchface = lib.config.watchface || 'none';
				if (get.is.phoneLayout()) {
					if (lib.config.show_time3) {
						ui.time3 = ui.create.div('.touchinfo.left', ui.window);
					}
					ui.cardPileNumber = ui.create.div('.touchinfo.right', ui.window);
				}
				else {
					if (lib.config.show_time3) {
						ui.time3 = ui.create.div(ui.gameinfo);
					}
					ui.cardPileNumber = ui.create.div(ui.gameinfo);
				}
				if (!lib.config.show_cardpile_number) {
					ui.cardPileNumber.style.display = 'none';
				}
				if (ui.time3) {
					ui.time3.starttime = get.utc();
					ui.time3.interval = setInterval(function () {
						var num = Math.round((get.utc() - ui.time3.starttime) / 1000);
						if (num >= 3600) {
							var num1 = Math.floor(num / 3600);
							var num2 = Math.floor((num - num1 * 3600) / 60);
							if (num2 < 10) {
								num2 = '0' + num2.toString();
							}
							var num3 = num - num1 * 3600 - parseInt(num2) * 60;
							if (num3 < 10) {
								num3 = '0' + num3.toString();
							}
							ui.time3.innerHTML = num1 + ':' + num2 + ':' + num3;
						}
						else {
							var num1 = Math.floor(num / 60);
							var num2 = num - num1 * 60;
							if (num2 < 10) {
								num2 = '0' + num2.toString();
							}
							ui.time3.innerHTML = num1 + ':' + num2;
						}
					}, 1000);
				}
				if (get.is.nomenu()) {
					if (!['menu', 'system'].contains(lib.config.round_menu_func)) {
						lib.config.round_menu_func = 'system';
					}
				}
				else if (!lib.config.show_round_menu) {
					ui.roundmenu.style.display = 'none';
				}

				var resetround = function (e) {
					_status.draggingroundmenu = false;
					ui.roundmenu.style.transform = '';
					ui.roundmenu._dragtransform = [0, 0];
					ui.roundmenu.style.transition = 'all 0.3s';
					delete ui.roundmenu._dragtouches;
					delete ui.roundmenu._dragorigin;
					delete ui.roundmenu._dragorigintransform;
					setTimeout(function () {
						ui.roundmenu.style.transition = '';
					}, 500);
					game.saveConfig('roundmenu_transform', [0, 0]);
					if (e) e.stopPropagation();
					return false;
				};
				ui.click.resetround = resetround;
				if (lib.config.touchscreen) {
					ui.roundmenu.addEventListener('touchstart', function (e) {
						_status.draggingroundmenu = true;
						ui.roundmenu._dragorigin = {
							clientX: e.touches[0].clientX,
							clientY: e.touches[0].clientY,
						};
						if (!ui.roundmenu._dragtransform) {
							ui.roundmenu._dragtransform = [0, 0];
						}
						ui.roundmenu._dragorigintransform = ui.roundmenu._dragtransform.slice(0);
						ui.roundmenu._resetTimeout = setTimeout(function () {
							resetround();
							delete ui.roundmenu._resetTimeout;
						}, 1000);
					});
				}
				else {
					ui.roundmenu.oncontextmenu = resetround;
				}
				if (!lib.config.remember_round_button) {
					game.saveConfig('roundmenu_transform');
				}
				if (lib.config.roundmenu_transform) {
					var translate = lib.config.roundmenu_transform;
					ui.roundmenu._dragtransform = translate;
					ui.roundmenu.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
					ui.click.checkroundtranslate();
				}
				if (get.is.phoneLayout()) {
					ui.arena.classList.add('phone');
				}

				ui.sidebar = ui.create.div('#sidebar');
				ui.sidebar3 = ui.create.div('#sidebar3');
				ui.canvas = document.createElement('canvas');

				ui.arena.appendChild(ui.canvas);
				ui.canvas.id = 'canvas';
				ui.ctx = ui.canvas.getContext('2d');

				ui.sidebar.ontouchstart = ui.click.touchStart;
				ui.sidebar.ontouchmove = ui.click.touchScroll;
				ui.sidebar.style.WebkitOverflowScrolling = 'touch';

				var zoom;
				switch (lib.config.ui_zoom) {
					case 'esmall': zoom = 0.8; break;
					case 'vsmall': zoom = 0.9; break;
					case 'small': zoom = 0.93; break;
					case 'big': zoom = 1.05; break;
					case 'vbig': zoom = 1.1; break;
					case 'ebig': zoom = 1.2; break;
					default: zoom = 1;
				}
				game.documentZoom = game.deviceZoom * zoom;
				if (zoom != 1) {
					ui.updatez();
				}

				ui.system1 = ui.create.div('#system1', ui.system);
				ui.system2 = ui.create.div('#system2', ui.system);

				ui.replay = ui.create.system('重来', game.reload, true);
				ui.replay.id = 'restartbutton';
				ui.config2 = ui.create.system('选项', ui.click.config);
				ui.pause = ui.create.system('暂停', ui.click.pause);
				ui.pause.id = 'pausebutton';
				if (!_status.video) {
					ui.pause.hide();
				}
				if (!lib.config.touchscreen) {
					lib.setPopped(ui.pause, ui.click.pausehistory, 220, 400, null, true);
				}
				if (!lib.config.show_pause) {
					ui.pause.style.display = 'none';
				}
				ui.cardPileButton = ui.create.system('牌堆', null, true);
				ui.cardPileButton.style.display = 'none';
				lib.setPopped(ui.cardPileButton, ui.click.cardPileButton, 220);
				ui.wuxie = ui.create.system('不询问无懈', ui.click.wuxie, true);
				if (!lib.config.touchscreen) {
					lib.setPopped(ui.config2, ui.click.pauseconfig, 170);
				}
				ui.auto = ui.create.system('托管', ui.click.auto);
				if (!game.syncMenu) {
					ui.config2.classList.add('hidden');
					ui.config2.style.transition = 'all 0.5s';
					ui.roundmenu.classList.add('transparent2');

					ui.auto.style.opacity = 0.5;
					ui.auto.style.transition = 'all 0.5s';
					lib.onfree.push(function () {
						ui.auto.style.opacity = '';
						setTimeout(function () {
							ui.auto.style.transition = '';
						}, 500);
					});
				}
				ui.auto.id = 'autobutton';
				ui.autonode = ui.create.div('#autonode', '<div>托管中...</div>', ui.arena);
				ui.autonode.listen(ui.click.auto);
				if (lib.config.mode == 'connect') {
					ui.auto.hide();
					ui.pause.hide();
				}

				if (lib.forcehide) {
					if (lib.forcehide.contains('replay')) ui.replay.classList.add('forcehide');
					if (lib.forcehide.contains('auto')) ui.auto.classList.add('forcehide');
					if (lib.forcehide.contains('pause')) ui.pause.classList.add('forcehide');
					if (lib.forcehide.contains('wuxie')) ui.wuxie.classList.add('forcehide');
					if (lib.forcehide.contains('cardPileButton')) ui.cardPileButton.classList.add('forcehide');
				}
				ui.volumn = ui.create.system('♫');
				lib.setPopped(ui.volumn, ui.click.volumn, 200);
				// if(lib.config.show_pause) ui.auto.style.marginLeft='10px';
				if (!lib.config.show_volumn) {
					ui.volumn.style.display = 'none';
				}
				if (!lib.config.show_auto) {
					ui.auto.style.display = 'none';
				}
				if (!lib.config.show_wuxie) {
					ui.wuxie.style.display = 'none';
				}
				// if(!lib.config.show_cardpile||_status.connectMode){
				// 	ui.cardPileButton.style.display='none';
				// }

				ui.sortCard = ui.create.system('整理手牌', function () {
					var hs = game.me.getCards('h');
					if (!hs.length) return;
					game.addVideo('lose', game.me, [get.cardsInfo(hs), [], []]);
					for (var i = 0; i < hs.length; i++) {
						hs[i].goto(ui.special);
					}
					hs.sort(function (b, a) {
						if (a.name != b.name) return lib.sort.card(a.name, b.name);
						else if (a.suit != b.suit) return lib.suit.indexOf(a) - lib.suit.indexOf(b);
						else return a.number - b.number;
					});
					game.me.directgain(hs, false);
				});
				if (!lib.config.show_sortcard) {
					ui.sortCard.style.display = 'none';
				}
				ui.playerids = ui.create.system('显示身份', function () {
					if (game.showIdentity) {
						game.showIdentity();
						_status.identityShown = true;
					}
				}, true);
				if (!lib.config.show_playerids || !game.showIdentity) {
					ui.playerids.style.display = 'none';
				}
				if (!lib.config.show_replay) {
					ui.replay.style.display = 'none';
				}
				ui.control = ui.create.div('#control', ui.arena).animate('nozoom');
				ui.cardPile = ui.create.div('#cardPile');
				ui.discardPile = ui.create.div('#discardPile');
				ui.special = ui.create.div('#special');
				ui.ordering = ui.create.div('#ordering');
				ui.dialogs = [];
				ui.controls = [];
				ui.style = {};

				ui.time = ui.create.div(ui.gameinfo);
				var timeInterval = function () {
					var date = new Date();
					var hours = date.getHours();
					var minutes = date.getMinutes();
					if (lib.config.watchface == 'simple') {
						ui.roundmenu.childNodes[13].style.transform = 'rotate(' + get.round((hours + 9) * 30, 2) + 'deg)';
					}
					else {
						ui.roundmenu.childNodes[13].style.transform = 'rotate(' + get.round((hours + minutes / 60 + 9) * 30, 2) + 'deg)';
					}
					ui.roundmenu.childNodes[12].style.transform = 'rotate(' + (minutes + 45) * 6 + 'deg)';
					if (minutes < 10) {
						minutes = '0' + minutes.toString();
					}
					ui.time.innerHTML = hours + ':' + minutes;
				};
				_status.timeInterval = setInterval(timeInterval, 30000);
				timeInterval();
				if (!lib.config.show_time) {
					ui.time.style.display = 'none';
				}

				ui.timer = ui.create.div('.skillbar.shadowed.playerbg.hidden');
				ui.timer.id = 'timer';
				ui.create.div('.skillbarshadow', ui.timer);
				ui.create.div('.skillbarfill', ui.timer);
				ui.timer.fillnode = ui.create.div(ui.timer.lastChild);
				ui.timer.popnode = ui.create.div('.skillbartext', ui.timer);
				ui.timer.popnode.style.opacity = 1;
				ui.timer.position = 4;
				ui.timer.style.zIndex = 5;
				ui.timer.set = function (text, percentage) {
					if (typeof text == 'string' || typeof text == 'number') {
						ui.timer.popnode.innerHTML = text;
					}
					ui.timer.fillnode.style.top = ((1 - percentage) * 100) + '%';
				}
				var setTimerPosition = function (e) {
					this.position++;
					if (this.position > 4) {
						this.position = 1;
					}
					var left1 = '180px';
					var left2 = 'calc(100% - 245px)';
					var top1 = '210px';
					var top2 = 'calc(100% - 245px)';
					if (game.layout == 'default') {
						left1 = '265px';
						top1 = '160px';
						left2 = 'calc(100% - 330px)';
						top2 = 'calc(100% - 235px)';
					}
					if (this.position == 1 || this.position == 2) {
						this.style.top = top2;
					}
					else {
						this.style.top = top1;
					}
					if (this.position == 1 || this.position == 4) {
						this.style.left = left2;
					}
					else {
						this.style.left = left1;
					}
				}
				ui.timer.listen(setTimerPosition);

				ui.shortcut = ui.create.div('#shortcut.hidden', ui.window);
				ui.shortcut.listen(ui.click.shortcut);
				ui.create.div(ui.shortcut, function (e) { e.stopPropagation() });
				ui.create.div('.menubutton.round', '<span>重来</span>', ui.shortcut, game.reload).dataset.position = 1;
				ui.create.div('.menubutton.round', '<span>退出</span>', ui.shortcut, game.exit).dataset.position = 3;
				ui.create.div('.menubutton.round', '<span>记录</span>', ui.shortcut, ui.click.pause).dataset.position = 4;
				ui.shortcut.autobutton = ui.create.div('.menubutton.round', '<span>托管</span>', ui.shortcut, ui.click.auto);
				ui.shortcut.autobutton.dataset.position = 2;
				ui.favmodelist = ui.create.div('.favmodelist', ui.shortcut);
				ui.favmodelist.update = function () {
					this.innerHTML = '';
					var num = Math.min(6, lib.config.favouriteMode.length);
					for (var i = 0; i < num; i++) {
						this.add(lib.config.favouriteMode[i], i);
					}
					var mode = get.mode();
					if (typeof get.config(mode + '_mode') == 'string') {
						mode += '|' + get.config(mode + '_mode');
					}
					if (lib.config.favouriteMode.contains(mode)) {
						ui.favmode.classList.add('glow');
					}
					else {
						ui.favmode.classList.remove('glow');
					}
				};
				ui.favmodelist.add = function (name, index) {
					var info = name.split('|');
					var mode = info[0];
					var submode = info[1];
					var node = ui.create.div('.menubutton.large', this);
					var num = Math.min(6, lib.config.favouriteMode.length);
					node.dataset.type = num % 2 == 0 ? 'even' : 'odd';
					node.dataset.position = index;
					var str = lib.translate[name] || lib.translate[mode] || '';
					if (str.length == 2) {
						str += '模式';
					}
					node.innerHTML = str;
					node.listen(function () {
						game.saveConfig('mode', mode);
						if (submode) {
							game.saveConfig(mode + '_mode', submode, mode);
						}
						game.reload();
					});
				};
				ui.favmode = ui.create.system('收藏', function () {
					var mode = get.mode();
					if (typeof _status.mode == 'string') {
						mode += '|' + _status.mode;
					}
					if (this.classList.contains('glow')) {
						this.classList.remove('glow');
						lib.config.favouriteMode.remove(mode);
					}
					else {
						this.classList.add('glow');
						lib.config.favouriteMode.add(mode);
					}
					game.saveConfig('favouriteMode', lib.config.favouriteMode);
					ui.favmodelist.update();
					_status.clicked = true;
				});
				ui.favmode.style.display = 'none';
				ui.favmodelist.update();
				// ui.create.div('.menubutton.round','<span>菜单</span>',ui.shortcut,ui.click.config).dataset.position=5;


				if (_status.connectMode) {
					ui.playerids.remove();
					ui.pause.innerHTML = '记录';
				}
				setTimerPosition.call(ui.timer);
				ui.arena.appendChild(ui.timer);

				if (!game.syncMenu) {
					lib.onfree.push(function () {
						ui.create.menu();
						ui.config2.classList.remove('hidden');
						ui.roundmenu.classList.remove('transparent2');
						setTimeout(function () {
							ui.config2.style.transition = '';
						}, 500);
					});
				}
				else {
					ui.create.menu();
				}

				lib.status.date = new Date();
				lib.status.dateDelayed = 0;

				while (lib.arenaReady.length) {
					(lib.arenaReady.shift())();
				}
				delete lib.arenaReady;
				if (lib.config.auto_check_update) {
					setTimeout(function () {
						game.checkForUpdate(false);
					}, 3000);
				}
				if (!lib.config.asset_version) {
					lib.onfree.push(function () {
						setTimeout(function () {
							if (!game.download) {
								game.saveConfig('asset_version', '无');
							}
							else {
								var func = function () {
									if (confirm('是否下载图片和字体素材？（约175MB）')) {
										if (!ui.arena.classList.contains('menupaused')) {
											ui.click.configMenu();
											ui.click.menuTab('其它');
										}
										setTimeout(game.checkForAssetUpdate, 500);
									}
									else {
										game.saveConfig('asset_version', '无');
									}
								}
								if (_status.new_tutorial) {
									_status.new_tutorial = func;
								}
								else {
									func();
								}
							}
						}, 3000);
					});
				}
				if (localStorage.getItem(lib.configprefix + 'playback')) {
					setTimeout(lib.init.onfree);
				}

				if (lib.config.test_game) {
					ui.window.classList.add('testing');
					lib.config.game_speed = 'vfast';
					lib.config.low_performance = true;
					lib.config.animation = false;
					_status.auto = true;
					ui.auto.classList.add('glow');
					setTimeout(function () {
						var node = ui.create.pause().animate('start');
						node.appendChild(ui.sidebar);
						node.firstChild.innerHTML = '正在测试';
						node.removeEventListener('click', ui.click.resume);
					}, 500);
				}
			},
			system: function (str, func, right, before) {
				var parent = right ? ui.system2 : ui.system1;
				var node = ui.create.div();
				if (before) {
					parent.insertBefore(node, parent.firstChild);
				}
				else {
					parent.appendChild(node);
				}
				node.innerHTML = str;
				if (func) {
					node.listen(func);
				}
				if (lib.config.button_press) {
					node.addEventListener(lib.config.touchscreen ? 'touchstart' : 'mousedown', function (e) {
						if (!node.classList.contains('hidden')) node.classList.add('pressdown');
					});
					node.addEventListener(lib.config.touchscreen ? 'touchend' : 'mouseup', function (e) {
						node.classList.remove('pressdown');
					});
					node.addEventListener(lib.config.touchscreen ? 'touchmove' : 'mousemove', function (e) {
						node.classList.remove('pressdown');
					});
				}
				return node;
			},
			pause: function () {
				if (_status.pausing) return;
				ui.click.shortcut(false);
				var node = ui.create.div(".pausedbg", ui.window);
				_status.pausing = true;
				setTimeout(function () {
					_status.pausing = false;
				}, 500);
				if (lib.config.touchscreen) {
					setTimeout(function () {
						node.addEventListener('touchend', ui.click.resume);
					}, 500);
				}
				else {
					node.addEventListener('click', ui.click.resume);
				}
				if (!lib.config.touchscreen) {
					node.oncontextmenu = ui.click.resume;
				}

				var node2 = ui.create.div(node);
				if (_status.connectMode) {
					node2.innerHTML = '';
				}
				else {
					node2.innerHTML = '已暂停';
				}

				// node2.listen(function(){
				// 	_status.clicked=true;
				// 	if(ui.sidebar.classList.contains('hidden')){
				// 		ui.sidebar.show();
				// 		ui.sidebar3.show();
				// 	}
				// 	else{
				// 		ui.sidebar.hide();
				// 		ui.sidebar3.hide();
				// 	}
				// });
				return node;
			},
			prebutton: function (item, type, position, noclick) {
				var node = ui.create.div(position);
				node.style.display = 'none';
				node.link = item;
				node.activate = function () {
					ui.create.button(item, type, position, noclick, node);
					delete node.activate;
				}
				_status.prebutton.push(node);
				return node;
			},
			button: function (item, type, position, noclick, node) {
				switch (type) {
					case 'blank':
						node = ui.create.div('.button.card', position);
						node.link = item;
						break;

					case 'card':
						if (typeof item.copy == 'function') {
							node = item.copy(false);
						}
						else {
							node = item.cloneNode(true);
						}
						node.classList.add('button');
						position.appendChild(node);
						node.link = item;
						if (item.style.backgroundImage) {
							node.style.backgroundImage = item.style.backgroundImage;
							node.style.backgroundSize = 'cover';
						}
						if (item.style.color) {
							node.style.color = item.style.color;
						}
						if (item.nature) {
							node.classList.add(item.nature);
						}
						if (!noclick) {
							lib.setIntro(node);
						}
						break;

					case 'vcard':
						if (typeof item == 'string') {
							item = [get.type(item), '', item];
						}
						node = ui.create.card(position, 'noclick', noclick);
						node.classList.add('button');
						node.init(item);
						node.link = item;
						break;

					case 'character': case 'player':
						if (node) {
							node.classList.add('button');
							node.classList.add('character');
							node.style.display = '';
						}
						else {
							node = ui.create.div('.button.character', position);
						}
						node.link = item;
						if (type == 'character') {
							node.setBackground(item, 'character');
							node.node = {
								name: ui.create.div('.name', node),
								hp: ui.create.div('.hp', node),
								intro: ui.create.div('.intro', node),
								group: ui.create.div('.identity', node)
							}
							var infoitem = lib.character[item];
							if (!infoitem) {
								for (var itemx in lib.characterPack) {
									if (lib.characterPack[itemx][item]) {
										infoitem = lib.characterPack[itemx][item]; break;
									}
								}
							}
							node.node.name.innerHTML = get.slimName(item);
							if (lib.config.buttoncharacter_style == 'default' || lib.config.buttoncharacter_style == 'simple') {
								if (lib.config.buttoncharacter_style == 'simple') {
									node.node.group.style.display = 'none';
								}
								node.node.name.dataset.nature = get.groupnature(infoitem[1]);
								node.node.group.dataset.nature = get.groupnature(infoitem[1], 'raw');
								node.classList.add('newstyle');
								ui.create.div(node.node.hp);
								var textnode = ui.create.div('.text', get.numStr(infoitem[2]), node.node.hp);
								if (infoitem[2] == 0) {
									node.node.hp.hide();
								}
								else if (get.infoHp(infoitem[2]) <= 3) {
									node.node.hp.dataset.condition = 'mid';
								}
								else {
									node.node.hp.dataset.condition = 'high';
								}
							}
							else {
								var hp = get.infoHp(infoitem[2]);
								var maxHp = get.infoMaxHp(infoitem[2]);
								if (maxHp > 14) {
									if (typeof infoitem[2] == 'string') node.node.hp.innerHTML = infoitem[2];
									else node.node.hp.innerHTML = get.numStr(infoitem[2]);
									node.node.hp.classList.add('text');
								}
								else {
									for (var i = 0; i < maxHp; i++) {
										var next = ui.create.div('', node.node.hp);
										if (i >= hp) next.classList.add('exclude');
									}
								}
							}
							if (node.node.hp.childNodes.length == 0) {
								node.node.name.style.top = '8px';
							}
							if (node.node.name.querySelectorAll('br').length >= 4) {
								node.node.name.classList.add('long');
								if (lib.config.buttoncharacter_style == 'old') {
									node.addEventListener('mouseenter', ui.click.buttonnameenter);
									node.addEventListener('mouseleave', ui.click.buttonnameleave);
								}
							}
							node.node.intro.innerHTML = lib.config.intro;
							if (!noclick) {
								lib.setIntro(node);
							}
							if (infoitem[1]) {
								node.node.group.innerHTML = '<div>' + get.translation(infoitem[1]) + '</div>';
								node.node.group.style.backgroundColor = get.translation(infoitem[1] + 'Color');
							}
							else {
								node.node.group.style.display = 'none';
							}
						}
						else {
							node.node = {
								name: ui.create.div('.name', node),
								intro: ui.create.div('.intro', node)
							}
							if (item.name.indexOf('unknown') == 0) {
								if (item.node && item.node.name_seat) {
									node.classList.add('cardbg');
									ui.create.div('.avatar_name', node, item.node.name_seat.innerHTML[0] + '号位');
								}
								else {
									node.setBackground(item.name1, 'character');
								}
							}
							else {
								node.setBackground(item.name, 'character');
							}
						}
						break;

					case 'text':
						node = ui.create.div('.button.text', position);
						node.link = item;
						node.innerHTML = item;
						break;

					case 'textButton':
						node = ui.create.div('.caption', position);
						node.link = item;
						node.innerHTML = item;
						break;
				}
				if (!noclick) {
					node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.button);
				}
				else {
					node.classList.add('noclick');
					if (node.querySelector('.intro')) {
						node.querySelector('.intro').remove();
					}
				}
				for (var i in lib.element.button) {
					node[i] = lib.element.button[i];
				}
				return node;
			},
			buttons: function (list, type, position, noclick, zoom) {
				var buttons = [];
				var pre = (type.slice(0, 3) == 'pre');
				if (pre) {
					if (!_status.prebutton) {
						_status.prebutton = [];
						lib.onfree.push(function () {
							for (var i = 0; i < _status.prebutton.length; i++) {
								if (_status.prebutton[i].activate) {
									_status.prebutton[i].activate();
								}
							}
							delete _status.prebutton;
						});
					}
				}
				for (var i = 0; i < list.length; i++) {
					if (pre) {
						buttons.push(ui.create.prebutton(list[i], type.slice(3), position, noclick));
					}
					else {
						buttons.push(ui.create.button(list[i], type, position, noclick));
					}
				}
				return buttons;
			},
			player: function (position, noclick) {
				var node = ui.create.div('.player', position);
				node.node = {
					avatar: ui.create.div('.avatar', node, ui.click.avatar).hide(),
					avatar2: ui.create.div('.avatar2', node, ui.click.avatar2).hide(),
					turnedover: ui.create.div('.turned', '<div>翻<br>面<div>', node),
					framebg: ui.create.div('.framebg', node),
					intro: ui.create.div('.intro', node),
					identity: ui.create.div('.identity', node),
					hp: ui.create.div('.hp', node),
					name: ui.create.div('.name', node),
					name2: ui.create.div('.name.name2', node),
					nameol: ui.create.div('.nameol', node),
					count: ui.create.div('.count', node).hide(),
					equips: ui.create.div('.equips', node).hide(),
					judges: ui.create.div('.judges', node),
					marks: ui.create.div('.marks', node),
					chain: ui.create.div('.chain', '<div></div>', node),
					handcards1: ui.create.div('.handcards'),
					handcards2: ui.create.div('.handcards'),
				};
				var chainlength = game.layout == 'default' ? 64 : 40;
				for (var i = 0; i < chainlength; i++) {
					ui.create.div(node.node.chain.firstChild, '.cardbg').style.transform = 'translateX(' + (i * 5 - 5) + 'px)';
				}
				node.node.action = ui.create.div('.action', node.node.avatar);

				node.phaseNumber = 0;
				node.skipList = [];
				node.skills = [];
				node.initedSkills = [];
				node.additionalSkills = {};
				node.disabledSkills = {};
				node.hiddenSkills = [];
				node.awakenedSkills = [];
				node.forbiddenSkills = {};
				node.popups = [];
				node.damagepopups = [];
				node.judging = [];
				node.stat = [{ card: {}, skill: {} }];
				node.actionHistory = [{ useCard: [], respond: [], skipped: [], lose: [], gain: [], sourceDamage: [], damage: [], custom: [] }];
				node.tempSkills = {};
				node.storage = {};
				node.marks = {};
				node.ai = { friend: [], enemy: [], neutral: [], handcards: { global: [], source: [], viewed: [] } };
				node.queueCount = 0;
				node.outCount = 0;

				for (var i in lib.element.player) {
					node[i] = lib.element.player[i];
				}
				node.node.link = node.mark(' ', { mark: get.linkintro });
				node.node.link.firstChild.setBackgroundImage('image/card/tiesuo_mark.png')
				node.node.link.firstChild.style.backgroundSize = 'cover';
				ui.create.div(node.node.identity);
				if (!noclick) {
					node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.target);
					node.node.identity.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.identity);
					if (lib.config.touchscreen) {
						node.addEventListener('touchstart', ui.click.playertouchstart);
					}
				}

				return node;
			},
			connectPlayers: function (ip) {
				game.connectPlayers = [];
				for (var i = 0; i < 8; i++) {
					var player = ui.create.player(ui.window);
					player.dataset.position = i;
					player.classList.add('connect');
					game.connectPlayers.push(player);
					if (i >= lib.configOL.number) {
						player.classList.add('unselectable2');
					}
				}

				var bar = ui.create.div(ui.window);
				bar.style.height = '20px';
				bar.style.width = '80%';
				bar.style.left = '10%';
				bar.style.top = 'calc(200% / 7 - 120px + 5px)';
				bar.style.textAlign = 'center';
				var ipbar = ui.create.div('.shadowed', ip, bar);
				ipbar.style.padding = '4px';
				ipbar.style.borderRadius = '2px';
				ipbar.style.position = 'relative';

				var button = ui.create.div('.menubutton.large.highlight.connectbutton.pointerdiv', game.online ? '退出联机' : '开始游戏', ui.window, function () {
					if (button.clicked) return;
					if (game.online) {
						if (game.onlinezhu) {
							game.send('startGame');
						}
						else {
							game.saveConfig('tmp_owner_roomId');
							game.saveConfig('tmp_user_roomId');
							game.saveConfig('reconnect_info');
							game.reload();
						}
					}
					else {
						var num = 0;
						for (var i of game.connectPlayers) {
							if (!i.nickname && !i.classList.contains('unselectable2')) num++;
						}
						if (num >= lib.configOL.number - 1) {
							alert('至少要有两名玩家才能开始游戏！');
							return;
						}
						game.resume();
					}
					button.delete();
					bar.delete();
					delete ui.connectStartButton;
					delete ui.connectStartBar;
					button.clicked = true;
				});

				ui.connectStartButton = button;
				ui.connectStartBar = bar;
			},
			players: function (num) {
				if (num === 0) {
					return;
				}
				if (num == undefined) num = lib.configOL.number;
				if (num == undefined) num = get.playerNumber();
				if (typeof num == 'string') {
					num = parseInt(num);
				}
				if (!num) num = 5;
				for (var i = 0; i < num; i++) {
					var player = ui.create.player().animate('start');
					game.players.push(player);
					player.dataset.position = i;
				}
				var players = game.players;
				for (var i = 0; i < players.length; i++) {
					if (i > 0) {
						players[i].previous = players[i - 1];
						players[i].previousSeat = players[i - 1];
					}
					if (i < players.length - 1) {
						players[i].next = players[i + 1];
						players[i].nextSeat = players[i + 1];
					}
				}
				players[0].previous = players[players.length - 1];
				players[0].previousSeat = players[players.length - 1];
				players[players.length - 1].next = players[0];
				players[players.length - 1].nextSeat = players[0];
				ui.arena.setNumber(num);
				for (var i = 0; i < num; i++) {
					ui.arena.appendChild(players[i]);
				}
				// ui.arena.classList.add('glass');
				// for(var i=0;i<num;i++){
				// 	var bg=ui.create.div('.glassbg');
				// 	var bg2=ui.create.div(bg);
				// 	ui.create.div(bg);
				// 	var rect=players[i].getBoundingClientRect();
				// 	bg2.style.backgroundImage='url("image/background/huangtian_bg.jpg")';
				// 	bg2.style.width=ui.window.offsetWidth+'px';
				// 	bg2.style.height=ui.window.offsetHeight+'px';
				// 	bg2.style.transform='translate('+(-rect.left)+'px,'+(-rect.top)+'px)';
				// 	players[i].insertBefore(bg,players[i].firstChild);
				// }
				return players;
			},
			me: function (hasme) {
				ui.mebg = ui.create.div('#mebg', ui.arena);
				ui.me = ui.create.div('#me', ui.arena).animate('start');
				ui.handcards1Container = ui.create.div('#handcards1', ui.me);
				ui.handcards2Container = ui.create.div('#handcards2', ui.me);
				ui.arena.classList.remove('nome');
				if (lib.config.mousewheel && !lib.config.touchscreen) {
					ui.handcards1Container.onmousewheel = ui.click.mousewheel;
					ui.handcards2Container.onmousewheel = ui.click.mousewheel;
				}
				ui.handcards1Container.ontouchstart = ui.click.touchStart;
				ui.handcards2Container.ontouchstart = ui.click.touchStart;
				ui.handcards1Container.ontouchmove = ui.click.touchScroll;
				ui.handcards2Container.ontouchmove = ui.click.touchScroll;
				ui.handcards1Container.style.WebkitOverflowScrolling = 'touch';
				ui.handcards2Container.style.WebkitOverflowScrolling = 'touch';

				if (hasme && game.me) {
					ui.handcards1 = game.me.node.handcards1;
					ui.handcards2 = game.me.node.handcards2;
					ui.handcards1Container.appendChild(ui.handcards1);
					ui.handcards2Container.appendChild(ui.handcards2);
					// ui.updatehl();
				}
				else if (game.players.length) {
					game.me = game.players[0];
					ui.handcards1 = game.me.node.handcards1;
					ui.handcards2 = game.me.node.handcards2;
					ui.handcards1Container.appendChild(ui.handcards1);
					ui.handcards2Container.appendChild(ui.handcards2);
					// ui.updatehl();
				}
			},
			card: function (position, info, noclick) {
				var node = ui.create.div('.card', position);
				node.node = {
					image: ui.create.div('.image', node),
					info: ui.create.div('.info', node),
					name: ui.create.div('.name', node),
					name2: ui.create.div('.name2', node),
					background: ui.create.div('.background', node),
					intro: ui.create.div('.intro', node),
					range: ui.create.div('.range', node),
				}
				for (var i in lib.element.card) {
					node[i] = lib.element.card[i];
				}
				node.node.intro.innerHTML = lib.config.intro;
				if (!noclick) {
					lib.setIntro(node);
				}
				node.storage = {};
				node.vanishtag = [];
				node._uncheck = [];
				if (info != 'noclick') {
					node.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.card);
					if (lib.config.touchscreen) {
						node.addEventListener('touchstart', ui.click.cardtouchstart);
						node.addEventListener('touchmove', ui.click.cardtouchmove);
					}
					if (lib.cardSelectObserver) {
						lib.cardSelectObserver.observe(node, { attributes: true });
					}
				}
				return node;
			},
			cardsAsync: function () {
				if (lib.onfree) {
					_status.waitingForCards = Array.from(arguments);
					lib.onfree.push(function () {
						if (_status.waitingForCards) {
							ui.create.cards.apply(ui.create, _status.waitingForCards);
							delete _status.waitingForCards;
						}
					});
				}
				else {
					ui.create.cards.apply(ui.create, arguments);
				}
			},
			cards: function (ordered) {
				if (_status.brawl) {
					if (_status.brawl.cardPile) {
						lib.card.list = _status.brawl.cardPile(lib.card.list);
					}
					if (_status.brawl.orderedPile) {
						ordered = true;
					}
				}
				if (!ordered) {
					lib.card.list.randomSort();
				}
				for (var i = 0; i < lib.card.list.length; i++) {
					if (lib.card[lib.card.list[i][2]]) {
						if (!lib.card.list[i]._replaced) {
							if (!_status.connectMode) {
								if (lib.config.bannedcards.contains(lib.card.list[i][2])) continue;
							}
							else {
								if (lib.configOL.bannedcards.contains(lib.card.list[i][2])) continue;
							}
							if (game.bannedcards && game.bannedcards.contains(lib.card.list[i][2])) continue;
						}
						lib.inpile.add(lib.card.list[i][2]);
						ui.create.card(ui.cardPile).init(lib.card.list[i]);
					}
				}
				lib.inpile.sort(lib.sort.card);
				game.broadcastAll(function (num, pile, top) {
					if (ui.cardPileNumber) ui.cardPileNumber.innerHTML = '0轮 剩余牌: ' + num;
					lib.inpile = pile;
					_status.pileTop = top;
				}, ui.cardPile.childNodes.length, lib.inpile, ui.cardPile.firstChild);
			},
		},
		click: {
			identitycircle: function () {
				var list = [];
				this.classList.toggle('transparent');
				for (var i = 0; i < this.parentNode.childNodes.length; i++) {
					if (!this.parentNode.childNodes[i].classList.contains('transparent')) {
						list.add(this.parentNode.childNodes[i].link[2]);
					}
				}
				var info = this.link;
				if (list.length == 1) {
					for (var i = 0; i < this.parentNode.childNodes.length; i++) {
						if (!this.parentNode.childNodes[i].classList.contains('transparent')) {
							var info2 = this.parentNode.childNodes[i].link;
							info[0].firstChild.innerHTML = info2[1];
							info[0].dataset.color = info2[2];
						}
					}
				}
				else {
					info[0].firstChild.innerHTML = '';
					info[0].dataset.color = '';
					ui.create.identitycircle(list, info[0].firstChild);
				}
				this._source._guozhanguess = list;
			},
			connectEvents: function () {
				if (this.info) {
					var button = this;
					var layer = ui.create.div('.poplayer', ui.window);
					var uiintro = ui.create.dialog('hidden', 'notouchscroll');
					this.classList.add('active');
					if (lib.config.touchscreen) {
						lib.setScroll(uiintro.contentContainer);
					}
					layer.listen(function () {
						if (this.clicked) {
							this.clicked = false;
							return;
						}
						button.classList.remove('active');
						uiintro.delete();
						this.delete();
					});
					uiintro.listen(function () {
						_status.clicked = true;
					});
					uiintro.style.zIndex = 21;
					uiintro.classList.add('popped');
					uiintro.classList.add('static');
					uiintro.classList.add('onlineclient');
					uiintro.style.width = '180px';
					uiintro.style.height = '300px';
					uiintro.style.left = 'auto';
					uiintro.style.right = '20px';
					uiintro.style.top = 'auto';
					uiintro.style.bottom = '75px';

					uiintro.refresh = function () {
						if (button.focused) return;
						uiintro.content.innerHTML = '';
						uiintro.addText('创建约战');
						button.textnode = uiintro.content.lastChild.lastChild;
						uiintro.add('<input type="text" style="width:calc(100% - 10px);resize: none;border: none;border-radius: 2px;box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 0px 1px;margin-top: -2px;margin-bottom: 2px;">');
						uiintro.content.lastChild.style.paddingTop = 0;
						button.input = uiintro.content.lastChild.lastChild;
						button.input.onfocus = function () {
							button.focused = true;
						}
						button.input.onblur = function () {
							delete button.focused;
						}
						if (button.interval) {
							button.input.disabled = true;
							button.input.style.opacity = 0.6;
							if (button.intervaltext) {
								button.textnode.innerHTML = button.intervaltext;
							}
						}
						var datenode = ui.create.div(uiintro.content);
						datenode.style.marginTop = 0;
						datenode.style.whiteSpace = 'nowrap';
						var date = new Date();
						var days = [];
						var currentDay = date.getDay();
						if (currentDay == 0) currentDay = 7;
						for (var i = 1; i <= 7; i++) {
							if (i < currentDay) {
								days.push([i.toString(), '下周' + get.cnNumber(i, true)]);
							}
							else if (i == 7) {
								days.push([i.toString(), '周日']);
							}
							else if (i == currentDay) {
								days.push([i.toString(), '今天']);
							}
							else {
								days.push([i.toString(), '周' + get.cnNumber(i, true)]);
							}
						}
						days = days.concat(days.splice(0, currentDay - 1));
						var initday = currentDay + 1;
						if (initday > 7) {
							initday -= 7;
						}
						var daysselect = ui.create.selectlist(days, initday.toString(), datenode);
						daysselect.style.width = '55px';
						var hours = [];
						for (var i = 0; i < 24; i++) {
							hours.push([i.toString(), i.toString() + '点']);
						}
						var hoursselect = ui.create.selectlist(hours, date.getHours().toString(), datenode);
						hoursselect.style.marginLeft = '5px';
						hoursselect.style.width = '55px';
						var timeconfirm = ui.create.node('button', '确定', datenode);
						timeconfirm.style.marginLeft = '5px';
						timeconfirm.onclick = function () {
							if (!button.input.value) {
								alert('请填写约战标题');
								return;
							}
							var date2 = new Date();
							date2.setHours(parseInt(hoursselect.value));
							date2.setMinutes(0);
							date2.setSeconds(0);
							var deltaday = parseInt(daysselect.value) - currentDay;
							if (deltaday < 0) {
								deltaday += 7;
							}
							var utc = date2.getTime() + deltaday * 24 * 3600000;
							if (utc < date.getTime()) {
								alert('创建失败，时间已过');
								return;
							}
							if (get.is.banWords(button.input.value)) {
								var eventnode = ui.create.div('.menubutton.videotext.onlineevent.pointerdiv', function () {
									var that = this;
									setTimeout(function () {
										if (that.classList.contains('active')) {
											if (confirm('确定要离开' + that.info.content + '？')) {
												that.classList.remove('active');
											}
										}
										else {
											if (confirm('确定要加入' + that.info.content + '？')) {
												that.classList.add('active');
											}
										}
									});
								}, uiintro.content, 4);
								var fakeinfo = {
									utc: utc,
									day: parseInt(daysselect.value),
									hour: parseInt(hoursselect.value),
									nickname: lib.config.connect_nickname,
									avatar: lib.config.connect_avatar,
									content: button.input.value,
									create: game.onlineKey,
									members: [game.onlineKey],
								};
								eventnode.info = fakeinfo;
								ui.create.div('.title', fakeinfo.content, eventnode);
								var str;
								if (fakeinfo.day < currentDay) {
									str = '下周';
								}
								else {
									str = '周';
								}
								if (fakeinfo.day == 7) {
									str += '日'
								}
								else {
									str += get.cnNumber(fakeinfo.day, true);
								}
								str += ' ';
								var hour = fakeinfo.hour;
								if (hour <= 12) {
									if (hour <= 5) {
										str += '凌晨';
									}
									else if (hour < 12) {
										str += '上午';
									}
									else {
										str += '中午';
									}
									str += fakeinfo.hour + '点';
								}
								else {
									if (hour <= 17) {
										str += '下午';
									}
									else {
										str += '晚上';
									}
									str += (fakeinfo.hour - 12) + '点';
								}
								ui.create.div('', '已有' + (fakeinfo.members.length) + '人加入', eventnode);
								ui.create.div('', '时间：' + str, eventnode);
								if (fakeinfo.members.contains(game.onlineKey)) {
									eventnode.classList.add('active');
								}
								button.input.value = '';
								return;
							}
							game.send('server', 'events', {
								utc: utc,
								day: parseInt(daysselect.value),
								hour: parseInt(hoursselect.value),
								nickname: lib.config.connect_nickname,
								avatar: lib.config.connect_avatar,
								content: button.input.value
							}, game.onlineKey);
						};

						var num = 0;
						for (var i = 0; i < button.info.length; i++) {
							if (typeof button.info[i].creator == 'string' && button.info[i].creator != game.onlineKey && get.is.banWords(button.info[i].content)) continue;
							if (button.info[i].creator == game.onlineKey) {
								num++;
							}
							var eventnode = ui.create.div('.menubutton.videotext.onlineevent.pointerdiv', function () {
								var that = this;
								if (typeof that.info.creator != 'string') return;
								setTimeout(function () {
									if (that.classList.contains('active')) {
										if (confirm('确定要离开' + that.info.content + '？')) {
											game.send('server', 'events', that.info.id, game.onlineKey, 'leave');
										}
									}
									else {
										if (confirm('确定要加入' + that.info.content + '？')) {
											game.send('server', 'events', that.info.id, game.onlineKey, 'join');
										}
									}
								});
							}, uiintro.content);
							eventnode.info = button.info[i];
							if (typeof button.info[i].creator == 'string') {
								ui.create.div('.title', button.info[i].content, eventnode);
								var str;
								if (button.info[i].day < currentDay) {
									str = '下周';
								}
								else {
									str = '周';
								}
								if (button.info[i].day == 7) {
									str += '日'
								}
								else {
									str += get.cnNumber(button.info[i].day, true);
								}
								str += ' ';
								var hour = button.info[i].hour;
								if (hour <= 12) {
									if (hour <= 5) {
										str += '凌晨';
									}
									else if (hour < 12) {
										str += '上午';
									}
									else {
										str += '中午';
									}
									str += button.info[i].hour + '点';
								}
								else {
									if (hour <= 17) {
										str += '下午';
									}
									else {
										str += '晚上';
									}
									str += (button.info[i].hour - 12) + '点';
								}
								ui.create.div('', '创建者：' + (button.info[i].nickname), eventnode);
								//ui.create.div('','创建者：'+(button.info[i].nickname)+'<br>ID：'+button.info[i].creator,eventnode);
								ui.create.div('', '已有' + (button.info[i].members.length) + '人加入', eventnode);
								ui.create.div('', '时间：' + str, eventnode);
								if (button.info[i].members.contains(game.onlineKey)) {
									eventnode.classList.add('active');
								}
							}
							else {
								ui.create.div('.title', button.info[i].title, eventnode);
								ui.create.div('', button.info[i].content, eventnode);
								ui.create.div('', '创建者：' + (button.info[i].nickname), eventnode);
							}
						}
						if (num >= 3) {
							button.input.disabled = true;
							button.input.style.opacity = 0.6;
							hoursselect.disabled = true;
							daysselect.disabled = true;
							timeconfirm.disabled = true;
						}
					}
					uiintro.refresh();
					ui.window.appendChild(uiintro);
					_status.connectEventsCallback = function () {
						if (uiintro.parentNode == ui.window) {
							uiintro.refresh();
						}
					};
				}
			},
			connectClients: function () {
				if (this.info) {
					var button = this;
					var layer = ui.create.div('.poplayer', ui.window);
					var uiintro = ui.create.dialog('hidden', 'notouchscroll');
					this.classList.add('active');
					if (lib.config.touchscreen) {
						lib.setScroll(uiintro.contentContainer);
					}
					layer.listen(function () {
						if (this.clicked) {
							this.clicked = false;
							return;
						}
						button.classList.remove('active');
						uiintro.delete();
						this.delete();
					});
					uiintro.listen(function () {
						_status.clicked = true;
					});
					uiintro.style.zIndex = 21;
					uiintro.classList.add('popped');
					uiintro.classList.add('static');
					uiintro.classList.add('onlineclient');
					uiintro.style.width = '180px';
					uiintro.style.height = '300px';
					uiintro.style.left = 'auto';
					uiintro.style.right = '20px';
					uiintro.style.top = 'auto';
					uiintro.style.bottom = '75px';

					uiintro.refresh = function () {
						if (button.focused) return;
						uiintro.content.innerHTML = '';
						uiintro.addText('发状态');
						button.textnode = uiintro.content.lastChild.lastChild;
						uiintro.add('<input type="text" style="width:calc(100% - 10px);resize: none;border: none;border-radius: 2px;box-shadow: rgba(0, 0, 0, 0.2) 0px 0px 0px 1px;margin-top: -2px;margin-bottom: 2px;">');
						uiintro.content.lastChild.style.paddingTop = 0;
						button.input = uiintro.content.lastChild.lastChild;
						button.input.onfocus = function () {
							button.focused = true;
						}
						button.input.onblur = function () {
							delete button.focused;
						}
						if (button.interval) {
							button.input.disabled = true;
							button.input.style.opacity = 0.6;
							if (button.intervaltext) {
								button.textnode.innerHTML = button.intervaltext;
							}
						}
						button.input.onkeydown = function (e) {
							if (e.keyCode == 13 && !this.disabled) {
								game.send('server', 'status', this.value);
								this.blur();
								this.disabled = true;
								this.style.opacity = 0.6;
								button.textnode.innerHTML = '发状态(10)';
								button.intervaltext = button.textnode.innerHTML;
								var num = 10;
								var that = this;
								button.input.disabled = true;
								button.input.style.opacity = 0.6;
								this.value = '';
								button.interval = setInterval(function () {
									num--;
									if (num > 0) {
										button.textnode.innerHTML = '发状态(' + num + ')';
										button.intervaltext = button.textnode.innerHTML;
									}
									else {
										button.textnode.innerHTML = '发状态';
										button.input.disabled = false;
										button.input.style.opacity = '';
										clearInterval(button.interval);
										delete button.interval;
										delete button.intervaltext;
									}
								}, 1000);
							}
						}

						for (var i = 0; i < button.info.length; i++) {
							var node = ui.create.div('.menubutton.videonode.pointerdiv', uiintro.content);
							ui.create.div('.menubutton.videoavatar', node).setBackground(button.info[i][1] || 'caocao', 'character');
							if (button.info[i][4] == game.wsid) {
								ui.create.div('.name', '<span class="thundertext thunderauto">' + (button.info[i][0] || '无名玩家'), node); node.isme = true;
							}
							else if (button.info[i][2]) {
								ui.create.div('.name', (button.info[i][0] || '无名玩家'), node);
							}
							else {
								ui.create.div('.name', '<span style="opacity:0.6">' + (button.info[i][0] || '无名玩家'), node);
							}
							//ui.create.div('.videostatus',node,button.info[i][5]);
							//node.classList.add('videonodestatus');
							if (button.info[i][3]) {
								ui.create.div('.videostatus', node, button.info[i][3].slice(0, 80));
								node.classList.add('videonodestatus')
							}
						}
					};

					uiintro.refresh();
					ui.window.appendChild(uiintro);
					_status.connectClientsCallback = function () {
						if (uiintro.parentNode == ui.window) {
							uiintro.refresh();
						}
					};
				}
			},
			autoskin: function () {
				if (!lib.config.change_skin) return;
				var players = game.filterPlayer();
				var change = function (player, num, callback) {
					if (num == '1') {
						ui.click.skin(player.node.avatar, player.name, callback);
					}
					else {
						ui.click.skin(player.node.avatar2, player.name2, callback);
					}
				};
				var finish = function () {
					if (lib.config.change_skin_auto != 'off') {
						_status.skintimeout = setTimeout(ui.click.autoskin, parseInt(lib.config.change_skin_auto));
					}
				};
				var autoskin = function () {
					if (players.length) {
						var player = players.randomRemove();
						var list = [];
						if (player.name && !player.isUnseen(0)) {
							list.push('1');
						}
						if (player.name2 && !player.isUnseen(1)) {
							list.push('2');
						}
						if (list.length) {
							change(player, list.randomRemove(), function (bool) {
								if (bool) {
									finish();
								}
								else if (list.length) {
									change(player, list[0], function (bool) {
										if (bool) {
											finish();
										}
										else {
											autoskin();
										}
									});
								}
								else {
									autoskin();
								}
							});
						}
						else {
							autoskin();
						}
					}
				}
				autoskin();
			},
			skin: function (avatar, name, callback) {
				var num = 1;
				if (name.indexOf('gz_') == 0) {
					name = name.slice(3);
				}
				if (lib.config.skin[name]) {
					num = lib.config.skin[name] + 1;
				}
				var fakeavatar = avatar.cloneNode(true);
				var finish = function (bool) {
					var player = avatar.parentNode;
					if (bool) {
						fakeavatar.style.boxShadow = 'none';
						player.insertBefore(fakeavatar, avatar.nextSibling);
						setTimeout(function () {
							fakeavatar.delete();
						}, 100);
					}
					if (bool && lib.config.animation && !lib.config.low_performance) {
						player.$rare();
					}
					if (callback) {
						callback(bool);
					}
				}
				var img = new Image();
				img.onload = function () {
					lib.config.skin[name] = num;
					game.saveConfig('skin', lib.config.skin);
					avatar.style.backgroundImage = 'url("' + img.src + '")';
					finish(true);
				}
				img.onerror = function () {
					if (lib.config.skin[name]) {
						finish(true);
					}
					else {
						finish(false);
					}
					delete lib.config.skin[name];
					game.saveConfig('skin', lib.config.skin);
					avatar.setBackground(name, 'character');
				}
				img.src = lib.assetURL + 'image/skin/' + name + '/' + num + '.jpg';
			},
			touchpop: function (forced) {
				if (lib.config.touchscreen || forced) {
					_status.touchpopping = true;
					clearTimeout(_status.touchpoppingtimeout);
					_status.touchpoppingtimeout = setTimeout(function () {
						_status.touchpopping = false;
					}, 600);
				}
			},
			exit: function () {
				if (game.servermode && lib.config.reconnect_info && _status.over) {
					if (!_status.roomtimeout) {
						lib.config.reconnect_info[2] = game.roomId;
						game.saveConfig('reconnect_info', lib.config.reconnect_info);
					}
					game.reload();
					return;
				}
				else {
					if (typeof game.roomId != 'number') {
						game.saveConfig('reconnect_info');
					}
				}
				if (!ui.exit || !ui.exit.stay) {
					if (lib.config.reconnect_info) {
						lib.config.reconnect_info.length = 1;
						game.saveConfig('reconnect_info', lib.config.reconnect_info);
					}
					game.saveConfig('tmp_user_roomId', undefined, false, function () {
						game.reload();
					});
				}
				else {
					game.reload();
				}
			},
			shortcut: function (show) {
				if (show === false) {
					ui.shortcut.classList.add('hidden');
				}
				else {
					ui.shortcut.classList.toggle('hidden');
				}
				if (ui.shortcut.classList.contains('hidden')) {
					ui.favmode.style.display = 'none';
					if (window.StatusBar && lib.config.show_statusbar_ios == 'auto') {
						document.body.classList.remove('statusbar');
						window.StatusBar.hide();
					}
					ui.window.classList.remove('shortcutpaused');
				}
				else {
					if (lib.config.show_favmode) {
						ui.favmode.style.display = '';
					}
					if (window.StatusBar && lib.config.show_statusbar_ios == 'auto') {
						document.body.classList.add('statusbar');
						window.StatusBar.overlaysWebView(true);
						window.StatusBar.backgroundColorByName('black');
						window.StatusBar.show();
					}
					if (_status.auto) {
						ui.shortcut.autobutton.classList.add('active');
					}
					else {
						ui.shortcut.autobutton.classList.remove('active');
					}
					ui.window.classList.add('shortcutpaused');
				}
			},
			favouriteCharacter: function (e) {
				if (typeof this.link == 'string') {
					if (this.innerHTML == '添加收藏') {
						this.innerHTML = '移除收藏';
						lib.config.favouriteCharacter.add(this.link);
					}
					else {
						this.innerHTML = '添加收藏';
						lib.config.favouriteCharacter.remove(this.link);
					}
					if (ui.favouriteCharacter) {
						if (lib.config.favouriteCharacter.contains(this.link)) {
							for (var i = 0; i < ui.favouriteCharacter.childElementCount; i++) {
								if (ui.favouriteCharacter.childNodes[i].link == this.link) {
									break;
								}
							}
							if (i == ui.favouriteCharacter.childElementCount) {
								ui.create.button(this.link, 'character', ui.favouriteCharacter).listen(function (e) {
									this._banning = 'offline';
									ui.click.touchpop();
									ui.click.intro.call(this, e);
									_status.clicked = false;
									delete this._banning;
								}).classList.add('noclick');
							}
						}
						else {
							for (var i = 0; i < ui.favouriteCharacter.childElementCount; i++) {
								if (ui.favouriteCharacter.childNodes[i].link == this.link) {
									ui.favouriteCharacter.childNodes[i].remove();
									break;
								}
							}
						}
						var shownode = false;
						for (var i = 0; i < lib.config.favouriteCharacter.length; i++) {
							var favname = lib.config.favouriteCharacter[i];
							if (lib.character[favname]) {
								shownode = true; break;
							}
						}
						if (shownode) {
							ui.favouriteCharacter.node.style.display = '';
						}
						else {
							ui.favouriteCharacter.node.style.display = 'none';
						}
					}
					game.saveConfig('favouriteCharacter', lib.config.favouriteCharacter);
				}
				e.stopPropagation();
			},
			buttonnameenter: function () {
				if (this.buttonscrollinterval) {
					clearInterval(this.buttonscrollinterval);
				}
				var node = this.node.name;
				if (node.offsetHeight < node.scrollHeight) {
					var that = this;
					var num = 40;
					that.buttonscrollinterval = setInterval(function () {
						if (node.scrollTop + node.offsetHeight >= node.scrollHeight) {
							clearInterval(that.buttonscrollinterval);
							delete that.buttonscrollinterval;
						}
						else {
							if (num > 0) {
								num--;
							}
							else {
								node.scrollTop += 2;
							}
						}
					}, 16);
				}
			},
			buttonnameleave: function () {
				if (this.buttonscrollinterval) {
					clearInterval(this.buttonscrollinterval);
				}
				var node = this.node.name;
				if (node.offsetHeight < node.scrollHeight) {
					var that = this;
					that.buttonscrollinterval = setInterval(function () {
						if (node.scrollTop == 0) {
							clearInterval(that.buttonscrollinterval);
							delete that.buttonscrollinterval;
						}
						else {
							node.scrollTop -= 2;
						}
					}, 16);
				}
			},
			dragtouchdialog: function (e) {
				if (e.touches.length > 1 &&
					!this.classList.contains('popped') &&
					!this.classList.contains('fixed')) {
					_status.draggingtouchdialog = this;
					this._dragorigin = {
						clientX: e.touches[0].clientX,
						clientY: e.touches[0].clientY,
					};
					if (!this._dragtransform) {
						this._dragtransform = [0, 0];
					}
					this._dragorigintransform = this._dragtransform.slice(0);
					e.preventDefault();
					e.stopPropagation();
				}
			},
			identity: function (e) {
				if (_status.dragged) return;
				_status.clicked = true;
				if (!game.getIdentityList) return;
				if (_status.video) return;
				if (this.parentNode.forceShown) return;
				if (_status.clickingidentity) {
					for (var i = 0; i < _status.clickingidentity[1].length; i++) {
						_status.clickingidentity[1][i].delete();
						_status.clickingidentity[1][i].style.transform = '';
					}
					if (_status.clickingidentity[0] == this.parentNode) {
						delete _status.clickingidentity;
						return;
					}
				}
				var list = game.getIdentityList(this.parentNode);
				if (!list) return;
				if (lib.config.mark_identity_style == 'click') {
					var list2 = [];
					for (var i in list) {
						list2.push(i);
					}
					list2.push(list2[0]);
					for (var i = 0; i < list2.length; i++) {
						if (this.firstChild.innerHTML == list[list2[i]]) {
							this.firstChild.innerHTML = list[list2[i + 1]];
							this.dataset.color = list2[i + 1];
							break;
						}
					}
				} else {
					if (get.is.guozhanMode()) {
						if (get.mode() == 'SNH48')
							list = {
								S: 'S',
								N: 'N',
								H: 'H',
								X: 'X',
								B: 'B',
								E: 'E',
								J: 'J',
								G: 'G',
								N3: 'N3',
								Z: 'Z',
								C: 'C',
								K: 'K',
								guan: '官'
							}
						else
							list = {
								wei: '魏',
								shu: '蜀',
								wu: '吴',
								qun: '群'
							};
					}
					var list2 = get.copy(list);
					if (game.getIdentityList2) {
						game.getIdentityList2(list2);
					}
					var rect = this.parentNode.getBoundingClientRect();
					this._customintro = function (uiintro) {
						if (get.is.guozhanMode()) {
							uiintro.clickintro = true;
						}
						else {
							uiintro.touchclose = true;
						}
						// if(lib.config.theme!='woodden'){
						uiintro.classList.add('woodbg');
						// }
						if (get.is.phoneLayout()) {
							uiintro.style.width = '100px';
						}
						else {
							uiintro.style.width = '85px';
						}
						var source = this.parentNode;
						for (var i in list) {
							var node = ui.create.div();
							node.classList.add('guessidentity');
							node.classList.add('pointerdiv');
							ui.create.div('.menubutton.large', list2[i], node);
							if (!get.is.phoneLayout()) {
								node.firstChild.style.fontSize = '24px';
								node.firstChild.style.lineHeight = '24px';
							}
							if (get.is.guozhanMode()) {
								if (source._guozhanguess) {
									if (!source._guozhanguess.contains(i)) {
										node.classList.add('transparent');
									}
								}
								node._source = source;
								node.listen(ui.click.identitycircle);
							}
							else {
								node.listen(function () {
									var info = this.link;
									info[0].firstChild.innerHTML = info[1];
									info[0].dataset.color = info[2];
									_status.clicked = false;
								});
							}

							node.link = [this, list[i], i];
							uiintro.add(node);
						}
					};
					ui.click.touchpop();
					ui.click.intro.call(this, {
						clientX: (rect.left + rect.width) * game.documentZoom,
						clientY: (rect.top) * game.documentZoom
					});
					// var nodes=[];
					// _status.clickingidentity=[this.parentNode,nodes];
					// var num=1;
					// var dy=30;
					// if(get.is.phoneLayout()){
					// 	dy=45;
					// }
					// for(var i in list){
					// 	if(this.firstChild.innerHTML!=list[i]){
					// 		var node=ui.create.div('.identity.hidden.pointerdiv',this.parentNode,ui.click.identity2);
					// 		ui.create.div(node).innerHTML=list[i];
					// 		node.dataset.color=i;
					// 		ui.refresh(node);
					// 		node.show();
					// 		var transstr='translateY('+((num++)*dy)+'px)';
					// 		if(get.is.phoneLayout()){
					// 			transstr+=' scale(1.3)';
					// 		}
					// 		if(get.is.newLayout()&&this.parentNode.classList.contains('linked')){
					// 			transstr+=' rotate(90deg)';
					// 		}
					// 		node.style.transform=transstr;
					// 		nodes.push(node);
					// 	}
					// }
				}
			},
			identity2: function () {
				if (_status.clickingidentity) {
					_status.clicked = true;
					var player = _status.clickingidentity[0];
					var nodes = _status.clickingidentity[1];
					player.node.identity.dataset.color = this.dataset.color;
					player.node.identity.firstChild.innerHTML = this.firstChild.innerHTML;
					for (var i = 0; i < nodes.length; i++) {
						nodes[i].delete();
						nodes[i].style.transform = '';
					}
					delete _status.clickingidentity;
				}
			},
			roundmenu: function () {
				game.closeConnectMenu();
				switch (lib.config.round_menu_func) {
					case 'system':
						game.closePopped();
						ui.system1.classList.add('shown');
						ui.system2.classList.add('shown');
						game.closeMenu();
						ui.click.shortcut();
						break;
					case 'menu':
						if (ui.click.configMenu) {
							game.closePopped();
							game.pause2();
							ui.click.configMenu();
							ui.system1.classList.remove('shown');
							ui.system2.classList.remove('shown');
						}
						break;
					case 'pause':
						ui.click.pause();
						break;
					case 'auto':
						ui.click.auto();
						break;
				}
				_status.clicked = true;
			},
			pausehistory: function () {
				if (!lib.config.auto_popped_history) return;
				if (!ui.sidebar.childNodes.length) return;
				var uiintro = ui.create.dialog('hidden');
				uiintro.style.maxHeight = '400px';
				uiintro.add(ui.sidebar);
				return uiintro;
			},
			pauseconfig: function () {
				if (!lib.config.auto_popped_config) return;
				if (get.is.phoneLayout()) return;
				var uiintro = ui.create.dialog('hidden');
				uiintro.listen(function (e) {
					e.stopPropagation();
				});

				var rows = Math.floor(lib.config.all.mode.length / 3);
				uiintro.type = 'config';
				var modes = lib.config.modeorder || lib.config.all.mode.slice(0);
				for (var i = 0; i < modes.length; i++) {
					if (!lib.config.all.mode.contains(modes[i])) {
						modes.splice(i--, 1);
					}
				}
				for (var k = 0; k < rows; k++) {
					var node = ui.create.div('.newgame.pointernode');
					for (var i = 0; i < 3 && i + k * 3 < modes.length; i++) {
						var thismode = modes[i + k * 3];
						var div = ui.create.div(thismode == (_status.sourcemode || lib.config.mode) ? '.underlinenode.on' : '.underlinenode', node);
						div.innerHTML = lib.translate[thismode];
						div.link = thismode;
						div.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', function () {
							game.saveConfig('mode', this.link);
							localStorage.setItem(lib.configprefix + 'directstart', true);
							game.reload();
						});
					}
					uiintro.add(node);
				}

				return uiintro;
			},
			cardPileButton: function () {
				var uiintro = ui.create.dialog('hidden');
				uiintro.listen(function (e) {
					e.stopPropagation();
				});
				var num;
				if (game.online) {
					num = _status.cardPileNum || 0;
				}
				else {
					num = ui.cardPile.childNodes.length;
				}
				uiintro.add('剩余 <span style="font-family:' + 'xinwei' + '">' + num);

				if (_status.connectMode) return uiintro;
				uiintro.add('<div class="text center">轮数 <span style="font-family:xinwei">' + game.roundNumber + '</span>&nbsp;&nbsp;&nbsp;&nbsp;洗牌 <span style="font-family:xinwei">' + game.shuffleNumber + '</div>');
				uiintro.add('<div class="text center">弃牌堆</div>');
				if (ui.discardPile.childNodes.length) {
					var list = [];
					for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
						list.unshift(ui.discardPile.childNodes[i]);
					}
					uiintro.addSmall([list, 'card']);
				}
				else {
					uiintro.add('<div class="text center" style="padding-bottom:3px">无</div>');
				}
				return uiintro;
			},
			chat: function () {
				ui.system1.classList.add('shown');
				ui.system2.classList.add('shown');

				var uiintro = ui.create.dialog('hidden');
				uiintro.listen(function (e) {
					e.stopPropagation();
				});

				var list = ui.create.div('.caption');
				if (get.is.phoneLayout()) {
					list.style.maxHeight = '150px';
				}
				else {
					list.style.maxHeight = '250px';
				}
				list.style.overflow = 'scroll';
				lib.setScroll(list);
				uiintro.contentContainer.style.overflow = 'hidden';

				var input;
				var addEntry = function (info, clear) {
					if (list._chatempty) {
						list.innerHTML = '';
						delete list._chatempty;
					}
					var node = ui.create.div('.text.chat');
					node.innerHTML = info[0] + ': ' + info[1];
					list.appendChild(node);
					list.scrollTop = list.scrollHeight;
					uiintro.style.height = uiintro.content.scrollHeight + 'px';
				}
				_status.addChatEntry = addEntry;
				_status.addChatEntry._origin = uiintro;
				if (lib.chatHistory.length) {
					for (var i = 0; i < lib.chatHistory.length; i++) {
						addEntry(lib.chatHistory[i]);
					}
				}
				else {
					list._chatempty = true;
					list.appendChild(ui.create.div('.text.center', '无聊天记录'))
				}
				uiintro.add(list);
				uiintro.style.height = uiintro.content.offsetHeight + 'px';
				list.scrollTop = list.scrollHeight;

				if (!_status.chatValue) _status.chatValue = '';
				var node = uiintro.add('<input type="text" value="' + _status.chatValue + '">');
				node.style.paddingTop = 0;
				node.style.marginBottom = '16px';
				input = node.firstChild;
				input.style.width = 'calc(100% - 20px)';
				input.onchange = function () {
					_status.chatValue = input.value;
				}
				input.onkeydown = function (e) {
					if (e.keyCode == 13 && input.value) {
						var player = game.me;
						var str = input.value;
						if (!player) {
							if (game.connectPlayers) {
								if (game.online) {
									for (var i = 0; i < game.connectPlayers.length; i++) {
										if (game.connectPlayers[i].playerid == game.onlineID) {
											player = game.connectPlayers[i]; break;
										}
									}
								}
								else {
									player = game.connectPlayers[0];
								}
							}
						}
						if (!player) return;
						if (get.is.banWords(input.value)) {
							player.say(input.value);
							input.value = '';
							_status.chatValue = '';
						}
						else {
							if (game.online) {
								game.send('chat', game.onlineID, str);
							}
							else {
								lib.element.player.chat.call(player, str);
							}
							input.value = '';
							_status.chatValue = '';
						}
					}
					e.stopPropagation();
				}
				uiintro._onopen = function () {
					input.focus();
					list.scrollTop = list.scrollHeight;
				};
				uiintro._heightfixed = true;
				var emotionTitle = ui.create.div('.text.center', '聊天表情');
				emotionTitle.style.width = 'calc(100%)';
				uiintro.add(emotionTitle);
				var list1 = ui.create.div('');
				if (get.is.phoneLayout()) {
					list1.style.height = '100px';
				}
				else {
					list1.style.height = '150px';
				}
				list1.style.overflow = 'scroll';
				uiintro.add(list1);
				uiintro.style.height = uiintro.content.offsetHeight + 'px';
				var list2 = ui.create.div('');
				if (get.is.phoneLayout()) {
					list2.style.height = '100px';
				}
				else {
					list2.style.height = '150px';
				}
				list2.style.overflow = 'scroll';
				uiintro.add(list2);
				uiintro.style.height = uiintro.content.offsetHeight + 'px';
				for (var i in lib.emotionList) {
					var emotionPack = ui.create.div('.card.fullskin', '<img src="' + lib.assetURL + 'image/emotion/' + i + '/1.gif" width="50" height="50">', function () {
						emotionTitle.innerHTML = get.translation(this.pack);
						for (var j = 1; j <= lib.emotionList[this.pack]; j++) {
							var emotionButton = ui.create.div('.card.fullskin', '<img src="' + lib.assetURL + 'image/emotion/' + this.pack + '/' + j + '.gif" width="50" height="50">', function () {
								var player = game.me;
								if (!player) {
									if (game.connectPlayers) {
										if (game.online) {
											for (var i = 0; i < game.connectPlayers.length; i++) {
												if (game.connectPlayers[i].playerid == game.onlineID) {
													player = game.connectPlayers[i]; break;
												}
											}
										}
										else {
											player = game.connectPlayers[0];
										}
									}
								}
								if (!player) return;
								if (game.online) {
									game.send('emotion', game.onlineID, this.pack, this.emotionID);
								}
								else {
									lib.element.player.emotion.apply(player, [this.pack, this.emotionID]);
								}
							});
							emotionButton.emotionID = j;
							emotionButton.pack = this.pack;
							emotionButton.style.height = '50px';
							emotionButton.style.width = '50px';
							list2.appendChild(emotionButton);
						}
						list1.delete();
						uiintro.add(list2);
					});
					emotionPack.pack = i;
					emotionPack.style.height = '50px';
					emotionPack.style.width = '50px';
					list1.appendChild(emotionPack);
				}
				return uiintro;
			},
			volumn: function () {
				var uiintro = ui.create.dialog('hidden');
				uiintro.listen(function (e) {
					e.stopPropagation();
				});
				uiintro.add('背景音乐');
				var vol1 = ui.create.div('.volumn');
				uiintro.add(vol1);
				for (var i = 0; i < 8; i++) {
					var span = document.createElement('span');
					span.link = i + 1;
					span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.volumn_background);
					if (i < lib.config.volumn_background) {
						span.innerHTML = '●';
					}
					else {
						span.innerHTML = '○';
					}
					vol1.appendChild(span);
				}
				uiintro.add('游戏音效');

				var vol2 = ui.create.div('.volumn');
				uiintro.add(vol2);
				for (var i = 0; i < 8; i++) {
					var span = document.createElement('span');
					span.link = i + 1;
					span.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.volumn_audio);
					if (i < lib.config.volumn_audio) {
						span.innerHTML = '●';
					}
					else {
						span.innerHTML = '○';
					}
					vol2.appendChild(span);
				}
				uiintro.add(ui.create.div('.placeholder'));
				return uiintro;
			},
			volumn_background: function (e) {
				if (_status.dragged) return;
				var volume = this.link;
				if (volume === 1 && lib.config.volumn_background === 1) {
					volume = 0;
				}
				game.saveConfig('volumn_background', volume);
				ui.backgroundMusic.volume = volume / 8;
				for (var i = 0; i < 8; i++) {
					if (i < lib.config.volumn_background) {
						this.parentNode.childNodes[i].innerHTML = '●';
					}
					else {
						this.parentNode.childNodes[i].innerHTML = '○';
					}
				}
				e.stopPropagation();
			},
			volumn_audio: function (e) {
				if (_status.dragged) return;
				var volume = this.link;
				if (volume === 1 && lib.config.volumn_audio === 1) {
					volume = 0;
				}
				game.saveConfig('volumn_audio', volume);
				for (var i = 0; i < 8; i++) {
					if (i < lib.config.volumn_audio) {
						this.parentNode.childNodes[i].innerHTML = '●';
					}
					else {
						this.parentNode.childNodes[i].innerHTML = '○';
					}
				}
				e.stopPropagation();
			},
			hoverpopped: function () {
				if (this._uiintro) {
					return;
				}
				if (!this._poppedfunc) {
					return;
				}
				ui.click.touchpop(this.forceclick);
				var uiintro = this._poppedfunc();
				if (!uiintro) return;
				if (ui.currentpopped && ui.currentpopped._uiintro) {
					ui.currentpopped._uiintro.delete();
					delete ui.currentpopped._uiintro;
				}
				ui.currentpopped = this;
				uiintro.classList.add('popped');
				uiintro.classList.add('hoverdialog');
				uiintro.classList.add('static');
				this._uiintro = uiintro;

				ui.window.appendChild(uiintro);
				var width = this._poppedwidth || 330;
				uiintro.style.width = width + 'px';
				if (get.is.phoneLayout()) {
					width *= 1.3;
				}

				if (uiintro._heightfixed) {
					uiintro.style.height = uiintro.content.scrollHeight + 'px';
				}
				else {
					var height = this._poppedheight || uiintro.content.scrollHeight;
					var height2 = ui.window.offsetHeight - 260;
					if (get.is.phoneLayout()) {
						height2 = (ui.window.offsetHeight - 80) / 1.3;
					}
					uiintro.style.height = Math.min(height2, height) + 'px';
				}
				if (get.is.phoneLayout()) {
					uiintro.style.top = '70px';
				}
				else {
					uiintro.style.top = '50px';
				}
				var left = this.parentNode.offsetLeft + this.offsetLeft + this.offsetWidth / 2 - width / 2;
				if (left < 10) {
					left = 10;
				}
				else if (left + width > ui.window.offsetWidth - 10) {
					left = ui.window.offsetWidth - width - 10;
				}
				uiintro.style.left = left + 'px';
				uiintro._poppedorigin = this;
				if (!lib.config.touchscreen) {
					uiintro.addEventListener('mouseleave', ui.click.leavehoverpopped);
				}
				ui.click.shortcut(false);
				if (uiintro._onopen) {
					uiintro._onopen();
				}
				if (this._paused2 && !lib.config.touchscreen) {
					game.pause2();
					uiintro.classList.add('static');
					var layer = ui.create.div('.poplayer', ui.window);
					var clicklayer = function (e) {
						uiintro.delete();
						layer.remove();
						game.resume2();
						e.stopPropagation();
						return false;
					}
					uiintro.style.zIndex = 21;
					layer.onclick = clicklayer;
					layer.oncontextmenu = clicklayer;
					uiintro.addEventListener('mouseleave', clicklayer);
					uiintro.addEventListener('click', clicklayer);
				}
			},
			hoverpopped_leave: function () {
				this._poppedalready = false;
			},
			leavehoverpopped: function () {
				if (_status.dragged) return;
				if (this.classList.contains('noleave')) return;
				this.delete();
				var button = this._poppedorigin;

				var uiintro = this;
				setTimeout(function () {
					if (button._uiintro == uiintro) {
						delete button._uiintro;
					}
				}, 500);

			},
			dierevive: function () {
				if (game.me.isDead()) {
					game.me.revive(Math.max(1, game.me.maxHp));
					game.me.draw(2);
				}
				else {
					if (ui.revive) {
						ui.revive.close();
						delete ui.revive;
					}
				}
			},
			dieswap: function () {
				if (game.me.isDead()) {
					_status.clicked = true;
					var i, translation, intro, str;
					if (ui.intro) {
						ui.intro.close();
						if (ui.intro.source == 'dieswap') {
							delete ui.intro;
							ui.control.show();
							game.resume2();
							return;
						}
					}
					game.pause2();
					ui.control.hide();
					ui.intro = ui.create.dialog();
					ui.intro.source = 'dieswap';

					var players = [];
					for (var i = 0; i < game.players.length; i++) {
						if (game.players[i].isAlive()) {
							players.push(game.players[i]);
						}
					}
					ui.intro.add(players, true);
					var buttons = ui.intro.querySelectorAll('.button');
					for (var i = 0; i < buttons.length; i++) {
						buttons[i].addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.dieswap2);
					}
				}
				else {
					if (ui.swap) {
						ui.swap.close();
						delete ui.swap;
					}
				}
			},
			dieswap2: function () {
				if (_status.dragged) return;
				game.swapPlayer(this.link);
			},
			touchconfirm: function () {
				_status.touchconfirmed = true;
				document.removeEventListener('touchstart', ui.click.touchconfirm);
			},
			windowtouchstart: function (e) {
				if (window.inSplash) return;
				if (e.touches[0] && lib.config.swipe && e.touches.length < 2) {
					_status._swipeorigin = {
						clientX: e.touches[0].clientX,
						clientY: e.touches[0].clientY,
						time: get.utc()
					}
				}
				// if(window.ForceTouch&&!_status.paused2&&!_status.forcetouchinterval&&lib.config.enable_pressure){
				// 	_status.forcetouchinterval=setInterval(ui.click.forcetouch,30);
				// }
			},
			windowtouchmove: function (e) {
				e.preventDefault();
				if (window.inSplash) return;
				if (_status.draggingroundmenu) {
					delete _status._swipeorigin;
					if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform && e.touches.length) {
						var translate = ui.roundmenu._dragtransform.slice(0);
						var dx = e.touches[0].clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
						var dy = e.touches[0].clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
						translate[0] += dx;
						translate[1] += dy;
						if (dx * dx + dy * dy > 100) {
							if (ui.roundmenu._resetTimeout) {
								clearTimeout(ui.roundmenu._resetTimeout);
								delete ui.roundmenu._resetTimeout;
							}
						}
						ui.roundmenu._dragtouches = e.touches[0];
						ui.click.checkroundtranslate(translate);
					}
					_status.clicked = true;
				}
				else if (_status.draggingtouchdialog) {
					delete _status._swipeorigin;
					if (_status.draggingtouchdialog._dragorigin && _status.draggingtouchdialog._dragtransform && e.touches.length) {
						var translate = _status.draggingtouchdialog._dragtransform.slice(0);
						var dx = e.touches[0].clientX / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientX / game.documentZoom;
						var dy = e.touches[0].clientY / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientY / game.documentZoom;
						translate[0] += dx;
						translate[1] += dy;
						_status.draggingtouchdialog._dragtouches = e.touches[0];
						ui.click.checkdialogtranslate(translate, _status.draggingtouchdialog);
					}
					_status.clicked = true;
				}
				else if (_status._swipeorigin && e.touches[0]) {
					_status._swipeorigin.touches = e.touches[0];
				}

				if (_status.mousedragging && e.touches.length) {
					e.preventDefault();
					var item = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
					if (game.chess && ui.selected.cards.length) {
						var itemtype = get.itemtype(item);
						if (itemtype != 'card' && itemtype != 'button') {
							var ex = e.touches[0].clientX / game.documentZoom - ui.arena.offsetLeft;
							var ey = e.touches[0].clientY / game.documentZoom - ui.arena.offsetTop;
							for (var i = 0; i < game.players.length; i++) {
								var left = -ui.chessContainer.chessLeft + ui.chess.offsetLeft + game.players[i].getLeft();
								var top = -ui.chessContainer.chessTop + ui.chess.offsetTop + game.players[i].getTop();
								var width = game.players[i].offsetWidth;
								var height = game.players[i].offsetHeight;
								if (ex > left && ex < left + width && ey > top && ey < top + height) {
									item = game.players[i];
									break;
								}
							}
						}
					}
					while (item) {
						if (lib.config.enable_touchdragline && _status.mouseleft && !game.chess) {
							ui.canvas.width = ui.arena.offsetWidth;
							ui.canvas.height = ui.arena.offsetHeight;
							var ctx = ui.ctx;
							ctx.shadowBlur = 5;
							ctx.shadowColor = 'rgba(0,0,0,0.3)';
							ctx.strokeStyle = 'white';
							ctx.lineWidth = 3;
							ctx.setLineDash([8, 2]);

							ctx.beginPath();

							ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);

							if (_status.multitarget) {
								for (var i = 0; i < _status.lastdragchange.length; i++) {
									var exy = _status.lastdragchange[i]._lastdragchange;
									ctx.lineTo(exy[0], exy[1]);
								}
							}
							if (!_status.selectionfull) {
								ctx.lineTo(e.touches[0].clientX / game.documentZoom - ui.arena.offsetLeft, e.touches[0].clientY / game.documentZoom - ui.arena.offsetTop);
							}
							ctx.stroke();
							if (!_status.multitarget) {
								for (var i = 0; i < _status.lastdragchange.length; i++) {
									ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);
									var exy = _status.lastdragchange[i]._lastdragchange;
									ctx.lineTo(exy[0], exy[1]);
									ctx.stroke();
								}
							}
						}

						if (item == _status.mousedragorigin) {
							if (_status.mouseleft) {
								_status.mousedragging = null;
								_status.mousedragorigin = null;
								_status.clicked = false;
								game.uncheck();
								game.check();
								_status.clicked = true;
							}
							return;
						}
						var itemtype = get.itemtype(item);
						if (itemtype == 'card' || itemtype == 'button' || itemtype == 'player') {
							_status.mouseleft = true;
							if (ui.selected.cards.length) {
								ui.selected.cards[0].updateTransform(true, 100);
							}
							var ex = e.touches[0].clientX / game.documentZoom - ui.arena.offsetLeft;
							var ey = e.touches[0].clientY / game.documentZoom - ui.arena.offsetTop;
							var exx = ex, eyy = ey;
							if (game.chess) {
								ex -= -ui.chessContainer.chessLeft + ui.chess.offsetLeft;
								ey -= -ui.chessContainer.chessTop + ui.chess.offsetTop;
							}
							if (itemtype != 'player' || game.chess || (ex > item.offsetLeft && ex < item.offsetLeft + item.offsetWidth &&
								ey > item.offsetTop && ey < item.offsetTop + item.offsetHeight)) {
								var targetfixed = false;
								if (itemtype == 'player') {
									if (get.select(_status.event.selectTarget)[1] == -1) {
										targetfixed = true;
									}
								}
								if (!targetfixed && item.classList.contains('selectable') && _status.dragstatuschanged != item) {
									_status.mouseleft = true;
									_status.dragstatuschanged = item;
									_status.clicked = false;
									_status.dragged = false;
									var notbefore = itemtype == 'player' && !item.classList.contains('selected');
									ui.click[itemtype].call(item);
									if (item.classList.contains('selected')) {
										if (notbefore) {
											_status.lastdragchange.push(item);
											item._lastdragchange = [exx, eyy];
											if (lib.falseitem) {
												var from = [_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop];
												var to = [exx, eyy];
												var node = ui.create.div('.linexy.hidden');
												node.style.left = from[0] + 'px';
												node.style.top = from[1] + 'px';
												node.style.transitionDuration = '0.3s';
												node.style.backgroundColor = 'white';
												var dy = to[1] - from[1];
												var dx = to[0] - from[0];
												var deg = Math.atan(Math.abs(dy) / Math.abs(dx)) / Math.PI * 180;
												if (dx >= 0) {
													if (dy <= 0) {
														deg += 90;
													}
													else {
														deg = 90 - deg;
													}
												}
												else {
													if (dy <= 0) {
														deg = 270 - deg;
													}
													else {
														deg += 270;
													}
												}
												node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(0)';
												node.style.height = get.xyDistance(from, to) + 'px';
												if (game.chess) {
													ui.chess.appendChild(node);
												}
												else {
													ui.arena.appendChild(node);
												}
												ui.refresh(node);
												node.show();
												node.style.transform = 'rotate(' + (-deg) + 'deg) scaleY(1)';
												ui.touchlines.push(node);
												node._origin = item;
											}
										}
									}
									else {
										_status.lastdragchange.remove(item);
										for (var i = 0; i < ui.touchlines.length; i++) {
											if (ui.touchlines[i]._origin == item) {
												ui.touchlines[i].delete();
												ui.touchlines.splice(i--, 1);
											}
										}
									}
									_status.selectionfull = true;
									if (_status.event.filterButton && ui.selected.buttons.length < get.select(_status.event.selectButton)[1]) {
										_status.selectionfull = false;
									}
									else if (_status.event.filterCard && ui.selected.cards.length < get.select(_status.event.selectCard)[1]) {
										_status.selectionfull = false;
									}
									else if (_status.event.filterTarget && ui.selected.targets.length < get.select(_status.event.selectTarget)[1]) {
										_status.selectionfull = false;
									}
								}
							}
							return;
						}
						item = item.parentNode;
					}
					_status.mouseleft = true;
					_status.dragstatuschanged = null;
				}
			},
			windowtouchend: function (e) {
				delete _status.force;
				// if(_status.forcetouchinterval){
				// 	clearInterval(_status.forcetouchinterval);
				// 	delete _status.forcetouchinterval;
				// }
				if (window.inSplash) return;
				if (e.touches.length == 1 && !_status.dragged && !_status.draggingtouchdialog) {
					ui.click.pause();
				}
				if (_status.draggingroundmenu) {
					delete _status._swipeorigin;
					if (ui.roundmenu._resetTimeout) {
						clearTimeout(ui.roundmenu._resetTimeout);
						delete ui.roundmenu._resetTimeout;
					}
					var translate;
					if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform && ui.roundmenu._dragtouches) {
						var dx = ui.roundmenu._dragtouches.clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
						var dy = ui.roundmenu._dragtouches.clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
						if (dx * dx + dy * dy < 1000) {
							ui.click.roundmenu();
							ui.roundmenu._dragtransform = ui.roundmenu._dragorigintransform;
							translate = ui.roundmenu._dragtransform;
							ui.roundmenu.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
						}
						else {
							translate = ui.roundmenu._dragtransform;
							translate[0] += dx;
							translate[1] += dy;
							ui.click.checkroundtranslate();
						}
						delete ui.roundmenu._dragorigin;
					}
					else {
						ui.click.roundmenu();
					}
					_status.clicked = false;
					game.saveConfig('roundmenu_transform', translate);
					delete _status.draggingroundmenu;
				}
				else if (_status.draggingtouchdialog) {
					delete _status._swipeorigin;
					var translate;
					if (_status.draggingtouchdialog._dragorigin && _status.draggingtouchdialog._dragtransform && _status.draggingtouchdialog._dragtouches) {
						var dx = _status.draggingtouchdialog._dragtouches.clientX / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientX / game.documentZoom;
						var dy = _status.draggingtouchdialog._dragtouches.clientY / game.documentZoom - _status.draggingtouchdialog._dragorigin.clientY / game.documentZoom;
						translate = _status.draggingtouchdialog._dragtransform;
						translate[0] += dx;
						translate[1] += dy;
						ui.click.checkdialogtranslate(null, _status.draggingtouchdialog);

						delete _status.draggingtouchdialog._dragorigin;
					}
					_status.clicked = false;
					game.saveConfig('dialog_transform', translate);
					delete _status.draggingtouchdialog;
					_status.justdragged = true;
					setTimeout(function () {
						_status.justdragged = false;
					}, 500);
				}
				else if (_status._swipeorigin && !_status.paused2 && !_status.mousedragging && _status._swipeorigin.touches && !_status.filterCharacter) {
					if (get.utc() - _status._swipeorigin.time < 500) {
						var dx = _status._swipeorigin.touches.clientX / game.documentZoom - _status._swipeorigin.clientX / game.documentZoom;
						var dy = _status._swipeorigin.touches.clientY / game.documentZoom - _status._swipeorigin.clientY / game.documentZoom;
						var goswipe = function (action) {
							game.closeConnectMenu();
							switch (action) {
								case 'system':
									game.closePopped();
									ui.system1.classList.add('shown');
									ui.system2.classList.add('shown');
									game.closeMenu();
									ui.click.shortcut();
									break;
								case 'menu':
									if (ui.click.configMenu) {
										game.closePopped();
										game.pause2();
										ui.click.configMenu();
										ui.system1.classList.remove('shown');
										ui.system2.classList.remove('shown');
									}
									break;
								case 'pause':
									ui.click.pause();
									break;
								case 'auto':
									ui.click.auto();
									break;
								case 'chat':
									game.closeMenu();
									if (ui.chatButton) {
										ui.click.hoverpopped.call(ui.chatButton);
									}
									break;
							}
						}
						if (Math.abs(dx) < 100) {
							if (dy < -200) {
								goswipe(lib.config.swipe_up);
							}
							else if (dy > 200) {
								goswipe(lib.config.swipe_down);
							}
						}
						else if (Math.abs(dy) < 100) {
							if (dx < -200) {
								goswipe(lib.config.swipe_left);
							}
							else if (dx > 200) {
								goswipe(lib.config.swipe_right);
							}
						}
					}
				}
				var tmpflag = false;
				_status.mousedown = false;
				_status.clicked = false;
				if (_status.mousedragging && _status.mouseleft) {
					if (game.check()) {
						if (ui.confirm) {
							ui.confirm.close();
						}
						ui.click.ok();
						ui.canvas.width = ui.arena.offsetWidth;
						ui.canvas.height = ui.arena.offsetHeight;
					}
					else {
						game.uncheck();
						game.check();
					}
				}
				else if (_status.mousedragging && _status.mousedragorigin) {
					tmpflag = _status.mousedragorigin;
				}
				_status.lastdragchange.length = 0;
				_status.mousedragging = null;
				_status.mouseleft = false;
				_status.mousedragorigin = null;
				_status.dragstatuschanged = false;
				while (ui.touchlines.length) {
					ui.touchlines.shift().delete();
				}
				if (tmpflag) {
					game.check();
				}
				_status.dragged = false;
				_status.clicked = false;
			},
			checkroundtranslate: function (translate) {
				var translate = translate || ui.roundmenu._dragtransform;
				if (translate[1] + ui.roundmenu._position[1] + 50 + ui.arena.offsetTop > ui.window.offsetHeight) {
					translate[1] = ui.window.offsetHeight - (ui.roundmenu._position[1] + 50) - ui.arena.offsetTop;
				}
				else if (translate[1] + ui.roundmenu._position[1] + ui.arena.offsetTop < 0) {
					translate[1] = -ui.roundmenu._position[1] - ui.arena.offsetTop;
				}
				if (translate[0] + ui.roundmenu._position[0] + 50 + ui.arena.offsetLeft > ui.window.offsetWidth) {
					translate[0] = ui.window.offsetWidth - (ui.roundmenu._position[0] + 50) - ui.arena.offsetLeft;
				}
				else if (translate[0] + ui.roundmenu._position[0] + ui.arena.offsetLeft < 0) {
					translate[0] = -ui.roundmenu._position[0] - ui.arena.offsetLeft;
				}
				ui.roundmenu.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
			},
			checkdialogtranslate: function (translate, dialog) {
				var translate = translate || dialog._dragtransform;
				if (Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]) < 10) {
					translate[0] = 0;
					translate[1] = 0;
				}
				dialog.style.transform = 'translate(' + translate[0] + 'px,' + translate[1] + 'px)';
			},
			windowmousewheel: function (e) {
				_status.tempunpopup = e;
			},
			windowmousemove: function (e) {
				if (window.inSplash) return;
				if (_status.tempunpopup) {
					if (get.evtDistance(_status.tempunpopup, e) > 5) {
						delete _status.tempunpopup;
					}
				}
				if (e.button == 2) return;
				var dialogs = document.querySelectorAll('#window>.dialog.popped:not(.static)');
				for (var i = 0; i < dialogs.length; i++) {
					dialogs[i].delete();
				}
				var node = _status.currentmouseenter;
				var sourceitem = document.elementFromPoint(e.clientX, e.clientY);
				if (game.chess && ui.selected.cards.length) {
					var itemtype = get.itemtype(sourceitem);
					if (itemtype != 'card' && itemtype != 'button') {
						for (var i = 0; i < game.players.length; i++) {
							var ex = e.clientX / game.documentZoom - ui.arena.offsetLeft;
							var ey = e.clientY / game.documentZoom - ui.arena.offsetTop;
							var left = -ui.chessContainer.chessLeft + ui.chess.offsetLeft + game.players[i].getLeft();
							var top = -ui.chessContainer.chessTop + ui.chess.offsetTop + game.players[i].getTop();
							var width = game.players[i].offsetWidth;
							var height = game.players[i].offsetHeight;
							if (ex > left && ex < left + width && ey > top && ey < top + height) {
								sourceitem = game.players[i];
								break;
							}
						}
					}
				}
				var item = sourceitem;
				if (_status.mousedragging) {
					e.preventDefault();
					if (lib.config.enable_dragline) {
						// var i=0;
						// var startPoint0=[_status.mousedragging.clientX/game.documentZoom-ui.arena.offsetLeft,_status.mousedragging.clientY/game.documentZoom-ui.arena.offsetTop];
						// var startPoint=startPoint0;
						// var endPoint;
						// if(_status.multitarget){
						// 	for(;i<_status.lastdragchange.length;i++){
						// 		var exy=_status.lastdragchange[i]._lastdragchange;
						// 		endPoint=[exy[0],exy[1]];
						// 		_status.dragline[i]=game.linexy(startPoint.concat(endPoint),'drag',_status.dragline[i]);
						// 		startPoint=endPoint;
						// 	}
						// }
						// if(!_status.selectionfull){
						// 	endPoint=[e.clientX/game.documentZoom-ui.arena.offsetLeft,e.clientY/game.documentZoom-ui.arena.offsetTop];
						// 	_status.dragline[i]=game.linexy(startPoint.concat(endPoint),'drag',_status.dragline[i]);
						// 	startPoint=endPoint;
						// 	i++;
						// }
						// if(!_status.multitarget){
						// 	for(var j=0;j<_status.lastdragchange.length;j++){
						// 		i+=j;
						// 		var exy=_status.lastdragchange[j]._lastdragchange;
						// 		_status.dragline[i]=game.linexy(startPoint0.concat([exy[0],exy[1]]),'drag',_status.dragline[i]);
						// 	}
						// }
						// var remained=_status.dragline.splice(i+1);
						// for(var j=0;j<remained.length;j++){
						// 	if(remained[j]) remained[j].remove();
						// }

						ui.canvas.width = ui.arena.offsetWidth;
						ui.canvas.height = ui.arena.offsetHeight;
						var ctx = ui.ctx;
						ctx.shadowBlur = 5;
						ctx.shadowColor = 'rgba(0,0,0,0.3)';
						ctx.strokeStyle = 'white';
						ctx.lineWidth = 3;
						ctx.setLineDash([8, 2]);

						ctx.beginPath();

						ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);
						if (_status.multitarget) {
							for (var i = 0; i < _status.lastdragchange.length; i++) {
								var exy = _status.lastdragchange[i]._lastdragchange;
								ctx.lineTo(exy[0], exy[1]);
							}
						}
						if (!_status.selectionfull) {
							ctx.lineTo(e.clientX / game.documentZoom - ui.arena.offsetLeft, e.clientY / game.documentZoom - ui.arena.offsetTop);
						}
						ctx.stroke();
						if (!_status.multitarget) {
							for (var i = 0; i < _status.lastdragchange.length; i++) {
								ctx.moveTo(_status.mousedragging.clientX / game.documentZoom - ui.arena.offsetLeft, _status.mousedragging.clientY / game.documentZoom - ui.arena.offsetTop);
								var exy = _status.lastdragchange[i]._lastdragchange;
								ctx.lineTo(exy[0], exy[1]);
								ctx.stroke();
							}
						}
					}

					while (item) {
						if (item == _status.mousedragorigin) {
							if (_status.mouseleft) {
								_status.mousedragging = null;
								_status.mousedragorigin = null;
								_status.clicked = false;
								if (_status.event.type == 'phase' && !_status.event.skill && ui.confirm) {
									ui.confirm.classList.add('removing');
								}
								game.uncheck();
								game.check();
								_status.clicked = true;
							}
							return;
						}
						var itemtype = get.itemtype(item);
						if (itemtype == 'card' || itemtype == 'button' || itemtype == 'player') {
							_status.mouseleft = true;
							if (ui.selected.cards.length) {
								ui.selected.cards[0].updateTransform(true, 100);
							}
							var ex = e.clientX / game.documentZoom - ui.arena.offsetLeft;
							var ey = e.clientY / game.documentZoom - ui.arena.offsetTop;
							var exx = ex, eyy = ey;
							if (game.chess) {
								ex -= -ui.chessContainer.chessLeft + ui.chess.offsetLeft;
								ey -= -ui.chessContainer.chessTop + ui.chess.offsetTop;
							}
							if (itemtype != 'player' || game.chess || (ex > item.offsetLeft && ex < item.offsetLeft + item.offsetWidth &&
								ey > item.offsetTop && ey < item.offsetTop + item.offsetHeight)) {
								var targetfixed = false;
								if (itemtype == 'player') {
									if (get.select(_status.event.selectTarget)[1] == -1) {
										targetfixed = true;
									}
								}
								if (!targetfixed && item.classList.contains('selectable') && _status.dragstatuschanged != item) {
									_status.mouseleft = true;
									_status.dragstatuschanged = item;
									_status.clicked = false;
									var notbefore = itemtype == 'player' && !item.classList.contains('selected');
									ui.click[itemtype].call(item);
									if (item.classList.contains('selected')) {
										if (notbefore) {
											_status.lastdragchange.push(item);
											item._lastdragchange = [exx, eyy];
										}
									}
									else {
										_status.lastdragchange.remove(item);
									}
									_status.selectionfull = true;
									if (_status.event.filterButton && ui.selected.buttons.length < get.select(_status.event.selectButton)[1]) {
										_status.selectionfull = false;
									}
									else if (_status.event.filterCard && ui.selected.cards.length < get.select(_status.event.selectCard)[1]) {
										_status.selectionfull = false;
									}
									else if (_status.event.filterTarget && ui.selected.targets.length < get.select(_status.event.selectTarget)[1]) {
										_status.selectionfull = false;
									}
								}
							}
							return;
						}
						item = item.parentNode;
					}
					if (!_status.mouseleft) {
						_status.mouseleft = true;
						game.check();
						for (var i = 0; i < ui.selected.cards.length; i++) {
							ui.selected.cards[i].updateTransform(true);
						}
					}
					_status.dragstatuschanged = null;
				}
				else {
					while (item) {
						if (item == node && !node._mouseentercreated) {
							ui.click.mouseentercancel();
							var hoveration;
							if (typeof node._hoveration == 'number') {
								hoveration = node._hoveration;
							}
							else {
								hoveration = parseInt(lib.config.hoveration);
								if (node.classList.contains('button') ||
									(node.parentNode && node.parentNode.parentNode) == ui.me) {
									hoveration += 500;
								}
							}
							_status._mouseentertimeout = setTimeout(function () {
								if (_status.currentmouseenter != node || node._mouseentercreated || _status.tempunpopup ||
									_status.mousedragging || _status.mousedown || !node.offsetWidth || !node.offsetHeight) {
									return;
								}
								if (node._hoverfunc && !node._nopup) {
									var dialog = node._hoverfunc.call(node, e);
									if (dialog) {
										dialog.classList.add('popped');
										ui.window.appendChild(dialog);
										lib.placePoppedDialog(dialog, e);
										if (node._hoverwidth) {
											dialog.style.width = node._hoverwidth + 'px';
											dialog._hovercustomed = true;
										}
										node._mouseenterdialog = dialog;
										node._mouseentercreated = true;
									}
								}
							}, hoveration);
							break;
						}
						item = item.parentNode;
					}
					if (_status.draggingdialog) {
						var ddialog = _status.draggingdialog;
						if (ddialog._dragorigin && ddialog._dragtransform) {
							var translate = ddialog._dragtransform.slice(0);
							translate[0] += e.clientX / game.documentZoom - ddialog._dragorigin.clientX / game.documentZoom;
							translate[1] += e.clientY / game.documentZoom - ddialog._dragorigin.clientY / game.documentZoom;
							ui.click.checkdialogtranslate(translate, ddialog);
						}
						_status.clicked = true;
					}
					if (_status.draggingroundmenu) {
						if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform) {
							var translate = ui.roundmenu._dragtransform.slice(0);
							translate[0] += e.clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
							translate[1] += e.clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
							ui.click.checkroundtranslate(translate);
						}
						_status.clicked = true;
					}
				}
			},
			windowmousedown: function (e) {
				if (window.inSplash) return;
				if (!ui.window) return;
				if (e.button == 2) return;
				_status.mousedown = true;
				var dialogs = ui.window.querySelectorAll('#window>.dialog.popped:not(.static)');
				for (var i = 0; i < dialogs.length; i++) {
					dialogs[i].delete();
				}
				var sourceitem = document.elementFromPoint(e.clientX, e.clientY);
				var item = sourceitem;
				while (item) {
					var itemtype = get.itemtype(item);
					if (itemtype == 'button') break;
					if (itemtype == 'dialog' &&
						!item.classList.contains('popped') &&
						!item.classList.contains('fixed')) {
						var ddialog = item;
						_status.draggingdialog = ddialog;
						ddialog._dragorigin = e;
						if (!ddialog._dragtransform) {
							ddialog._dragtransform = [0, 0];
						}
						return;
					}
					if (item == ui.roundmenu) {
						_status.draggingroundmenu = true;
						ui.roundmenu._dragorigin = e;
						if (!ui.roundmenu._dragtransform) {
							ui.roundmenu._dragtransform = [0, 0];
						}
						return;
					}
					item = item.parentNode;
				}

				var evt = _status.event;
				if (!lib.config.enable_drag) return;
				if (!ui.arena.classList.contains('selecting')) return;
				if (!evt.isMine()) return;

				item = sourceitem;
				while (item) {
					var itemtype = get.itemtype(item);
					if (itemtype == 'card' || itemtype == 'button' || itemtype == 'player') {
						if (item.classList.contains('selectable') &&
							!item.classList.contains('selected') &&
							!item.classList.contains('noclick')) {
							_status.clicked = false;
							ui.click[itemtype].call(item);
							if (item.classList.contains('selected')) {
								_status.mousedragging = e;
								_status.mousedragorigin = item;
								_status.mouseleft = false;
								_status.selectionfull = false;
								_status.multitarget = false;
								_status.lastmouseutc = get.utc();
								ui.arena.classList.add('dragging');
							}
						}
						return;
					}
					item = item.parentNode;
				}
			},
			cardtouchstart: function (e) {
				if (e.touches.length != 1) return;
				if (!lib.config.enable_drag) return;
				if (!this.parentNode) return;
				if (!this.parentNode.parentNode) return;
				if (this.parentNode.parentNode.parentNode != ui.me) return;
				if (this.parentNode.parentNode.classList.contains('scrollh')) return;
				if (this.classList.contains('selectable') &&
					!this.classList.contains('selected') &&
					!this.classList.contains('noclick')) {
					this._waitingfordrag = {
						clientX: e.touches[0].clientX,
						clientY: e.touches[0].clientY
					};
				}
			},
			cardtouchmove: function (e) {
				ui.click.longpresscancel.call(this);
				if (this._waitingfordrag) {
					var drag = this._waitingfordrag;
					_status.clicked = false;
					_status.touchnocheck = true;
					ui.click.card.call(this);
					_status.touchnocheck = false;
					if (this.classList.contains('selected')) {
						_status.mousedragging = drag;
						_status.mousedragorigin = this;
						_status.mouseleft = false;
						_status.selectionfull = false;
						_status.multitarget = false;
					}
					delete this._waitingfordrag;
				}
			},
			windowmouseup: function (e) {
				delete _status.force;
				// if(_status.forcetouchinterval){
				// 	clearInterval(_status.forcetouchinterval);
				// 	delete _status.forcetouchinterval;
				// }
				if (window.inSplash) return;
				if (_status.draggingdialog) {
					var ddialog = _status.draggingdialog;
					var translate;
					if (ddialog._dragorigin && ddialog._dragtransform) {
						translate = ddialog._dragtransform;
						translate[0] += e.clientX / game.documentZoom - ddialog._dragorigin.clientX / game.documentZoom;
						translate[1] += e.clientY / game.documentZoom - ddialog._dragorigin.clientY / game.documentZoom;
						ui.click.checkdialogtranslate(null, ddialog);
						delete ddialog._dragorigin;
					}
					game.saveConfig('dialog_transform', translate);
					delete _status.draggingdialog;
				}
				if (_status.draggingroundmenu) {
					var translate;
					if (ui.roundmenu._dragorigin && ui.roundmenu._dragtransform) {
						var dx = e.clientX / game.documentZoom - ui.roundmenu._dragorigin.clientX / game.documentZoom;
						var dy = e.clientY / game.documentZoom - ui.roundmenu._dragorigin.clientY / game.documentZoom;
						if (dx * dx + dy * dy < 25) {
							ui.click.roundmenu();
						}
						translate = ui.roundmenu._dragtransform;
						translate[0] += dx;
						translate[1] += dy;
						ui.click.checkroundtranslate();
						delete ui.roundmenu._dragorigin;
					}
					game.saveConfig('roundmenu_transform', translate);
					delete _status.draggingroundmenu;
				}
				if (e.button == 2) {
					if (_status.mousedragging) {
						_status.mousedragging = null;
						_status.mouseleft = false;
						_status.mousedragorigin = null;
						_status.dragstatuschanged = false;
						game.uncheck();
						game.check();
						_status.noright = true;
					}
				}
				else {
					var tmpflag = false;
					_status.mousedown = false;
					for (var i = 0; i < ui.selected.cards.length; i++) {
						ui.selected.cards[i].updateTransform(true);
					}
					if (_status.mousedragging && _status.mouseleft) {
						if (game.check()) {
							if (ui.confirm) {
								ui.confirm.close();
							}
							ui.click.ok();
						}
						else {
							game.uncheck();
							game.check();
						}
					}
					else if (_status.mousedragging && _status.mousedragorigin) {
						tmpflag = _status.mousedragorigin;
					}
					_status.lastdragchange.length = 0;
					_status.mousedragging = null;
					_status.mouseleft = false;
					_status.mousedragorigin = null;
					_status.dragstatuschanged = false;
					if (ui.arena) {
						ui.canvas.width = ui.arena.offsetWidth;
						ui.canvas.height = ui.arena.offsetHeight;
					}
					if (tmpflag) {
						ui.click[get.itemtype(tmpflag)].call(tmpflag);
						game.check();
					}
					// ui.updatehl();
				}
				if (ui.arena) {
					ui.arena.classList.remove('dragging');
				}
			},
			mousemove: function () {
				if (!lib.config.hover_handcard && this.parentNode && this.parentNode.parentNode == ui.me) {
					return;
				}
				if (!_status.currentmouseenter) {
					_status.currentmouseenter = this;
				}
			},
			mouseenter: function () {
				if (!lib.config.hover_handcard && this.parentNode && this.parentNode.parentNode == ui.me) {
					return;
				}
				_status.currentmouseenter = this;
			},
			mouseleave: function () {
				ui.click.mouseentercancel();
				if (_status.currentmouseenter == this) {
					_status.currentmouseenter = null;
				}
				this._mouseentercreated = false;
			},
			mousedown: function () {
				ui.click.mouseentercancel();
				if (_status.currentmouseenter == this) {
					_status.currentmouseenter = null;
				}
				this._mouseentercreated = true;
			},
			mouseentercancel: function () {
				if (_status._mouseentertimeout) {
					clearTimeout(_status._mouseentertimeout);
					delete _status._mouseentertimeout
				}
			},
			hoverplayer: function (e) {
				var node = get.nodeintro(this, true);
				if (node) node.style.zIndex = 21;
				return node;
			},
			longpressdown: function (e) {
				if (_status.longpressed) return;
				if (this._longpresstimeout) {
					clearTimeout(this._longpresstimeout);
				}
				if (lib.config.longpress_info) {
					this._longpresstimeout = setTimeout(ui.click.longpresscallback, 500);
				}
				this._longpressevent = e;
				if (_status.longpressing && _status.longpressing != this) {
					ui.click.longpresscancel.call(_status.longpressing);
				}
				// if(window.ForceTouch&&!_status.forcetouchinterval&&lib.config.enable_pressure){
				// 	_status.forcetouchinterval=setInterval(ui.click.forcetouch,30);
				// }
				_status.longpressing = this;
			},
			longpresscallback: function () {
				if (!_status.longpressing) return;
				var node = _status.longpressing;
				var func = node._longpresscallback;
				var e = node._longpressevent;
				if (!func || !e) return;
				clearTimeout(node._longpresstimeout);
				_status.force = true;
				delete _status.longpressing;
				delete node._longpresstimeout;
				delete node._longpressevent;
				if (_status.mousedragging && _status.mouseleft) return;
				if (!_status.longpressed) {
					_status.longpressed = true;
					setTimeout(function () {
						_status.longpressed = false;
					}, 500);
					func.call(node, e);
					if (lib.config.touchscreen && lib.config.enable_drag && !node._waitingfordrag) {
						_status.mousedragging = null;
						_status.mousedragorigin = null;
						_status.clicked = false;
						game.uncheck();
						game.check();
						_status.clicked = true;
					}
					delete node._waitingfordrag;
					ui.click.touchpop();
				}
			},
			longpresscancel: function () {
				if (this._longpresstimeout) {
					clearTimeout(this._longpresstimeout);
					delete this._longpresstimeout;
				}
				delete this._longpressevent;
				if (_status.longpressing == this) {
					delete _status.longpressing;
				}
			},
			window: function () {
				var clicked = _status.clicked;
				var dialogtouched = false;
				if (_status.dialogtouched) {
					_status.dialogtouched = false;
					dialogtouched = true;
				}
				if (_status.dragged) return;
				if (_status.touchpopping) return;
				if (_status.reloading) return;
				if (_status.clicked || _status.clicked2) {
					_status.clicked = false;
					_status.clicked2 = false;
				}
				else {
					if (_status.clickingidentity) {
						for (var i = 0; i < _status.clickingidentity[1].length; i++) {
							_status.clickingidentity[1][i].delete();
							_status.clickingidentity[1][i].style.transform = '';
						}
						delete _status.clickingidentity;
					}
					if (!_status.event.isMine) return;
					if (ui.controls.length) {
						ui.updatec();
					}
					if (_status.editing) {
						if (_status.editing.innerHTML.length) {
							_status.editing.link = _status.editing.innerHTML;
						}
						_status.editing.innerHTML = get.translation(_status.editing.link);
						delete _status.editing;
					}
					else if (_status.choosing) {
						if (!_status.choosing.expand) {
							_status.choosing.parentNode.style.height = '';
							_status.choosing.nextSibling.delete();
							_status.choosing.previousSibling.show();
							delete _status.choosing;
						}
					}
					else if (ui.intro) {
						ui.intro.close();
						delete ui.intro;
						ui.control.show();
						game.resume2();
					}
					else if ((_status.event.isMine() || _status.event.forceMine) && !dialogtouched) {
						if (_status.event.custom.replace.window) {
							_status.event.custom.replace.window();
						}
						else {
							if (_status.event.skill && _status.event.name == 'chooseToUse') {
								ui.click.cancel();
							}
							else {
								game.uncheck();
								game.check();
							}
						}
					}
					if (!ui.shortcut.classList.contains('hidden')) {
						ui.click.shortcut(false);
					}
					if (get.is.phoneLayout() && ui.menuContainer && ui.menuContainer.classList.contains('hidden')) {
						if (ui.system2.classList.contains('shown')) {
							_status.removinground = true;
							setTimeout(function () {
								_status.removinground = false;
							}, 200);
						}
						ui.arena.classList.remove('phonetop');
						ui.system1.classList.remove('shown');
						ui.system2.classList.remove('shown');
						// if(ui.chessinfo){
						// 	ui.chessinfo.classList.remove('zoomed');
						// }
					}
				}
				if (_status.tempunpop) {
					_status.tempunpop = false;
				}
				else {
					game.closePopped();
				}
				if (_status.event.custom && _status.event.custom.add.window) {
					_status.event.custom.add.window(clicked);
				}
			},
			toggle: function () {
				if (_status.dragged) return;
				if (this.parentNode.classList.contains('disabled')) return;
				_status.tempunpop = true;
				if (this.link) {
					this.link = false;
					this.classList.remove('on');
					if (this.additionalCommand) this.additionalCommand(false, this.parentNode);
				}
				else {
					this.link = true;
					this.classList.add('on');
					if (this.additionalCommand) this.additionalCommand(true, this.parentNode);
				}
			},
			editor: function () {
				if (_status.dragged) return;
				if (_status.editing) return;
				_status.clicked = true;
				this.innerHTML = '';
				_status.editing = this;
				if (this.additionalCommand) this.additionalCommand(this);
			},
			switcher: function () {
				if (_status.dragged) return;
				if (this.parentNode.classList.contains('disabled')) return;
				if (_status.choosing) return;
				_status.clicked = true;
				_status.tempunpop = true;
				this.previousSibling.hide();
				var node = ui.create.div('.switcher', this.parentNode).animate('start');
				for (var i = 0; i < this.choice.length; i++) {
					var choice = ui.create.div('.pointerdiv', node);
					choice.innerHTML = get.translation(this.choice[i]);
					choice.link = this.choice[i];
					choice.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.choice);
				}
				// this.parentNode.style.height=(node.offsetHeight)+'px';
				_status.choosing = this;
				if (!_status.choosing.expand) {
					_status.choosing.expand = true;
					setTimeout(function () {
						_status.choosing.expand = false;
					}, 500);
				}
			},
			choice: function () {
				if (_status.dragged) return;
				if (!_status.choosing) return;
				_status.choosing.link = this.link;
				_status.choosing.innerHTML = get.translation(this.link);
				this.parentNode.parentNode.style.height = '';
				this.parentNode.delete();
				_status.choosing.previousSibling.show();
				delete _status.choosing;
				if (this.parentNode.parentNode.querySelector('.toggle').additionalCommand) {
					this.parentNode.parentNode.querySelector('.toggle').additionalCommand(this.link, this.parentNode.parentNode);
				}
			},
			button: function () {
				if (_status.dragged) return;
				if (_status.clicked) return;
				if (_status.tempNoButton) return;
				if (_status.draggingtouchdialog) return;
				if (this.classList.contains('noclick')) return;
				if (_status.justdragged) return;
				_status.clicked = true;
				var custom = _status.event.custom;
				if (custom.replace.button) {
					custom.replace.button(this);
					return;
				}
				if (!_status.event.isMine()) return;
				if (this.classList.contains('selectable') == false) return;
				if (this.classList.contains('selected')) {
					ui.selected.buttons.remove(this);
					this.classList.remove('selected');
					if (_status.multitarget || _status.event.complexSelect) {
						game.uncheck();
						game.check();
					}
				}
				else {
					this.classList.add('selected');
					ui.selected.buttons.add(this);
				}
				if (custom.add.button) {
					custom.add.button();
				}
				game.check();
			},
			touchintro: function () {
				var rect = this.getBoundingClientRect();
				ui.click.touchpop();
				ui.click.intro.call(this, {
					clientX: rect.left + 18,
					clientY: rect.top + 12
				});
				_status.clicked = false;
			},
			card: function () {
				delete this._waitingfordrag;
				if (_status.dragged) return;
				if (_status.clicked) return;
				if (ui.intro) return;
				_status.clicked = true;
				if (this.parentNode && (this.parentNode.classList.contains('judges') || this.parentNode.classList.contains('marks'))) {
					var rect = this.getBoundingClientRect();
					ui.click.touchpop();
					ui.click.intro.call(this, {
						clientX: rect.left + 18,
						clientY: rect.top + 12
					});
					_status.clicked = false;
					return;
				}
				var custom = _status.event.custom;
				if (custom.replace.card) {
					custom.replace.card(this);
					return;
				}
				if (this.classList.contains('selectable') == false) return;
				if (this.classList.contains('selected')) {
					ui.selected.cards.remove(this);
					if (_status.multitarget || _status.event.complexSelect) {
						game.uncheck();
						game.check();
					}
					else {
						this.classList.remove('selected');
						this.updateTransform();
					}
				}
				else {
					ui.selected.cards.add(this);
					this.classList.add('selected');
					this.updateTransform(true);
				}
				if (game.chess && get.config('show_range') && !_status.event.skill && this.classList.contains('selected') &&
					_status.event.isMine() && _status.event.name == 'chooseToUse') {
					var player = _status.event.player;
					var range = get.info(this).range;
					if (range) {
						if (typeof range.attack === 'number') {
							player.createRangeShadow(Math.min(8, player.getAttackRange(true) + range.attack - 1));
						}
						else if (typeof range.global === 'number') {
							player.createRangeShadow(Math.min(8, player.getGlobalFrom() + range.global));
						}
					}
				}
				if (custom.add.card) {
					custom.add.card();
				}
				game.check();

				if (lib.config.popequip && get.is.phoneLayout() &&
					arguments[0] != 'popequip' && ui.arena && ui.arena.classList.contains('selecting') &&
					this.parentNode.classList.contains('popequip')) {
					var rect = this.getBoundingClientRect();
					ui.click.touchpop();
					ui.click.intro.call(this.parentNode, {
						clientX: rect.left + 18,
						clientY: rect.top + 12
					});
				}
			},
			avatar: function () {
				if (!lib.config.doubleclick_intro) return;
				if (this.parentNode.isUnseen(0)) return;
				if (!lib.character[this.parentNode.name]) return;
				if (!ui.menuContainer) return;
				var avatar = this;
				var player = this.parentNode;
				if (!game.players.contains(player) && !game.dead.contains(player)) return;
				if (!this._doubleClicking) {
					this._doubleClicking = true;
					setTimeout(function () {
						avatar._doubleClicking = false;
					}, 500);
					return;
				}
				// ui.click.skin(this,player.name);
				game.pause2();
				ui.click.charactercard(player.name, null, null, true, this);
			},
			avatar2: function () {
				if (!lib.config.doubleclick_intro) return;
				if (this.parentNode.classList.contains('unseen2')) return;
				if (!lib.character[this.parentNode.name2]) return;
				if (!ui.menuContainer) return;
				var avatar = this;
				var player = this.parentNode;
				if (!game.players.contains(player) && !game.dead.contains(player)) return;
				if (!this._doubleClicking) {
					this._doubleClicking = true;
					setTimeout(function () {
						avatar._doubleClicking = false;
					}, 500);
					return;
				}
				// ui.click.skin(this,player.name2);
				game.pause2();
				ui.click.charactercard(player.name2, null, null, true, this);
			},
			player: function () {
				return ui.click.target.apply(this, arguments);
			},
			target: function (e) {
				if (_status.dragged) return;
				if (_status.clicked) return;
				if (ui.intro) return;
				if (this.classList.contains('connect')) {
					if (game.online) {
						if (game.onlinezhu) {
							if (!this.playerid && game.connectPlayers) {
								if (lib.configOL.mode == 'versus' || lib.configOL.mode == 'doudizhu') return;
								if (lib.configOL.mode == 'identity' && lib.configOL.identity_mode == 'zhong') return;
								if (!this.classList.contains('unselectable2') && lib.configOL.number <= 2) return;
								this.classList.toggle('unselectable2')
								if (this.classList.contains('unselectable2')) {
									lib.configOL.number--;
								}
								else {
									lib.configOL.number++;
								}
								game.send('changeNumConfig', lib.configOL.number,
									game.connectPlayers.indexOf(this), this.classList.contains('unselectable2'));
							}
						}
						else if (this.hasOwnProperty('roomindex')) {
							if (this.roomfull) {
								alert('房间已满');
							}
							else if (this.roomgaming && !game.onlineID) {
								if (this.config && this.config.observe) {
									alert('房间暂时不可旁观');
								}
								else {
									alert('房间不允许旁观');
								}
							}
							else if (!this.roomempty && this.version != lib.versionOL) {
								if (this.version > lib.versionOL) {
									alert('加入失败：你的游戏版本过低');
								}
								else {
									alert('加入失败：房主的游戏版本过低');
								}
							}
							else {
								if (!_status.enteringroom) {
									_status.enteringroom = true;
									_status.enteringroomserver = this.serving;
									if (this.roomempty) {
										_status.roomindex = this.roomindex;
										ui.click.connectMenu();
									}
									else {
										game.send('server', 'enter', this.roomindex, lib.config.connect_nickname, lib.config.connect_avatar);
									}
								}
							}
						}
						return;
					}
					if (this.playerid) {
						if (this.ws) {
							if (confirm('是否踢出' + this.nickname + '？')) {
								var id = get.id();
								this.ws.send(function (id) {
									if (game.ws) {
										game.ws.close();
										game.saveConfig('reconnect_info');
										game.saveConfig('banned_info', id);
									}
								}, id);
								lib.node.banned.push(id);
							}
						}
					}
					else {
						if (lib.configOL.mode == 'versus' || lib.configOL.mode == 'doudizhu' || lib.configOL.mode == 'single') return;
						if (lib.configOL.mode == 'identity' && (lib.configOL.identity_mode == 'zhong' || lib.configOL.identity_mode == 'purple')) return;
						if (!this.classList.contains('unselectable2') && lib.configOL.number <= 2) return;
						this.classList.toggle('unselectable2')
						if (this.classList.contains('unselectable2')) {
							lib.configOL.number--;
						}
						else {
							lib.configOL.number++;
						}
						game.send('server', 'config', lib.configOL);
						game.updateWaiting();
					}
					return;
				}
				_status.clicked = true;
				var custom = _status.event.custom;
				if (custom.replace.target) {
					custom.replace.target(this, e);
					return;
				}
				if (this.classList.contains('selectable') == false) return;
				this.unprompt();
				if (this.classList.contains('selected')) {
					ui.selected.targets.remove(this);
					if (_status.multitarget || _status.event.complexSelect) {
						game.uncheck();
						game.check();
					}
					else {
						this.classList.remove('selected');
					}
				}
				else {
					ui.selected.targets.add(this);
					if (_status.event.name == 'chooseTarget' || _status.event.name == 'chooseToUse' || _status.event.name == 'chooseCardTarget') {
						var targetprompt = null;
						if (_status.event.targetprompt) {
							targetprompt = _status.event.targetprompt;
						}
						else if (_status.event.skill && !get.info(_status.event.skill).viewAs) {
							targetprompt = get.info(_status.event.skill).targetprompt;
						}
						else if (_status.event.name == 'chooseToUse') {
							var currentcard = get.card();
							if (currentcard) {
								targetprompt = get.info(currentcard).targetprompt;
							}
						}
						if (targetprompt) {
							if (Array.isArray(targetprompt)) {
								targetprompt = targetprompt[Math.min(targetprompt.length - 1, ui.selected.targets.indexOf(this))];
							}
							else if (typeof targetprompt == 'function') {
								targetprompt = targetprompt(this);
							}
							if (targetprompt && typeof targetprompt == 'string') {
								this.prompt(targetprompt);
							}
						}
					}
					this.classList.add('selected');
				}
				if (custom.add.target) {
					custom.add.target();
				}
				game.check();
			},
			control2: function () {
				if (this.childNodes.length == 1 && !this._doubleclick) {
					ui.click.control.call(this.firstChild);
				}
			},
			control: function () {
				if (_status.dragged) return;
				if (ui.control.classList.contains('hidden')) return;
				var node = this.parentNode;
				if (node) {
					if (node._doubleclick) {
						return;
					}
					else {
						node._doubleclick = true;
						setTimeout(function () {
							node._doubleclick = false;
						}, 500);
					}
					if (node.classList.contains('hidden')) return;
					if (node.classList.contains('removing')) return;
					if (node.classList.contains('disabled')) return;
				}
				if (ui.intro) {
					ui.intro.close();
					delete ui.intro;
				}
				_status.clicked = true;
				if (this.parentNode.custom) {
					this.parentNode.custom(this.link, this);
					return;
				}
				if (this.link == 'ok') {
					ui.click.ok(this);
				}
				else if (this.link == 'cancel') {
					ui.click.cancel(this);
				}
				else {
					_status.event.result = {
						buttons: ui.selected.buttons.slice(0),
						cards: ui.selected.cards.slice(0),
						targets: ui.selected.targets.slice(0),
						control: this.link,
						links: get.links(ui.selected.buttons)
					};
					if (this.parentNode.close != false) {
						game.uncheck();
						this.parentNode.close();
					}
					game.resume();
				}
			},
			dialogcontrol: function () {
				_status.event.result = {
					buttons: ui.selected.buttons.slice(0),
					cards: ui.selected.cards.slice(0),
					targets: ui.selected.targets.slice(0),
					control: this.link,
					links: get.links(ui.selected.buttons)
				};
				game.resume();
			},
			skill: function (skill) {
				var info = get.info(skill);
				var event = _status.event;
				event.backup(skill);
				if (info.filterCard && info.discard != false && info.lose != false && !info.viewAs) {
					var cards = event.player.getCards(event.position);
					for (var i = 0; i < cards.length; i++) {
						if (!lib.filter.cardDiscardable(cards[i], event.player)) {
							cards[i].uncheck('useSkill');
						}
					}
				}
				if (typeof event.skillDialog == 'object') {
					event.skillDialog.close();
				}
				if (event.isMine()) {
					event.skillDialog = true;
				}
				game.uncheck();
				game.check();
				if (event.skillDialog) {
					var str = get.translation(skill);
					if (info.prompt) {
						var str2;
						if (typeof info.prompt == 'function') {
							str2 = info.prompt(event);
						}
						else {
							str2 = info.prompt;
						}
						event.skillDialog = ui.create.dialog(str, '<div><div style="width:100%;text-align:center">' + str2 + '</div></div>');
						if (info.longprompt) {
							event.skillDialog.forcebutton = true;
							ui.update();
						}
					}
					else if (info.promptfunc) {
						event.skillDialog = ui.create.dialog(str, '<div><div style="width:100%">' + info.promptfunc(event, event.player) + '</div></div>');
					}
					else if (lib.dynamicTranslate[skill]) {
						event.skillDialog = ui.create.dialog(str, '<div><div style="width:100%">' + lib.dynamicTranslate[skill](event.player, skill) + '</div></div>');
					}
					else if (lib.translate[skill + '_info']) {
						event.skillDialog = ui.create.dialog(str, '<div><div style="width:100%">' + lib.translate[skill + '_info'] + '</div></div>');
					}
				}
			},
			ok: function (node) {
				var event = _status.event;
				if (event.custom.replace.confirm) {
					event.custom.replace.confirm(true); return;
				}
				event.result = {
					buttons: ui.selected.buttons.slice(0),
					cards: ui.selected.cards.slice(0),
					targets: ui.selected.targets.slice(0),
					confirm: 'ok',
					bool: true,
					links: get.links(ui.selected.buttons)
				};
				if (node) {
					node.parentNode.close();
				}
				if (event.skill) {
					event.result.skill = event.skill;
					if (typeof get.info(event.skill).viewAs == 'function') event.result.card = get.info(event.skill).viewAs(event.result.cards, event.player);
					else event.result.card = get.copy(get.info(event.skill).viewAs);
					if (event.result.cards.length == 1 && event.result.card) {
						event.result.card.suit = get.suit(event.result.cards[0]);
						event.result.card.number = get.number(event.result.cards[0]);
					}
					if (event.skillDialog && get.objtype(event.skillDialog) == 'div') {
						event.skillDialog.close();
					}
					var cards = event.player.getCards('hej');
					for (var i = 0; i < cards.length; i++) {
						cards[i].recheck('useSkill');
					}
					event.restore();
				}
				if (ui.skills) ui.skills.close();
				if (ui.skills2) ui.skills2.close();
				if (ui.skills3) ui.skills3.close();
				game.uncheck();
				if (event.custom.add.confirm) {
					event.custom.add.confirm(true);
				}
				game.resume();
			},
			cancel: function (node) {
				var event = _status.event;
				if (event.custom.replace.confirm) {
					event.custom.replace.confirm(false); return;
				}
				if (event.skill && !event.norestore) {
					if (event.skillDialog && get.objtype(event.skillDialog) == 'div') {
						event.skillDialog.close();
					}
					if (typeof event.dialog == 'string' && event.isMine()) {
						event.dialog = ui.create.dialog(event.dialog);
					}
					if (_status.event.type == 'phase' && ui.confirm) {
						ui.confirm.classList.add('removing');
					}
					// ui.control.animate('nozoom',100);
					event.restore();
					var cards = event.player.getCards('hej');
					for (var i = 0; i < cards.length; i++) {
						cards[i].recheck('useSkill');
					}
					game.uncheck();
					game.check();
					return;
				}
				event.result = {
					confirm: 'cancel',
					bool: false
				};
				if (node) {
					node.parentNode.close();
				}
				if (ui.skills) ui.skills.close();
				if (ui.skills2) ui.skills2.close();
				if (ui.skills3) ui.skills3.close();
				game.uncheck();
				if (event.custom.add.confirm) {
					event.custom.add.confirm(true);
				}
				game.resume();
			},
			logv: function (e) {
				if (_status.currentlogv) {
					if (_status.currentlogv == this) return;
					if (_status.logvtimeout) {
						clearTimeout(_status.logvtimeout);
					}
					var that = this;
					_status.logvtimeout = setTimeout(function () {
						if (!_status.currentlogv) {
							_status.currentlogv = that;
							ui.click.intro.call(that, e);
						}
					}, 200);
					this.logvtimeout = _status.logvtimeout;
				}
				else {
					_status.currentlogv = this;
					ui.click.intro.call(this, e);
				}
			},
			logvleave: function () {
				if (_status.currentlogv == this) {
					setTimeout(function () {
						delete _status.currentlogv;
					}, 150);
				}
				if (this.logvtimeout) {
					clearTimeout(this.logvtimeout);
					if (_status.logvtimeout == this.logvtimeout) {
						delete _status.logvtimeout;
					}
					delete this.logvtimeout;
				}
			},
			charactercard: function (name, sourcenode, noedit, resume, avatar) {
				if (_status.dragged) return;
				if (lib.config.theme != 'simple') {
					ui.window.classList.add('shortcutpaused');
					ui.menuContainer.classList.add('forceopaque');
				}
				else {
					ui.window.classList.add('systempaused');
					ui.menuContainer.classList.add('transparent2');
				}
				if (lib.config.blur_ui) {
					ui.arena.classList.add('blur');
					ui.system.classList.add('blur');
					ui.menuContainer.classList.add('blur');
				}
				var layer = ui.create.div('.popup-container');
				var clicklayer = function (e) {
					if (_status.touchpopping) return;
					if (_status.dragged) return;
					ui.window.classList.remove('shortcutpaused');
					ui.window.classList.remove('systempaused');
					ui.menuContainer.classList.remove('forceopaque');
					ui.menuContainer.classList.remove('transparent2');
					ui.arena.classList.remove('blur');
					ui.system.classList.remove('blur');
					ui.menuContainer.classList.remove('blur');
					this.delete();
					e.stopPropagation();
					if (resume) game.resume2();
					return false;
				}
				var uiintro = ui.create.div('.menubg.charactercard', layer);
				var playerbg = ui.create.div('.menubutton.large.ava', uiintro);
				var bg = ui.create.div('.avatar', playerbg, function () {
					if (changeskinfunc) {
						changeskinfunc();
					}
				}).setBackground(name, 'character');
				var changeskinfunc = null;
				var nameskin = name;
				var nameskin2 = name;
				var gzbool = false;
				if (nameskin.indexOf('gz_shibing') == 0) {
					nameskin = nameskin.slice(3, 11);
				}
				else if (nameskin.indexOf('gz_') == 0) {
					nameskin = nameskin.slice(3);
					gzbool = true;
				}
				var changeskin = function () {
					var node = ui.create.div('.changeskin', '可换肤', playerbg);
					var avatars = ui.create.div('.avatars', playerbg);
					changeskinfunc = function () {
						playerbg.classList.add('scroll');
						if (node._created) {
							return;
						}
						node._created = true;
						var createButtons = function (num) {
							if (!num) return;
							if (num >= 4) {
								avatars.classList.add('scroll');
								if (lib.config.touchscreen) {
									lib.setScroll(avatars);
								}
							}
							for (var i = 0; i <= num; i++) {
								var button = ui.create.div(avatars, function () {
									playerbg.classList.remove('scroll');
									if (this._link) {
										lib.config.skin[nameskin] = this._link;
										bg.style.backgroundImage = this.style.backgroundImage;
										if (sourcenode) sourcenode.style.backgroundImage = this.style.backgroundImage;
										if (avatar) avatar.style.backgroundImage = this.style.backgroundImage;
										game.saveConfig('skin', lib.config.skin);
									}
									else {
										delete lib.config.skin[nameskin];
										if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) {
											bg.setBackground(nameskin2, 'character');
											if (sourcenode) sourcenode.setBackground(nameskin2, 'character');
											if (avatar) avatar.setBackground(nameskin2, 'character');
										}
										else {
											bg.setBackground(nameskin, 'character');
											if (sourcenode) sourcenode.setBackground(nameskin, 'character');
											if (avatar) avatar.setBackground(nameskin, 'character');
										}
										game.saveConfig('skin', lib.config.skin);
									}
								});
								button._link = i;
								if (i) {
									button.setBackgroundImage('image/skin/' + nameskin + '/' + i + '.jpg');
								}
								else {
									if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) button.setBackground(nameskin2, 'character', 'noskin');
									else button.setBackground(nameskin, 'character', 'noskin');
								}
							}
						};
						var num = 1;
						var loadImage = function () {
							var img = new Image();
							img.onload = function () {
								num++;
								loadImage();
							}
							img.onerror = function () {
								num--;
								createButtons(num);
							}
							img.src = lib.assetURL + 'image/skin/' + nameskin + '/' + num + '.jpg';
						}
						if (lib.config.change_skin) {
							loadImage();
						}
						else {
							createButtons(lib.skin[nameskin]);
						}
					};
				};
				if (lib.config.change_skin) {
					var img = new Image();
					img.onload = changeskin;
					img.src = lib.assetURL + 'image/skin/' + nameskin + '/1.jpg';
				}
				else if (lib.config.debug && lib.skin[nameskin]) {
					changeskin();
				}
				var ban = ui.create.div('.menubutton.large.ban.character', uiintro, '禁用', function (e) {
					if (this.classList.contains('unselectable')) return;
					if (typeof noedit == 'string') {
						this.classList.toggle('active');
						var bannedname = noedit + '_banned';
						if (!lib.config[bannedname]) {
							lib.config[bannedname] = [];
						}
						if (this.classList.contains('active')) {
							lib.config[bannedname].add(name);
						}
						else {
							lib.config[bannedname].remove(name);
						}
						game.saveConfig(bannedname, lib.config[bannedname]);
						ban.updateBanned();
					}
					else {
						ui.click.touchpop();
						ui.click.intro.call(this, e);
						_status.clicked = true;
					}
				});
				ban.link = name;
				ban._banning = 'offline';
				ban.updateBanned = function () {
					if (noedit === true) return;
					if (lib.config[get.mode() + '_banned'] && lib.config[get.mode() + '_banned'].contains(name)) {
						ban.classList.add('active');
					}
					else {
						ban.classList.remove('active');
					}
					if (sourcenode && sourcenode.updateBanned) {
						sourcenode.updateBanned();
					}
				};
				ban.updateBanned();
				var fav = ui.create.div('.menubutton.large.fav', uiintro, '收藏', function () {
					if (this.classList.contains('unselectable')) return;
					this.classList.toggle('active');
					if (this.classList.contains('active')) {
						lib.config.favouriteCharacter.add(name);
					}
					else {
						lib.config.favouriteCharacter.remove(name);
					}
					game.saveConfig('favouriteCharacter', lib.config.favouriteCharacter);
				});
				if (noedit === true) {
					fav.classList.add('unselectable');
					ban.classList.add('unselectable');
				}
				else if (lib.config.favouriteCharacter.contains(name)) {
					fav.classList.add('active');
				}
				var intro = ui.create.div('.characterintro', get.characterIntro(name), uiintro);
				var intro2 = ui.create.div('.characterintro.intro2', uiintro);
				var list = get.character(name, 3) || [];
				var skills = ui.create.div('.characterskill', uiintro);
				if (lib.config.touchscreen) {
					lib.setScroll(intro);
					lib.setScroll(intro2);
					lib.setScroll(skills);
				}

				if (lib.config.mousewheel) {
					skills.onmousewheel = ui.click.mousewheel;
				}
				var clickSkill = function (e) {
					var current = this.parentNode.querySelector('.active');
					if (current) {
						current.classList.remove('active');
					}
					this.classList.add('active');
					intro2.innerHTML = '<span style="font-weight:bold;margin-right:5px">' + get.translation(this.link) + '</span>' + get.skillInfoTranslation(this.link);
					var info = get.info(this.link);
					var skill = this.link;
					var playername = this.linkname;
					var skillnode = this;
					if (info.derivation) {
						var derivation = info.derivation;
						if (typeof derivation == 'string') {
							derivation = [derivation];
						}
						for (var i = 0; i < derivation.length; i++) {
							intro2.innerHTML += '<br><br><span style="font-weight:bold;margin-right:5px">' + get.translation(derivation[i]) + '</span>' + get.skillInfoTranslation(derivation[i]);
						}
					}
					if (info.alter) {
						intro2.innerHTML += '<br><br><div class="hrefnode skillversion"></div>';
						var skillversionnode = intro2.querySelector('.hrefnode.skillversion');
						if (lib.config.vintageSkills.contains(skill)) {
							skillversionnode.innerHTML = '切换至新版';
						}
						else {
							skillversionnode.innerHTML = '切换至旧版';
						}
						skillversionnode.listen(function () {
							if (lib.config.vintageSkills.contains(skill)) {
								lib.config.vintageSkills.remove(skill);
								lib.translate[skill + '_info'] = lib.translate[skill + '_info_alter'];
							}
							else {
								lib.config.vintageSkills.push(skill);
								lib.translate[skill + '_info'] = lib.translate[skill + '_info_origin'];
							}
							game.saveConfig('vintageSkills', lib.config.vintageSkills);
							clickSkill.call(skillnode, 'init');
						});
					}
					if (lib.config.background_speak && e !== 'init') {
						var audioname = this.link;
						if (info.audioname2 && info.audioname2[playername]) {
							audioname = info.audioname2[playername];
							info = lib.skill[audioname];
						}
						var audioinfo = info.audio;
						var that = this;
						var getIndex = function (i) {
							if (typeof that.audioindex != 'number') {
								that.audioindex = i;
							}
							that.audioindex++;
							if (that.audioindex > i) {
								that.audioindex = 1;
							}
							return that.audioindex;
						};
						if (typeof audioinfo == 'string') {
							if (audioinfo.indexOf('ext:') == 0) {
								audioinfo = audioinfo.split(':');
								if (audioinfo.length == 3) {
									if (audioinfo[2] == 'true') {
										game.playAudio('..', 'extension', audioinfo[1], audioname);
									}
									else {
										audioinfo[2] = parseInt(audioinfo[2]);
										if (audioinfo[2]) {
											game.playAudio('..', 'extension', audioinfo[1], audioname + getIndex(audioinfo[2]));
										}
									}
								}
								return;
							}
							else {
								audioname = audioinfo;
								if (lib.skill[audioinfo]) {
									audioinfo = lib.skill[audioinfo].audio;
								}
							}
						}
						else if (Array.isArray(audioinfo)) {
							audioname = audioinfo[0];
							audioinfo = audioinfo[1];
						}
						if (typeof audioinfo == 'number') {
							if (Array.isArray(info.audioname) && info.audioname.contains(playername)) audioname = audioname + '_' + playername;
							game.playAudio('skill', audioname + getIndex(audioinfo));
						}
						else if (audioinfo) {
							if (Array.isArray(info.audioname) && info.audioname.contains(playername)) audioname = audioname + '_' + playername;
							game.playAudio('skill', audioname);
						}
						else if (true && info.audio !== false) {
							if (Array.isArray(info.audioname) && info.audioname.contains(playername)) audioname = audioname + '_' + playername;
							game.playSkillAudio(audioname, getIndex(2));
						}
					}
				}
				var initskill = false;
				for (var i = 0; i < list.length; i++) {
					if (!get.info(list[i]) || get.info(list[i]).nopop) continue;
					if (!lib.translate[list[i]] || !lib.translate[list[i] + '_info']) continue;
					var skilltrans = get.translation(list[i]);
					if (skilltrans.indexOf('&nbsp;') == 0) {
						skilltrans = skilltrans.slice(6);
					}
					var current = ui.create.div('.menubutton.large', skills, clickSkill, skilltrans);
					current.link = list[i];
					current.linkname = name;
					if (!initskill) {
						initskill = true;
						clickSkill.call(current, 'init');
					}
				}

				uiintro.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', ui.click.touchpop);
				layer.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clicklayer);
				ui.window.appendChild(layer);
			},
			intro: function (e) {
				if (_status.dragged) return;
				_status.clicked = true;
				if (this.classList.contains('player') && !this.name) {
					return;
				}
				if (this.parentNode == ui.historybar) {
					if (ui.historybar.style.zIndex == '22') {
						if (_status.removePop) {
							if (_status.removePop(this) == false) return;
						}
						else {
							return;
						}
					}
					ui.historybar.style.zIndex = 22;
				}
				var uiintro;
				if (this.classList.contains('card') && this.parentNode &&
					this.parentNode.classList.contains('equips') && get.is.phoneLayout() &&
					!get.is.mobileMe(this.parentNode.parentNode)) {
					uiintro = get.nodeintro(this.parentNode.parentNode, false, e);
				}
				uiintro = uiintro || get.nodeintro(this, false, e);
				if (!uiintro) return;
				uiintro.classList.add('popped');
				uiintro.classList.add('static');
				ui.window.appendChild(uiintro);
				var layer = ui.create.div('.poplayer', ui.window);
				var clicklayer = function (e) {
					if (_status.touchpopping) return;
					delete _status.removePop;
					uiintro.delete();
					this.remove();
					ui.historybar.style.zIndex = '';
					delete _status.currentlogv;
					if (!ui.arena.classList.contains('menupaused') && !uiintro.noresume) game.resume2();
					if (e && e.stopPropagation) e.stopPropagation();
					if (uiintro._onclose) {
						uiintro._onclose();
					}
					return false;
				}
				layer.addEventListener(lib.config.touchscreen ? 'touchend' : 'click', clicklayer);
				if (!lib.config.touchscreen) layer.oncontextmenu = clicklayer;
				if (this.parentNode == ui.historybar && lib.config.touchscreen) {
					var rect = this.getBoundingClientRect();
					e = { clientX: 0, clientY: rect.top + 30 };
				}
				lib.placePoppedDialog(uiintro, e);
				if (this.parentNode == ui.historybar) {
					if (lib.config.show_history == 'right') {
						uiintro.style.left = (ui.historybar.offsetLeft - 230) + 'px';
					}
					else {
						uiintro.style.left = (ui.historybar.offsetLeft + 60) + 'px';
					}
				}
				uiintro.style.zIndex = 21;
				var clickintro = function () {
					if (_status.touchpopping) return;
					delete _status.removePop;
					layer.remove();
					this.delete();
					ui.historybar.style.zIndex = '';
					delete _status.currentlogv;
					if (!ui.arena.classList.contains('menupaused') && !uiintro.noresume) game.resume2();
					if (uiintro._onclose) {
						uiintro._onclose();
					}
				};
				var currentpop = this;
				_status.removePop = function (node) {
					if (node == currentpop) return false;
					layer.remove();
					uiintro.delete();
					delete _status.removePop;
					return true;
				};
				if (uiintro.clickintro) {
					uiintro.listen(function () {
						_status.clicked = true;
					});
					uiintro._clickintro = clicklayer;
				}
				else if (!lib.config.touchscreen) {
					uiintro.addEventListener('mouseleave', clickintro);
					uiintro.addEventListener('click', clickintro);
				}
				else if (uiintro.touchclose) {
					uiintro.listen(clickintro);
				}
				uiintro._close = clicklayer;

				game.pause2();
				return uiintro;
			},
			intro2: function () {
				if (ui.intro) {
					ui.intro.close();
					if (ui.intro.source == this) {
						delete ui.intro;
						ui.control.show();
						game.resume2();
						return;
					}
				}
			},
			auto: function () {
				if (ui.auto.classList.contains('hidden') && arguments[0] !== 'forced') return;
				if (_status.paused2) return;
				ui.click.shortcut(false);
				if (!_status.auto) {
					_status.auto = true;
					ui.auto.classList.add('glow');
					ui.arena.classList.add('auto');

					if (_status.imchoosing && _status.paused) {
						if (ui.confirm) ui.confirm.close();
						ui.control.hide();
						if (_status.event.switchToAuto) {
							_status.event.switchToAuto();
						}
						else {
							if (_status.paused && _status.imchoosing) {
								game.uncheck();
								_status.event.redo();
							}
						}
						game.resume();
					}
					else if (_status.event.switchToAuto) {
						_status.event.switchToAuto();
					}
					if (game.online) {
						game.send('auto');
					}
					else if (_status.connectMode) {
						game.broadcastAll(function (player) {
							player.setNickname(player.nickname + ' - 托管');
						}, game.me);
					}
				}
				else {
					if (game.notMe) return;
					ui.control.show();
					_status.auto = false;
					ui.auto.classList.remove('glow');
					ui.arena.classList.remove('auto');

					if (game.online) {
						game.send('unauto');
					}
					else if (_status.connectMode) {
						game.broadcastAll(function (player) {
							player.setNickname(player.nickname);
						}, game.me);
					}
				}
			},
			wuxie: function () {
				if (this.classList.contains('hidden')) return;
				this.classList.toggle('glow');
				if (this.classList.contains('glow') && _status.event.type == 'wuxie' &&
					_status.event.isMine() && ui.confirm && _status.imchoosing) {
					ui.click.cancel(ui.confirm.lastChild);
				}
			},
			tempnowuxie: function () {
				if (this.classList.contains('hidden')) return;
				this.classList.toggle('glow');
				if (this.classList.contains('glow') && _status.event.type == 'wuxie' &&
					_status.event.isMine() && ui.confirm && _status.imchoosing) {
					var triggerevent = _status.event.getTrigger();
					if (triggerevent && this._origin == triggerevent.parent.id) {
						if (triggerevent.targets && triggerevent.num == triggerevent.targets.length - 1) {
							this.close();
						}
					}
					ui.click.cancel(ui.confirm.lastChild);
				}
			},
			pause: function () {
				if (_status.paused2) return;
				if (_status.nopause) return;
				if (!_status.video) {
					if (ui.pause.classList.contains('hidden')) return;
					if (!_status.gameStarted) return;
				}
				ui.system.hide();
				game.pause2();
				var node = ui.create.pause().animate('start');
				ui.sidebar3.innerHTML = '';
				if (lib.config.show_discardpile) {
					for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
						var div = ui.create.div(ui.sidebar3);
						div.innerHTML = get.translation(ui.discardPile.childNodes[i]);
						ui.sidebar3.insertBefore(div, ui.sidebar3.firstChild);
					}
				}
				node.appendChild(ui.sidebar);
				node.appendChild(ui.sidebar3);
				ui.historybar.classList.add('paused');
				ui.arena.classList.add('paused');
				ui.window.classList.add('touchinfohidden');
				ui.time.hide();
				if (game.onpause) {
					game.onpause();
				}
			},
			resume: function (e) {
				if (_status.pausing) return;
				if (_status.dragged) return;
				if (_status.clicked) return;
				this.delete();
				ui.system.show();
				ui.time.show();
				ui.historybar.classList.remove('paused');
				ui.arena.classList.remove('paused');
				ui.window.classList.remove('touchinfohidden');
				game.resume2();
				e.stopPropagation();
				if (game.onresume) {
					game.onresume();
				}
				return false;
			},
			config: function () {
				if (!ui.click.configMenu) return;
				if (_status.paused2) _status.config2 = false;
				else _status.config2 = true;

				_status.clicked = true;
				game.pause2();
				ui.click.configMenu();
				ui.system1.classList.remove('shown');
				ui.system2.classList.remove('shown');
			},
			swap: function () {
				if (_status.dragged) return;
				if (this.classList.contains('dead')) return;
				if (_status.over) return;
				if (ui.auto) ui.auto.show();
				if (ui.wuxie) ui.wuxie.show();
				game.swapPlayer(this);
			},
			mousewheel: function (evt) {
				if (this.firstChild && this.firstChild.classList.contains('handcards') &&
					!this.classList.contains('scrollh')) return;
				var node = this;
				var num = this._scrollnum || 6;
				var speed = this._scrollspeed || 16;
				clearInterval(node.interval);
				if (evt.detail > 0 || evt.wheelDelta < 0) {
					node.interval = setInterval(function () {
						if (num-- && Math.abs(node.scrollLeft + node.clientWidth - node.scrollWidth) > 0) {
							node.scrollLeft += speed;
						}
						else {
							clearInterval(node.interval);
						}
					}, 16);
				}
				else {
					node.interval = setInterval(function () {
						if (num-- && node.scrollLeft > 0) {
							node.scrollLeft -= speed;
						}
						else {
							clearInterval(node.interval);
						}
					}, 16);
				}
			},
			touchStart: function (e) {
				this.startX = e.touches[0].clientX / game.documentZoom;
				this.startY = e.touches[0].clientY / game.documentZoom;
				_status.dragged = false;
			},
			dialogtouchStart: function (e) {
				ui.click.touchStart.call(this, e);
				_status.dialogtouched = true;
			},
			touchScroll: function (e) {
				if (_status.mousedragging) return;
				if (_status.draggingtouchdialog) return;
				if (!_status.dragged) {
					if (Math.abs(e.touches[0].clientX / game.documentZoom - this.startX) > 10 ||
						Math.abs(e.touches[0].clientY / game.documentZoom - this.startY) > 10) {
						_status.dragged = true;
					}
				}
				if ((this == ui.handcards1Container || this == ui.handcards2Container) && !this.classList.contains('scrollh')) {
					e.preventDefault();
				}
				else if (lib.device == 'ios' && this.scrollHeight <= this.offsetHeight + 5 && this.scrollWidth <= this.offsetWidth + 5) {
					e.preventDefault();
				}
				else {
					delete _status._swipeorigin;
					e.stopPropagation();
				}
			},
			autoskill: function (bool, node) {
				var list = lib.config.autoskilllist;
				if (bool) {
					list.remove(node.link);
				}
				else {
					list.add(node.link);
				}
				game.saveConfig('autoskilllist', list);
			},
			skillbutton: function () {
				this.func(this.link);
			},
			autoskill2: function (e) {
				this.classList.toggle('on');
				var list = [];
				if (lib.skill[this.link].frequent) {
					list.push(this.link);
				}
				if (lib.skill[this.link].subfrequent) {
					for (var i = 0; i < lib.skill[this.link].subfrequent.length; i++) {
						list.push(this.link + '_' + lib.skill[this.link].subfrequent[i]);
					}
				}
				for (var i = 0; i < list.length; i++) {
					if (this.classList.contains('on')) {
						lib.config.autoskilllist.remove(list[i]);
					}
					else {
						lib.config.autoskilllist.add(list[i]);
					}
				}
				game.saveConfig('autoskilllist', lib.config.autoskilllist);
				ui.click.touchpop();
				e.stopPropagation();
			},
			// forcetouch:function(){
			// 	if(_status.force||_status.dragged){
			// 		clearInterval(_status.forcetouchinterval);
			// 		delete _status.forcetouchinterval;
			// 		return;
			// 	}
			// 	window.ForceTouch.getForceTouchData(function(ForceTouchData){
			// 		if(ForceTouchData.touches[0]){
			// 			var force = parseFloat(ForceTouchData.touches[0].force);
			// 			if(force > 0.2){
			// 				_status.force=true;
			// 				var taptic=false;
			// 				if(_status.longpressing){
			// 					delete _status.longpressing._waitingfordrag;
			// 					ui.click.touchpop();
			// 					ui.click.longpresscallback.call(_status.longpressing);
			// 					taptic=true;
			// 				}
			// 				else if(!_status.forceright){
			// 					_status.forceright=true;
			// 					setTimeout(function(){
			// 						_status.forceright=false;
			// 					},600);
			// 					if(_status.mousedragging){
			// 						_status.mousedragging=null;
			// 						_status.mouseleft=false;
			// 						_status.mousedragorigin=null;
			// 						_status.dragstatuschanged=false;
			// 						game.uncheck();
			// 						game.check();
			// 					}
			// 					switch(lib.config.pressure_click){
			// 						case 'pause':ui.click.pause();break;
			// 						case 'auto':ui.click.auto();break;
			// 						case 'config':ui.click.config();break;
			// 					}
			// 					taptic=true;
			// 				}
			// 				if(taptic&&lib.config.pressure_taptic){
			// 					if(window.TapticEngine){
			// 						window.TapticEngine.generateTapticFeedback();
			// 					}
			// 					else{
			// 						game.vibrate(50);
			// 					}
			// 				}
			// 			}
			// 		}
			// 	});
			// },
			// pressurepause:function(force,event){
			// 	if(!_status.force&&!_status.mousedragging&&force>=0.5&&!_status.forceright){
			// 		_status.force=true;
			// 		_status.forceright=true;
			// 		setTimeout(function(){
			// 			_status.forceright=false;
			// 		},600);
			// 		switch(lib.config.pressure_click){
			// 			case 'pause':ui.click.pause();break;
			// 			case 'auto':ui.click.auto();break;
			// 			case 'config':ui.click.config();break;
			// 		}
			// 	}
			// },
			// rightpressure:function(force, event){
			// 	if(force>0){
			// 		_status.force=true;
			// 	}
			// 	if(force>=0.5){
			// 		if(_status.mousedragging){
			// 			_status.mousedragging=null;
			// 			_status.mouseleft=false;
			// 			_status.mousedragorigin=null;
			// 			_status.dragstatuschanged=false;
			// 			game.uncheck();
			// 			game.check();
			// 		}
			// 		ui.click.rightplayer.call(this,event);
			// 		_status.clickedplayer=false;
			// 	}
			// },
			rightplayer: function (e) {
				if (this._nopup) return false;
				if (_status.clickedplayer) {
					return false;
				}

				if (this._mouseenterdialog && this._mouseenterdialog.parentNode) {
					this._mouseenterdialog.delete();
				}
				else {
					ui.click.intro.call(this, e);
				}
				_status.clickedplayer = true;
				_status.clicked = false;
				ui.click.longpresscancel.call(this);
				return false;
			},
			right: function (e) {
				if (window.inSplash) return false;
				if (lib.config.touchscreen) return;
				if (_status.noright) {
					_status.noright = false;
					return false;
				}
				if (_status.clickedplayer) {
					_status.clickedplayer = false;
					return;
				}
				game.closePopped();
				switch (lib.config.right_click) {
					case 'shortcut': ui.click.shortcut(); break;
					case 'pause': ui.click.pause(); break;
					case 'auto': ui.click.auto(); break;
					case 'config': ui.click.config(); break;
				}
				e.preventDefault();
				return false;
			}
		},
		selected: {
			buttons: [], cards: [], targets: []
		},
		clear: function () {
			game.addVideo('uiClear');
			var thrown = document.getElementsByClassName('thrown');
			var nodes = [];
			var i;
			for (i = 0; i < thrown.length; i++) {
				nodes.push(thrown[i]);
			}
			for (i = 0; i < nodes.length; i++) {
				if (!nodes[i].fixed) nodes[i].delete();
			}
		},
		updatec: function () {
			if (_status.noupdatec) return;
			var length = 0;
			var controls = [];
			var widths = [];
			var add = function (node, first) {
				var thiswidth = parseInt(node.style.width);
				if (thiswidth) {
					thiswidth += 8;
					length += thiswidth;
					if (first) {
						widths.unshift(thiswidth);
					}
					else {
						widths.push(thiswidth);
					}
				}
				else {
					length += node.offsetWidth;
					if (first) {
						widths.unshift(node.offsetWidth);
					}
					else {
						widths.push(node.offsetWidth);
					}
				}
				if (first) {
					controls.unshift(node);
				}
				else {
					controls.push(node);
				}
			}
			var stayleft = null;
			for (var i = 0; i < ui.control.childNodes.length; i++) {
				if (ui.control.childNodes[i].classList.contains('removing')) continue;
				if (!stayleft && lib.config.wuxie_right && ui.control.childNodes[i].stayleft) {
					stayleft = ui.control.childNodes[i];
				}
				else {
					add(ui.control.childNodes[i]);
				}
			}
			if (stayleft) {
				var fullwidth = 0;
				var fullright = (game.layout == 'long' || game.layout == 'long2' || game.chess || (game.layout != 'nova' && parseInt(ui.arena.dataset.number) <= 5));
				for (var i = 0; i < widths.length; i++) {
					fullwidth += widths[i] + 6;
					if (get.is.phoneLayout()) fullwidth += 6;
				}
				fullwidth /= 2;
				fullwidth += stayleft.offsetWidth;
				if (get.is.phoneLayout()) {
					fullwidth += 18;
				}
				else {
					fullwidth += 12;
				}
				if (fullright) {
					fullwidth += 124;
					if ((game.layout == 'long2' || game.layout == 'nova') && ui.arena.dataset.number == '8' && get.mode() != 'boss') {
						fullwidth += game.me.getLeft();
					}
				}
				else {
					fullwidth += 154;
				}
				if (game.layout != 'default' && game.layout != 'newlayout' && ui.arena.offsetWidth / 2 >= fullwidth) {
					var current_offset = stayleft._offset;
					if (fullright) {
						stayleft._offset = Math.ceil(-ui.arena.offsetWidth / 2) + 135;
						if ((game.layout == 'long2' || game.layout == 'nova') && ui.arena.dataset.number == '8' && get.mode() != 'boss') {
							stayleft._offset += game.me.getLeft();
						}
					}
					else {
						stayleft._offset = Math.ceil(-ui.arena.offsetWidth / 2) + 165;
					}
					if (current_offset != stayleft._offset) {
						stayleft.animate('controlpressdownx', 500);
						stayleft.style.transform = 'translateX(' + stayleft._offset + 'px)';
					}
				}
				else {
					add(stayleft, true);
				}
			}
			if (!controls.length) return;
			var offset = -length / 2;
			var control = controls.shift();
			if (control._offset != offset) {
				control.animate('controlpressdownx', 500);
				control.style.transform = 'translateX(' + offset + 'px)';
				control._offset = offset;
			}
			while (controls.length) {
				var control = controls.shift();
				var width = widths.shift();
				offset += width + 6;
				if (get.is.phoneLayout()) {
					offset += 6;
				}
				if (control._offset != offset) {
					control.animate('controlpressdownx', 500);
					control.style.transform = 'translateX(' + offset + 'px)';
					control._offset = offset;
				}
			}
		},
		updatex: function () {
			ui.update.apply(this, arguments);
			ui.updatehl();
			for (var i = 0; i < lib.onresize.length; i++) {
				lib.onresize[i]();
			}
			var cfg = game.documentZoom / game.deviceZoom;
			ui.updated();
			game.documentZoom = cfg * game.deviceZoom;
			ui.updatez();
			delete ui._updatexr;
		},
		updatexr: function () {
			if (ui._updatexr) {
				clearTimeout(ui._updatexr);
			}
			ui._updatexr = setTimeout(ui.updatex, 500);
		},
		updatejm: function (player, nodes, start, inv) {
			if (typeof start != 'number') {
				start = 0;
			}
			var str;
			if (get.is.mobileMe(player) || game.layout == 'default' || player.classList.contains('linked')) {
				str = 'translateX(';
				if (inv) {
					str += '-';
				}
			}
			else {
				str = 'translateY(';
			}
			var num = 0;
			for (var i = 0; i < nodes.childElementCount; i++) {
				var node = nodes.childNodes[i];
				if (i < start) {
					node.style.transform = '';
				}
				else if (node.classList.contains('removing')) {
					start++;
				}
				else {
					ui.refresh(node);
					node.classList.remove('drawinghidden');
					node._transform = str + ((i - start) * 28) + 'px)';
					node.style.transform = node._transform;
				}
			}
		},
		updatem: function (player) {
			if (player) {
				var start = 0;
				if (!player.classList.contains('linked2') || !ui.arena.classList.contains('nolink')) {
					start = 1;
				}
				ui.updatejm(player, player.node.marks, start, get.is.mobileMe(player));
			}
			else {
				for (var i = 0; i < game.players.length; i++) {
					ui.updatem(game.players[i]);
				}
			}
		},
		updatej: function (player) {
			if (player) {
				ui.updatejm(player, player.node.judges);
			}
			else {
				for (var i = 0; i < game.players.length; i++) {
					ui.updatej(game.players[i]);
				}
			}
		},
		updatehl: function () {
			if (!game.me) return;
			if (!ui.handcards1Container || !ui.handcards2Container) return;
			if (!ui.handcards1Container.childNodes.length) return;
			var hs1 = [], hs2 = [];
			for (var i = 0; i < ui.handcards1Container.firstChild.childElementCount; i++) {
				if (!ui.handcards1Container.firstChild.childNodes[i].classList.contains('removing')) {
					hs1.push(ui.handcards1Container.firstChild.childNodes[i]);
				}
			}
			for (var i = 0; i < ui.handcards2Container.firstChild.childElementCount; i++) {
				if (!ui.handcards2Container.firstChild.childNodes[i].classList.contains('removing')) {
					hs2.push(ui.handcards2Container.firstChild.childNodes[i]);
				}
			}
			var offset1, offset12 = 0;
			if (!lib.config.fold_card) {
				offset1 = 112;
				ui.handcards1Container.classList.add('scrollh');
			}
			else {
				offset1 = Math.min(112, (ui.handcards1Container.offsetWidth - 128) / (hs1.length - 1));
				if (hs1.length > 1 && offset1 < 32) {
					offset1 = 32;
					ui.handcards1Container.classList.add('scrollh');
				}
				else {
					ui.handcards1Container.classList.remove('scrollh');
				}
			}
			if (offset1 < 100) {
				offset12 = 100 - offset1;
			}
			for (var i = 0; i < hs1.length; i++) {
				hs1[i].style.transform = 'translateX(' + (i * offset1) + 'px)';
				hs1[i]._transform = 'translateX(' + (i * offset1) + 'px)';
				ui.refresh(hs1[i]);
				hs1[i].classList.remove('drawinghidden');
				if (offset12 > 40) {
					offset12 = 90 - hs1[i].node.info.offsetWidth;
					hs1[i].node.info.querySelector('span').style.display = 'none';
					if (hs1[i].node.name.classList.contains('long')) {
						hs1[i].node.name.style.transform = 'translateY(16px)  scale(0.85)';
						hs1[i].node.name.style.transformOrigin = 'top left';
					}
					else {
						hs1[i].node.name.style.transform = 'translateY(16px)';
					}
					hs1[i].node.info.style.transform = 'translateX(-' + offset12 + 'px) translateY(-3px)';
				}
				else {
					hs1[i].node.info.querySelector('span').style.display = '';
					hs1[i].node.name.style.transform = '';
					hs1[i].node.name.style.transformOrigin = '';
					hs1[i].node.info.style.transform = 'translateX(-' + offset12 + 'px)';
				}
			}
			ui.handcards1Container.firstChild.style.width = (offset1 * (hs1.length - 1) + 118) + 'px';

			var offset2, offset22 = 0;
			if (!lib.config.fold_card) {
				offset2 = 112;
				ui.handcards2Container.classList.add('scrollh');
			}
			else {
				offset2 = Math.min(112, (ui.handcards2Container.offsetWidth - 128) / (hs2.length - 1));
				if (hs2.length > 1 && offset2 < 32) {
					offset2 = 32;
					ui.handcards2Container.classList.add('scrollh');
				}
				else {
					ui.handcards2Container.classList.remove('scrollh');
				}
			}
			if (offset2 < 100) {
				offset22 = 100 - offset2;
			}
			for (var i = 0; i < hs2.length; i++) {
				hs2[i].style.transform = 'translateX(' + (i * offset2) + 'px)';
				hs2[i]._transform = 'translateX(' + (i * offset2) + 'px)';
				ui.refresh(hs2[i]);
				hs2[i].classList.remove('drawinghidden');
				if (offset22 > 40) {
					offset22 = 90 - hs2[i].node.info.offsetWidth;
					hs2[i].node.info.querySelector('span').style.display = 'none';
					if (hs2[i].node.name.classList.contains('long')) {
						hs2[i].node.name.style.transform = 'translateY(16px)  scale(0.85)';
						hs2[i].node.name.style.transformOrigin = 'top left';
					}
					else {
						hs2[i].node.name.style.transform = 'translateY(16px)';
					}
					hs2[i].node.info.style.transform = 'translateX(-' + offset22 + 'px) translateY(-3px)';
				}
				else {
					hs2[i].node.info.querySelector('span').style.display = '';
					hs2[i].node.name.style.transform = '';
					hs2[i].node.name.style.transformOrigin = '';
					hs2[i].node.info.style.transform = 'translateX(-' + offset22 + 'px)';
				}
			}
			ui.handcards2Container.firstChild.style.width = (offset2 * (hs2.length - 1) + 118) + 'px';
		},
		updateh: function (compute) {
			if (!game.me) return;
			if (!ui.handcards1Container) return;
			if (lib.config.low_performance) {
				if (compute) {
					ui.updatehl();
					setTimeout(ui.updatehl, 1000);
				}
				return;
			}
			if (compute) {
				ui.handcards1Container._handcardsWidth = ui.handcards1Container.offsetWidth;
				ui.handcards2Container._handcardsWidth = ui.handcards2Container.offsetWidth;
			}
			ui.updatehx(game.me.node.handcards1);
			ui.updatehx(game.me.node.handcards2);
		},
		updatehx: function (node) {
			var width = node.parentNode._handcardsWidth;
			var num = node.childElementCount - node.getElementsByClassName('removing').length;
			node.classList.remove('fold0');
			node.classList.remove('fold1');
			node.classList.remove('fold2');
			node.classList.remove('fold3');
			if (num * 78 + 40 >= width) {
				// node.dataset.fold=3;
				node.classList.add('fold3');
			}
			else if (num * 93 + 25 >= width) {
				// node.dataset.fold=2;
				node.classList.add('fold2');
			}
			else if (num * 112 + 6 >= width) {
				// node.dataset.fold=1;
				node.classList.add('fold1');
			}
			else {
				// node.dataset.fold=0;
				node.classList.add('fold0');
			}
		},
		updated: function () {
			if (document.documentElement.offsetWidth < 900 || document.documentElement.offsetHeight < 500) {
				game.deviceZoom = Math.min(
					Math.round(document.documentElement.offsetWidth / 98) / 10,
					Math.round(document.documentElement.offsetHeight / 50) / 10
				);
			}
			else {
				game.deviceZoom = 1;
			}
		},
		updatez: function () {
			var width = document.documentElement.offsetWidth;
			var height = document.documentElement.offsetHeight;
			var zoom = game.documentZoom;
			if (zoom != 1) {
				document.body.style.width = Math.round(width / zoom) + 'px';
				document.body.style.height = Math.round(height / zoom) + 'px';
				document.body.style.transform = 'scale(' + (Math.floor(zoom * 100) / 100) + ')';
			}
			else {
				document.body.style.width = width + 'px';
				document.body.style.height = height + 'px';
				document.body.style.transform = '';
			}
		},
		update: function () {
			for (var i = 0; i < ui.updates.length; i++) {
				ui.updates[i]();
			}
			if (ui.dialog && !ui.dialog.classList.contains('noupdate')) {
				if (game.chess) {
					if (ui.dialog.content.scrollHeight < 240 && (!ui.dialog.buttons || !ui.dialog.buttons.length) && !ui.dialog.forcebutton) {
						ui.dialog.style.height = ui.dialog.content.offsetHeight + 'px';
						ui.dialog.classList.add('slim');
					}
					else {
						ui.dialog.style.height = '';
						ui.dialog.classList.remove('slim');
					}
				}
				else {
					if ((!ui.dialog.buttons || !ui.dialog.buttons.length) && !ui.dialog.forcebutton && ui.dialog.classList.contains('fullheight') == false && get.mode() != 'stone') {
						ui.dialog.classList.add('nobutton');
						if (ui.dialog.content.offsetHeight < 240) {
							if (!ui.dialog._heightset) {
								ui.dialog._heightset = ui.dialog.style.height || true;
							}
							ui.dialog.style.height = ui.dialog.content.offsetHeight + 'px';
							if (lib.config.show_log != 'off') {
								ui.dialog.classList.add('scroll1');
								ui.dialog.classList.add('scroll2');
								return;
							}
						}
						else {
							if (typeof ui.dialog._heightset == 'string') {
								ui.dialog.style.height = ui.dialog._heightset;
							}
							else if (ui.dialog._heightset) {
								ui.dialog.style.height = '';
							}
							delete ui.dialog._heightset;
						}
					}
					else {
						if (typeof ui.dialog._heightset == 'string') {
							ui.dialog.style.height = ui.dialog._heightset;
						}
						else if (ui.dialog._heightset) {
							ui.dialog.style.height = '';
						}
						delete ui.dialog._heightset;
						ui.dialog.classList.remove('nobutton');
					}
				}
				var height1 = ui.dialog.content.offsetHeight;
				var height2 = ui.dialog.contentContainer.offsetHeight;
				if (game.chess) {
					if (height1 < 240) {
						ui.dialog.style.height = height1 + 'px';
					}
				}
				else {
					if (!ui.dialog.forcebutton && !ui.dialog._scrollset && (height1 <= 190 || (height2 >= height1 && height2 >= 210))) {
						ui.dialog.classList.remove('scroll1');
						ui.dialog.classList.remove('scroll2');
					}
					else {
						ui.dialog.classList.add('scroll1');
						ui.dialog.classList.add('scroll2');
						if (game.layout != 'default') {
							ui.dialog.style.height = Math.min(height1, ((game.layout == 'long2' || game.layout == 'nova') && ui.arena.classList.contains('choose-character')) ? 380 : 350) + 'px';
							ui.dialog._scrollset = true;
						}
					}
					if (game.layout == 'long2' || game.layout == 'nova') {
						if (height1 + 240 >= ui.arena.offsetHeight) {
							ui.dialog.classList.add('scroll3');
						}
						else {
							ui.dialog.classList.remove('scroll3');
						}
					}
				}
			}
		},
		recycle: function (node, key) {
			if (!ui._recycle) ui._recycle = {};
			if (typeof node == 'string') {
				return ui._recycle[node]
			}
			ui._recycle[key] = node;
		},
	};
	var get = {
		isLuckyStar: function (player) {
			if (player && player.hasSkillTag('luckyStar')) return true;
			if (_status.connectMode) return false;
			return (!player || player == game.me || player.isUnderControl()) && lib.config.lucky_star == true;
		},
		infoHp: function (hp) {
			if (typeof hp == 'number') return hp;
			else if (typeof hp == 'string' && hp.indexOf('/') != -1) {
				return parseInt(hp.slice(0, hp.indexOf('/')));
			}
			return 0;
		},
		infoMaxHp: function (hp) {
			if (typeof hp == 'number') return hp;
			else if (typeof hp == 'string' && hp.indexOf('/') != -1) {
				return parseInt(hp.slice(hp.indexOf('/') + 1));
			}
			return 0;
		},
		is: {
			banWords: function (str) {
				for (var i of window.bannedKeyWords) {
					if (str.indexOf(i) != -1) return true;
				}
				return false;
			},
			modeInGuozhan: function (mode) {
				return mode == 'guozhan' || mode == 'SNH48';
			},
			guozhanMode: function () {
				return get.is.modeInGuozhan(get.mode());
			},
			SNH48: function (player) {
				var SNH48 = ['S', 'N', 'H', 'X', 'guan', 'fen'];
				return SNH48.indexOf(player.group) > -1;
			},
			converted: function (event) {
				return !(event.card && event.card.isCard);
			},
			safari: function () {
				var ua = navigator.userAgent.toLowerCase();
				return ua.indexOf('safari' != -1) && ua.indexOf('chrome') == -1;
			},
			freePosition: function (cards) {
				for (var i = 0; i < cards.length; i++) {
					if (!cards[i].hasPosition) return false;
					if (cards[i].hasPosition()) return false;
				}
				return true;
			},
			nomenu: function (name, item) {
				var menus = ['system', 'menu'];
				var configs = {
					show_round_menu: lib.config.show_round_menu,
					round_menu_func: lib.config.round_menu_func,
					touchscreen: lib.config.touchscreen,
					swipe_up: lib.config.swipe_up,
					swipe_down: lib.config.swipe_down,
					swipe_left: lib.config.swipe_left,
					swipe_right: lib.config.swipe_right,
					right_click: lib.config.right_click,
					phonelayout: lib.config.phonelayout
				};
				configs[name] = item;
				if (!configs.phonelayout) return false;
				if (configs.show_round_menu && menus.contains(configs.round_menu_func)) {
					return false;
				}
				if (configs.touchscreen) {
					if (menus.contains(configs.swipe_up)) return false;
					if (menus.contains(configs.swipe_down)) return false;
					if (menus.contains(configs.swipe_left)) return false;
					if (menus.contains(configs.swipe_right)) return false;
				}
				else {
					if (configs.right_click == 'config') return false;
				}
				if (name) {
					setTimeout(function () {
						alert('请将至少一个操作绑定为显示按钮或打开菜单，否则将永远无法打开菜单');
					});
				}
				return true;
			},
			altered: function (skill) {
				return false;
				// if(_status.connectMode) return true;
				// return !lib.config.vintageSkills.contains(skill);
			},
			node: function (obj) {
				var str = Object.prototype.toString.call(obj);
				if (str && str.indexOf('[object HTML')) return true;
				return false;
			},
			div: function (obj) {
				return Object.prototype.toString.call(obj) === '[object HTMLDivElement]';
			},
			map: function (obj) {
				return Object.prototype.toString.call(obj) === '[object Map]';
			},
			set: function (obj) {
				return Object.prototype.toString.call(obj) === '[object Set]';
			},
			object: function (obj) {
				return Object.prototype.toString.call(obj) === '[object Object]';
			},
			singleSelect: function (func) {
				if (typeof func == 'function') return false;
				var select = get.select(func);
				return select[0] == 1 && select[1] == 1;
			},
			jun: function (name) {
				if (get.is.guozhanMode()) {
					if (name && typeof name == 'object') {
						if (name.isUnseen && name.isUnseen(0)) return false;
						name = name.name1;
					}
					if (typeof name == 'string' && name.indexOf('gz_jun_') == 0) {
						return true;
					}
				}
				return false;
			},
			versus: function () {
				return !_status.connectMode && get.mode() == 'versus' && _status.mode == 'three';
			},
			changban: function () {
				return get.mode() == 'single' && _status.mode == 'changban';
			},
			single: function () {
				return get.mode() == 'single' && _status.mode == 'normal';
			},
			mobileMe: function (player) {
				return (game.layout == 'mobile' || game.layout == 'long') && !game.chess && player.dataset.position == 0;
			},
			newLayout: function () {
				if (game.layout != 'default') return true;
				return false;
			},
			phoneLayout: function () {
				if (!lib.config.phonelayout) return false;
				return (game.layout == 'mobile' || game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova');
			},
			singleHandcard: function () {
				if (game.singleHandcard || game.layout == 'mobile' || game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova') {
					return true;
				}
				return false;
			},
			linked2: function (player) {
				if (game.chess) return true;
				if (lib.config.link_style2 != 'rotate') return true;
				// if(game.chess) return false;
				if (game.layout == 'long' || game.layout == 'long2' || game.layout == 'nova') return true;
				if (player.dataset.position == '0') {
					return ui.arena.classList.contains('oblongcard');
				}
				return false;
			},
			empty: function (obj) {
				for (var i in obj) return false;
				return true;
			},
			pos: function (str) {
				return (str == 'h' || str == 'e' || str == 'j' || str == 'he' || str == 'hj' || str == 'ej' || str == 'hej');
			},
			locked: function (skill) {
				var info = lib.skill[skill];
				if (info.locked == false) return false;
				if (info.trigger && info.forced) return true;
				if (info.mod) return true;
				if (info.locked) return true;
				return false;
			},
		},
		bottomCards: function (num) {
			if (_status.waitingForCards) {
				ui.create.cards.apply(ui.create, _status.waitingForCards);
				delete _status.waitingForCards;
			}
			var list = [];
			var card = false;
			if (typeof num != 'number') num = 1;
			if (num == 0) { card = true; num = 1; }
			if (num < 0) num = 1;
			while (num--) {
				if (ui.cardPile.hasChildNodes() == false) {
					if (_status.maxShuffle != undefined) {
						if (_status.maxShuffle == 0) {
							if (_status.maxShuffleCheck) {
								game.over(_status.maxShuffleCheck());
							}
							else {
								game.over('平局');
							}
							return [];
						}
						_status.maxShuffle--;
					}
					game.shuffleNumber++;
					if (_status.event.trigger) _status.event.trigger('washCard');
					var cards = [], i;
					for (var i = 0; i < lib.onwash.length; i++) {
						if (lib.onwash[i]() == 'remove') {
							lib.onwash.splice(i--, 1);
						}
					}
					if (_status.discarded) {
						_status.discarded.length = 0;
					}
					for (i = 0; i < ui.discardPile.childNodes.length; i++) {
						var currentcard = ui.discardPile.childNodes[i];
						currentcard.vanishtag.length = 0;
						if (get.info(currentcard).vanish || currentcard.storage.vanish) {
							currentcard.remove();
							continue;
						}
						cards.push(currentcard);
					}
					cards.randomSort();
					for (var i = 0; i < cards.length; i++) {
						ui.cardPile.appendChild(cards[i]);
					}
				}
				if (ui.cardPile.hasChildNodes() == false) {
					game.over('平局');
					return [];
				}
				var cardx = ui.cardPile.removeChild(ui.cardPile.lastChild);
				cardx.original = 'c';
				list.push(cardx);
			}
			game.updateRoundNumber();
			if (card) return list[0];
			return list;
		},
		discarded: function () {
			var list = _status.discarded.slice(0);
			for (var i = 0; i < list.length; i++) {
				if (list[i].parentNode != ui.discardPile) {
					list.splice(i--, 1);
				}
			}
			return list;
		},
		cardOffset: function () {
			var x = ui.arena.getBoundingClientRect();
			var y = ui.window.getBoundingClientRect();
			return -y.width / 2 + (x.left + x.width / 2);
		},
		colorspan: function (str) {
			if (str[0] == '#') {
				var color;
				switch (str[1]) {
					case 'r': color = 'fire'; break;
					case 'p': color = 'legend'; break;
					case 'b': color = 'blue'; break;
					case 'g': color = 'green'; break;
					default: return str.slice(2);
				}
				return '<span class="' + color + 'text ' + color + 'auto">' + str.slice(2) + '</span>';
			}
			return str;
		},
		evtprompt: function (next, str) {
			if (next.prompt) {
				next.set('prompt2', str);
			}
			else {
				if (str.indexOf('###') == 0) {
					var prompts = str.slice(3).split('###');
					if (prompts[0]) next.set('prompt', prompts[0]);
					if (prompts[1]) next.set('prompt2', prompts[1]);
				}
				else {
					next.set('prompt', str);
				}
			}
		},
		autoViewAs: function (card, cards) {
			var info = get.info(card);
			if (info.autoViewAs) {
				if (cards === false) {
					return {
						name: info.autoViewAs
					};
				}
				else if (Array.isArray(cards)) {
					return {
						name: info.autoViewAs,
						cards: cards.slice(0)
					};
				}
				else if (get.itemtype(card) == 'card') {
					return {
						name: info.autoViewAs,
						cards: [card]
					};
				}
				else {
					return {
						name: info.autoViewAs,
						suit: card.suit,
						number: card.number,
						nature: card.nature,
					};
				}
			}
			else {
				if (card.isCard || get.itemtype(card) == 'card') {
					var next = {
						name: get.name(card),
						suit: get.suit(card),
						number: card.number,
						nature: get.nature(card),
						isCard: true,
						cardid: card.cardid,
						wunature: card.wunature,
						storage: card.storage,
					};
					if (get.itemtype(cards) == 'cards' && !card.cards) next.cards = cards.slice(0);
					else next.cards = [card];
					return next;
				}
				else if (get.is.object(card) && get.itemtype(cards) == 'cards' && !card.cards) {
					card = get.copy(card);
					card.cards = cards.slice(0);
				}
				return card;
			}
		},
		max: function (list, func, type) {
			list = list.slice(0);
			if (typeof func == 'string') {
				var key = func;
				func = function (item) {
					return item[key];
				}
			}
			list.sort(function (a, b) {
				return func(b) - func(a);
			});
			if (type == 'list') {
				var list2 = [];
				for (var i = 0; i < list.length; i++) {
					if (func(list[i]) == func(list[0])) {
						list2.push(list[i]);
					}
				}
				return list2;
			}
			else if (type == 'item') {
				return list[0];
			}
			else {
				return func(list[0]);
			}
		},
		min: function (list, func, type) {
			list = list.slice(0);
			if (typeof func == 'string') {
				var key = func;
				func = function (item) {
					return item[key];
				}
			}
			list.sort(function (a, b) {
				return func(a) - func(b);
			});
			if (type == 'list') {
				var list2 = [];
				for (var i = 0; i < list.length; i++) {
					if (func(list[i]) == func(list[0])) {
						list2.push(list[i]);
					}
				}
				return list2;
			}
			else if (type == 'item') {
				return list[0];
			}
			else {
				return func(list[0]);
			}
		},
		character: function (name, num) {
			var info = lib.character[name];
			if (!info) {
				for (var i in lib.characterPack) {
					if (lib.characterPack[i][name]) {
						info = lib.characterPack[i][name];
						break;
					}
				}
			}
			if (info) {
				if (typeof num == 'number') {
					return info[num];
				}
				return info;
			}
			return null;
		},
		characterIntro: function (name) {
			if (lib.characterIntro[name]) return lib.characterIntro[name];
			var tags = get.character(name, 4);
			if (tags) {
				for (var i = 0; i < tags.length; i++) {
					if (tags[i].indexOf('des:') == 0) {
						return tags[i].slice(4);
					}
				}
			}
			if (name.indexOf('gz_') == 0) {
				name = name.slice(3);
				if (lib.characterIntro[name]) return lib.characterIntro[name];
			}
			if (name.indexOf('_') != -1) {
				name = name.slice(name.indexOf('_') + 1);
			}
			if (lib.characterIntro[name]) return lib.characterIntro[name];
			return '暂无武将介绍';
		},
		groupnature: function (group, method) {
			var nature = lib.groupnature[group];
			if (!nature) return '';
			if (method == 'raw') {
				return nature;
			}
			return nature + 'mm';
		},
		sgn: function (num) {
			if (num > 0) return 1;
			if (num < 0) return -1;
			return 0;
		},
		rand: function (num, num2) {
			if (typeof num2 == 'number') {
				return num + Math.floor(Math.random() * (num2 - num + 1));
			}
			else {
				return Math.floor(Math.random() * num);
			}
		},
		sort: function (arr, method) {
			switch (method) {
				case 'seat': {
					lib.tempSortSeat = arguments[2];
					arr.sort(lib.sort.seat);
					delete lib.tempSortSeat;
					return arr;
				}
			}
		},
		sortSeat: function (arr, target) {
			lib.tempSortSeat = target;
			arr.sort(lib.sort.seat);
			delete lib.tempSortSeat;
			return arr;
		},
		zip: function (callback) {
			if (!window.JSZip) {
				lib.init.js(lib.assetURL + 'game', 'jszip', function () {
					callback(new JSZip());
				});
			}
			else {
				callback(new JSZip());
			}
		},
		delayx: function (num, max) {
			if (typeof num != 'number') num = 1;
			if (typeof max != 'number') max = Infinity;
			switch (lib.config.game_speed) {
				case 'vslow': return Math.min(max, 2.5 * num);
				case 'slow': return Math.min(max, 1.5 * num);
				case 'fast': return Math.min(max, 0.7 * num);
				case 'vfast': return Math.min(max, 0.4 * num);
				case 'vvfast': return Math.min(max, 0.2 * num);
				default: return Math.min(max, num);
			}
		},
		prompt: function (skill, target, player) {
			player = player || _status.event.player;
			if (target) {
				var str = get.translation(target);
				if (target == player) {
					str += '（你）'
				}
				return '是否对' + str + '发动【' + get.skillTranslation(skill, player) + '】？';
			}
			else {
				return '是否发动【' + get.skillTranslation(skill, player) + '】？';
			}
		},
		prompt2: function (skill, target, player) {
			var str = get.prompt.apply(this, arguments);
			if (!lib.translate[skill + '_info']) return str;
			return '###' + str + '###' + lib.translate[skill + '_info'];
		},
		url: function (master) {
			var url = lib.config.updateURL || lib.updateURL;
			if (url[url.length - 1] != '/') {
				url += '/';
			}
			if (master != 'nodev') {
				return url + 'master/';
			}
			else {
				return url + 'v' + lib.version + '/';
			}
		},
		round: function (num, f) {
			var round = 1;
			for (var i = 0; i < f; i++) {
				round *= 10;
			}
			return Math.round(num * round) / round;
		},
		playerNumber: function () {
			var num;
			if (_status.brawl && _status.brawl.playerNumber) {
				num = _status.brawl.playerNumber
			}
			else {
				num = get.config('player_number');
			}
			return parseInt(num) || 2;
		},
		benchmark: function (func1, func2, iteration, arg) {
			var tic, toc;
			var key1, key2;
			if (!arg) arg = [];
			if (Array.isArray(func2)) {
				key1 = func2[0];
				key2 = func2[1];
			}
			else if (typeof func2 == 'string') {
				key1 = func2;
				func2 = iteration || 100;
			}
			else if (typeof func2 == 'number') {
				arg = iteration || arg;
				iteration = func2;
			}
			tic = get.utc();
			for (var i = 0; i < iteration; i++) {
				if (key1) {
					func1[key1](arg.randomGet());
				}
				else {
					func1(arg.randomGet());
				}
			}
			toc = get.utc();
			if (typeof func2 == 'number') {
				return toc - tic;
			}
			console.log('time1: ' + (toc - tic));
			tic = get.utc();
			for (var i = 0; i < iteration; i++) {
				if (key2) {
					func1[key2](arg.randomGet());
				}
				else {
					func2(arg.randomGet());
				}
			}
			toc = get.utc();
			console.log('time2: ' + (toc - tic));
		},
		stringify: function (obj, level) {
			level = level || 0;
			var indent = '';
			var str;
			for (var i = 0; i < level; i++) {
				indent += '    ';
			}
			if (get.objtype(obj) == 'object') {
				str = '{\n';
				for (var i in obj) {
					if (/[^a-zA-Z]/.test(i)) {
						str += indent + '    "' + i + '":' + get.stringify(obj[i], level + 1) + ',\n';
					}
					else {
						str += indent + '    ' + i + ':' + get.stringify(obj[i], level + 1) + ',\n';
					}
				}
				str += indent + '}';
				return str;
			}
			else {
				if (typeof obj == 'function') {
					str = obj.toString();
					str = str.replace(/\t/g, '    ');
					var i = str.lastIndexOf('\n');
					var num = 0;
					for (var j = i + 1; j < str.length && str[j] == ' '; j++) {
						num++;
					}
					num = Math.floor(num / 4);
					for (i = 0; i < num - level; i++) {
						str = str.replace(/\n    /g, '\n');
					}
				}
				else {
					try {
						if (Array.isArray(obj) && obj.contains(Infinity)) {
							obj = obj.slice(0);
							var rand = get.id();
							for (var i = 0; i < obj.length; i++) {
								if (obj[i] === Infinity) {
									obj[i] = parseInt(rand);
								}
							}
							str = JSON.stringify(obj).replace(new RegExp(rand, 'g'), 'Infinity');
						}
						else {
							str = JSON.stringify(obj) || '';
						}
					}
					catch (e) {
						str = '';
					}
				}
				return str;
			}
		},
		copy: function (obj) {
			if (get.objtype(obj) == 'object') {
				var copy = {};
				for (var i in obj) {
					copy[i] = get.copy(obj[i]);
				}
				return copy;
			}
			else if (Array.isArray(obj)) {
				var copy = [];
				for (var i = 0; i < obj.length; i++) {
					copy.push(get.copy(obj[i]));
				}
				return copy;
			}
			else {
				return obj;
			}
		},
		inpilefull: function (type) {
			var list = [];
			for (var i in lib.cardPile) {
				for (var j = 0; j < lib.cardPile[i].length; j++) {
					var info = lib.cardPile[i][j];
					if (lib.inpile.contains(info[2]) && get.type(info[2]) == type) {
						list.push({
							name: info[2],
							suit: info[0],
							number: info[1],
							nature: info[3]
						});
					}
				}
			}
			return list;
		},
		inpile: function (type, filter) {
			var list = [];
			if (filter == 'trick') {
				for (var i = 0; i < lib.inpile.length; i++) {
					if (get.type(lib.inpile[i], 'trick') == type) list.push(lib.inpile[i]);
				}
			}
			else {
				for (var i = 0; i < lib.inpile.length; i++) {
					if (typeof type == 'function') {
						if (type(lib.inpile[i])) {
							list.push(lib.inpile[i]);
						}
					}
					else {
						if (typeof filter == 'function' && !filter(lib.inpile[i])) continue;
						if (type.indexOf('equip') == 0 && type.length == 6) {
							if (get.subtype(lib.inpile[i]) == type) list.push(lib.inpile[i]);
						}
						else {
							if (get.type(lib.inpile[i]) == type) list.push(lib.inpile[i]);
						}
					}
				}
			}
			return list;
		},
		inpile2: function (type) {
			return get.inpile(type, 'trick');
		},
		typeCard: function (type, filter) {
			var list = [];
			for (var i in lib.card) {
				if (lib.card[i].mode && lib.card[i].mode.contains(get.mode()) == false) continue;
				// if(lib.card[i].vanish||lib.card[i].destroy) continue;
				if (lib.card[i].destroy) continue;
				if (typeof filter == 'function' && !filter(i)) continue;
				if (lib.config.bannedcards.contains(i)) continue;
				if (!lib.translate[i + '_info']) continue;
				if ((type.indexOf('equip') == 0 && type.length == 6) ||
					(type.indexOf('hslingjian') == 0 && type.length == 11) ||
					(type.indexOf('spell_') == 0)) {
					if (get.subtype(i) == type) list.push(i);
				}
				else {
					if (get.type(i) == type) list.push(i);
				}
			}
			return list;
		},
		libCard: function (filter) {
			var list = [];
			for (var i in lib.card) {
				if (lib.card[i].mode && lib.card[i].mode.contains(get.mode()) == false) continue;
				// if(lib.card[i].vanish||lib.card[i].destroy) continue;
				if (lib.card[i].destroy) continue;
				if (lib.config.bannedcards.contains(i)) continue;
				if (!lib.translate[i + '_info']) continue;
				if (filter(lib.card[i], i)) {
					list.push(i);
				}
			}
			return list;
		},
		ip: function () {
			if (!require) return '';
			var interfaces = require('os').networkInterfaces();
			for (var devName in interfaces) {
				var iface = interfaces[devName];
				for (var i = 0; i < iface.length; i++) {
					var alias = iface[i];
					if (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {
						return alias.address;
					}
				}
			}
		},
		modetrans: function (config, server) {
			if (config.mode == 'doudizhu') {
				switch (config.doudizhu_mode) {
					case 'kaihei': return '开黑斗地主';
					case 'huanle': return '欢乐斗地主';
					default: return '休闲斗地主';
				}
			}
			if (config.mode == 'versus') {
				switch (config.versus_mode) {
					case '1v1': return '单人对决';
					case '2v2': return '欢乐成双';
					case '3v3': return '血战到底';
					case '4v4': return '四人对决';
					case 'guandu': return '官渡之战';
				}
			}
			else if (config.mode == 'single') {
				switch (config.single_mode) {
					case 'normal': return '新1v1';
					case 'changban': return '血战长坂坡';
					case 'dianjiang': return '点将单挑';
				}
			}
			else if (config.mode == 'identity' && config.identity_mode != 'normal') {
				switch (config.identity_mode) {
					case 'purple': return '三对三对二';
					case 'zhong': return '忠胆英杰';
				}
			}
			else {
				if (server) {
					return get.translation(config.mode) + '模式';
				}
				else {
					return get.cnNumber(parseInt(config.number)) + '人' + get.translation(config.mode);
				}
			}
		},
		charactersOL: function (func) {
			var list = [];
			var libCharacter = {};
			for (var i = 0; i < lib.configOL.characterPack.length; i++) {
				var pack = lib.characterPack[lib.configOL.characterPack[i]];
				for (var j in pack) {
					if (typeof func == 'function' && func(j)) continue;
					if (lib.connectBanned.contains(j)) continue;
					if (lib.character[j]) libCharacter[j] = pack[j];
				}
			}
			for (i in libCharacter) {
				if (lib.filter.characterDisabled(i, libCharacter)) continue;
				list.push(i);
			}
			return list;
		},
		trimip: function (str) {
			var len = str.length - 5;
			if (str.lastIndexOf(':8080') == len) {
				str = str.slice(0, len);
			}
			return str;
		},
		mode: function () {
			if (_status.connectMode) {
				return lib.configOL.mode;
			}
			else {
				return lib.config.mode;
			}
		},
		idDialog: function (id) {
			for (var i = 0; i < ui.dialogs.length; i++) {
				if (ui.dialogs[i].videoId == id) {
					return ui.dialogs[i];
				}
			}
			return null;
		},
		arenaState: function () {
			var state = {
				number: ui.arena.dataset.number,
				players: {},
				mode: _status.mode,
				dying: _status.dying,
				servermode: window.isNonameServer,
				roomId: game.roomId,
				over: _status.over,
				inpile: lib.inpile,
			};
			for (var i in lib.playerOL) {
				state.players[i] = lib.playerOL[i].getState();
			}
			return state;
		},
		skillState: function (player) {
			var skills = {
				global: lib.skill.global
			};
			var skillinfo = {};
			for (var i in lib.playerOL) {
				skills[i] = {
					skills: lib.playerOL[i].skills,
					hiddenSkills: lib.playerOL[i].hiddenSkills,
					additionalSkills: lib.playerOL[i].additionalSkills,
					disabledSkills: lib.playerOL[i].disabledSkills,
					tempSkills: lib.playerOL[i].tempSkills,
					storage: lib.playerOL[i].storage,
				}
			}
			for (var i in lib.skill) {
				if (lib.skill[i].chooseButton && lib.skill[i].enable) {
					skillinfo[i] = lib.skill[i].chooseButton;
				}
			}
			skills.skillinfo = skillinfo;
			if (player) {
				skills.stat = player.getStat();
			}
			return skills;
		},
		id: function () {
			return (Math.floor(1000000 + 9000000 * Math.random())).toString() + (10 + lib.status.globalId++);
		},
		zhu: function (player, skill, unseen) {
			if (typeof player == 'string') {
				skill = player;
				player = null;
			}
			var mode = get.mode();
			if (mode == 'identity') {
				if (_status.mode == 'purple') {
					if (!player) return null;
					var zhu = game[player.identity.slice(0, 1) + 'Zhu'];
					if (!zhu) return null;
					if (skill && !zhu.hasSkill(skill)) return null;
					return zhu;
				}
				if (!game.zhu) return null;
				if (skill && !game.zhu.hasSkill(skill)) return null;
				if (game.zhu.isZhu) return game.zhu;
			}
			else if (mode == 'versus' && (_status.mode == 'four' || _status.mode == 'guandu')) {
				for (var i = 0; i < game.players.length; i++) {
					if (game.players[i].isZhu) {
						if (skill && !(game.players[i].hasSkill(skill))) continue;
						if (!player) return game.players[i];
						if (player.side == game.players[i].side) {
							return game.players[i];
						}
					}
				}
			}
			else if (mode == 'guozhan') {
				for (var i = 0; i < game.players.length; i++) {
					if (get.is.jun(game.players[i]) && !game.players[i].isUnseen()) {
						if (skill && !game.players[i].hasSkill(skill)) continue;
						if (!player) return game.players[i];
						if (player.identity == game.players[i].identity) {
							return game.players[i];
						}
						else if (unseen && player._group == game.players[i].identity) {
							return game.players[i];
						}
					}
				}
			}
			return null;
		},
		config: function (item, mode) {
			mode = mode || lib.config.mode;
			if (!lib.config.mode_config[mode]) return;
			return lib.config.mode_config[mode][item];
		},
		coinCoeff: function (list) {
			var num = 0;
			for (var i = 0; i < list.length; i++) {
				var rank = get.rank(list[i]);
				switch (rank) {
					case 'sp': return 0.1;
					case 's': num += 0.4; break;
					case 'ap': num += 0.6; break;
					case 'a': num += 0.8; break;
					case 'am': num += 0.95; break;
					case 'bp': num += 1.05; break;
					case 'b': num += 1.2; break;
					case 'bm': num += 1.4; break;
					case 'c': num += 1.6; break;
					case 'd': num += 1.8; break;
				}
			}
			return num / list.length;
		},
		rank: function (name, num) {
			if (typeof name == 'object' && name.name) {
				name = name.name;
			}
			if (num == true) num = 9;
			if (typeof num != 'number') num = false;
			if (name == _status.lord) return num ? Math.round(7 * (num - 1) / 8 + 1) : 'ap';
			var rank = lib.rank;
			if (lib.characterPack.standard[name] || lib.characterPack.shenhua[name]) {
				var skills;
				if (lib.character[name]) {
					skills = lib.character[name][3];
				}
				else {
					var tmpinfo = get.character(name);
					if (tmpinfo) {
						skills = tmpinfo[3];
					}
					else {
						skills = [];
					}
				}
				for (var i = 0; i < skills.length; i++) {
					if (skills[i].alter && !lib.config.vintageSkills.contains(skills[i])) {
						name = lib.rank.a[0]; break;
					}
				}
			}
			if (rank.s.contains(name)) return num ? Math.round(8 * (num - 1) / 8 + 1) : 's';
			if (rank.ap.contains(name)) return num ? Math.round(7 * (num - 1) / 8 + 1) : 'ap';
			if (rank.a.contains(name)) return num ? Math.round(6 * (num - 1) / 8 + 1) : 'a';
			if (rank.am.contains(name)) return num ? Math.round(5 * (num - 1) / 8 + 1) : 'am';
			if (rank.bp.contains(name)) return num ? Math.round(4 * (num - 1) / 8 + 1) : 'bp';
			if (rank.b.contains(name)) return num ? Math.round(3 * (num - 1) / 8 + 1) : 'b';
			if (rank.bm.contains(name)) return num ? Math.round(2 * (num - 1) / 8 + 1) : 'bm';
			if (rank.c.contains(name)) return num ? Math.round(1 * (num - 1) / 8 + 1) : 'c';
			if (rank.d.contains(name)) return num ? Math.round(0 * (num - 1) / 8 + 1) : 'd';
			if (lib.character[name] && lib.character[name][4]) {
				if (lib.character[name][4].contains('boss') ||
					lib.character[name][4].contains('bossallowed') ||
					lib.character[name][4].contains('hiddenboss')) {
					return num ? Math.round(9 * (num - 1) / 8 + 1) : 'sp';
				}
			}
			return num ? Math.round(9 * (num - 1) / 8 + 1) : 'x';
		},
		skillRank: function (skill, type, grouped) {
			var info = lib.skill[skill];
			var player = _status.event.skillRankPlayer || _status.event.player;
			if (!info) return 0;
			if (info.ai) {
				if (info.ai.halfneg) return 0;
				if (typeof info.ai.combo == 'string' && player && !player.hasSkill(info.ai.combo)) {
					return 0;
				}
				if (info.ai.neg) return -1;
			}
			var num = 1;
			var threaten = 1;
			if (info.ai && info.ai.threaten) {
				if (typeof info.ai.threaten == 'number') {
					threaten = info.ai.threaten;
				}
				else if (typeof info.ai.threaten == 'function' && player) {
					threaten = info.ai.threaten(player, player);
				}
			}
			if (type == 'in') {
				if (info.enable == 'phaseUse') num += 0.5;
				if (info.trigger && ['phaseBegin', 'phaseDrawBegin', 'phaseUseBegin', 'phaseEnd'].contains(info.trigger.player)) {
					num += 0.5;
				}
				if (info.trigger && ((typeof info.trigger.player == 'string' && info.trigger.player.indexOf('use') == 0) || info.trigger.source)) {
					num += 0.3;
				}
				if (num > 1 && threaten > 1) {
					num += Math.sqrt(threaten) - 1;
				}
			}
			else if (type == 'out') {
				if (threaten < 1) {
					num = 1 / Math.sqrt(threaten);
				}
				if (info.trigger && (info.trigger.global || info.trigger.target || (typeof info.trigger.player == 'string' &&
					(info.trigger.player.indexOf('damage') == 0 || info.trigger.player.indexOf('lose') == 0)))) num += 0.1;
				if (info.ai) {
					if (info.ai.maixie || info.ai.maixie_hp || info.ai.maixie_defend) {
						num += 0.5;
					}
					if (info.ai.nolose || info.ai.noh || info.ai.noe || info.ai.nodiscard) {
						num += 0.3;
					}
				}
			}
			if (!grouped) {
				var groups = game.expandSkills([skill]);
				groups.remove(skill);
				var ggt = [];
				for (var i = 0; i < groups.length; i++) {
					var gi = get.skillRank(groups[i], type, true);
					if (gi < 0) {
						num -= 0.5;
					}
					else if (gi > 1) {
						ggt.push(gi);
					}
				}
				if (ggt.length) {
					num += Math.max.apply(this, ggt) - 1 + ggt.length / 20;
				}
			}
			return num;
		},
		targetsInfo: function (targets) {
			var info = [];
			for (var i = 0; i < targets.length; i++) {
				info.push(targets[i].dataset.position);
			}
			return info;
		},
		infoTargets: function (info) {
			var targets = [];
			for (var i = 0; i < info.length; i++) {
				targets.push(game.playerMap[info[i]]);
			}
			return targets;
		},
		cardInfo: function (card) {
			return [card.suit, card.number, card.name, card.nature];
		},
		cardsInfo: function (cards) {
			var info = [];
			for (var i = 0; i < cards.length; i++) {
				info.push(get.cardInfo(cards[i]));
			}
			return info;
		},
		infoCard: function (info) {
			var card = ui.create.card();
			if (info[0]) {
				card.init(info);
			}
			return card;
		},
		infoCards: function (info) {
			var cards = [];
			for (var i = 0; i < info.length; i++) {
				cards.push(get.infoCard(info[i]));
			}
			return cards;
		},
		cardInfoOL: function (card) {
			return '_noname_card:' + JSON.stringify([card.cardid, card.suit, card.number, card.name, card.nature]);
		},
		infoCardOL: function (info) {
			if (!lib.cardOL) return info;
			var card;
			try {
				var info = JSON.parse(info.slice(13));
				var id = info.shift();
				if (!id) {
					card = ui.create.card();
					if (info && info[2]) card.init(info);
				}
				else if (lib.cardOL[id]) {
					if (lib.cardOL[id].name != info[2]) {
						if (info && info[2]) lib.cardOL[id].init(info);
					}
					card = lib.cardOL[id];
				}
				else if (game.online) {
					card = ui.create.card();
					card.cardid = id;
					if (info && info[2]) card.init(info);
					lib.cardOL[id] = card;
				}
			}
			catch (e) {
				console.log(e);
			}
			return card || info;
		},
		cardsInfoOL: function (cards) {
			var info = [];
			for (var i = 0; i < cards.length; i++) {
				info.push(get.cardInfoOL(cards[i]));
			}
			return info;
		},
		infoCardsOL: function (info) {
			var cards = [];
			for (var i = 0; i < info.length; i++) {
				cards.push(get.infoCardOL(info[i]));
			}
			return cards;
		},
		playerInfoOL: function (player) {
			return '_noname_player:' + player.playerid;
		},
		infoPlayerOL: function (info) {
			if (!lib.playerOL) return info
			return lib.playerOL[info.slice(15)] || info;
		},
		playersInfoOL: function (players) {
			var info = [];
			for (var i = 0; i < players.length; i++) {
				info.push(get.playerInfoOL(players[i]));
			}
			return info;
		},
		infoPlayersOL: function (info) {
			var players = [];
			for (var i = 0; i < info.length; i++) {
				players.push(get.infoPlayerOL(info[i]));
			}
			return players;
		},
		funcInfoOL: function (func) {
			if (typeof func == 'function') {
				if (func._filter_args) {
					return '_noname_func:' + JSON.stringify(get.stringifiedResult(func._filter_args, 3));
				}
				return '_noname_func:' + func.toString();
			}
			return '';
		},
		infoFuncOL: function (info) {
			var func;
			try {
				eval('func=(' + info.slice(13) + ');');
			}
			catch (e) {
				return function () { };
			}
			if (Array.isArray(func)) {
				func = get.filter.apply(this, get.parsedResult(func));
			}
			return func;
		},
		stringifiedResult: function (item, level) {
			if (!item) return item;
			if (typeof item == 'function') {
				return get.funcInfoOL(item);
			}
			else if (typeof item == 'object') {
				switch (get.itemtype(item)) {
					case 'card': return get.cardInfoOL(item);
					case 'cards': return get.cardsInfoOL(item);
					case 'player': return get.playerInfoOL(item);
					case 'players': return get.playersInfoOL(item);
					default:
						if (typeof level != 'number') {
							level = 5;
						}
						if (Array.isArray(item)) {
							if (level == 0) {
								return [];
							}
							var item2 = [];
							for (var i = 0; i < item.length; i++) {
								item2.push(get.stringifiedResult(item[i], level - 1));
							}
							return item2;
						}
						else if (Object.prototype.toString.call(item) == '[object Object]') {
							if (level == 0) {
								return {};
							}
							var item2 = {};
							for (var i in item) {
								item2[i] = get.stringifiedResult(item[i], level - 1);
							}
							return item2;
						}
						else {
							return {};
						}
				}
			}
			else if (item === Infinity) {
				return '_noname_infinity';
			}
			else {
				return item;
			}
		},
		parsedResult: function (item) {
			if (!item) return item;
			if (typeof item == 'string') {
				if (item.indexOf('_noname_func:') == 0) {
					return get.infoFuncOL(item);
				}
				else if (item.indexOf('_noname_card:') == 0) {
					return get.infoCardOL(item);
				}
				else if (item.indexOf('_noname_player:') == 0) {
					return get.infoPlayerOL(item);
				}
				else if (item == '_noname_infinity') {
					return Infinity;
				}
				else {
					return item;
				}
			}
			else if (Array.isArray(item)) {
				var item2 = [];
				for (var i = 0; i < item.length; i++) {
					item2.push(get.parsedResult(item[i]));
				}
				return item2;
			}
			else if (typeof item == 'object') {
				var item2 = {};
				for (var i in item) {
					item2[i] = get.parsedResult(item[i]);
				}
				return item2;
			}
			else {
				return item;
			}
		},
		verticalStr: function (str, sp) {
			if (typeof str != 'string') return '';
			str = str.toUpperCase();
			var str2 = '';
			var nobreak = false;
			for (var i = 0; i < str.length; i++) {
				if (str[i] == '`') {
					nobreak = !nobreak; continue;
				}
				str2 += str[i];
				if (nobreak) continue;
				if (sp && str[i] == 'S' && str[i + 1] == 'P') continue;
				if (/[0-9]/.test(str[i]) && /[0-9]/.test(str[i + 1])) continue;
				if (i < str.length - 1) {
					str2 += '<br>';
				}
			}
			return str2;
		},
		numStr: function (num, method) {
			if (num == Infinity) {
				if (method == 'card') return get.selectableCards().length + ui.selected.cards.length;
				if (method == 'target') return get.selectableTargets().length + ui.selected.targets.length;
				return '∞';
			}
			return num.toString();
		},
		rawName: function (str) {
			if (lib.translate[str + '_ab']) return lib.translate[str + '_ab'];
			var str2 = lib.translate[str];
			if (!str2) return '';
			if (str2.indexOf('SP') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('TW') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('OL') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('JSP') == 0) {
				str2 = str2.slice(3);
			}
			else if (str2.indexOf('☆SP') == 0) {
				str2 = str2.slice(3);
			}
			else if (str2.indexOf('手杀') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('界') == 0 && lib.characterPack.refresh && lib.characterPack.refresh[str]) {
				str2 = str2.slice(1);
			}
			else if (str2.indexOf('旧') == 0 && (lib.characterPack.old || lib.characterPack.mobile) && (lib.characterPack.old[str] || lib.characterPack.mobile[str])) {
				str2 = str2.slice(1);
			}
			else if (str2.indexOf('新') == 0 && (str.indexOf('re_') == 0 || str.indexOf('new_') == 0)) {
				str2 = str2.slice(1);
			}
			return str2;
		},
		rawName2: function (str) {
			if (lib.translate[str + '_ab']) return lib.translate[str + '_ab'];
			var str2 = lib.translate[str];
			if (!str2) return '';
			if (str2.indexOf('SP') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('TW') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('OL') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('JSP') == 0) {
				str2 = str2.slice(3);
			}
			else if (str2.indexOf('☆SP') == 0) {
				str2 = str2.slice(3);
			}
			else if (str2.indexOf('手杀') == 0) {
				str2 = str2.slice(2);
			}
			return str2;
		},
		slimName: function (str) {
			var str2 = lib.translate[str];
			if (lib.translate[str + '_ab']) str2 = lib.translate[str + '_ab'];
			if (!str2) return '';
			if (str2.indexOf('SP') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('TW') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('OL') == 0) {
				str2 = str2.slice(2);
			}
			else if (str2.indexOf('JSP') == 0) {
				str2 = str2.slice(3);
			}
			else if (str2.indexOf('☆SP') == 0) {
				str2 = str2.slice(3);
			}
			else if (str2.indexOf('手杀') == 0) {
				str2 = str2.slice(2);
			}
			return get.verticalStr(str2, true);
		},
		time: function () {
			if (lib.status.dateDelaying) {
				return lib.getUTC(lib.status.dateDelaying) - lib.getUTC(lib.status.date) - lib.status.dateDelayed;
			}
			else {
				return lib.getUTC(new Date()) - lib.getUTC(lib.status.date) - lib.status.dateDelayed;
			}
		},
		utc: function () {
			return (new Date()).getTime();
		},
		evtDistance: function (e1, e2) {
			var dx = (e1.clientX - e2.clientX) / game.documentZoom;
			var dy = (e1.clientY - e2.clientY) / game.documentZoom;
			return Math.sqrt(dx * dx + dy * dy);
		},
		xyDistance: function (from, to) {
			return Math.sqrt((from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]));
		},
		itemtype: function (obj) {
			var i, j;
			if (typeof obj == 'string') {
				if (obj.length <= 3) {
					var bool = true;
					for (i = 0; i < obj.length; i++) {
						if (/h|e|j/.test(obj[i]) == false) {
							bool = false; break;
						}
					}
					if (bool) return 'position';
				}
				if (lib.nature.contains(obj)) return 'nature';
			}
			if (Array.isArray(obj) && obj.length) {
				var isPlayers = true;
				for (i = 0; i < obj.length; i++) {
					if (get.itemtype(obj[i]) != 'player') { isPlayers = false; break; }
				}
				if (isPlayers) return 'players';

				var isCards = true;
				for (i = 0; i < obj.length; i++) {
					if (get.itemtype(obj[i]) != 'card') { isCards = false; break; }
				}
				if (isCards) return 'cards';

				if (obj.length == 2) {
					if (typeof obj[0] == 'number' && typeof obj[1] == 'number') {
						if (obj[0] <= obj[1] || obj[1] == -1) return 'select';
					}
				}

				if (obj.length == 4) {
					var isPosition = true;
					for (i = 0; i < obj.length; i++) {
						if (typeof obj[i] != 'number') { isPosition = false; break; }
					}
					if (isPosition) return 'divposition';
				}
			}
			if (get.objtype(obj) == 'div') {
				if (obj.classList.contains('button')) return 'button';
				if (obj.classList.contains('card')) return 'card';
				if (obj.classList.contains('player')) return 'player';
				if (obj.classList.contains('dialog')) return 'dialog';
			}
		},
		equipNum: function (card) {
			if (get.type(card) == 'equip') {
				return parseInt(get.subtype(card)[5]);
			}
			return 0;
		},
		objtype: function (obj) {
			if (Object.prototype.toString.call(obj) === '[object Array]') return 'array';
			if (Object.prototype.toString.call(obj) === '[object Object]') return 'object';
			if (Object.prototype.toString.call(obj) === '[object HTMLDivElement]') return 'div';
			if (Object.prototype.toString.call(obj) === '[object HTMLTableElement]') return 'table';
			if (Object.prototype.toString.call(obj) === '[object HTMLTableRowElement]') return 'tr';
			if (Object.prototype.toString.call(obj) === '[object HTMLTableCellElement]') return 'td';
			if (Object.prototype.toString.call(obj) === '[object HTMLBodyElement]') return 'td';
		},
		type: function (obj, method, player) {
			if (typeof obj == 'string') obj = { name: obj };
			if (typeof obj != 'object') return;
			var name = get.name(obj, player);
			if (!lib.card[name]) return;
			if (method == 'trick' && lib.card[name].type == 'delay') return 'trick';
			return lib.card[name].type;
		},
		type2: function (card, player) {
			return get.type(card, 'trick', player);
		},
		subtype: function (obj) {
			if (typeof obj == 'string') obj = { name: obj };
			if (typeof obj != 'object') return;
			if (!lib.card[obj.name]) return;
			return lib.card[obj.name].subtype;
		},
		equiptype: function (card) {
			var subtype = get.subtype(card, player);
			if (subtype.indexOf('equip') == 0) return parseInt(subtype[5]);
			return 0;
		},
		name: function (card, player) {
			if (get.itemtype(player) == 'player' || (player !== false && get.position(card) == 'h')) {
				var owner = player || get.owner(card);
				if (owner) {
					return game.checkMod(card, owner, card.name, 'cardname', owner);
				}
			}
			return card.name;
		},
		suit: function (card, player) {
			if (get.itemtype(card) == 'cards') {
				if (card.length == 1) return get.suit(card[0], player);
				return 'none';
				//var suit=get.suit(card[0])
				//for(var i=1;i<card.length;i++){
				//	if(get.suit(card[i])!=suit) return 'none';
				//}
				//return suit;
			}
			else if (get.itemtype(card.cards) == 'cards' && !lib.suit.contains(card.suit)) {
				return get.suit(card.cards, player);
			}
			else {
				var owner = player || get.owner(card);
				if (owner) {
					return game.checkMod(card, card.suit, 'suit', owner);
				}
				return card.suit;
			}
		},
		color: function (card, player) {
			if (get.itemtype(card) == 'cards') {
				var color = get.color(card[0], player)
				for (var i = 1; i < card.length; i++) {
					if (get.color(card[i], player) != color) return 'none';
				}
				return color;
			}
			else if (get.itemtype(card.cards) == 'cards' && !lib.suit.contains(card.suit)) {
				return get.color(card.cards, player);
			}
			else {
				if (get.suit(card, player) == 'spade' || get.suit(card, player) == 'club') return 'black';
				if (get.suit(card, player) == 'heart' || get.suit(card, player) == 'diamond') return 'red';
				return 'none';
			}
		},
		number: function (card, player) {
			//啥时候狗卡出相关技能我再完善
			if (typeof card.number == 'number') return card.number;
			else if (card.cards && card.cards.length == 1) return get.number(card.cards[0]);
			return null;
		},
		nature: function (card, player) {
			if (get.itemtype(player) == 'player' || player !== false) {
				var owner = get.owner(card);
				if (owner) {
					return game.checkMod(card, owner, card.nature, 'cardnature', owner);
				}
			}
			return card.nature;
		},
		cards: function (num) {
			if (_status.waitingForCards) {
				ui.create.cards.apply(ui.create, _status.waitingForCards);
				delete _status.waitingForCards;
			}
			var list = [];
			var card = false;
			if (typeof num != 'number') num = 1;
			if (num == 0) { card = true; num = 1; }
			if (num < 0) num = 1;
			while (num--) {
				if (ui.cardPile.hasChildNodes() == false) {
					if (_status.maxShuffle != undefined) {
						if (_status.maxShuffle == 0) {
							if (_status.maxShuffleCheck) {
								game.over(_status.maxShuffleCheck());
							}
							else {
								game.over('平局');
							}
							return [];
						}
						_status.maxShuffle--;
					}
					game.shuffleNumber++;
					var cards = [], i;
					for (var i = 0; i < lib.onwash.length; i++) {
						if (lib.onwash[i]() == 'remove') {
							lib.onwash.splice(i--, 1);
						}
					}
					if (_status.discarded) {
						_status.discarded.length = 0;
					}
					for (i = 0; i < ui.discardPile.childNodes.length; i++) {
						var currentcard = ui.discardPile.childNodes[i];
						currentcard.vanishtag.length = 0;
						if (get.info(currentcard).vanish || currentcard.storage.vanish) {
							currentcard.remove();
							continue;
						}
						cards.push(currentcard);
					}
					cards.randomSort();
					for (var i = 0; i < cards.length; i++) {
						ui.cardPile.appendChild(cards[i]);
					}
				}
				if (ui.cardPile.hasChildNodes() == false) {
					game.over('平局');
					return [];
				}
				var cardx = ui.cardPile.removeChild(ui.cardPile.firstChild);
				cardx.original = 'c';
				list.push(cardx);
			}
			game.updateRoundNumber();
			if (card) return list[0];
			return list;
		},
		judge: function (card) {
			if (card.viewAs) return lib.card[card.viewAs].judge;
			return get.info(card).judge;
		},
		distance: function (from, to, method) {
			if (from == to) return 0;
			if (!game.players.contains(from) && !game.dead.contains(from)) return Infinity;
			if (!game.players.contains(to) && !game.dead.contains(to)) return Infinity;
			var player = from, m, n = 1, i;
			var fxy, txy;
			if (game.chess) {
				fxy = from.getXY();
				txy = to.getXY();
				n = Math.abs(fxy[0] - txy[0]) + Math.abs(fxy[1] - txy[1]);
				if (method == 'raw' || method == 'pure' || method == 'absolute') return n;
			}
			else if (to.isMin(true) || from.isMin(true)) {
				if (method == 'raw' || method == 'pure' || method == 'absolute') return n;
			}
			else {
				var length = game.players.length;
				var totalPopulation = game.players.length + game.dead.length + 1;
				for (var iwhile = 0; iwhile < totalPopulation; iwhile++) {
					if (player.nextSeat != to) {
						player = player.nextSeat;
						if (player.isAlive() && !player.isOut() && !player.hasSkill('undist') && !player.isMin(true)) n++;
					}
					else {
						break;
					}
				}
				for (i = 0; i < game.players.length; i++) {
					if (game.players[i].isOut() || game.players[i].hasSkill('undist') || game.players[i].isMin(true)) length--;
				}
				if (method == 'absolute') return n;
				if (from.isDead()) length++;
				if (to.isDead()) length++;
				var left = from.hasSkillTag('left_hand');
				var right = from.hasSkillTag('right_hand');
				if (left === right) n = Math.min(n, length - n);
				else if (left == true) n = length - n;
				if (method == 'raw' || method == 'pure') return n;
			}

			n = game.checkMod(from, to, n, 'globalFrom', from);
			n = game.checkMod(from, to, n, 'globalTo', to);
			m = n;
			m = game.checkMod(from, to, m, 'attackFrom', from);
			m = game.checkMod(from, to, m, 'attackTo', to);
			var equips1 = from.getCards('e', function (card) {
				return !ui.selected.cards || !ui.selected.cards.contains(card);
			}), equips2 = to.getCards('e', function (card) {
				return !ui.selected.cards || !ui.selected.cards.contains(card);
			});
			for (i = 0; i < equips1.length; i++) {
				var info = get.info(equips1[i]).distance;
				if (!info) continue;
				if (info.globalFrom) {
					m += info.globalFrom;
					n += info.globalFrom;
				}
				if (info.attackFrom) {
					m += info.attackFrom;
				}
			}
			for (i = 0; i < equips2.length; i++) {
				var info = get.info(equips2[i]).distance;
				if (!info) continue;
				if (info.globalTo) {
					m += info.globalTo;
					n += info.globalTo;
				}
				if (info.attaclTo) {
					m += info.attaclTo;
				}
			}
			if (method == 'attack') return m;
			return n;
		},
		info: function (item, player) {
			if (typeof item == 'string') {
				return lib.skill[item];
			}
			if (typeof item == 'object') {
				var name = item.name;
				if (player !== false) name = get.name(item, player);
				return lib.card[name];
			}
		},
		select: function (select) {
			if (typeof select == 'number') return [select, select];
			if (get.itemtype(select) == 'select') return select;
			if (typeof select == 'function') return get.select(select());
			return [1, 1]
		},
		card: function (original) {
			if (_status.event.skill) {
				var card = get.info(_status.event.skill).viewAs;
				if (typeof card == 'function') card = card(ui.selected.cards, _status.event.player);
				if (card) {
					return get.autoViewAs(card, ui.selected.cards, _status.event.player);
				}
			}
			if (_status.event._get_card) {
				return _status.event._get_card;
			}
			var card = ui.selected.cards[0];
			if (original) return card;
			if (card) {
				card = get.autoViewAs(card, ui.selected.cards, _status.event.player);
			}
			return card;
		},
		player: function () {
			return _status.event.player;
		},
		players: function (sort, dead, out) {
			var players = game.players.slice(0);
			if (sort != false) {
				if (typeof sort == 'function') {
					players.sort(sort);
				}
				else {
					if (get.itemtype(sort) != 'player') lib.tempSortSeat = _status.event.player;
					else lib.tempSortSeat = sort;
					players.sort(lib.sort.seat);
					delete lib.tempSortSeat;
				}
			}
			if (dead) players = players.concat(game.dead);
			if (!out) {
				for (var i = 0; i < players.length; i++) {
					if (players[i].isOut()) players.splice(i--, 1);
				}
			}
			return players;
		},
		position: function (card, ordering) {
			if (get.itemtype(card) == 'player') return parseInt(card.dataset.position);
			if (card.timeout && card.destiny) {
				if (card.destiny.classList.contains('equips')) return 'e';
				if (card.destiny.classList.contains('judges')) return 'j';
				if (card.destiny.classList.contains('handcards')) return 'h';
				if (card.destiny.id == 'cardPile') return 'c';
				if (card.destiny.id == 'discardPile') return 'd';
				if (card.destiny.id == 'special') return 's';
				if (card.destiny.id == 'ordering') return ordering ? 'o' : 'd';
				return null;
			}
			if (!card.parentNode) return;
			if (card.parentNode.classList.contains('equips')) return 'e';
			if (card.parentNode.classList.contains('judges')) return 'j';
			if (card.parentNode.classList.contains('handcards')) return 'h';
			if (card.parentNode.id == 'cardPile') return 'c';
			if (card.parentNode.id == 'discardPile') return 'd';
			if (card.parentNode.id == 'special') return 's';
			if (card.parentNode.id == 'ordering') return ordering ? 'o' : 'd';
			return null;
		},
		skillTranslation: function (str, player) {
			var str2;
			if (str.indexOf('re') == 0) {
				str2 = str.slice(2);
				if (str2) {
					if (lib.translate[str] == lib.translate[str2]) {
						if (player.hasSkill(str2)) {
							return '界' + lib.translate[str];
						}
					}
				}
			}
			else if (str.indexOf('xin') == 0) {
				str2 = str.slice(3);
				if (str2) {
					if (lib.translate[str] == lib.translate[str2]) {
						if (player.hasSkill(str2)) {
							return '新' + lib.translate[str];
						}
					}
				}
			}
			return get.translation(str);
		},
		skillInfoTranslation: function (name, player) {
			if (player && lib.dynamicTranslate[name]) return lib.dynamicTranslate[name](player, name);
			var str = lib.translate[name + '_info'];
			if (!str) return '';
			return str;
			// return str.replace(/锁定技/g,'<span class="yellowtext">锁定技</span>').
			// 	replace(/限定技/g,'<span class="yellowtext">限定技</span>').
			// 	replace(/觉醒技/g,'<span class="greentext">觉醒技</span>').
			// 	replace(/主将技/g,'<span class="bluetext">主将技</span>').
			// 	replace(/副将技/g,'<span class="bluetext">副将技</span>').
			// 	replace(/阵法技/g,'<span class="bluetext">阵法技</span>').
			// 	replace(/主公技/g,'<span class="firetext">主公技</span>');
		},
		translation: function (str, arg) {
			if (str && typeof str == 'object' && (str.name || str._tempTranslate)) {
				if (str._tempTranslate) return str._tempTranslate;
				var str2;
				if (arg == 'viewAs' && str.viewAs) {
					str2 = get.translation(str.viewAs);
				}
				else {
					str2 = get.translation(str.name);
				}
				if (str2 == '杀') {
					if (str.nature == 'fire') {
						str2 = '火' + str2;
					}
					else if (str.nature == 'thunder') {
						str2 = '雷' + str2;
					}
					else if (str.nature == 'kami') {
						str2 = '神' + str2;
					}
				}
				if (get.itemtype(str) == 'card' || str.isCard) {
					if (_status.cardtag && str.cardid) {
						var tagstr = '';
						for (var i in _status.cardtag) {
							if (_status.cardtag[i].contains(str.cardid)) {
								tagstr += lib.translate[i + '_tag'];
							}
						}
						if (tagstr) {
							str2 += '·' + tagstr;
						}
					}
					if (str.suit && str.number) {
						var cardnum = str.number || '';
						if ([1, 11, 12, 13].contains(cardnum)) {
							cardnum = { '1': 'A', '11': 'J', '12': 'Q', '13': 'K' }[cardnum]
						}
						if (arg == 'viewAs' && str.viewAs != str.name && str.viewAs) {
							str2 += '（' + get.translation(str) + '）';
						}
						else {
							str2 += '【' + get.translation(str.suit) + cardnum + '】';
							// var len=str2.length-1;
							// str2=str2.slice(0,len)+'<span style="letter-spacing: -2px">'+str2[len]+'·</span>'+get.translation(str.suit)+str.number;
						}
					}
				}
				return str2;
			}
			if (Array.isArray(str)) {
				var str2 = get.translation(str[0], arg);
				for (var i = 1; i < str.length; i++) {
					str2 += '、' + get.translation(str[i], arg);
				}
				return str2;
			}
			if (arg == 'skill') {
				if (lib.translate[str + '_ab']) return lib.translate[str + '_ab'];
				if (lib.translate[str]) return lib.translate[str].slice(0, 2);
				return str;
			}
			else if (arg == 'info') {
				if (lib.translate[str + '_info']) return lib.translate[str + '_info'];
				var str2 = str.slice(0, str.length - 1);
				if (lib.translate[str2 + '_info']) return lib.translate[str2 + '_info'];
				if (str.lastIndexOf('_') > 0) {
					str2 = str.slice(0, str.lastIndexOf('_'));
					if (lib.translate[str2 + '_info']) return lib.translate[str2 + '_info'];
				}
				str2 = str.slice(0, str.length - 2);
				if (lib.translate[str2 + '_info']) return lib.translate[str2 + '_info'];
				if (lib.skill[str] && lib.skill[str].prompt) return lib.skill[str].prompt;
			}
			if (lib.translate[str]) {
				return lib.translate[str];
			}
			if (typeof str == 'string') {
				return str;
			}
			if (typeof str == 'number' || typeof str == 'boolean') {
				return str.toString();
			}
			if (str && str.toString) {
				return str.toString();
			}
			return '';
		},
		cnNumber: function (num, two) {
			if (num == Infinity) return '∞';
			if (isNaN(num)) return '';
			if (typeof num != 'number') return num;
			if (num < 0 || num > 99) return num;
			if (num <= 10) {
				switch (num) {
					case 0: return '〇';
					case 1: return '一';
					case 2: return two ? '二' : '两';
					case 3: return '三';
					case 4: return '四';
					case 5: return '五';
					case 6: return '六';
					case 7: return '七';
					case 8: return '八';
					case 9: return '九';
					case 10: return '十';
				}
			}
			if (num < 20) {
				return '十' + get.cnNumber(num - 10, true);
			}
			var x = Math.floor(num / 10);
			return get.cnNumber(x, true) + '十' + (num > 10 * x ? get.cnNumber(num - 10 * x, true) : '');
		},
		selectableButtons: function (sort) {
			if (!_status.event.player) return [];
			var buttons = _status.event.dialog.buttons;
			var selectable = [];
			for (var i = 0; i < buttons.length; i++) {
				if (buttons[i].classList.contains('selectable') &&
					buttons[i].classList.contains('selected') == false) {
					selectable.push(buttons[i]);
				}
			}
			if (sort) {
				selectable.sort(sort);
			}
			return selectable;
		},
		selectableCards: function (sort) {
			if (!_status.event.player) return [];
			var cards = _status.event.player.getCards('hej');
			var selectable = [];
			for (var i = 0; i < cards.length; i++) {
				if (cards[i].classList.contains('selectable') &&
					cards[i].classList.contains('selected') == false) {
					selectable.push(cards[i]);
				}
			}
			if (sort) {
				selectable.sort(sort);
			}
			return selectable;
		},
		skills: function () {
			var skills = [];
			if (ui.skills) {
				skills = skills.concat(ui.skills.skills);
			}
			if (ui.skills2) {
				skills = skills.concat(ui.skills2.skills);
			}
			if (ui.skills3) {
				skills = skills.concat(ui.skills3.skills);
			}
			return skills;
		},
		gainableSkills: function (func, player) {
			var list = [];
			for (var i in lib.character) {
				if (lib.character[i][4]) {
					if (lib.character[i][4].contains('boss')) continue;
					if (lib.character[i][4].contains('hiddenboss')) continue;
					if (lib.character[i][4].contains('minskin')) continue;
					if (lib.character[i][4].contains('unseen')) continue;
				}
				for (var j = 0; j < lib.character[i][3].length; j++) {
					var skill = lib.character[i][3][j];
					var info = lib.skill[skill];
					if (lib.filter.skillDisabled(skill)) continue;
					if (func && !func(info, skill, i)) continue;
					if (player && player.hasSkill && info.ai && info.ai.combo && !player.hasSkill(info.ai.combo)) continue;
					list.add(skill);
				}
			}
			return list;
		},
		gainableSkillsName: function (name, func) {
			var list = [];
			if (name && lib.character[name]) {
				if (lib.character[name][4]) {
					if (lib.character[name][4].contains('boss')) return list;
					if (lib.character[name][4].contains('hiddenboss')) return list;
					if (lib.character[name][4].contains('minskin')) return list;
					if (lib.character[name][4].contains('unseen')) return list;
				}
				for (var j = 0; j < lib.character[name][3].length; j++) {
					var skill = lib.character[name][3][j];
					var info = lib.skill[skill];
					if (lib.filter.skillDisabled(skill)) continue;
					if (func && !func(info, skill, name)) continue;
					list.add(skill);
				}
			}
			return list;
		},
		gainableCharacters: function (func) {
			var list = [];
			for (var i in lib.character) {
				var info = lib.character[i];
				if (typeof func == 'function' && !func(info, i)) continue;
				if (lib.filter.characterDisabled(i)) continue;
				if (lib.filter.characterDisabled2(i)) continue;
				list.push(i);
			}
			if (func === true) {
				var players = game.players.concat(game.dead);
				for (var i = 0; i < players.length; i++) {
					list.remove(players[i].name);
					list.remove(players[i].name1);
					list.remove(players[i].name2);
				}
			}
			return list;
		},
		selectableTargets: function (sort) {
			var selectable = [];
			var players = game.players.slice(0);
			if (_status.event.deadTarget) players.addArray(game.dead);
			for (var i = 0; i < players.length; i++) {
				if (players[i].classList.contains('selectable') &&
					players[i].classList.contains('selected') == false) {
					selectable.push(players[i]);
				}
			}
			selectable.randomSort();
			if (sort) {
				selectable.sort(sort);
			}
			return selectable;
		},
		filter: function (filter, i) {
			if (typeof filter == 'function') return filter;
			if (i == undefined) i = 0;
			var result = function () {
				if (filter == arguments[i]) return true;
				for (var j in filter) {
					if (filter.hasOwnProperty(j)) {
						if (get.itemtype(arguments[i]) == 'card') {
							if (j == 'name') {
								if (typeof filter[j] == 'object') {
									if (filter[j].contains(get.name(arguments[i])) == false) return false;
								}
								else if (typeof filter[j] == 'string') {
									if (get.name(arguments[i]) != filter[j]) return false;
								}
							}
							else if (j == 'type') {
								if (typeof filter[j] == 'object') {
									if (filter[j].contains(get.type(arguments[i])) == false) return false;
								}
								else if (typeof filter[j] == 'string') {
									if (get.type(arguments[i]) != filter[j]) return false;
								}
							}
							else if (j == 'subtype') {
								if (typeof filter[j] == 'object') {
									if (filter[j].contains(get.subtype(arguments[i])) == false) return false;
								}
								else if (typeof filter[j] == 'string') {
									if (get.subtype(arguments[i]) != filter[j]) return false;
								}
							}
							else if (j == 'color') {
								if (typeof filter[j] == 'object') {
									if (filter[j].contains(get.color(arguments[i])) == false) return false;
								}
								else if (typeof filter[j] == 'string') {
									if (get.color(arguments[i]) != filter[j]) return false;
								}
							}
							else if (j == 'suit') {
								if (typeof filter[j] == 'object') {
									if (filter[j].contains(get.suit(arguments[i])) == false) return false;
								}
								else if (typeof filter[j] == 'string') {
									if (get.suit(arguments[i]) != filter[j]) return false;
								}
							}
							else if (j == 'number') {
								if (typeof filter[j] == 'object') {
									if (filter[j].contains(get.number(arguments[i])) == false) return false;
								}
								else if (typeof filter[j] == 'string') {
									if (get.number(arguments[i]) != filter[j]) return false;
								}
							}
							else if (typeof filter[j] == 'object') {
								if (filter[j].contains(arguments[i][j]) == false) return false;
							}
							else if (typeof filter[j] == 'string') {
								if (arguments[i][j] != filter[j]) return false;
							}
						}
						else {
							if (arguments[i][j] != filter[j]) return false;
						}
					}
				}
				return true;
			}
			result._filter_args = [filter, i];
			return result;
		},
		cardCount: function (card, player) {
			var num;
			if (card == true) {
				num = 0;
				var stat = player.getStat('card');
				for (var i in stat) {
					if (typeof stat[i] == 'number') num += stat[i];
				}
				return num;
			}
			if (player == undefined) player = _status.event.player;
			if (typeof card == 'object') {
				card = card.name;
			}
			num = player.getStat('card')[card];
			if (num == undefined) return 0;
			return num;
		},
		skillCount: function (skill, player) {
			if (player == undefined) player = _status.event.player;
			var num = player.getStat('skill')[skill];
			if (num == undefined) return 0;
			return num;
		},
		owner: function (card, method) {
			for (var i = 0; i < game.players.length; i++) {
				if (game.players[i].getCards('hej').contains(card)) return game.players[i];
				if (game.players[i].judging[0] == card && method != 'judge') return game.players[i];
			}
			//for(var i=0;i<game.players.length;i++){
			//	if(game.players[i].using&&game.players[i].using.contains(card)) return game.players[i];
			//}
		},
		noSelected: function () {
			return (ui.selected.buttons.length + ui.selected.cards.length + ui.selected.targets.length == 0)
		},
		population: function (identity) {
			if (identity == undefined) return game.players.length + game.dead.length;
			var i;
			var num = 0;
			for (i = 0; i < game.players.length; i++) {
				if (game.players[i].identity == identity) num++;
			}
			return num;
		},
		totalPopulation: function (identity) {
			if (identity == undefined) return game.players.length + game.dead.length;
			var i, players = game.players.concat(game.dead);
			var num = 0;
			for (i = 0; i < players.length; i++) {
				if (players[i].identity == identity) num++;
			}
			return num;
		},
		cardtag: function (item, tag) {
			if (item.cardid && _status.cardtag && _status.cardtag[tag] && _status.cardtag[tag].contains(item.cardid)) {
				return true;
			}
			return false;
		},
		tag: function (item, tag, item2) {
			var result;
			if (get.info(item) && get.info(item).ai && get.info(item).ai.tag) {
				result = get.info(item).ai.tag[tag];
			}
			if (typeof result == 'function') return result(item, item2);
			return result;
		},
		sortCard: function (sort) {
			var func;
			if (sort == 'type_sort') {
				func = function (card) {
					var type = get.type(card);
					var subtype = get.subtype(card);
					if (lib.cardType[subtype]) {
						return lib.cardType[subtype];
					}
					if (lib.cardType[type]) {
						return lib.cardType[type];
					}
					switch (type) {
						case 'basic': return 2;
						case 'chess': return 1.5;
						case 'trick': return -1;
						case 'delay': return -2;
						case 'equip': return -3;
						default: return -4;
					}
				}
			}
			else if (sort == 'suit_sort') {
				func = function (card) {
					if (get.suit(card) == 'heart') return 2;
					if (get.suit(card) == 'diamond') return 1;
					if (get.suit(card) == 'spade') return -1;
					if (get.suit(card) == 'club') return -2;
				}
			}
			else if (sort == 'number_sort') {
				func = function (card) {
					return get.number(card) - 7 + 0.5;
				}
			}
			return func;
		},
		difficulty: function () {
			switch (get.config('difficulty')) {
				case 'easy': return 1;
				case 'normal': return 2;
				case 'hard': return 3;
				default: return 1;
			}
		},
		cardPile: function (name, create) {
			var filter = function (card) {
				if (typeof name == 'string') {
					if (card.name == name) {
						return true;
					}
				}
				else if (typeof name == 'function') {
					if (name(card)) {
						return true;
					}
				}
				return false;
			};
			if (create != 'discardPile') {
				for (var i = 0; i < ui.cardPile.childNodes.length; i++) {
					if (filter(ui.cardPile.childNodes[i])) {
						return ui.cardPile.childNodes[i];
					}
				}
			}
			if (create != 'cardPile') {
				for (var i = 0; i < ui.discardPile.childNodes.length; i++) {
					if (filter(ui.discardPile.childNodes[i])) {
						return ui.discardPile.childNodes[i];
					}
				}
			}
			if (create == 'field') {
				var found = null;
				game.findPlayer(function (current) {
					var ej = current.getCards('ej');
					for (var i = 0; i < ej.length; i++) {
						if (filter(ej[i])) {
							found = ej[i];
							return true;
						}
					}
				});
				return found;
			}
			if (create && !['cardPile', 'discardPile', 'field'].contains(create)) {
				return game.createCard(name);
			}
			return null;
		},
		cardPile2: function (name) {
			return get.cardPile(name, 'cardPile');
		},
		discardPile: function (name) {
			return get.cardPile(name, 'discardPile');
		},
		aiStrategy: function () {
			switch (get.config('ai_strategy')) {
				case 'ai_strategy_1': return 1;
				case 'ai_strategy_2': return 2;
				case 'ai_strategy_3': return 3;
				case 'ai_strategy_4': return 4;
				case 'ai_strategy_5': return 5;
				case 'ai_strategy_6': return 6;
				default: return 1;
			}
		},
		skillintro: function (name, learn, learn2) {
			var str = '';
			var infoitem = lib.character[name];
			if (!infoitem) {
				for (var itemx in lib.characterPack) {
					if (lib.characterPack[itemx][name]) {
						infoitem = lib.characterPack[itemx][name]; break;
					}
				}
			}
			var skills = infoitem[3];
			var opacity;
			for (var i = 0; i < skills.length; i++) {
				if (lib.translate[skills[i]] && lib.translate[skills[i] + '_info'] && lib.skill[skills[i]]) {
					if (learn && lib.skill[skills[i]].unique && (learn2 || !lib.skill[skills[i]].gainable)) {
						opacity = 'opacity:0.5';
					}
					else {
						opacity = '';
					}
					var skilltrans = get.translation(skills[i]).slice(0, 2);
					str += '<div class="skill" style="' + opacity +
						'">【' + skilltrans + '】</div><div style="' + opacity + '">' +
						get.skillInfoTranslation(skills[i]) + '</div><div style="display:block;height:10px"></div>';
				}
			}
			return str;
		},
		intro: function (name) {
			var info = lib.character[name];
			var str = '性别：' + get.translation(info[0]) + '<br/>';
			str += '势力：' + get.translation(info[1]) + '<br/>';
			str += '体力：' + get.translation(info[2]) + '<br/>';
			str += '技能：';
			if (info[3].length) {
				str += get.translation(info[3][0]);
				for (var i = 1; i < info[3].length; i++) {
					str += '、' + get.translation(info[3][i]);
				}
			}
			return str;
		},
		storageintro: function (type, content, player, dialog, skill) {
			switch (type) {
				case 'mark': {
					if (content > 0) {
						return '共有' + content + '个标记';
					}
					return false;
				}
				case 'turn': {
					if (content > 0) {
						return '剩余' + content + '个回合';
					}
					return false;
				}
				case 'time': {
					if (content > 0) {
						return '剩余' + content + '次';
					}
					return false;
				}
				case 'limited': {
					if (content) {
						return '已发动';
					}
					return '未发动';
				}
				case 'info': {
					return lib.translate[skill + '_info'];
				}
				case 'cardCount': {
					if (typeof content == 'object' && typeof content.length == 'number') {
						return '共有' + get.cnNumber(content.length) + '张牌';
					}
					return false;
				}
				case 'card': case 'cards': {
					if (get.itemtype(content) == 'card') {
						content = [content];
					}
					if (dialog && get.itemtype(content) == 'cards') {
						dialog.addAuto(content);
					}
					else {
						if (content && content.length) {
							return get.translation(content);
						}
					}
					if (Array.isArray(content) && !content.length) {
						return '没有卡牌';
					}
					return false;
				}
				case 'player': case 'players': {
					if (get.itemtype(content) == 'player') {
						content = [content];
					}
					if (dialog && get.itemtype(content) == 'players') {
						dialog.addAuto(content);
						return false;
					}
					else {
						if (content && content.length) {
							return get.translation(content);
						}
						return false;
					}
				}
				case 'character': case 'characters': {
					if (typeof content == 'string') {
						content = [content];
					}
					if (dialog && Array.isArray(content)) {
						dialog.addAuto([content, 'character']);
						return false;
					}
					else {
						if (content && content.length) {
							return get.translation(content);
						}
						return false;
					}
				}
				default: {
					if (typeof type == 'string') {
						type = type.replace(/#/g, content);
						type = type.replace(/&/g, get.cnNumber(content));
						type = type.replace(/\$/g, get.translation(content));
						return type;
					}
					else if (typeof type == 'function') {
						return type(content, player, skill);
					}
					return false;
				}
			}
		},
		nodeintro: function (node, simple, evt) {
			var uiintro = ui.create.dialog('hidden', 'notouchscroll');
			if (node.classList.contains('player') && !node.name) {
				return uiintro;
			}
			var i, translation, intro, str;
			if (node._nointro) return;
			if (typeof node._customintro == 'function') {
				if (node._customintro(uiintro) === false) return;
			}
			else if (Array.isArray(node._customintro)) {
				var caption = node._customintro[0];
				var content = node._customintro[1];
				if (typeof caption == 'function') {
					caption = caption(node);
				}
				if (typeof content == 'function') {
					content = content(node);
				}
				uiintro.add(caption);
				uiintro.add('<div class="text center" style="padding-bottom:5px">' + content + '</div>');
			}
			else if (node.classList.contains('player') || node.linkplayer) {
				if (node.linkplayer) {
					node = node.link;
				}
				var capt = get.translation(node.name);
				if (lib.character[node.name] && (lib.character[node.name][1] || lib.group.contains(node.group))) {
					capt += '&nbsp;&nbsp;' + (lib.group.contains(node.group) ? get.translation(node.group) : lib.translate[lib.character[node.name][1]]);
				}
				uiintro.add(capt);

				if (lib.characterTitle[node.name]) {
					uiintro.addText(get.colorspan(lib.characterTitle[node.name]));
				}

				if (node.isUnderControl() || (!game.observe && game.me && game.me.hasSkillTag('viewHandcard', null, node, true))) {
					var hs = node.getCards('h');
					if (hs.length) {
						uiintro.add('<div class="text center">手牌</div>');
						uiintro.addSmall(node.getCards('h'));
					}
				}

				var skills = node.getSkills(false, false);
				for (var i in node.forbiddenSkills) {
					skills.add(i);
				}
				skills = skills.slice(0);
				var skills2 = game.filterSkills(skills, node);
				if (node == game.me && node.hiddenSkills.length) {
					skills.addArray(node.hiddenSkills);
				}
				for (var i in node.disabledSkills) {
					if (node.disabledSkills[i].length == 1 &&
						node.disabledSkills[i][0] == i + '_awake' &&
						!node.hiddenSkills.contains(i)) {
						skills.push(i);
					}
				}
				for (i = 0; i < skills.length; i++) {
					if (lib.skill[skills[i]] && (lib.skill[skills[i]].nopop || lib.skill[skills[i]].equipSkill)) continue;
					if (lib.translate[skills[i] + '_info']) {
						translation = lib.translate[skills[i] + '_ab'] || get.translation(skills[i]).slice(0, 2);
						if (node.forbiddenSkills[skills[i]]) {
							var forbidstr = '<div style="opacity:0.5"><div class="skill">【' + translation + '】</div><div>';
							if (node.forbiddenSkills[skills[i]].length) {
								forbidstr += '（与' + get.translation(node.forbiddenSkills[skills[i]]) + '冲突）<br>';
							}
							else {
								forbidstr += '（双将禁用）<br>';
							}
							forbidstr += get.skillInfoTranslation(skills[i], node) + '</div></div>'
							uiintro.add(forbidstr);
						}
						else if (!skills2.contains(skills[i])) {
							uiintro.add('<div style="opacity:0.5"><div class="skill">【' + translation + '】</div><div>' + get.skillInfoTranslation(skills[i], node) + '</div></div>');
						}
						else if (lib.skill[skills[i]].temp || !node.skills.contains(skills[i]) || lib.skill[skills[i]].thundertext) {
							if (lib.skill[skills[i]].frequent || lib.skill[skills[i]].subfrequent) {
								uiintro.add('<div><div class="skill thundertext thunderauto">【' + translation + '】</div><div class="thundertext thunderauto">' + get.skillInfoTranslation(skills[i], node) + '<br><div class="underlinenode on gray" style="position:relative;padding-left:0;padding-top:7px">自动发动</div></div></div>');
								var underlinenode = uiintro.content.lastChild.querySelector('.underlinenode');
								if (lib.skill[skills[i]].frequent) {
									if (lib.config.autoskilllist.contains(skills[i])) {
										underlinenode.classList.remove('on');
									}
								}
								if (lib.skill[skills[i]].subfrequent) {
									for (var j = 0; j < lib.skill[skills[i]].subfrequent.length; j++) {
										if (lib.config.autoskilllist.contains(skills[i] + '_' + lib.skill[skills[i]].subfrequent[j])) {
											underlinenode.classList.remove('on');
										}
									}
								}
								if (lib.config.autoskilllist.contains(skills[i])) {
									underlinenode.classList.remove('on');
								}
								underlinenode.link = skills[i];
								underlinenode.listen(ui.click.autoskill2);
							}
							else {
								uiintro.add('<div><div class="skill thundertext thunderauto">【' + translation + '】</div><div class="thundertext thunderauto">' + get.skillInfoTranslation(skills[i], node) + '</div></div>');
							}
						}
						else if (lib.skill[skills[i]].frequent || lib.skill[skills[i]].subfrequent) {
							uiintro.add('<div><div class="skill">【' + translation + '】</div><div>' + get.skillInfoTranslation(skills[i], node) + '<br><div class="underlinenode on gray" style="position:relative;padding-left:0;padding-top:7px">自动发动</div></div></div>');
							var underlinenode = uiintro.content.lastChild.querySelector('.underlinenode');
							if (lib.skill[skills[i]].frequent) {
								if (lib.config.autoskilllist.contains(skills[i])) {
									underlinenode.classList.remove('on');
								}
							}
							if (lib.skill[skills[i]].subfrequent) {
								for (var j = 0; j < lib.skill[skills[i]].subfrequent.length; j++) {
									if (lib.config.autoskilllist.contains(skills[i] + '_' + lib.skill[skills[i]].subfrequent[j])) {
										underlinenode.classList.remove('on');
									}
								}
							}
							if (lib.config.autoskilllist.contains(skills[i])) {
								underlinenode.classList.remove('on');
							}
							underlinenode.link = skills[i];
							underlinenode.listen(ui.click.autoskill2);
						}
						else if (lib.skill[skills[i]].clickable && node.isIn() && node.isUnderControl(true)) {
							var intronode = uiintro.add('<div><div class="skill">【' + translation + '】</div><div>' + get.skillInfoTranslation(skills[i], node) + '<br><div class="menubutton skillbutton" style="position:relative;margin-top:5px">点击发动</div></div></div>').querySelector('.skillbutton');
							if (!_status.gameStarted || (lib.skill[skills[i]].clickableFilter && !lib.skill[skills[i]].clickableFilter(node))) {
								intronode.classList.add('disabled');
								intronode.style.opacity = 0.5;
							}
							else {
								intronode.link = node;
								intronode.func = lib.skill[skills[i]].clickable;
								intronode.classList.add('pointerdiv');
								intronode.listen(ui.click.skillbutton);
							}
						}
						else if (lib.skill[skills[i]].nobracket) {
							uiintro.add('<div><div class="skilln">' + get.translation(skills[i]) + '</div><div>' + lib.translate[skills[i] + '_info'] + '</div></div>');
						}
						else {
							uiintro.add('<div><div class="skill">【' + translation + '】</div><div>' + get.skillInfoTranslation(skills[i], node) + '</div></div>');
						}
						if (lib.translate[skills[i] + '_append']) {
							uiintro._place_text = uiintro.add('<div class="text">' + lib.translate[skills[i] + '_append'] + '</div>')
						}
					}
				}
				// if(get.is.phoneLayout()){
				//     var storage=node.storage;
				//     for(i in storage){
				//      			if(get.info(i)&&get.info(i).intro){
				//      						 intro=get.info(i).intro;
				//      						 if(node.getSkills().concat(lib.skill.global).contains(i)==false&&!intro.show) continue;
				//      						 var name=intro.name?intro.name:get.translation(i);
				//      						 if(typeof name=='function'){
				//      									  name=name(storage[i],node);
				//      						 }
				//      						 translation='<div><div class="skill">『'+name.slice(0,2)+'』</div><div>';
				//      						 var stint=get.storageintro(intro.content,storage[i],node,null,i);
				//      						 if(stint){
				//      									  translation+=stint+'</div></div>';
				//      									  uiintro.add(translation);
				//      						 }
				//      			}
				//     }
				// }

				if (lib.config.right_range && _status.gameStarted) {
					uiintro.add(ui.create.div('.placeholder'));
					var table, tr, td;
					table = document.createElement('table');
					tr = document.createElement('tr');
					table.appendChild(tr);
					td = document.createElement('td');
					td.innerHTML = '距离';
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = '手牌';
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = '行动';
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = '伤害';
					tr.appendChild(td);

					tr = document.createElement('tr');
					table.appendChild(tr);
					td = document.createElement('td');
					if (node == game.me || !game.me || !game.me.isIn()) {
						td.innerHTML = '-';
					}
					else {
						var dist1 = get.numStr(Math.max(1, game.me.distanceTo(node)));
						var dist2 = get.numStr(Math.max(1, node.distanceTo(game.me)));
						if (dist1 == dist2) {
							td.innerHTML = dist1;
						}
						else {
							td.innerHTML = dist1 + '/' + dist2;
						}
					}
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = node.countCards('h');
					tr.appendChild(td);
					td = document.createElement('td');
					td.innerHTML = node.stat.length - 1;
					tr.appendChild(td);
					td = document.createElement('td');

					(function () {
						num = 0;
						for (var j = 0; j < node.stat.length; j++) {
							if (typeof node.stat[j].damage == 'number') num += node.stat[j].damage;
						}
						td.innerHTML = num;
					}());
					tr.appendChild(td);
					table.style.width = 'calc(100% - 20px)';
					table.style.marginLeft = '10px';

					uiintro.content.appendChild(table);
					if (!lib.config.show_favourite) {
						table.style.paddingBottom = '5px'
					}
				}
				if (!simple || get.is.phoneLayout()) {
					var es = node.getCards('e');
					for (var i = 0; i < es.length; i++) {
						uiintro.add('<div><div class="skill">' + es[i].outerHTML + '</div><div>' + lib.translate[es[i].name + '_info'] + '</div></div>');
						uiintro.content.lastChild.querySelector('.skill>.card').style.transform = '';
					}
					var js = node.getCards('j');
					for (var i = 0; i < js.length; i++) {
						if (js[i].viewAs && js[i].viewAs != js[i].name) {
							uiintro.add('<div><div class="skill">' + js[i].outerHTML + '</div><div>' + lib.translate[js[i].viewAs] + '：' + lib.translate[js[i].viewAs + '_info'] + '</div></div>');
						}
						else {
							uiintro.add('<div><div class="skill">' + js[i].outerHTML + '</div><div>' + lib.translate[js[i].name + '_info'] + '</div></div>');
						}
						uiintro.content.lastChild.querySelector('.skill>.card').style.transform = '';
					}
					if (get.is.phoneLayout()) {
						var markCoutainer = ui.create.div('.mark-container.marks');
						for (var i in node.marks) {
							var nodemark = node.marks[i].cloneNode(true);
							nodemark.classList.add('pointerdiv');
							nodemark.link = node.marks[i];
							nodemark.style.transform = '';
							markCoutainer.appendChild(nodemark);
							nodemark.listen(function () {
								uiintro.noresume = true;
								var rect = this.link.getBoundingClientRect();
								ui.click.intro.call(this.link, {
									clientX: rect.left + rect.width,
									clientY: rect.top + rect.height / 2,
								});
								if (lib.config.touchscreen) {
									uiintro._close();
								}
							});
						}
						if (markCoutainer.childElementCount) {
							uiintro.addText('标记');
							uiintro.add(markCoutainer);
						}
					}
				}
				var modepack = lib.characterPack['mode_' + get.mode()];
				if (lib.config.show_favourite && lib.character[node.name] && game.players.contains(node) &&
					(!modepack || !modepack[node.name]) && (!simple || get.is.phoneLayout())) {
					var addFavourite = ui.create.div('.text.center.pointerdiv');
					addFavourite.link = node.link;
					if (lib.config.favouriteCharacter.contains(node.name)) {
						addFavourite.innerHTML = '移除收藏';
					}
					else {
						addFavourite.innerHTML = '添加收藏';
					}
					addFavourite.listen(ui.click.favouriteCharacter)
					uiintro.add(addFavourite);
				}
				if (!simple || get.is.phoneLayout()) {
					if ((lib.config.change_skin || lib.skin) && !node.isUnseen()) {
						var num = 1;
						var introadded = false;
						var createButtons = function (num, avatar2) {
							if (!introadded) {
								introadded = true;
								uiintro.add('<div class="text center">更改皮肤</div>');
							}
							var buttons = ui.create.div('.buttons.smallzoom.scrollbuttons');
							lib.setMousewheel(buttons);
							var nameskin = (avatar2 ? node.name2 : node.name);
							var nameskin2 = nameskin;
							var gzbool = false;
							if (nameskin.indexOf('gz_shibing') == 0) {
								nameskin = nameskin.slice(3, 11);
							}
							else if (nameskin.indexOf('gz_') == 0) {
								nameskin = nameskin.slice(3);
								gzbool = true;
							}
							for (var i = 0; i <= num; i++) {
								var button = ui.create.div('.button.character.pointerdiv', buttons, function () {
									if (this._link) {
										if (avatar2) {
											lib.config.skin[nameskin] = this._link;
											node.node.avatar2.style.backgroundImage = this.style.backgroundImage;
										}
										else {
											lib.config.skin[nameskin] = this._link;
											node.node.avatar.style.backgroundImage = this.style.backgroundImage;
										}
									}
									else {
										delete lib.config.skin[nameskin];
										if (avatar2) {
											if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) node.node.avatar2.setBackground(nameskin2, 'character');
											else node.node.avatar2.setBackground(nameskin, 'character');
										}
										else {
											if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) node.node.avatar.setBackground(nameskin2, 'character');
											else node.node.avatar.setBackground(nameskin, 'character');
										}
									}
									game.saveConfig('skin', lib.config.skin);
								});
								button._link = i;
								if (i) {
									button.setBackgroundImage('image/skin/' + nameskin + '/' + i + '.jpg');
								}
								else {
									if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) button.setBackground(nameskin2, 'character', 'noskin');
									else button.setBackground(nameskin, 'character', 'noskin');
								}
							}
							uiintro.add(buttons);
						};
						var loadImage = function (avatar2) {
							var img = new Image();
							img.onload = function () {
								num++;
								loadImage(avatar2);
							}
							img.onerror = function () {
								num--;
								if (num) {
									createButtons(num, avatar2);
								}
								if (!avatar2) {
									if (!node.classList.contains('unseen2') && node.name2) {
										num = 1;
										loadImage(true);
									}
								}
							}
							var nameskin = (avatar2 ? node.name2 : node.name);
							var nameskin2 = nameskin;
							var gzbool = false;
							if (nameskin.indexOf('gz_shibing') == 0) {
								nameskin = nameskin.slice(3, 11);
							}
							else if (nameskin.indexOf('gz_') == 0) {
								nameskin = nameskin.slice(3);
								gzbool = true;
							}
							img.src = lib.assetURL + 'image/skin/' + nameskin + '/' + num + '.jpg';
						}
						if (lib.config.change_skin) {
							if (!node.isUnseen(0)) {
								loadImage();
							}
							else {
								loadImage(true);
							}
						}
						else {
							setTimeout(function () {
								var nameskin1 = node.name;
								var nameskin2 = node.name2;
								if (nameskin1 && nameskin1.indexOf('gz_') == 0) {
									nameskin1 = nameskin1.slice(3);
								}
								if (nameskin2 && nameskin2.indexOf('gz_') == 0) {
									nameskin2 = nameskin2.slice(3);
								}
								if (!node.isUnseen(0) && lib.skin[nameskin1]) {
									createButtons(lib.skin[nameskin1]);
								}
								if (!node.isUnseen(1) && lib.skin[nameskin2]) {
									createButtons(lib.skin[nameskin2], true);
								}
							});
						}
					}
				}

				uiintro.add(ui.create.div('.placeholder.slim'));
			}
			else if (node.classList.contains('mark') && node.info &&
				node.parentNode && node.parentNode.parentNode && node.parentNode.parentNode.classList.contains('player')) {
				var info = node.info;
				var player = node.parentNode.parentNode;
				if (info.name) {
					if (typeof info.name == 'function') {
						var named = info.name(player.storage[node.skill], player);
						if (named) {
							uiintro.add(named);
						}
					}
					else {
						uiintro.add(info.name);
					}
				}
				else if (info.name !== false) {
					uiintro.add(get.translation(node.skill));
				}
				if (typeof info.id == 'string' && info.id.indexOf('subplayer') == 0 &&
					player.isUnderControl(true) && player.storage[info.id] && !_status.video) {
					var storage = player.storage[info.id];
					uiintro.addText('当前体力：' + storage.hp + '/' + storage.maxHp);
					if (storage.hs.length) {
						uiintro.addText('手牌区');
						uiintro.addSmall(storage.hs);
					}
					if (storage.es.length) {
						uiintro.addText('装备区');
						uiintro.addSmall(storage.es);
					}
				}
				if (typeof info.mark == 'function') {
					var stint = info.mark(uiintro, player.storage[node.skill], player);
					if (stint) {
						var placetext = uiintro.add('<div class="text" style="display:inline">' + stint + '</div>');
						if (stint.indexOf('<div class="skill"') != 0) {
							uiintro._place_text = placetext;
						}
						// if(stint.length<=100){
						// 	uiintro.add('<div class="text center">'+stint+'</div>');
						// }
						// else{
						// 	uiintro.add('<div class="text">'+stint+'</div>');
						// }
					}
				}
				else {
					var stint = get.storageintro(info.content, player.storage[node.skill], player, uiintro, node.skill);
					if (stint) {
						if (stint[0] == '@') {
							uiintro.add('<div class="caption">' + stint.slice(1) + '</div>');
						}
						else {
							var placetext = uiintro.add('<div class="text" style="display:inline">' + stint + '</div>');
							if (stint.indexOf('<div class="skill"') != 0) {
								uiintro._place_text = placetext;
							}
						}
						// else if(stint.length<=100){
						// 	uiintro.add('<div class="text center">'+stint+'</div>');
						// }
						// else{
						// 	uiintro.add('<div class="text">'+stint+'</div>');
						// }
					}
				}
				uiintro.add(ui.create.div('.placeholder.slim'));
			}
			else if (node.classList.contains('card')) {
				if (ui.arena.classList.contains('observe') && node.parentNode.classList.contains('handcards')) {
					return;
				}
				var name = node.name;
				if (node.parentNode.cardMod) {
					var moded = false;
					for (var i in node.parentNode.cardMod) {
						var item = node.parentNode.cardMod[i](node);
						if (Array.isArray(item)) {
							moded = true;
							uiintro.add(item[0]);
							uiintro._place_text = uiintro.add('<div class="text" style="display:inline">' + item[1] + '</div>');
						}
					}
					if (moded) return uiintro;
				}
				if (node.link && node.link.name && lib.card[node.link.name]) {
					name = node.link.name;
				}
				if (get.position(node) == 'j' && node.viewAs && node.viewAs != name) {
					uiintro.add(get.translation(node.viewAs));
					uiintro.add('<div class="text center">（' + get.translation(get.translation(node)) + '）</div>');
					// uiintro.add(get.translation(node.viewAs)+'<br><div class="text center" style="padding-top:5px;">（'+get.translation(node)+'）</div>');
					uiintro.nosub = true;
					name = node.viewAs;
				}
				else {
					uiintro.add(get.translation(node));
				}
				if (node._banning) {
					var clickBanned = function () {
						var banned = lib.config[this.bannedname] || [];
						if (banned.contains(name)) {
							banned.remove(name);
						}
						else {
							banned.push(name);
						}
						game.saveConfig(this.bannedname, banned);
						this.classList.toggle('on');
						if (node.updateBanned) {
							node.updateBanned();
						}
					};
					var modeorder = lib.config.modeorder || [];
					for (var i in lib.mode) {
						modeorder.add(i);
					}
					var list = [];
					uiintro.contentContainer.listen(function (e) {
						ui.click.touchpop();
						e.stopPropagation();
					});
					for (var i = 0; i < modeorder.length; i++) {
						if (node._banning == 'online') {
							if (!lib.mode[modeorder[i]].connect) continue;
						}
						else if (modeorder[i] == 'connect' || modeorder[i] == 'brawl') {
							continue;
						}
						if (lib.config.all.mode.contains(modeorder[i])) {
							list.push(modeorder[i]);
						}
					}
					var page = ui.create.div('.menu-buttons.configpopped', uiintro.content);
					var banall = false;
					for (var i = 0; i < list.length; i++) {
						var cfg = ui.create.div('.config', lib.translate[list[i]] + '模式', page);
						cfg.classList.add('toggle');
						if (node._banning == 'offline') {
							cfg.bannedname = list[i] + '_bannedcards';
						}
						else {
							cfg.bannedname = 'connect_' + list[i] + '_bannedcards';
						}
						cfg.listen(clickBanned);
						ui.create.div(ui.create.div(cfg));
						var banned = lib.config[cfg.bannedname] || [];
						if (!banned.contains(name)) {
							cfg.classList.add('on');
							banall = true;
						}
					}
					ui.create.div('.menubutton.pointerdiv', banall ? '全部禁用' : '全部启用', uiintro.content, function () {
						if (this.innerHTML == '全部禁用') {
							for (var i = 0; i < page.childElementCount; i++) {
								if (page.childNodes[i].bannedname && page.childNodes[i].classList.contains('on')) {
									clickBanned.call(page.childNodes[i]);
								}
							}
							this.innerHTML = '全部启用';
						}
						else {
							for (var i = 0; i < page.childElementCount; i++) {
								if (page.childNodes[i].bannedname && !page.childNodes[i].classList.contains('on')) {
									clickBanned.call(page.childNodes[i]);
								}
							}
							this.innerHTML = '全部禁用';
						}
					}).style.marginTop = '-10px';
					ui.create.div('.placeholder.slim', uiintro.content);
				}
				else {
					if (lib.translate[name + '_info']) {
						if (!uiintro.nosub) {
							if (get.subtype(node) == 'equip1') {
								var added = false;
								if (lib.card[node.name] && lib.card[node.name].distance) {
									var dist = lib.card[node.name].distance;
									if (dist.attackFrom) {
										added = true;
										uiintro.add('<div class="text center">攻击范围：' + (-dist.attackFrom + 1) + '</div>');
									}
								}
								if (!added) {
									uiintro.add('<div class="text center">攻击范围：1</div>');
								}
							}
							else if (get.subtype(node)) {
								uiintro.add('<div class="text center">' + get.translation(get.subtype(node)) + '</div>');
							}
							else if (lib.card[name] && lib.card[name].addinfomenu) {
								uiintro.add('<div class="text center">' + lib.card[name].addinfomenu + '</div>');
							}
							else if (lib.card[name] && lib.card[name].derivation) {
								if (typeof lib.card[name].derivation == 'string') {
									uiintro.add('<div class="text center">来源：' + get.translation(lib.card[name].derivation) + '</div>');
								}
								else if (lib.card[name].derivationpack) {
									uiintro.add('<div class="text center">来源：' + get.translation(lib.card[name].derivationpack + '_card_config') + '包</div>');
								}
							}
							else {
								if (lib.card[name].unique) {
									uiintro.add('<div class="text center">特殊' + get.translation(lib.card[name].type) + '牌</div>');
								}
								else {
									if (lib.card[name].type && lib.translate[lib.card[name].type]) uiintro.add('<div class="text center">' + get.translation(lib.card[name].type) + '牌</div>');
								}
							}
							if (lib.card[name].unique && lib.card[name].type == 'equip') {
								if (lib.cardPile.guozhan && lib.cardPack.guozhan.contains(name)) {
									uiintro.add('<div class="text center">专属装备</div>').style.marginTop = '-5px';
								}
								else {
									uiintro.add('<div class="text center">特殊装备</div>').style.marginTop = '-5px';
								}
							}
						}
						if (lib.translate[name + '_info']) {
							var placetext = uiintro.add('<div class="text" style="display:inline">' + lib.translate[name + '_info'] + '</div>');
							if (lib.translate[name + '_info'].indexOf('<div class="skill"') != 0) {
								uiintro._place_text = placetext;
							}
						}
						if (lib.translate[name + '_append']) {
							uiintro.add('<div class="text" style="display:inline">' + lib.translate[name + '_append'] + '</div>');
						}
					}
					uiintro.add(ui.create.div('.placeholder.slim'));
				}
			}
			else if (node.classList.contains('character')) {
				var character = node.link;
				if (lib.character[node.link] && lib.character[node.link][1]) {
					uiintro.add(get.translation(character) + '&nbsp;&nbsp;' + lib.translate[lib.character[node.link][1]]);
				}
				else {
					uiintro.add(get.translation(character));
				}

				if (lib.characterTitle[node.link]) {
					uiintro.addText(get.colorspan(lib.characterTitle[node.link]));
				}

				if (node._banning) {
					var clickBanned = function () {
						var banned = lib.config[this.bannedname] || [];
						if (banned.contains(character)) {
							banned.remove(character);
						}
						else {
							banned.push(character);
						}
						game.saveConfig(this.bannedname, banned);
						this.classList.toggle('on');
						if (node.updateBanned) {
							node.updateBanned();
						}
					};
					var modeorder = lib.config.modeorder || [];
					for (var i in lib.mode) {
						modeorder.add(i);
					}
					var list = [];
					uiintro.contentContainer.listen(function (e) {
						ui.click.touchpop();
						e.stopPropagation();
					});
					for (var i = 0; i < modeorder.length; i++) {
						if (node._banning == 'online') {
							if (!lib.mode[modeorder[i]].connect) continue;
							if (!lib.config['connect_' + modeorder[i] + '_banned']) {
								lib.config['connect_' + modeorder[i] + '_banned'] = [];
							}
						}
						else if (modeorder[i] == 'connect' || modeorder[i] == 'brawl') {
							continue;
						}
						if (lib.config.all.mode.contains(modeorder[i])) {
							list.push(modeorder[i]);
						}
					}
					var page = ui.create.div('.menu-buttons.configpopped', uiintro.content);
					var banall = false;
					for (var i = 0; i < list.length; i++) {
						var cfg = ui.create.div('.config', lib.translate[list[i]] + '模式', page);
						cfg.classList.add('toggle');
						if (node._banning == 'offline') {
							cfg.bannedname = list[i] + '_banned';
						}
						else {
							cfg.bannedname = 'connect_' + list[i] + '_banned';
						}
						cfg.listen(clickBanned);
						ui.create.div(ui.create.div(cfg));
						var banned = lib.config[cfg.bannedname] || [];
						if (!banned.contains(character)) {
							cfg.classList.add('on');
							banall = true;
						}
					}
					if (node._banning == 'offline') {
						var cfg = ui.create.div('.config', 'AI可选', page);
						cfg.classList.add('toggle');
						cfg.listen(function () {
							this.classList.toggle('on');
							if (this.classList.contains('on')) {
								lib.config.forbidai_user.remove(character);
							}
							else {
								lib.config.forbidai_user.add(character);
							}
							game.saveConfig('forbidai_user', lib.config.forbidai_user);
						});
						ui.create.div(ui.create.div(cfg));
						if (!lib.config.forbidai_user.contains(character)) {
							cfg.classList.add('on');
						}
					}
					ui.create.div('.menubutton.pointerdiv', banall ? '全部禁用' : '全部启用', uiintro.content, function () {
						if (this.innerHTML == '全部禁用') {
							for (var i = 0; i < page.childElementCount; i++) {
								if (page.childNodes[i].bannedname && page.childNodes[i].classList.contains('on')) {
									clickBanned.call(page.childNodes[i]);
								}
							}
							this.innerHTML = '全部启用';
						}
						else {
							for (var i = 0; i < page.childElementCount; i++) {
								if (page.childNodes[i].bannedname && !page.childNodes[i].classList.contains('on')) {
									clickBanned.call(page.childNodes[i]);
								}
							}
							this.innerHTML = '全部禁用';
						}
					}).style.marginTop = '-10px';
					ui.create.div('.placeholder.slim', uiintro.content);
				}
				else {
					var infoitem = lib.character[character];
					if (!infoitem) {
						for (var itemx in lib.characterPack) {
							if (lib.characterPack[itemx][character]) {
								infoitem = lib.characterPack[itemx][character]; break;
							}
						}
					}
					var skills = infoitem[3];
					for (i = 0; i < skills.length; i++) {
						if (lib.translate[skills[i] + '_info']) {
							translation = lib.translate[skills[i] + '_ab'] || get.translation(skills[i]).slice(0, 2);
							if (lib.skill[skills[i]] && lib.skill[skills[i]].nobracket) {
								uiintro.add('<div><div class="skilln">' + get.translation(skills[i]) + '</div><div>' + get.skillInfoTranslation(skills[i]) + '</div></div>');
							}
							else {
								uiintro.add('<div><div class="skill">【' + translation + '】</div><div>' + get.skillInfoTranslation(skills[i]) + '</div></div>');
							}
							if (lib.translate[skills[i] + '_append']) {
								uiintro._place_text = uiintro.add('<div class="text">' + lib.translate[skills[i] + '_append'] + '</div>')
							}
						}
					}
					var modepack = lib.characterPack['mode_' + get.mode()];
					if (lib.config.show_favourite &&
						lib.character[node.link] && (!modepack || !modepack[node.link]) && (!simple || get.is.phoneLayout())) {
						var addFavourite = ui.create.div('.text.center.pointerdiv');
						addFavourite.link = node.link;
						addFavourite.style.marginBottom = '15px';
						if (lib.config.favouriteCharacter.contains(node.link)) {
							addFavourite.innerHTML = '移除收藏';
						}
						else {
							addFavourite.innerHTML = '添加收藏';
						}
						addFavourite.listen(ui.click.favouriteCharacter)
						uiintro.add(addFavourite);
					}
					else {
						uiintro.add(ui.create.div('.placeholder.slim'));
					}
					var addskin = false;
					if (node.parentNode.classList.contains('menu-buttons')) {
						addskin = !lib.config.show_charactercard;
					}
					else {
						addskin = lib.config.change_skin || lib.skin;
					}
					if (addskin && (!simple || get.is.phoneLayout())) {
						var num = 1;
						var introadded = false;
						var nameskin = node.link;
						var nameskin2 = nameskin;
						var gzbool = false;
						if (nameskin.indexOf('gz_shibing') == 0) {
							nameskin = nameskin.slice(3, 11);
						}
						else if (nameskin.indexOf('gz_') == 0) {
							nameskin = nameskin.slice(3);
							gzbool = true;
						}
						var createButtons = function (num) {
							if (!num) return;
							if (!introadded) {
								introadded = true;
								uiintro.add('<div class="text center">更改皮肤</div>');
							}
							var buttons = ui.create.div('.buttons.smallzoom.scrollbuttons');
							lib.setMousewheel(buttons);
							for (var i = 0; i <= num; i++) {
								var button = ui.create.div('.button.character.pointerdiv', buttons, function () {
									if (this._link) {
										lib.config.skin[nameskin] = this._link;
										node.style.backgroundImage = this.style.backgroundImage;
										game.saveConfig('skin', lib.config.skin);
									}
									else {
										delete lib.config.skin[nameskin];
										if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) node.setBackground(nameskin2, 'character');
										else node.setBackground(nameskin, 'character');
										game.saveConfig('skin', lib.config.skin);
									}
								});
								button._link = i;
								if (i) {
									button.setBackgroundImage('image/skin/' + nameskin + '/' + i + '.jpg');
								}
								else {
									if (gzbool && lib.character[nameskin2][4].contains('gzskin') && lib.config.mode_config.guozhan.guozhanSkin) button.setBackground(nameskin2, 'character', 'noskin');
									else button.setBackground(nameskin, 'character', 'noskin');
								}
							}
							uiintro.add(buttons);
						};
						var loadImage = function () {
							var img = new Image();
							img.onload = function () {
								num++;
								loadImage();
							}
							img.onerror = function () {
								num--;
								createButtons(num);
							}
							img.src = lib.assetURL + 'image/skin/' + nameskin + '/' + num + '.jpg';
						}
						if (lib.config.change_skin) {
							loadImage();
						}
						else {
							setTimeout(function () {
								createButtons(lib.skin[nameskin]);
							});
						}
					}
				}
			}
			else if (node.classList.contains('equips') && ui.arena.classList.contains('selecting')) {
				(function () {
					uiintro.add('选择装备');
					uiintro.addSmall(Array.from(node.childNodes), true);
					uiintro.clickintro = true;
					ui.control.hide();
					uiintro._onclose = function () {
						ui.control.show();
					}
					var confirmbutton;
					for (var i = 0; i < uiintro.buttons.length; i++) {
						var button = uiintro.buttons[i];
						button.classList.add('pointerdiv');
						if (button.link.classList.contains('selected')) {
							button.classList.add('selected');
						}
						button.listen(function (e) {
							ui.click.card.call(this.link, 'popequip');
							ui.click.window.call(ui.window, e);
							if (this.link.classList.contains('selected')) {
								this.classList.add('selected');
							}
							else {
								this.classList.remove('selected');
							}
							if (ui.confirm && ui.confirm.str && ui.confirm.str.indexOf('o') != -1) {
								confirmbutton.classList.remove('disabled');
							}
							else {
								confirmbutton.classList.add('disabled');
							}
						});
					}
					var buttoncontainer = uiintro.add(ui.create.div());
					buttoncontainer.style.display = 'block';
					confirmbutton = ui.create.div('.menubutton.large.pointerdiv', '确定', function () {
						if (ui.confirm && ui.confirm.str && ui.confirm.str.indexOf('o') != -1) {
							uiintro._clickintro();
							ui.click.ok(ui.confirm.firstChild);
						}
					}, buttoncontainer);
					confirmbutton.style.position = 'relative';
					setTimeout(function () {
						if (ui.confirm && ui.confirm.str && ui.confirm.str.indexOf('o') != -1) {
							confirmbutton.classList.remove('disabled');
						}
						else {
							confirmbutton.classList.add('disabled');
						}
					}, 300);
				}());
			}
			else if (node.classList.contains('identity') && node.dataset.career) {
				var career = node.dataset.career;
				uiintro.add(get.translation(career));
				uiintro.add('<div class="text center" style="padding-bottom:5px">' + lib.translate['_' + career + '_skill_info'] + '</div>');
			}
			else if (node.classList.contains('skillbar')) {
				if (node == ui.friendBar) {
					uiintro.add('友方怒气值');
					uiintro.add('<div class="text center" style="padding-bottom:5px">' + _status.friendRage + '/100</div>');
				}
				else if (node == ui.enemyBar) {
					uiintro.add('敌方怒气值');
					uiintro.add('<div class="text center" style="padding-bottom:5px">' + _status.enemyRage + '/100</div>');
				}
			}
			else if (node.parentNode == ui.historybar) {
				if (node.dead) {
					if (!node.source || node.source == node.player) {
						uiintro.add('<div class="text center">' + get.translation(node.player) + '阵亡</div>');
						uiintro.addSmall([node.player]);
					}
					else {
						uiintro.add('<div class="text center">' + get.translation(node.player) + '被' + get.translation(node.source) + '杀害</div>');
						uiintro.addSmall([node.source]);
					}
				}
				if (node.skill) {
					uiintro.add('<div class="text center">' + get.translation(node.skill, 'skill') + '</div>');
					uiintro._place_text = uiintro.add('<div class="text" style="display:inline">' + get.translation(node.skill, 'info') + '</div>');
				}
				if (node.targets && get.itemtype(node.targets) == 'players') {
					uiintro.add('<div class="text center">目标</div>');
					uiintro.addSmall(node.targets);
				}
				if (node.players && node.players.length > 1) {
					uiintro.add('<div class="text center">使用者</div>');
					uiintro.addSmall(node.players);
				}
				if (node.cards && node.cards.length) {
					uiintro.add('<div class="text center">卡牌</div>');
					uiintro.addSmall(node.cards);
				}
				for (var i = 0; i < node.added.length; i++) {
					uiintro.add(node.added[i]);
				}
				if (node.added.length) {
					uiintro.add(ui.create.div('.placeholder.slim'));
				}
				if (uiintro.content.firstChild) {
					uiintro.content.firstChild.style.paddingTop = '3px';
				}
			}
			if (lib.config.touchscreen) {
				lib.setScroll(uiintro.contentContainer);
			}
			return uiintro;
		},
		linkintro: function (dialog, content, player) {
			dialog.content.firstChild.remove();
			dialog.add('<div class="text center">已横置</div>');
			var list = [];
			for (var i = 0; i < game.players.length; i++) {
				if (game.players[i].isLinked() && game.players[i].name && game.players[i].name.indexOf('unknown') != 0) {
					list.push(game.players[i]);
				}
			}
			if (list.length) {
				dialog.add(list, true, true);
			}
		},
		groups: function () {
			return get.mode() == 'SNH48' ? ['S', 'N', 'H', 'X', 'guan'] : ['wei', 'shu', 'wu', 'qun', 'western', 'key'];
		},
		types: function () {
			var types = [];
			for (var i in lib.card) {
				if (lib.card[i].mode && lib.card[i].mode.contains(lib.config.mode) == false) continue;
				if (lib.card[i].forbid && lib.card[i].forbid.contains(lib.config.mode)) continue;
				if (lib.card[i].type) {
					if (lib.card[i].type == 'delay') types.add('trick');
					else types.add(lib.card[i].type);
				}
			}
			return types;
		},
		links: function (buttons) {
			var links = [];
			for (var i = 0; i < buttons.length; i++) {
				if (buttons[i].link != undefined) links.push(buttons[i].link);
			}
			return links;
		},
		threaten: function (target, player, hp) {
			var threaten = 1;
			var skills = target.getSkills();
			if (!player && player !== false) {
				player = _status.event.player;
			}
			for (var i = 0; i < skills.length; i++) {
				var info = get.info(skills[i]);
				if (info && info.ai && info.ai.threaten) {
					if (typeof info.ai.threaten == 'function' && player) {
						var tmp = info.ai.threaten(player, target);
						if (typeof tmp == 'number') {
							threaten *= tmp;
						}
					}
					else if (typeof info.ai.threaten == 'number') {
						threaten *= info.ai.threaten;
					}
				}
			}
			if (hp) {
				switch (target.hp) {
					case 0: threaten *= 1.5; break;
					case 1: threaten *= 1.2; break;
				}
				switch (target.countCards('h')) {
					case 0: threaten *= 1.5; break;
					case 1: threaten *= 1.2; break;
				}
			}
			return threaten;
		},
		condition: function (player) {
			var num = player.hp;
			if (num > 4) {
				num = 4 + Math.sqrt(num - 4);
			}
			else {
				if (player.isHealthy()) {
					if (player.hp == 3) {
						num += 0.5;
					}
					else if (player.hp < 3) {
						num++;
					}
				}
			}
			num += player.countCards('h') / 2;
			var es = player.getCards('e');
			for (var i = 0; i < es.length; i++) {
				var val = get.equipValueNumber(es[i]);
				if (val >= 7) num += 0.8;
				if (val >= 5) num += 0.5;
				if (val >= 3) num += 0.2;
			}
			return num;
		},
		attitude: function (from, to) {
			if (!from || !to) return 0;
			from = from._trueMe || from;
			arguments[0] = from;
			var att = get.rawAttitude.apply(this, arguments);
			if (from.isMad()) att = -att;
			if (to.isMad() && att > 0) {
				if (to.identity == 'zhu') {
					att = 1;
				}
				else {
					att = 0;
				}
			}
			if (!_status.tempnofake) {
				_status.tempnofake = true;
				if (from.ai.modAttitudeFrom) {
					att = from.ai.modAttitudeFrom(from, to, att);
				}
				if (to.ai.modAttitudeTo) {
					att = to.ai.modAttitudeTo(from, to, att);
				}
				delete _status.tempnofake;
			}
			return att;
		},
		sgnAttitude: function () {
			return get.sgn(get.attitude.apply(this, arguments));
		},
		useful: function (card) {
			if (get.position(card) == 'j') return -1;
			if (get.position(card) == 'e') return get.equipValue(card);
			if (card._modUseful) {
				return card._modUseful();
			}
			var i = 0;
			if (_status.event.player) {
				i = _status.event.player.getCards('h', card.name).indexOf(card);
				if (i < 0) i = 0;
			}
			var aii = get.info(card).ai;
			var useful;
			if (aii && aii.useful) useful = aii.useful;
			else if (aii && aii.basic) useful = aii.basic.useful;
			if (useful == undefined) return -1;
			if (typeof useful == 'function') {
				return useful(card, i);
			}
			if (typeof useful == 'number') return useful;
			if (i < useful.length) {
				return useful[i];
			}
			return useful[useful.length - 1];
		},
		unuseful: function (card) {
			return -get.useful(card);
		},
		unuseful2: function (card) {
			return 10 - get.useful(card);
		},
		unuseful3: function (card) {
			if (card.name == 'du') return 20;
			return 10 - get.useful(card);
		},
		value: function (card, player, method) {
			var result = 0;
			var value;
			if (Array.isArray(card)) {
				value = 0;
				for (var i = 0; i < card.length; i++) {
					value += get.value(card[i], player, method);
				}
				return value / Math.sqrt(card.length);
			}
			if (card._modValue) {
				return card._modValue(player, method);
			}
			var aii = get.info(card).ai;
			if (aii && aii.value) value = aii.value;
			else if (aii && aii.basic) value = aii.basic.value;
			if (player == undefined || get.itemtype(player) != 'player') player = _status.event.player;
			var geti = function () {
				var num = 0, i;
				var cards = player.getCards('h', card.name);
				if (cards.contains(card)) {
					return cards.indexOf(card);
				}
				return cards.length;
			};
			if (typeof value == 'function') {
				result = value(card, player, geti(), method);
			}
			if (typeof value == 'number') result = value;
			if (Array.isArray(value)) {
				if (method == 'raw') result = value[0];
				var num = geti();
				if (num < value.length) result = value[num];
				else result = value[value.length - 1];
			}
			result = game.checkMod(player, card, result, 'aiValue', player);
			return result;
		},
		equipResult: function (player, target, name) {
			var card = get.card();
			if (!card || card.name != name) {
				card = { name: name };
			}
			var value1 = get.equipValue(card, target);
			var value2 = 0;
			var current = target.getEquip(card);
			if (current && current != card) {
				value2 = get.equipValue(current, target);
				if (value2 > 0 && !target.needsToDiscard() && !get.tag(card, 'valueswap')) {
					return 0;
				}
			}
			return Math.max(0, value1 - value2) / 5;
		},
		equipValue: function (card, player) {
			if (player == undefined || get.itemtype(player) != 'player') player = get.owner(card);
			if (player == undefined || get.itemtype(player) != 'player') player = _status.event.player;
			var info = get.info(card);
			if (!info.ai) return 0;
			var value = info.ai.equipValue;
			if (value == undefined) {
				if (info.ai.basic && info.ai.basic.equipValue != undefined) {
					value = info.ai.basic.equipValue;
				}
				else return 0;
			}
			if (typeof value == 'number') return value;
			if (typeof value == 'function') return value(card, player, null, 'raw2');
			return 0;
		},
		equipValueNumber: function (card) {
			var info = get.info(card);
			if (info.ai) {
				if (typeof info.ai.equipValue == 'number') return info.ai.equipValue;
				if (info.ai.basic && typeof info.ai.basic.equipValue == 'number') return info.ai.basic.equipValue;
			}
			return 0;
		},
		disvalue: function (card, player) {
			return -get.value(card, player);
		},
		disvalue2: function (card, player) {
			return -get.value(card, player, 'raw');
		},
		skillthreaten: function (skill, player, target) {
			if (!lib.skill[skill]) return 1;
			if (!lib.skill[skill].ai) return 1;
			var threaten = lib.skill[skill].ai.threaten;
			if (typeof threaten == 'number') return threaten;
			if (typeof threaten == 'function') {
				player = player || _status.event.player;
				target = target || player;
				return threaten(player, target);
			}
			return 1;
		},
		order: function (item) {
			var info = get.info(item);
			if (!info) return -1;
			var aii = info.ai;
			var order;
			if (aii && aii.order) order = aii.order;
			else if (aii && aii.basic) order = aii.basic.order;
			if (order == undefined) return -1;
			var num = order;
			if (typeof (order) == 'function') {
				num = order(item, _status.event.player);
			}
			if (typeof item == 'object' && _status.event.player) {
				var player = _status.event.player;
				num = game.checkMod(player, item, num, 'aiOrder', player);
			}
			return num;
		},
		result: function (item, skill) {
			var result;
			var info = get.info(item);
			if (info.ai) result = get.copy(info.ai.result);
			if (typeof (result) == 'function') result = result(item);
			if (!result) result = {};
			if (skill) {
				var info2 = get.info(skill);
				if (info2.ai) {
					info2 = info2.ai.result;
					for (var i in info2) {
						result[i] = info2[i];
					}
				}
			}
			return result;
		},
		effect_use: function (target, card, player, player2, isLink) {
			var event = _status.event;
			var eventskill = null;
			if (player == undefined) player = _status.event.player;
			if (typeof card != 'string' && (typeof card != 'object' || !card.name)) {
				var skillinfo = get.info(event.skill);
				if (event.skill && skillinfo.viewAs == undefined) card = _status.event.skill;
				else {
					card = get.card();
					if (skillinfo && skillinfo.viewAs && card.name === skillinfo.viewAs.name) {
						eventskill = event.skill;
					}
				}
			}
			var info = get.info(card);
			if (typeof card == 'object' && info && info.changeTarget) {
				var targets = [target];
				info.changeTarget(player, targets);
				var eff = 0;
				for (var i of targets) {
					eff += get.effect(i, card, player, player2, isLink);
				}
				return eff;
			}
			var result = get.result(card, eventskill);
			var result1 = result.player_use || result.player, result2 = result.target_use || result.target;
			if (typeof result1 == 'function') result1 = result1(player, target, card, isLink);
			if (typeof result2 == 'function') result2 = result2(player, target, card, isLink);

			if (typeof result1 != 'number') result1 = 0;
			if (typeof result2 != 'number') result2 = 0;
			var temp1, temp2, temp3, temp01 = 0, temp02 = 0, threaten = 1;
			var skills1 = player.getSkills().concat(lib.skill.global);
			game.expandSkills(skills1);
			var zerotarget = false, zeroplayer = false;
			for (var i = 0; i < skills1.length; i++) {
				temp1 = get.info(skills1[i]).ai;
				if (temp1 && typeof temp1.effect == 'object' && typeof temp1.effect.player == 'function') {
					temp1 = temp1.effect.player(card, player, target, result1, isLink);
				}
				else temp1 = undefined;
				if (typeof temp1 == 'object') {
					if (temp1.length == 2 || temp1.length == 4) {
						result1 *= temp1[0];
						temp01 += temp1[1];
					}
					if (temp1.length == 4) {
						result2 *= temp1[2];
						temp02 += temp1[3];
					}
				}
				else if (typeof temp1 == 'number') {
					result1 *= temp1;
				}
				else if (temp1 == 'zeroplayer') {
					zeroplayer = true;
				}
				else if (temp1 == 'zerotarget') {
					zerotarget = true;
				}
				else if (temp1 == 'zeroplayertarget') {
					zeroplayer = true;
					zerotarget = true;
				}
			}
			if (target) {
				var skills2 = target.getSkills().concat(lib.skill.global);
				game.expandSkills(skills2);
				for (var i = 0; i < skills2.length; i++) {
					temp2 = get.info(skills2[i]).ai;
					if (temp2 && temp2.threaten) temp3 = temp2.threaten;
					else temp3 = undefined;
					if (temp2 && typeof temp2.effect == 'function') {
						if (!player.hasSkillTag('ignoreSkill', true, {
							card: card,
							target: target,
							skill: skills2[i],
							isLink: isLink,
						})) temp2 = temp2.effect(card, player, target, result2, isLink);
						else temp2 = undefined;
					}
					else if (temp2 && typeof temp2.effect == 'object' && typeof temp2.effect.target == 'function') {
						if (!player.hasSkillTag('ignoreSkill', true, {
							card: card,
							target: target,
							skill: skills2[i],
							isLink: isLink,
						})) temp2 = temp2.effect.target(card, player, target, result2, isLink);
						else temp2 = undefined;
					}
					else temp2 = undefined;
					if (typeof temp2 == 'object') {
						if (temp2.length == 2 || temp2.length == 4) {
							result2 *= temp2[0];
							temp02 += temp2[1];
						}
						if (temp2.length == 4) {
							result1 *= temp2[2];
							temp01 += temp2[3];
						}
					}
					else if (typeof temp2 == 'number') {
						result2 *= temp2;
					}
					else if (temp2 == 'zeroplayer') {
						zeroplayer = true;
					}
					else if (temp2 == 'zerotarget') {
						zerotarget = true;
					}
					else if (temp2 == 'zeroplayertarget') {
						zeroplayer = true;
						zerotarget = true;
					}
					if (typeof temp3 == 'function' && temp3(player, target) != undefined) {
						threaten *= temp3(player, target);
					}
					else if (typeof temp3 == 'object') {
						if (typeof temp3.target == 'number') {
							threaten *= temp3;
						}
						else if (typeof temp3.target == 'function' && temp3(player, target) != undefined) {
							threaten *= temp3(player, target);
						}
					}
					else if (typeof temp3 == 'number') {
						threaten *= temp3;
					}
				}
				result2 += temp02;
				result1 += temp01;
				if (get.attitude(player, target) < 0) {
					result2 *= Math.sqrt(threaten);
				}
				else {
					result2 *= Math.sqrt(Math.sqrt(threaten));
				}
				if (target.hp == 1) result2 *= 2.5;
				if (target.hp == 2) result2 *= 1.8;
				if (target.countCards('h') == 0) {
					if (get.tag(card, 'respondSha') || get.tag(card, 'respondShan')) {
						result2 *= 1.7;
					}
					else {
						result2 *= 1.5;
					}
				}
				if (target.countCards('h') == 1) result2 *= 1.3;
				if (target.countCards('h') == 2) result2 *= 1.1;
				if (target.countCards('h') > 3) result2 *= 0.5;
				if (target.hp == 4) result2 *= 0.9;
				if (target.hp == 5) result2 *= 0.8;
				if (target.hp > 5) result2 *= 0.6;
			}
			else {
				result2 += temp02;
				result1 += temp01;
			}
			if (zeroplayer) result1 = 0;
			if (zerotarget) result2 = 0;
			var final = 0;
			if (player2) {
				final = (result1 * get.attitude(player2, player) + (target ? result2 * get.attitude(player2, target) : 0));
			}
			else final = (result1 * get.attitude(player, player) + (target ? result2 * get.attitude(player, target) : 0));
			if (!isLink && get.tag(card, 'natureDamage') && target.isLinked() && !zerotarget) {
				game.countPlayer(function (current) {
					if (current != target && current.isLinked()) final += get.effect(current, card, player, player2, true);
				})
			}
			return final;
		},
		effect: function (target, card, player, player2, isLink) {
			var event = _status.event;
			var eventskill = null;
			if (player == undefined) player = _status.event.player;
			if (typeof card != 'string' && (typeof card != 'object' || !card.name)) {
				var skillinfo = get.info(event.skill);
				if (event.skill && skillinfo.viewAs == undefined) card = _status.event.skill;
				else {
					card = get.card();
					if (skillinfo && skillinfo.viewAs && card.name === skillinfo.viewAs.name) {
						eventskill = event.skill;
					}
				}
			}
			var result = get.result(card, eventskill);
			var result1 = result.player, result2 = result.target;
			if (typeof result1 == 'function') result1 = result1(player, target, card, isLink);
			if (typeof result2 == 'function') result2 = result2(player, target, card, isLink);

			if (typeof result1 != 'number') result1 = 0;
			if (typeof result2 != 'number') result2 = 0;
			var temp1, temp2, temp3, temp01 = 0, temp02 = 0, threaten = 1;
			var skills1 = player.getSkills().concat(lib.skill.global);
			game.expandSkills(skills1);
			var zerotarget = false, zeroplayer = false;
			for (var i = 0; i < skills1.length; i++) {
				temp1 = get.info(skills1[i]).ai;
				if (temp1 && typeof temp1.effect == 'object' && typeof temp1.effect.player == 'function') {
					temp1 = temp1.effect.player(card, player, target, result1, isLink);
				}
				else temp1 = undefined;
				if (typeof temp1 == 'object') {
					if (temp1.length == 2 || temp1.length == 4) {
						result1 *= temp1[0];
						temp01 += temp1[1];
					}
					if (temp1.length == 4) {
						result2 *= temp1[2];
						temp02 += temp1[3];
					}
				}
				else if (typeof temp1 == 'number') {
					result1 *= temp1;
				}
				else if (temp1 == 'zeroplayer') {
					zeroplayer = true;
				}
				else if (temp1 == 'zerotarget') {
					zerotarget = true;
				}
				else if (temp1 == 'zeroplayertarget') {
					zeroplayer = true;
					zerotarget = true;
				}
			}
			if (target) {
				var skills2 = target.getSkills().concat(lib.skill.global);
				game.expandSkills(skills2);
				for (var i = 0; i < skills2.length; i++) {
					temp2 = get.info(skills2[i]).ai;
					if (temp2 && temp2.threaten) temp3 = temp2.threaten;
					else temp3 = undefined;
					if (temp2 && typeof temp2.effect == 'function') {
						if (!player.hasSkillTag('ignoreSkill', true, {
							card: card,
							target: target,
							skill: skills2[i],
							isLink: isLink,
						})) temp2 = temp2.effect(card, player, target, result2, isLink);
						else temp2 = undefined;
					}
					else if (temp2 && typeof temp2.effect == 'object' && typeof temp2.effect.target == 'function') {
						if (!player.hasSkillTag('ignoreSkill', true, {
							card: card,
							target: target,
							skill: skills2[i],
							isLink: isLink,
						})) temp2 = temp2.effect.target(card, player, target, result2, isLink);
						else temp2 = undefined;
					}
					else temp2 = undefined;
					if (typeof temp2 == 'object') {
						if (temp2.length == 2 || temp2.length == 4) {
							result2 *= temp2[0];
							temp02 += temp2[1];
						}
						if (temp2.length == 4) {
							result1 *= temp2[2];
							temp01 += temp2[3];
						}
					}
					else if (typeof temp2 == 'number') {
						result2 *= temp2;
					}
					else if (temp2 == 'zeroplayer') {
						zeroplayer = true;
					}
					else if (temp2 == 'zerotarget') {
						zerotarget = true;
					}
					else if (temp2 == 'zeroplayertarget') {
						zeroplayer = true;
						zerotarget = true;
					}
					if (typeof temp3 == 'function' && temp3(player, target) != undefined) {
						threaten *= temp3(player, target);
					}
					else if (typeof temp3 == 'object') {
						if (typeof temp3.target == 'number') {
							threaten *= temp3;
						}
						else if (typeof temp3.target == 'function' && temp3(player, target) != undefined) {
							threaten *= temp3(player, target);
						}
					}
					else if (typeof temp3 == 'number') {
						threaten *= temp3;
					}
				}
				result2 += temp02;
				result1 += temp01;
				if (get.attitude(player, target) < 0) {
					result2 *= Math.sqrt(threaten);
				}
				else {
					result2 *= Math.sqrt(Math.sqrt(threaten));
				}
				// *** continue here ***
				if (target.hp == 1) result2 *= 2.5;
				if (target.hp == 2) result2 *= 1.8;
				if (target.countCards('h') == 0) {
					if (get.tag(card, 'respondSha') || get.tag(card, 'respondShan')) {
						result2 *= 1.7;
					}
					else {
						result2 *= 1.5;
					}
				}
				if (target.countCards('h') == 1) result2 *= 1.3;
				if (target.countCards('h') == 2) result2 *= 1.1;
				if (target.countCards('h') > 3) result2 *= 0.5;
				if (target.hp == 4) result2 *= 0.9;
				if (target.hp == 5) result2 *= 0.8;
				if (target.hp > 5) result2 *= 0.6;
				// if(get.attitude(player,target)<0){
				// 	result2*=threaten;
				// }
				// else{
				// 	result2*=Math.sqrt(threaten);
				// }
				// if(target.hp<=1) result2*=2;
				// if(target.hp==2) result2*=1.1;
				// if(target.countCards('h')==0){
				// 	result2*=1.1;
				// 	if(get.tag(card,'respondSha')||get.tag(card,'respondShan')) result2*=1.4;
				// }
				// if(target.countCards('h')==1) result2*=1.05;
				// if(target.countCards('h')==2) result2*=1.02;
				// if(target.countCards('h')>3) result2*=0.9;
				// if(target.hp==4) result2*=0.9;
				// if(target.hp==5) result2*=0.8;
				// if(target.hp>5) result2*=0.6;
			}
			else {
				result2 += temp02;
				result1 += temp01;
			}
			if (zeroplayer) result1 = 0;
			if (zerotarget) result2 = 0;
			var final = 0;
			if (player2) {
				final = (result1 * get.attitude(player2, player) + (target ? result2 * get.attitude(player2, target) : 0));
			}
			else final = (result1 * get.attitude(player, player) + (target ? result2 * get.attitude(player, target) : 0));
			if (!isLink && get.tag(card, 'natureDamage') && target.isLinked() && !zerotarget) {
				game.countPlayer(function (current) {
					if (current != target && current.isLinked()) final += get.effect(current, card, player, player2, true);
				})
			}
			return final;
		},
		damageEffect: function (target, player, viewer, nature) {
			if (!player) {
				player = target;
			}
			if (!viewer) {
				viewer = target;
			}
			var name = 'damage';
			if (nature == 'fire') {
				name = 'firedamage';
			}
			else if (nature == 'thunder') {
				name = 'thunderdamage';
			}
			var eff = get.effect(target, { name: name }, player, viewer);
			if (eff > 0 && target.hujia > 0) return 0;
			return eff;
		},
		recoverEffect: function (target, player, viewer) {
			if (target.hp == target.maxHp) return 0;
			if (!player) {
				player = target;
			}
			if (!viewer) {
				viewer = target;
			}
			return get.effect(target, { name: 'recover' }, player, viewer);
		},
		buttonValue: function (button) {
			var card = button.link;
			var player = get.owner(card);
			if (!player) player = _status.event.player;
			if (player.getCards('j').contains(card)) {
				var efff = get.effect(player, card, player, player);
				if (efff > 0) return 0.5;
				if (efff == 0) return 0;
				return -1.5;
			}
			if (player.getCards('e').contains(card)) {
				var evalue = get.equipValue(card);
				if (player.hasSkillTag('noe')) {
					if (evalue >= 7) {
						return evalue / 6;
					}
					return evalue / 10;
				}
				return evalue / 3;
			}
			if (player.hasSkillTag('noh')) return 0.1;
			var nh = player.countCards('h');
			switch (nh) {
				case 1: return 2;
				case 2: return 1.6;
				case 3: return 1;
				case 4: return 0.8;
				case 5: return 0.6;
				default: return 0.4;
			}
		},
		attitude2: function (to) {
			return get.attitude(_status.event.player, to);
		},
	};
	var ai = {
		basic: {
			chooseButton: function (check) {
				var event = _status.event;
				var i, j, range, buttons, buttons2;
				var ok = false, forced = event.forced;
				var iwhile = 100;
				while (iwhile--) {
					range = get.select(event.selectButton);
					if (range[1] == -1) {
						j = 0;
						for (i = 0; i < ui.selected.buttons.length; i++) {
							j += check(ui.selected.buttons[i]);
						}
						return (j > 0);
					}
					buttons = get.selectableButtons();
					if (buttons.length == 0) {
						return ok;
					}
					buttons2 = buttons.slice(0);
					var ix = 0;
					var checkix = check(buttons[0], buttons2);
					for (i = 1; i < buttons.length; i++) {
						var checkixtmp = check(buttons[i], buttons2);
						if (checkixtmp > checkix) {
							ix = i;
							checkix = checkixtmp;
						}
					}
					// buttons.sort(function(a,b){
					// 	return check(b,buttons2)-check(a,buttons2);
					// });
					if (check(buttons[ix]) <= 0) {
						if (!forced || ok) {
							return ok;
						}
					}
					buttons[ix].classList.add('selected');
					ui.selected.buttons.add(buttons[ix]);
					game.check();
					if (ui.selected.buttons.length >= range[0]) {
						ok = true;
					}
					if (ui.selected.buttons.length == range[1]) {
						return true;
					}
				}
			},
			chooseCard: function (check) {
				var event = _status.event;
				if (event.filterCard == undefined) return (check() > 0);
				var i, j, range, cards, cards2, skills, check, effect;
				var ok = false, forced = event.forced;
				var iwhile = 100;
				while (iwhile--) {
					range = get.select(event.selectCard);
					if (ui.selected.cards.length >= range[0]) {
						ok = true;
					}
					if (range[1] == -1) {
						if (ui.selected.cards.length == 0) return true;
						j = 0;
						for (i = 0; i < ui.selected.cards.length; i++) {
							effect = check(ui.selected.cards[i]);
							if (effect < 0) j -= Math.sqrt(-effect);
							else j += Math.sqrt(effect);
						}
						return (j > 0);
					}
					cards = get.selectableCards();
					if (!_status.event.player._noSkill) {
						cards = cards.concat(get.skills());
					}
					if (cards.length == 0) {
						return ok;
					}
					cards2 = cards.slice(0);
					// cards.sort(function(a,b){
					// 	return (check(b,cards2)-check(a,cards2));
					// });
					var ix = 0;
					var checkix = check(cards[0], cards2);
					for (i = 1; i < cards.length; i++) {
						var checkixtmp = check(cards[i], cards2);
						if (checkixtmp > checkix) {
							ix = i;
							checkix = checkixtmp;
						}
					}
					if (check(cards[ix]) <= 0) {
						if (!forced || ok) {
							return ok;
						}
					}
					if (typeof cards[ix] == 'string') {
						ui.click.skill(cards[ix]);
						var info = get.info(event.skill);
						if (info.filterCard) {
							check = info.check || get.unuseful2;
							return (ai.basic.chooseCard(check));
						}
						else {
							return true;
						}
					}
					else {
						cards[ix].classList.add('selected');
						ui.selected.cards.add(cards[ix]);
						game.check();
						if (ui.selected.cards.length >= range[ix]) {
							ok = true;
						}
						if (ui.selected.cards.length == range[1]) {
							return true;
						}
					}
				}
			},
			chooseTarget: function (check) {
				var event = _status.event;
				if (event.filterTarget == undefined) return (check() > 0);
				var i, j, range, targets, targets2, effect;
				var ok = false, forced = event.forced;
				var iwhile = 100;
				while (iwhile--) {
					range = get.select(event.selectTarget);
					if (range[1] == -1) {
						j = 0;
						for (i = 0; i < ui.selected.targets.length; i++) {
							effect = check(ui.selected.targets[i]);
							if (effect < 0) j -= Math.sqrt(-effect);
							else j += Math.sqrt(effect);
						}
						return (j > 0);
					}
					else if (range[1] == 0) {
						return check() > 0
					}
					targets = get.selectableTargets();
					if (targets.length == 0) {
						return range[0] == 0 || ok;
					}
					targets2 = targets.slice(0);
					// targets.sort(function(a,b){
					// 	return check(b)-check(a);
					// });
					var ix = 0;
					var checkix = check(targets[0], targets2);
					for (i = 1; i < targets.length; i++) {
						var checkixtmp = check(targets[i], targets2);
						if (checkixtmp > checkix) {
							ix = i;
							checkix = checkixtmp;
						}
					}
					if (check(targets[ix]) <= 0) {
						if (!forced || ok) {
							return ok;
						}
					}
					targets[ix].classList.add('selected');
					ui.selected.targets.add(targets[ix]);
					game.check();
					if (ui.selected.targets.length >= range[0]) {
						ok = true;
					}
					if (ui.selected.targets.length == range[1]) {
						return true;
					}
				}
			}
		},
		get: get
	};
	lib.init.init();
}());
